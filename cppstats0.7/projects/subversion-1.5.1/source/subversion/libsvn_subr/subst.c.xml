<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/subst.c"><comment type="block">/*
 * subst.c :  generic eol/keyword substitution routines
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_cmdline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_subst.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<comment type="block">/* The Repository Default EOL used for files which
 * use the 'native' eol style.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_SUBST__DEFAULT_EOL_STR</name></cpp:macro> <cpp:value>"\n"</cpp:value></cpp:define>

<comment type="block">/**
 * The textual elements of a detranslated special file.  One of these
 * strings must appear as the first element of any special file as it
 * exists in the repository or the text base.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_SUBST__SPECIAL_LINK_STR</name></cpp:macro> <cpp:value>"link"</cpp:value></cpp:define>

<function><type><name>void</name></type>
<name>svn_subst_eol_style_from_value</name><parameter_list>(<param><decl><type><name>svn_subst_eol_style_t</name> *</type><name>style</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eol</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* property doesn't exist. */</comment>
      <expr_stmt><expr>*<name>eol</name> = <name>NULL</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>style</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_none</name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>"native"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>eol</name> = <name>APR_EOL_STR</name></expr>;</expr_stmt>       <comment type="block">/* whee, a portability library! */</comment>
      <if>if <condition>(<expr><name>style</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_native</name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>"LF"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>eol</name> = "\n"</expr>;</expr_stmt>
      <if>if <condition>(<expr><name>style</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_fixed</name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>"CR"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>eol</name> = "\r"</expr>;</expr_stmt>
      <if>if <condition>(<expr><name>style</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_fixed</name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>"CRLF"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>eol</name> = "\r\n"</expr>;</expr_stmt>
      <if>if <condition>(<expr><name>style</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_fixed</name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr>*<name>eol</name> = <name>NULL</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>style</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_unknown</name></expr>;</expr_stmt></then></if>
    }</block></else></if></else></if></else></if></else></if></else></if>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_subst_translation_required</name><parameter_list>(<param><decl><type><name>svn_subst_eol_style_t</name></type> <name>style</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol</name></decl></param>,
                               <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>force_eol_check</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<name>special</name> || <name>keywords</name>
          || (<name>style</name> != <name>svn_subst_eol_style_none</name> &amp;&amp; <name>force_eol_check</name>)
          || (<name>style</name> == <name>svn_subst_eol_style_native</name> &amp;&amp;
              <call><name>strcmp</name><argument_list>(<argument><expr><name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>SVN_SUBST__DEFAULT_EOL_STR</name></expr></argument>)</argument_list></call> != 0)
          || (<name>style</name> == <name>svn_subst_eol_style_fixed</name> &amp;&amp;
              <call><name>strcmp</name><argument_list>(<argument><expr><name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call> != 0))</expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_to_normal_form</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
                                   <param><decl><type><name>svn_subst_eol_style_t</name></type> <name>eol_style</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                                   <param><decl><type><name>svn_boolean_t</name></type> <name>always_repair_eols</name></decl></param>,
                                   <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                                   <param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{

  <if>if <condition>(<expr><name>eol_style</name> == <name>svn_subst_eol_style_native</name></expr>)</condition><then>
    <expr_stmt><expr><name>eol_str</name> = <name>SVN_SUBST__DEFAULT_EOL_STR</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr>! (<name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
              || <name>eol_style</name> == <name>svn_subst_eol_style_none</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNKNOWN_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

  <return>return <expr><call><name>svn_subst_copy_and_translate3</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
                                       <argument><expr><name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
                                       || <name>always_repair_eols</name></expr></argument>,
                                       <argument><expr><name>keywords</name></expr></argument>,
                                       <argument><expr><name>FALSE</name></expr></argument> <comment type="block">/* contract keywords */</comment>,
                                       <argument><expr><name>special</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_stream_translated_to_normal_form</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream</name></decl></param>,
                                           <param><decl><type><name>svn_stream_t</name> *</type><name>source</name></decl></param>,
                                           <param><decl><type><name>svn_subst_eol_style_t</name></type> <name>eol_style</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                                           <param><decl><type><name>svn_boolean_t</name></type> <name>always_repair_eols</name></decl></param>,
                                           <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
 <if>if <condition>(<expr><name>eol_style</name> == <name>svn_subst_eol_style_native</name></expr>)</condition><then>
    <expr_stmt><expr><name>eol_str</name> = <name>SVN_SUBST__DEFAULT_EOL_STR</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr>! (<name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
              || <name>eol_style</name> == <name>svn_subst_eol_style_none</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNKNOWN_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

 <expr_stmt><expr>*<name>stream</name> = <call><name>svn_subst_stream_translated</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
                                       <argument><expr><name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
                                       || <name>always_repair_eols</name></expr></argument>,
                                       <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* Helper function for svn_subst_build_keywords */</comment>

<comment type="block">/* Given a printf-like format string, return a string with proper
 * information filled in.
 *
 * Important API note: This function is the core of the implementation of
 * svn_subst_build_keywords (all versions), and as such must implement the
 * tolerance of NULL and zero inputs that that function's documention
 * stipulates.
 *
 * The format codes:
 *
 * %a author of this revision
 * %b basename of the URL of this file
 * %d short format of date of this revision
 * %D long format of date of this revision
 * %r number of this revision
 * %u URL of this file
 * %% a literal %
 *
 * All memory is allocated out of @a pool.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_string_t</name> *</type>
<name>keyword_printf</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
               <param><decl><type><name>apr_time_t</name></type> <name>date</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>value</name> <init>= <expr><call><name>svn_stringbuf_ncreate</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cur</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

  <for>for (<init>;</init><condition>;</condition><incr/>)
    <block>{
      <expr_stmt><expr><name>cur</name> = <name>fmt</name></expr>;</expr_stmt>

      <while>while <condition>(<expr>*<name>cur</name> != '\0' &amp;&amp; *<name>cur</name> != '%'</expr>)</condition>
        <expr_stmt><expr><name>cur</name>++</expr>;</expr_stmt></while>

      <if>if <condition>(<expr>(<name>n</name> = <name>cur</name> - <name>fmt</name>) &gt; 0</expr>)</condition><then> <comment type="block">/* Do we have an as-is string? */</comment>
        <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr>*<name>cur</name> == '\0'</expr>)</condition><then>
        <break>break;</break></then></if>

      <switch>switch <condition>(<expr><name><name>cur</name><index>[<expr>1</expr>]</index></name></expr>)</condition>
        <block>{
        <case>case <expr>'a'</expr>: <comment type="block">/* author of this revision */</comment>
          <if>if <condition>(<expr><name>author</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>author</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <break>break;</break>
        </case><case>case <expr>'b'</expr>: <comment type="block">/* basename of this file */</comment>
          <if>if <condition>(<expr><name>url</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_name</name>
                <init>= <expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <break>break;</break>
        </case><case>case <expr>'d'</expr>: <comment type="block">/* short format of date of this revision */</comment>
          <if>if <condition>(<expr><name>date</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>exploded_time</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>human</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>apr_time_exp_gmt</name><argument_list>(<argument><expr>&amp;<name>exploded_time</name></expr></argument>, <argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><name>human</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%04d-%02d-%02d %02d:%02d:%02dZ"</expr></argument>,
                                   <argument><expr><name><name>exploded_time</name>.<name>tm_year</name></name> + 1900</expr></argument>,
                                   <argument><expr><name><name>exploded_time</name>.<name>tm_mon</name></name> + 1</expr></argument>,
                                   <argument><expr><name><name>exploded_time</name>.<name>tm_mday</name></name></expr></argument>,
                                   <argument><expr><name><name>exploded_time</name>.<name>tm_hour</name></name></expr></argument>,
                                   <argument><expr><name><name>exploded_time</name>.<name>tm_min</name></name></expr></argument>,
                                   <argument><expr><name><name>exploded_time</name>.<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>human</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <break>break;</break>
        </case><case>case <expr>'D'</expr>: <comment type="block">/* long format of date of this revision */</comment>
          <if>if <condition>(<expr><name>date</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
                                     <argument><expr><call><name>svn_time_to_human_cstring</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <break>break;</break>
        </case><case>case <expr>'r'</expr>: <comment type="block">/* number of this revision */</comment>
          <if>if <condition>(<expr><name>rev</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <break>break;</break>
        </case><case>case <expr>'u'</expr>: <comment type="block">/* URL of this file */</comment>
          <if>if <condition>(<expr><name>url</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <break>break;</break>
        </case><case>case <expr>'%'</expr>: <comment type="block">/* '%%' =&gt; a literal % */</comment>
          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr>'\0'</expr>: <comment type="block">/* '%' as the last character of the string. */</comment>
          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* Now go back one character, since this was just a one character
           * sequence, whereas all others are two characters, and we do not
           * want to skip the null terminator entirely and carry on
           * formatting random memory contents. */</comment>
          <expr_stmt><expr><name>cur</name>--</expr>;</expr_stmt>
          <break>break;</break>
        </case><default>default: <comment type="block">/* Unrecognized code, just print it literally. */</comment>
          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </default>}</block></switch>

      <comment type="block">/* Format code is processed - skip it, and get ready for next chunk. */</comment>
      <expr_stmt><expr><name>fmt</name> = <name>cur</name> + 2</expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><call><name>svn_string_create_from_buf</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Convert an old-style svn_subst_keywords_t struct * into a new-style
 * keywords hash.  Keyword values are shallow copies, so the produced
 * hash must not be assumed to have lifetime longer than the struct it
 * is based on.  A NULL input causes a NULL output. */</comment>
<function><type><specifier>static</specifier> <name>apr_hash_t</name> *</type>
<name>kwstruct_to_kwhash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>kwstruct</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kwhash</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>kwstruct</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <expr_stmt><expr><name>kwhash</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>revision</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_LONG</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_MEDIUM</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_SHORT</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>date</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_LONG</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_SHORT</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>author</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_LONG</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>author</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_SHORT</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>author</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>url</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_LONG</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_SHORT</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>id</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_ID</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>kwhash</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_build_keywords</name><parameter_list>(<param><decl><type><name>svn_subst_keywords_t</name> *</type><name>kw</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keywords_val</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                         <param><decl><type><name>apr_time_t</name></type> <name>date</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kwhash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>val</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_build_keywords2</name><argument_list>(<argument><expr>&amp;<name>kwhash</name></expr></argument>, <argument><expr><name>keywords_val</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                                    <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The behaviour of pre-1.3 svn_subst_build_keywords, which we are
   * replicating here, is to write to a slot in the svn_subst_keywords_t
   * only if the relevant keyword was present in keywords_val, otherwise
   * leaving that slot untouched. */</comment>

  <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_LONG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>kw</name>-&gt;<name>revision</name></name> = <name>val</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_LONG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>kw</name>-&gt;<name>date</name></name> = <name>val</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_LONG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>kw</name>-&gt;<name>author</name></name> = <name>val</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_LONG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>kw</name>-&gt;<name>url</name></name> = <name>val</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_ID</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>kw</name>-&gt;<name>id</name></name> = <name>val</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_build_keywords2</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>kw</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keywords_val</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                          <param><decl><type><name>apr_time_t</name></type> <name>date</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>keyword_tokens</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>kw</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>keyword_tokens</name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>keywords_val</name></expr></argument>, <argument><expr>" \t\v\n\b\r\f"</expr></argument>,
                                     <argument><expr><name>TRUE</name></expr></argument> <comment type="block">/* chop */</comment>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>keyword_tokens</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keyword</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>keyword_tokens</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>(! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_LONG</name></expr></argument>)</argument_list></call>)
          || (! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_MEDIUM</name></expr></argument>)</argument_list></call>)
          || (! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_SHORT</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>revision_val</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>revision_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%r"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_LONG</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>revision_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_MEDIUM</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>revision_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_SHORT</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>revision_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>(! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_LONG</name></expr></argument>)</argument_list></call>)
               || (! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_SHORT</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>date_val</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>date_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%D"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_LONG</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>date_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_SHORT</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>date_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>(! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_LONG</name></expr></argument>)</argument_list></call>)
               || (! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_SHORT</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>author_val</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>author_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%a"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_LONG</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>author_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_SHORT</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>author_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>(! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_LONG</name></expr></argument>)</argument_list></call>)
               || (! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_SHORT</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>url_val</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>url_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%u"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_LONG</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>url_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_SHORT</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>url_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>(! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_ID</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_val</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>id_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%b %r %d %a"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_ID</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>id_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if></else></if></else></if>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** Helpers for svn_subst_translate_stream2 ***/</comment>


<comment type="block">/* Write out LEN bytes of BUF into STREAM. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translate_write</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>buf</name></decl></param>,
                <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>wrote</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>write_err</name> <init>= <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>wrote</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr>(<name>write_err</name>) || (<name>len</name> != <name>wrote</name>)</expr>)</condition><then>
    <return>return <expr><name>write_err</name></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Perform the substition of VALUE into keyword string BUF (with len
   *LEN), given a pre-parsed KEYWORD (and KEYWORD_LEN), and updating
   *LEN to the new size of the substituted result.  Return TRUE if all
   goes well, FALSE otherwise.  If VALUE is NULL, keyword will be
   contracted, else it will be expanded.  */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>translate_keyword_subst</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
                        <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keyword</name></decl></param>,
                        <param><decl><type><name>apr_size_t</name></type> <name>keyword_len</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>buf_ptr</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure we gotz good stuffs. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>len</name> &lt;= <name>SVN_KEYWORD_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>buf</name><index>[<expr>0</expr>]</index></name> == '$') &amp;&amp; (<name><name>buf</name><index>[<expr>*<name>len</name> - 1</expr>]</index></name> == '$')</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Need at least a keyword and two $'s. */</comment>
  <if>if <condition>(<expr>*<name>len</name> &lt; <name>keyword_len</name> + 2</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* The keyword needs to match what we're looking for. */</comment>
  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name> + 1</expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>keyword_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <expr_stmt><expr><name>buf_ptr</name> = <name>buf</name> + 1 + <name>keyword_len</name></expr>;</expr_stmt>

  <comment type="block">/* Check for fixed-length expansion.
   * The format of fixed length keyword and its data is
   * Unexpanded keyword:         "$keyword::       $"
   * Expanded keyword:           "$keyword:: value $"
   * Expanded kw with filling:   "$keyword:: value   $"
   * Truncated keyword:          "$keyword:: longval#$"
   */</comment>
  <if>if <condition>(<expr>(<name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> == ':') <comment type="block">/* first char after keyword is ':' */</comment>
      &amp;&amp; (<name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> == ':') <comment type="block">/* second char after keyword is ':' */</comment>
      &amp;&amp; (<name><name>buf_ptr</name><index>[<expr>2</expr>]</index></name> == ' ') <comment type="block">/* third char after keyword is ' ' */</comment>
      &amp;&amp; ((<name><name>buf</name><index>[<expr>*<name>len</name> - 2</expr>]</index></name> == ' ')  <comment type="block">/* has ' ' for next to last character */</comment>
          || (<name><name>buf</name><index>[<expr>*<name>len</name> - 2</expr>]</index></name> == '#')) <comment type="block">/* .. or has '#' for next to last
                                        character */</comment>
      &amp;&amp; ((6 + <name>keyword_len</name>) &lt; *<name>len</name>)</expr>)</condition><then>  <comment type="block">/* holds "$kw:: x $" at least */</comment>
    <block>{
      <comment type="block">/* This is fixed length keyword, so *len remains unchanged */</comment>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>max_value_len</name> <init>= <expr>*<name>len</name> - (6 + <name>keyword_len</name>)</expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>! <name>value</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* no value, so unexpand */</comment>
          <expr_stmt><expr><name>buf_ptr</name> += 2</expr>;</expr_stmt>
          <while>while <condition>(<expr>*<name>buf_ptr</name> != '$'</expr>)</condition>
            <expr_stmt><expr>*(<name>buf_ptr</name>++) = ' '</expr>;</expr_stmt></while>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr><name><name>value</name>-&gt;<name>len</name></name> &lt;= <name>max_value_len</name></expr>)</condition><then>
            <block>{ <comment type="block">/* replacement not as long as template, pad with spaces */</comment>
              <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf_ptr</name> + 3</expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>buf_ptr</name> += 3 + <name><name>value</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
              <while>while <condition>(<expr>*<name>buf_ptr</name> != '$'</expr>)</condition>
                <expr_stmt><expr>*(<name>buf_ptr</name>++) = ' '</expr>;</expr_stmt></while>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* replacement needs truncating */</comment>
              <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf_ptr</name> + 3</expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>max_value_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>buf</name><index>[<expr>*<name>len</name> - 2</expr>]</index></name> = '#'</expr>;</expr_stmt>
              <expr_stmt><expr><name><name>buf</name><index>[<expr>*<name>len</name> - 1</expr>]</index></name> = '$'</expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then>

  <comment type="block">/* Check for unexpanded keyword. */</comment>
  <else>else <if>if <condition>(<expr><name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> == '$'</expr>)</condition><then>          <comment type="block">/* "$keyword$" */</comment>
    <block>{
      <comment type="block">/* unexpanded... */</comment>
      <if>if <condition>(<expr><name>value</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ...so expand. */</comment>
          <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> = ':'</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> = ' '</expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>value</name>-&gt;<name>len</name></name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>apr_size_t</name></type> <name>vallen</name> <init>= <expr><name><name>value</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>

              <comment type="block">/* "$keyword: value $" */</comment>
              <if>if <condition>(<expr><name>vallen</name> &gt; (<name>SVN_KEYWORD_MAX_LEN</name> - 5 - <name>keyword_len</name>)</expr>)</condition><then>
                <expr_stmt><expr><name>vallen</name> = <name>SVN_KEYWORD_MAX_LEN</name> - 5 - <name>keyword_len</name></expr>;</expr_stmt></then></if>
              <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf_ptr</name> + 2</expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2 + <name>vallen</name></expr>]</index></name> = ' '</expr>;</expr_stmt>
              <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2 + <name>vallen</name> + 1</expr>]</index></name> = '$'</expr>;</expr_stmt>
              <expr_stmt><expr>*<name>len</name> = 5 + <name>keyword_len</name> + <name>vallen</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* "$keyword: $"  */</comment>
              <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2</expr>]</index></name> = '$'</expr>;</expr_stmt>
              <expr_stmt><expr>*<name>len</name> = 4 + <name>keyword_len</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* ...but do nothing. */</comment>
        }</block></else></if>
      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then>

  <comment type="block">/* Check for expanded keyword. */</comment>
  <else>else <if>if <condition>(<expr>((*<name>len</name> &gt;= 4 + <name>keyword_len</name> ) <comment type="block">/* holds at least "$keyword: $" */</comment>
           &amp;&amp; (<name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> == ':')      <comment type="block">/* first char after keyword is ':' */</comment>
           &amp;&amp; (<name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> == ' ')      <comment type="block">/* second char after keyword is ' ' */</comment>
           &amp;&amp; (<name><name>buf</name><index>[<expr>*<name>len</name> - 2</expr>]</index></name> == ' '))
        || ((*<name>len</name> &gt;= 3 + <name>keyword_len</name> ) <comment type="block">/* holds at least "$keyword:$" */</comment>
           &amp;&amp; (<name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> == ':')      <comment type="block">/* first char after keyword is ':' */</comment>
           &amp;&amp; (<name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> == '$'))</expr>)</condition><then>    <comment type="block">/* second char after keyword is '$' */</comment>
    <block>{
      <comment type="block">/* expanded... */</comment>
      <if>if <condition>(<expr>! <name>value</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ...so unexpand. */</comment>
          <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> = '$'</expr>;</expr_stmt>
          <expr_stmt><expr>*<name>len</name> = 2 + <name>keyword_len</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* ...so re-expand. */</comment>
          <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> = ':'</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> = ' '</expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>value</name>-&gt;<name>len</name></name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>apr_size_t</name></type> <name>vallen</name> <init>= <expr><name><name>value</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>

              <comment type="block">/* "$keyword: value $" */</comment>
              <if>if <condition>(<expr><name>vallen</name> &gt; (<name>SVN_KEYWORD_MAX_LEN</name> - 5)</expr>)</condition><then>
                <expr_stmt><expr><name>vallen</name> = <name>SVN_KEYWORD_MAX_LEN</name> - 5</expr>;</expr_stmt></then></if>
              <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf_ptr</name> + 2</expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2 + <name>vallen</name></expr>]</index></name> = ' '</expr>;</expr_stmt>
              <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2 + <name>vallen</name> + 1</expr>]</index></name> = '$'</expr>;</expr_stmt>
              <expr_stmt><expr>*<name>len</name> = 5 + <name>keyword_len</name> + <name>vallen</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* "$keyword: $"  */</comment>
              <expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2</expr>]</index></name> = '$'</expr>;</expr_stmt>
              <expr_stmt><expr>*<name>len</name> = 4 + <name>keyword_len</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>
      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if></else></if></else></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* Parse BUF (whose length is LEN, and which starts and ends with '$'),
   trying to match one of the keyword names in KEYWORDS.  If such a
   keyword is found, update *KEYWORD_NAME with the keyword name and
   return TRUE. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>match_keyword</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
              <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
              <param><decl><type><name>char</name> *</type><name>keyword_name</name></decl></param>,
              <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Early return for ignored keywords */</comment>
  <if>if <condition>(<expr>! <name>keywords</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* Extract the name of the keyword */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name> - 2 &amp;&amp; <name><name>buf</name><index>[<expr><name>i</name> + 1</expr>]</index></name> != ':'</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <expr_stmt><expr><name><name>keyword_name</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr>;</expr_stmt></for>
  <expr_stmt><expr><name><name>keyword_name</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

  <return>return <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Try to translate keyword *KEYWORD_NAME in BUF (whose length is LEN):
   optionally perform the substitution in place, update *LEN with
   the new length of the translated keyword string, and return TRUE.
   If this buffer doesn't contain a known keyword pattern, leave BUF
   and *LEN untouched and return FALSE.

   See the docstring for svn_subst_copy_and_translate for how the
   EXPAND and KEYWORDS parameters work.

   NOTE: It is assumed that BUF has been allocated to be at least
   SVN_KEYWORD_MAX_LEN bytes longs, and that the data in BUF is less
   than or equal SVN_KEYWORD_MAX_LEN in length.  Also, any expansions
   which would result in a keyword string which is greater than
   SVN_KEYWORD_MAX_LEN will have their values truncated in such a way
   that the resultant keyword string is still valid (begins with
   "$Keyword:", ends in " $" and is SVN_KEYWORD_MAX_LEN bytes long).  */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>translate_keyword</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
                  <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keyword_name</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                  <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure we gotz good stuffs. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>len</name> &lt;= <name>SVN_KEYWORD_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>buf</name><index>[<expr>0</expr>]</index></name> == '$') &amp;&amp; (<name><name>buf</name><index>[<expr>*<name>len</name> - 1</expr>]</index></name> == '$')</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Early return for ignored keywords */</comment>
  <if>if <condition>(<expr>! <name>keywords</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>value</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>translate_keyword_subst</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
                                     <argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>keyword_name</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>expand</name> ? <name>value</name> : <name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<comment type="block">/* Translate NEWLINE_BUF (length of NEWLINE_LEN) to the newline format
   specified in EOL_STR (length of EOL_STR_LEN), and write the
   translated thing to FILE (whose path is DST_PATH).

   SRC_FORMAT (length *SRC_FORMAT_LEN) is a cache of the first newline
   found while processing SRC_PATH.  If the current newline is not the
   same style as that of SRC_FORMAT, look to the REPAIR parameter.  If
   REPAIR is TRUE, ignore the inconsistency, else return an
   SVN_ERR_IO_INCONSISTENT_EOL error.  If we are examining the first
   newline in the file, copy it to {SRC_FORMAT, *SRC_FORMAT_LEN} to
   use for later consistency checks. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translate_newline</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                  <param><decl><type><name>apr_size_t</name></type> <name>eol_str_len</name></decl></param>,
                  <param><decl><type><name>char</name> *</type><name>src_format</name></decl></param>,
                  <param><decl><type><name>apr_size_t</name> *</type><name>src_format_len</name></decl></param>,
                  <param><decl><type><name>char</name> *</type><name>newline_buf</name></decl></param>,
                  <param><decl><type><name>apr_size_t</name></type> <name>newline_len</name></decl></param>,
                  <param><decl><type><name>svn_stream_t</name> *</type><name>dst</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* If this is the first newline we've seen, cache it
     future comparisons, else compare it with our cache to
     check for consistency. */</comment>
  <if>if <condition>(<expr>*<name>src_format_len</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Comparing with cache.  If we are inconsistent and
         we are NOT repairing the file, generate an error! */</comment>
      <if>if <condition>(<expr>(! <name>repair</name>) &amp;&amp;
          ((*<name>src_format_len</name> != <name>newline_len</name>) ||
           (<call><name>strncmp</name><argument_list>(<argument><expr><name>src_format</name></expr></argument>, <argument><expr><name>newline_buf</name></expr></argument>, <argument><expr><name>newline_len</name></expr></argument>)</argument_list></call>))</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_IO_INCONSISTENT_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* This is our first line ending, so cache it before
         handling it. */</comment>
      <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>src_format</name></expr></argument>, <argument><expr><name>newline_buf</name></expr></argument>, <argument><expr><name>newline_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>src_format_len</name> = <name>newline_len</name></expr>;</expr_stmt>
    }</block></else></if>
  <comment type="block">/* Translate the newline */</comment>
  <return>return <expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>eol_str_len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Public interfaces. ***/</comment>

<function><type><name>svn_boolean_t</name></type>
<name>svn_subst_keywords_differ</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>a</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>b</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>compare_values</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>((<name>a</name> == <name>NULL</name>) &amp;&amp; (<name>b</name> == <name>NULL</name>)) <comment type="block">/* no A or B */</comment>
      <comment type="block">/* no A, and B has no contents */</comment>
      || ((<name>a</name> == <name>NULL</name>)
          &amp;&amp; (<name><name>b</name>-&gt;<name>revision</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>b</name>-&gt;<name>date</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>b</name>-&gt;<name>author</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>b</name>-&gt;<name>url</name></name> == <name>NULL</name>))
      <comment type="block">/* no B, and A has no contents */</comment>
      || ((<name>b</name> == <name>NULL</name>)           &amp;&amp; (<name><name>a</name>-&gt;<name>revision</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>a</name>-&gt;<name>date</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>a</name>-&gt;<name>author</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>a</name>-&gt;<name>url</name></name> == <name>NULL</name>))
      <comment type="block">/* neither A nor B has any contents */</comment>
      || ((<name>a</name> != <name>NULL</name>) &amp;&amp; (<name>b</name> != <name>NULL</name>)
          &amp;&amp; (<name><name>b</name>-&gt;<name>revision</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>b</name>-&gt;<name>date</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>b</name>-&gt;<name>author</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>b</name>-&gt;<name>url</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>a</name>-&gt;<name>revision</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>a</name>-&gt;<name>date</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>a</name>-&gt;<name>author</name></name> == <name>NULL</name>)
          &amp;&amp; (<name><name>a</name>-&gt;<name>url</name></name> == <name>NULL</name>))</expr>)</condition><then>
    <block>{
      <return>return <expr><name>FALSE</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr>(<name>a</name> == <name>NULL</name>) || (<name>b</name> == <name>NULL</name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>

  <comment type="block">/* Else both A and B have some keywords. */</comment>

  <if>if <condition>(<expr>(! <name><name>a</name>-&gt;<name>revision</name></name>) != (! <name><name>b</name>-&gt;<name>revision</name></name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr>(<name>compare_values</name> &amp;&amp; (<name><name>a</name>-&gt;<name>revision</name></name> != <name>NULL</name>))
           &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>revision</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>revision</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>

  <if>if <condition>(<expr>(! <name><name>a</name>-&gt;<name>date</name></name>) != (! <name><name>b</name>-&gt;<name>date</name></name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr>(<name>compare_values</name> &amp;&amp; (<name><name>a</name>-&gt;<name>date</name></name> != <name>NULL</name>))
           &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>date</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>date</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>

  <if>if <condition>(<expr>(! <name><name>a</name>-&gt;<name>author</name></name>) != (! <name><name>b</name>-&gt;<name>author</name></name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr>(<name>compare_values</name> &amp;&amp; (<name><name>a</name>-&gt;<name>author</name></name> != <name>NULL</name>))
           &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>author</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>author</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>

  <if>if <condition>(<expr>(! <name><name>a</name>-&gt;<name>url</name></name>) != (! <name><name>b</name>-&gt;<name>url</name></name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr>(<name>compare_values</name> &amp;&amp; (<name><name>a</name>-&gt;<name>url</name></name> != <name>NULL</name>))
           &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>url</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>url</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>

  <comment type="block">/* Else we never found a difference, so they must be the same. */</comment>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<function><type><name>svn_boolean_t</name></type>
<name>svn_subst_keywords_differ2</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>a</name></decl></param>,
                           <param><decl><type><name>apr_hash_t</name> *</type><name>b</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>compare_values</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>a_count</name></decl>, <decl><type ref="prev"/><name>b_count</name></decl>;</decl_stmt>

  <comment type="block">/* An empty hash is logically equal to a NULL,
   * as far as this API is concerned. */</comment>
  <expr_stmt><expr><name>a_count</name> = (<name>a</name> == <name>NULL</name>) ? 0 : <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>b_count</name> = (<name>b</name> == <name>NULL</name>) ? 0 : <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>a_count</name> != <name>b_count</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>a_count</name> == 0</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* The hashes are both non-NULL, and have the same number of items.
   * We must check that every item of A is present in B. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>void_a_val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>a_val</name></decl>, *<decl><type ref="prev"/><name>b_val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>void_a_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>a_val</name> = <name>void_a_val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>b_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>!<name>b_val</name> || (<name>compare_values</name> &amp;&amp; !<call><name>svn_string_compare</name><argument_list>(<argument><expr><name>a_val</name></expr></argument>, <argument><expr><name>b_val</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><name>TRUE</name></expr>;</return></then></if>
    }</block></for>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_stream2</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>s</name></decl></param>, <comment type="block">/* src stream */</comment>
                            <param><decl><type><name>svn_stream_t</name> *</type><name>d</name></decl></param>, <comment type="block">/* dst stream */</comment>
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kh</name> <init>= <expr><call><name>kwstruct_to_kwhash</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_subst_translate_stream3</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>kh</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Baton for translate_chunk() to store its state in. */</comment>
<struct>struct <name>translation_baton</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl>;</decl_stmt>

  <comment type="block">/* Characters (excluding the terminating NUL character) which
     may trigger a translation action, hence are 'interesting' */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>interesting</name></decl>;</decl_stmt>

  <comment type="block">/* Length of the string EOL_STR points to. */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>eol_str_len</name></decl>;</decl_stmt>

  <comment type="block">/* Buffer to cache any newline state between translation chunks */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>newline_buf</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* Offset (within newline_buf) of the first *unused* character */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>newline_off</name></decl>;</decl_stmt>

  <comment type="block">/* Buffer to cache keyword-parsing state between translation chunks */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>keyword_buf</name><index>[<expr><name>SVN_KEYWORD_MAX_LEN</name></expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* Offset (within keyword-buf) to the first *unused* character */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>keyword_off</name></decl>;</decl_stmt>

  <comment type="block">/* EOL style used in the chunk-source */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>src_format</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* Length of the EOL style string found in the chunk-source,
     or zero if none encountered yet */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>src_format_len</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Allocate a baton for use with translate_chunk() in POOL and
 * initialize it for the first iteration.
 *
 * The caller must assure that EOL_STR and KEYWORDS at least
 * have the same life time as that of POOL.
 *
 */</comment>

<function><type><specifier>static</specifier> struct <name>translation_baton</name> *</type>
<name>create_translation_baton</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                         <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>translation_baton</name> *</type><name>b</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* For efficiency, convert an empty set of keywords to NULL. */</comment>
  <if>if <condition>(<expr><name>keywords</name> &amp;&amp; (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
    <expr_stmt><expr><name>keywords</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name><name>b</name>-&gt;<name>eol_str</name></name> = <name>eol_str</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>eol_str_len</name></name> = <name>eol_str</name> ? <call><name>strlen</name><argument_list>(<argument><expr><name>eol_str</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>repair</name></name> = <name>repair</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>keywords</name></name> = <name>keywords</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>expand</name></name> = <name>expand</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>interesting</name></name> = (<name>eol_str</name> &amp;&amp; <name>keywords</name>) ? "$\r\n" : <name>eol_str</name> ? "\r\n" : "$"</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>newline_off</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>src_format_len</name></name> = 0</expr>;</expr_stmt>

  <return>return <expr><name>b</name></expr>;</return>
}</block></function>

<comment type="block">/* Translate eols and keywords of a 'chunk' of characters BUF of size BUFLEN
 * according to the settings and state stored in baton B.
 *
 * Write output to stream DST.
 *
 * To finish a series of chunk translations, flush all buffers by calling
 * this routine with a NULL value for BUF.
 *
 * Use POOL for temporary allocations.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translate_chunk</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>dst</name></decl></param>,
                <param><decl><type>struct <name>translation_baton</name> *</type><name>b</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl></param>,
                <param><decl><type><name>apr_size_t</name></type> <name>buflen</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>buf</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* precalculate some oft-used values */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>buf</name> + <name>buflen</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>interesting</name> <init>= <expr><name><name>b</name>-&gt;<name>interesting</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>next_sign_off</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

      <comment type="block">/* At the beginning of this loop, assume that we might be in an
       * interesting state, i.e. with data in the newline or keyword
       * buffer.  First try to get to the boring state so we can copy
       * a run of boring characters; then try to get back to the
       * interesting state by processing an interesting character,
       * and repeat. */</comment>
      <for>for (<init><expr><name>p</name> = <name>buf</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>end</name></expr>;</condition><incr/>)
        <block>{
          <comment type="block">/* Try to get to the boring state, if necessary. */</comment>
          <if>if <condition>(<expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr>*<name>p</name> == '\n'</expr>)</condition><then>
                <expr_stmt><expr><name><name>b</name>-&gt;<name>newline_buf</name><index>[<expr><name><name>b</name>-&gt;<name>newline_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt></then></if>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_newline</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>eol_str</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>eol_str_len</name></name></expr></argument>,
                                        <argument><expr><name><name>b</name>-&gt;<name>src_format</name></name></expr></argument>,
                                        <argument><expr>&amp;<name><name>b</name>-&gt;<name>src_format_len</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>newline_buf</name></name></expr></argument>,
                                        <argument><expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repair</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><name><name>b</name>-&gt;<name>newline_off</name></name> = 0</expr>;</expr_stmt>
            }</block></then>
          <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>keyword_off</name></name> &amp;&amp; *<name>p</name> == '$'</expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>keyword_matches</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>char</name></type> <name><name>keyword_name</name><index>[<expr><name>SVN_KEYWORD_MAX_LEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>

              <comment type="block">/* If keyword is matched, but not correctly translated, try to
               * look for the next ending '$'. */</comment>
              <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_buf</name><index>[<expr><name><name>b</name>-&gt;<name>keyword_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
              <expr_stmt><expr><name>keyword_matches</name> = <call><name>match_keyword</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>,
                                              <argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keywords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>keyword_matches</name> == <name>FALSE</name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* reuse the ending '$' */</comment>
                  <expr_stmt><expr><name>p</name>--</expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name>--</expr>;</expr_stmt>
                }</block></then></if>

              <if>if <condition>(<expr><name>keyword_matches</name> == <name>FALSE</name> ||
                  <call><name>translate_keyword</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>,
                                    <argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>expand</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keywords</name></name></expr></argument>)</argument_list></call> ||
                  <name><name>b</name>-&gt;<name>keyword_off</name></name> &gt;= <name>SVN_KEYWORD_MAX_LEN</name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* write out non-matching text or translated keyword */</comment>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <expr_stmt><expr><name>next_sign_off</name> = 0</expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = 0</expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <if>if <condition>(<expr><name>next_sign_off</name> == 0</expr>)</condition><then>
                    <expr_stmt><expr><name>next_sign_off</name> = <name><name>b</name>-&gt;<name>keyword_off</name></name> - 1</expr>;</expr_stmt></then></if>

                  <continue>continue;</continue>
                }</block></else></if>
            }</block></then>
          <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>keyword_off</name></name> == <name>SVN_KEYWORD_MAX_LEN</name> - 1
                   || (<name><name>b</name>-&gt;<name>keyword_off</name></name> &amp;&amp; (*<name>p</name> == '\r' || *<name>p</name> == '\n'))</expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name>next_sign_off</name> &gt; 0</expr>)</condition><then>
              <block>{
                <comment type="block">/* rolling back, continue with next '$' in keyword_buf */</comment>
                <expr_stmt><expr><name>p</name> -= (<name><name>b</name>-&gt;<name>keyword_off</name></name> - <name>next_sign_off</name>)</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = <name>next_sign_off</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>next_sign_off</name> = 0</expr>;</expr_stmt>
              }</block></then></if>
              <comment type="block">/* No closing '$' found; flush the keyword buffer. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = 0</expr>;</expr_stmt>
            }</block></then>
          <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_buf</name><index>[<expr><name><name>b</name>-&gt;<name>keyword_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then></if></else></if></else></if></else></if>

          <comment type="block">/* We're in the boring state; look for interest characters. */</comment>
          <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>

          <comment type="block">/* We wanted memcspn(), but lacking that, the loop below has
             the same effect.

             Also, skip NUL characters explicitly, since strchr()
             considers them part of the string argument,
             but we don't consider them interesting
          */</comment>
          <while>while <condition>(<expr>(<name>p</name> + <name>len</name>) &lt; <name>end</name>
                 &amp;&amp; (! <name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> || ! <call><name>strchr</name><argument_list>(<argument><expr><name>interesting</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition>
            <expr_stmt><expr><name>len</name>++</expr>;</expr_stmt></while>

          <if>if <condition>(<expr><name>len</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><name>p</name> += <name>len</name></expr>;</expr_stmt>

          <comment type="block">/* Set up state according to the interesting character, if any. */</comment>
          <if>if <condition>(<expr><name>p</name> &lt; <name>end</name></expr>)</condition><then>
            <block>{
              <switch>switch <condition>(<expr>*<name>p</name></expr>)</condition>
                <block>{
                <case>case <expr>'$'</expr>:
                  <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_buf</name><index>[<expr><name><name>b</name>-&gt;<name>keyword_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
                  <break>break;</break>
                </case><case>case <expr>'\r'</expr>:
                  <expr_stmt><expr><name><name>b</name>-&gt;<name>newline_buf</name><index>[<expr><name><name>b</name>-&gt;<name>newline_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
                  <break>break;</break>
                </case><case>case <expr>'\n'</expr>:
                  <expr_stmt><expr><name><name>b</name>-&gt;<name>newline_buf</name><index>[<expr><name><name>b</name>-&gt;<name>newline_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>

                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_newline</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>eol_str</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>eol_str_len</name></name></expr></argument>,
                                            <argument><expr><name><name>b</name>-&gt;<name>src_format</name></name></expr></argument>,
                                            <argument><expr>&amp;<name><name>b</name>-&gt;<name>src_format_len</name></name></expr></argument>,
                                            <argument><expr><name><name>b</name>-&gt;<name>newline_buf</name></name></expr></argument>,
                                            <argument><expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repair</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <expr_stmt><expr><name><name>b</name>-&gt;<name>newline_off</name></name> = 0</expr>;</expr_stmt>
                  <break>break;</break>

                </case>}</block></switch>
            }</block></then></if>
        }</block></for>
    }</block></then>
  <else>else
    <block>{
      <if>if <condition>(<expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_newline</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>eol_str</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>eol_str_len</name></name></expr></argument>,
                                    <argument><expr><name><name>b</name>-&gt;<name>src_format</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>src_format_len</name></name></expr></argument>,
                                    <argument><expr><name><name>b</name>-&gt;<name>newline_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr></argument>,
                                    <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repair</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>b</name>-&gt;<name>newline_off</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Baton for use with translated stream callbacks. */</comment>
<struct>struct <name>translated_stream_baton</name>
<block>{
  <comment type="block">/* Stream to take input from (before translation) on read
     /write output to (after translation) on write. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <comment type="block">/* Input/Output translation batons to make them separate chunk streams. */</comment>
  <decl_stmt><decl><type>struct <name>translation_baton</name> *</type><name>in_baton</name></decl>, *<decl><type ref="prev"/><name>out_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Remembers whether any write operations have taken place;
     if so, we need to flush the output chunk stream. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>written</name></decl>;</decl_stmt>

  <comment type="block">/* Buffer to hold translated read data. */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>readbuf</name></decl>;</decl_stmt>

  <comment type="block">/* Offset of the first non-read character in readbuf. */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>readbuf_off</name></decl>;</decl_stmt>

  <comment type="block">/* Buffer to hold read data
     between svn_stream_read() and translate_chunk(). */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>

  <comment type="block">/* Pool in which (only!) this baton is allocated. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <comment type="block">/* Pool for callback iterations */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translated_stream_read</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                       <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>,
                       <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>translated_stream_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>readlen</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>unsatisfied</name> <init>= <expr>*<name>len</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>off</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>iterpool</name> = <name><name>b</name>-&gt;<name>iterpool</name></name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>readlen</name> == <name>SVN__STREAM_CHUNK_SIZE</name> &amp;&amp; <name>unsatisfied</name> &gt; 0</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>to_copy</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buffer_remainder</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* fill read buffer, if necessary */</comment>
      <if>if <condition>(<expr>! (<name><name>b</name>-&gt;<name>readbuf_off</name></name> &lt; <name><name>b</name>-&gt;<name>readbuf</name>-&gt;<name>len</name></name>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>buf_stream</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_stringbuf_setempty</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>readbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>b</name>-&gt;<name>readbuf_off</name></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr>&amp;<name>readlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>buf_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>readbuf</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name>buf_stream</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>in_baton</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>buf</name></name></expr></argument>,
                                  <argument><expr><name>readlen</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>readlen</name> != <name>SVN__STREAM_CHUNK_SIZE</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name>buf_stream</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>in_baton</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
                                    <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>buf_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Satisfy from the read buffer */</comment>
      <expr_stmt><expr><name>buffer_remainder</name> = <name><name>b</name>-&gt;<name>readbuf</name>-&gt;<name>len</name></name> - <name><name>b</name>-&gt;<name>readbuf_off</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>to_copy</name> = (<name>buffer_remainder</name> &gt; <name>unsatisfied</name>)
        ? <name>unsatisfied</name> : <name>buffer_remainder</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name> + <name>off</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>readbuf</name>-&gt;<name>data</name></name> + <name><name>b</name>-&gt;<name>readbuf_off</name></name></expr></argument>, <argument><expr><name>to_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>off</name> += <name>to_copy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name>-&gt;<name>readbuf_off</name></name> += <name>to_copy</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>unsatisfied</name> -= <name>to_copy</name></expr>;</expr_stmt>
    }</block></while>

  <expr_stmt><expr>*<name>len</name> -= <name>unsatisfied</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translated_stream_write</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>,
                        <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>translated_stream_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>iterpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>b</name>-&gt;<name>written</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>out_baton</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>,
                          <argument><expr><name><name>b</name>-&gt;<name>iterpool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translated_stream_close</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>translated_stream_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>written</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>out_baton</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>iterpool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Also destroys the baton itself */</comment>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Given a special file at SRC, set TRANSLATED_STREAM_P to a stream
   with the textual representation of it. Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>detranslated_stream_special</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>translated_stream_p</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>strbuf</name></decl>;</decl_stmt>

  <comment type="block">/* First determine what type of special file we are
     detranslating. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name> | <name>APR_FINFO_LINK</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name></expr>)</condition> <block>{
  <case>case <expr><name>APR_REG</name></expr>:
    <comment type="block">/* Nothing special to do here, just create stream from the original
       file's contents. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                             <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>translated_stream_p</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <break>break;</break>
  </case><case>case <expr><name>APR_LNK</name></expr>:
    <comment type="block">/* Determine the destination of the link. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_link</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>strbuf</name> = <call><name>svn_stringbuf_createf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"link %s"</expr></argument>, <argument><expr><name><name>buf</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>translated_stream_p</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <break>break;</break>
  </case><default>default:
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </default>}</block></switch>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_stream_detranslated</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream_p</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                              <param><decl><type><name>svn_subst_eol_style_t</name></type> <name>eol_style</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>always_repair_eols</name></decl></param>,
                              <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file_h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>src_stream</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>special</name></expr>)</condition><then>
    <return>return <expr><call><name>detranslated_stream_special</name><argument_list>(<argument><expr><name>stream_p</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>eol_style</name> == <name>svn_subst_eol_style_native</name></expr>)</condition><then>
    <expr_stmt><expr><name>eol_str</name> = <name>SVN_SUBST__DEFAULT_EOL_STR</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr>! (<name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
              || <name>eol_style</name> == <name>svn_subst_eol_style_none</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNKNOWN_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file_h</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>src_stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>file_h</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>stream_p</name> = <call><name>svn_subst_stream_translated</name><argument_list>(
    <argument><expr><name>src_stream</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
    <argument><expr><name>eol_style</name> == <name>svn_subst_eol_style_fixed</name> || <name>always_repair_eols</name></expr></argument>,
    <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_stream_t</name> *</type>
<name>svn_subst_stream_translated</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                            <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>baton_pool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>translated_stream_baton</name> *</type><name>baton</name>
    <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>s</name> <init>= <expr><call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make sure EOL_STR and KEYWORDS are allocated in POOL, as
     required by create_translation_baton() */</comment>
  <if>if <condition>(<expr><name>eol_str</name></expr>)</condition><then>
    <expr_stmt><expr><name>eol_str</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>keywords</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>keywords</name> = <name>NULL</name></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <comment type="block">/* deep copy the hash to make sure it's allocated in POOL */</comment>
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>copy</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</init>
               <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                           <argument><expr><call><name>svn_string_dup</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

          <expr_stmt><expr><name>keywords</name> = <name>copy</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* Setup the baton fields */</comment>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>stream</name></name> = <name>stream</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>in_baton</name></name>
    = <call><name>create_translation_baton</name><argument_list>(<argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>out_baton</name></name>
    = <call><name>create_translation_baton</name><argument_list>(<argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>written</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>readbuf</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>readbuf_off</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>iterpool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>pool</name></name> = <name>baton_pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>buf</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Setup the stream methods */</comment>
  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>translated_stream_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>translated_stream_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>translated_stream_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>s</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_stream3</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>s</name></decl></param>, <comment type="block">/* src stream */</comment>
                            <param><decl><type><name>svn_stream_t</name> *</type><name>d</name></decl></param>, <comment type="block">/* dst stream */</comment>
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                            <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>translation_baton</name> *</type><name>baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>readlen</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The docstring requires that *some* translation be requested. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>eol_str</name> || <name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>baton</name> = <call><name>create_translation_baton</name><argument_list>(<argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>readlen</name> == <name>SVN__STREAM_CHUNK_SIZE</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>readlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>readlen</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* also destroys iterpool */</comment>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_stream</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>s</name></decl></param>, <comment type="block">/* src stream */</comment>
                           <param><decl><type><name>svn_stream_t</name> *</type><name>d</name></decl></param>, <comment type="block">/* dst stream */</comment>
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_subst_translate_stream2</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>,
                                                 <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_cstring</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dst</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kh</name> <init>= <expr><call><name>kwstruct_to_kwhash</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_subst_translate_cstring2</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>,
                                      <argument><expr><name>kh</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_cstring2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dst</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                             <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>src_stringbuf</name></decl>, *<decl><type ref="prev"/><name>dst_stringbuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>src_stream</name></decl>, *<decl><type ref="prev"/><name>dst_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>src_stringbuf</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The easy way out:  no translation needed, just copy. */</comment>
  <if>if <condition>(<expr>! (<name>eol_str</name> || (<name>keywords</name> &amp;&amp; (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call> &gt; 0)))</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>dst_stringbuf</name> = <call><name>svn_stringbuf_dup</name><argument_list>(<argument><expr><name>src_stringbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>all_good</name>;</goto>
    }</block></then></if>

  <comment type="block">/* Convert our stringbufs into streams. */</comment>
  <expr_stmt><expr><name>src_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name>src_stringbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dst_stringbuf</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dst_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name>dst_stringbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Translate src stream into dst stream. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_subst_translate_stream3</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>, <argument><expr><name>dst_stream</name></expr></argument>,
                                    <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>dst_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* clean up nicely. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>dst_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <label><name>all_good</name>:</label>
  <expr_stmt><expr>*<name>dst</name> = <name><name>dst_stringbuf</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_copy_and_translate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_subst_copy_and_translate2</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
                                       <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Set SRC_STREAM to a stream from which the internal representation
 * for the special file at SRC can be read.
 *
 * The stream returned will be allocated in POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>detranslate_special_file_to_stream</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>src_stream</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>buf</name></decl>;</decl_stmt>

  <comment type="block">/* First determine what type of special file we are
     detranslating. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name> | <name>APR_FINFO_LINK</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 <switch>switch <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name></expr>)</condition> <block>{
  <case>case <expr><name>APR_REG</name></expr>:
    <comment type="block">/* Nothing special to do here, just copy the original file's
       contents. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                              <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>src_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <break>break;</break>
  </case><case>case <expr><name>APR_LNK</name></expr>:
    <comment type="block">/* Determine the destination of the link. */</comment>

    <expr_stmt><expr>*<name>src_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><call><name>svn_stringbuf_create</name> <argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_link</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr>*<name>src_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"link %s"</expr></argument>,
                              <argument><expr><name><name>buf</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </case><default>default:
    <expr_stmt><expr><call><name>abort</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
  </default>}</block></switch>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Given a special file at SRC, generate a textual representation of
   it in a normal file at DST.  Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>detranslate_special_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>src_stream</name></decl>, *<decl><type ref="prev"/><name>dst_stream</name></decl>;</decl_stmt>


  <comment type="block">/* Open a temporary destination that we will eventually atomically
     rename into place. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>,
                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>dst_stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>detranslate_special_file_to_stream</name><argument_list>(<argument><expr>&amp;<name>src_stream</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_copy</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>, <argument><expr><name>dst_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>dst_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do the atomic rename from our temporary location. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Creates a special file DST from the internal representation given
 * in SRC.
 *
 * All temporary allocations will be done in POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_special_file_from_stringbuf</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>src</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>identifier</name></decl>, *<decl><type ref="prev"/><name>remainder</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>create_using_internal_representation</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Separate off the identifier.  The first space character delimits
     the identifier, after which any remaining characters are specific
     to the actual special file type being created. */</comment>
  <expr_stmt><expr><name>identifier</name> = <name><name>src</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
  <for>for (<init><expr><name>remainder</name> = <name>identifier</name></expr>;</init> <condition><expr>*<name>remainder</name></expr>;</condition> <incr><expr><name>remainder</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr>*<name>remainder</name> == ' '</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>remainder</name>++</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
    }</block></for>

  <if>if <condition>(<expr>! <call><name>strncmp</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>, <argument><expr><name>SVN_SUBST__SPECIAL_LINK_STR</name> " "</expr></argument>,
                <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SVN_SUBST__SPECIAL_LINK_STR</name> " "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* For symlinks, the type specific data is just a filesystem
         path that the symlink should reference. */</comment>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_create_unique_link</name><argument_list>(<argument><expr>&amp;<name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>,
                                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If we had an error, check to see if it was because symlinks are
         not supported on the platform.  If so, fall back
         to using the internal representation. */</comment>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>create_using_internal_representation</name> = <name>TRUE</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <return>return <expr><name>err</name></expr>;</return></else></if>
        }</block></then></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Just create a normal file using the internal special file
         representation.  We don't want a commit of an unknown special
         file type to DoS all the clients. */</comment>
      <expr_stmt><expr><name>create_using_internal_representation</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* If nothing else worked, write out the internal representation to
     a file that can be edited by the user. */</comment>
  <if>if <condition>(<expr><name>create_using_internal_representation</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>dst_tmp_file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>written</name></decl>;</decl_stmt>


      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>dst_tmp_file</name></expr></argument>, <argument><expr>&amp;<name>dst_tmp</name></expr></argument>,
                                       <argument><expr><name>dst</name></expr></argument>, <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>dst_tmp_file</name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>,
                                     <argument><expr>&amp;<name>written</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>dst_tmp_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Do the atomic rename from our temporary location. */</comment>
  <return>return <expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Given a file containing a repository representation of a special
   file in SRC, create the appropriate special file at location DST.
   Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_special_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>contents</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_special</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>source</name></decl>;</decl_stmt>

  <comment type="block">/* Check to see if we are being asked to create a special file from
     a special file.  If so, do a temporary detranslation and work
     from there. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_special_path</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr>&amp;<name>is_special</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>is_special</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eof</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>detranslate_special_file_to_stream</name><argument_list>(<argument><expr>&amp;<name>source</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The special file normal form doesn't have line endings,
       * so, read all of the file into the stringbuf */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <comment type="block">/* Read in the detranslated file. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stringbuf_from_file</name><argument_list>(<argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><call><name>create_special_file_from_stringbuf</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_copy_and_translate2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kh</name> <init>= <expr><call><name>kwstruct_to_kwhash</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_subst_copy_and_translate3</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
                                       <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>kh</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>special</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_copy_and_translate3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
                              <param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>src_stream</name></decl>, *<decl><type ref="prev"/><name>dst_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init>, *<name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>  <comment type="block">/* init to null important for APR */</comment>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path_special</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_special_path</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr>&amp;<name>path_special</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a 'special' file, we may need to create it or
     detranslate it. */</comment>
  <if>if <condition>(<expr><name>special</name> || <name>path_special</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>expand</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_special_file</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>detranslate_special_file</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* The easy way out:  no translation needed, just copy. */</comment>
  <if>if <condition>(<expr>! (<name>eol_str</name> || (<name>keywords</name> &amp;&amp; (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call> &gt; 0)))</expr>)</condition><then>
    <return>return <expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Open source file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For atomicity, we translate to a tmp file and
     then rename the tmp file over the real destination. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>,
                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now convert our two open files into streams. */</comment>
  <expr_stmt><expr><name>src_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dst_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Translate src stream into dst stream. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_subst_translate_stream3</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>, <argument><expr><name>dst_stream</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
                                    <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_IO_INCONSISTENT_EOL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_IO_INCONSISTENT_EOL</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"File '%s' has inconsistent newlines"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
      <else>else
        <return>return <expr><name>err</name></expr>;</return></else></if>
    }</block></then></if>

  <comment type="block">/* clean up nicely. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>dst_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now that dst_tmp contains the translated data, do the atomic rename. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** 'Special file' stream support */</comment>

<struct>struct <name>special_stream_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>read_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>write_content</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>write_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_special</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>special_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>read_stream</name></name></expr>)</condition><then>
    <comment type="block">/* We actually found a file to read from */</comment>
    <return>return <expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>read_stream</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>APR_ENOENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr>"Can't read special file: File '%s' not found"</expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name> <argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler_special</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>special_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>write_stream</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_handler_special</name> <parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>special_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>write_content</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* yeay! we received data and need to create a special file! */</comment>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_special_file_from_stringbuf</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>write_content</name></name></expr></argument>,
                                                 <argument><expr><name><name>btn</name>-&gt;<name>path</name></name></expr></argument>,
                                                 <argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_stream_from_specialfile</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>special_stream_baton</name> *</type><name>baton</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>baton</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>detranslate_special_file_to_stream</name><argument_list>(<argument><expr>&amp;<name><name>baton</name>-&gt;<name>read_stream</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>baton</name>-&gt;<name>read_stream</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name><name>baton</name>-&gt;<name>write_content</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>write_stream</name></name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>write_content</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr>*<name>stream</name></expr></argument>, <argument><expr><name>read_handler_special</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr>*<name>stream</name></expr></argument>, <argument><expr><name>write_handler_special</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr>*<name>stream</name></expr></argument>, <argument><expr><name>close_handler_special</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** String translation */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_string</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>new_value</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val_utf8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val_utf8_lf</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>new_value</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name>encoding</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8_ex2</name><argument_list>(<argument><expr>&amp;<name>val_utf8</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>,
                                          <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>val_utf8</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_translate_cstring2</name><argument_list>(<argument><expr><name>val_utf8</name></expr></argument>,
                                       <argument><expr>&amp;<name>val_utf8_lf</name></expr></argument>,
                                       <argument><expr>"\n"</expr></argument>,  <comment type="block">/* translate to LF */</comment>
                                       <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* no repair */</comment>
                                       <argument><expr><name>NULL</name></expr></argument>,  <comment type="block">/* no keywords */</comment>
                                       <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* no expansion */</comment>
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>new_value</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><name>val_utf8_lf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_detranslate_string</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>new_value</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>for_output</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val_neol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val_nlocale_neol</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>new_value</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_translate_cstring2</name><argument_list>(<argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>,
                                       <argument><expr>&amp;<name>val_neol</name></expr></argument>,
                                       <argument><expr><name>APR_EOL_STR</name></expr></argument>,  <comment type="block">/* 'native' eol */</comment>
                                       <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* no repair */</comment>
                                       <argument><expr><name>NULL</name></expr></argument>,  <comment type="block">/* no keywords */</comment>
                                       <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* no expansion */</comment>
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>for_output</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_cmdline_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>val_nlocale_neol</name></expr></argument>, <argument><expr><name>val_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; (<call><name>APR_STATUS_IS_EINVAL</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>val_nlocale_neol</name> =
            <call><name>svn_cmdline_cstring_from_utf8_fuzzy</name><argument_list>(<argument><expr><name>val_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if></else></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>val_nlocale_neol</name></expr></argument>, <argument><expr><name>val_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; (<call><name>APR_STATUS_IS_EINVAL</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>val_nlocale_neol</name> = <call><name>svn_utf_cstring_from_utf8_fuzzy</name><argument_list>(<argument><expr><name>val_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if></else></if>
    }</block></else></if>

  <expr_stmt><expr>*<name>new_value</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><name>val_nlocale_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
