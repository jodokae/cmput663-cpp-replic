<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/utf.c"><comment type="block">/*
 * utf.c:  UTF-8 conversion routines
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_xlate.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32_xlate.h"</cpp:file></cpp:include>

<escape char="0xc"/>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_UTF_NTOU_XLATE_HANDLE</name></cpp:macro> <cpp:value>"svn-utf-ntou-xlate-handle"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_UTF_UTON_XLATE_HANDLE</name></cpp:macro> <cpp:value>"svn-utf-uton-xlate-handle"</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_APR_UTF8_CHARSET</name></cpp:macro> <cpp:value>"UTF-8"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_APR_UTF8_CHARSET</name></cpp:macro> <cpp:value>(const char*)1208</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_thread_mutex_t</name> *</type><name>xlate_handle_mutex</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The xlate handle cache is a global hash table with linked lists of xlate
 * handles.  In multi-threaded environments, a thread "borrows" an xlate
 * handle from the cache during a translation and puts it back afterwards.
 * This avoids holding a global lock for all translations.
 * If there is no handle for a particular key when needed, a new is
 * handle is created and put in the cache after use.
 * This means that there will be at most N handles open for a key, where N
 * is the number of simultanous handles in use for that key. */</comment>

<typedef>typedef <type><struct>struct <name>xlate_handle_node_t</name> <block>{
  <decl_stmt><decl><type><name>apr_xlate_t</name> *</type><name>handle</name></decl>;</decl_stmt>
  <comment type="block">/* FALSE if the handle is not valid, since its pool is being
     destroyed. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>valid</name></decl>;</decl_stmt>
  <comment type="block">/* The name of a char encoding or APR_LOCALE_CHARSET. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>frompage</name></decl>, *<name>topage</name>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>xlate_handle_node_t</name> *</type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>xlate_handle_node_t</name>;</typedef>

<comment type="block">/* This maps const char * userdata_key strings to xlate_handle_node_t **
   handles to the first entry in the linked list of xlate handles.  We don't
   store the pointer to the list head directly in the hash table, since we
   remove/insert entries at the head in the list in the code below, and
   we can't use apr_hash_set() in each character translation because that
   function allocates memory in each call where the value is non-NULL.
   Since these allocations take place in a global pool, this would be a
   memory leak. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_hash_t</name> *</type><name>xlate_handle_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Clean up the xlate handle cache. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>xlate_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* We set the cache variables to NULL so that translation works in other
     cleanup functions, even if it isn't cached then. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <expr_stmt><expr><call><name>apr_thread_mutex_destroy</name><argument_list>(<argument><expr><name>xlate_handle_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>xlate_handle_mutex</name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>xlate_handle_hash</name> = <name>NULL</name></expr>;</expr_stmt>

  <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/* Set the handle of ARG to NULL. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>xlate_handle_node_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>node</name>-&gt;<name>valid</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>svn_utf_initialize</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>mutex</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>!<name>xlate_handle_hash</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We create our own subpool, which we protect with the mutex.
         We can't use the pool passed to us by the caller, since we will
         use it for xlate handle allocations, possibly in multiple threads,
         and pool allocation is not thread-safe. */</comment>
      <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
      <if>if <condition>(<expr><call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name>mutex</name></expr></argument>, <argument><expr><name>APR_THREAD_MUTEX_DEFAULT</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call>
          == <name>APR_SUCCESS</name></expr>)</condition><then>
        <expr_stmt><expr><name>xlate_handle_mutex</name> = <name>mutex</name></expr>;</expr_stmt></then>
      <else>else
        <return>return;</return></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>xlate_handle_hash</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>xlate_cleanup</name></expr></argument>,
                                <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* Return a unique string key based on TOPAGE and FROMPAGE.  TOPAGE and
 * FROMPAGE can be any valid arguments of the same name to
 * apr_xlate_open().  Allocate the returned string in POOL. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>*</type>
<name>get_xlate_key</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>topage</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>frompage</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
  <comment type="block">/* In the cases of SVN_APR_LOCALE_CHARSET and SVN_APR_DEFAULT_CHARSET
   * topage/frompage is really an int, not a valid string.  So generate a
   * unique key accordingly. */</comment>
  <if>if <condition>(<expr><name>frompage</name> == <name>SVN_APR_LOCALE_CHARSET</name></expr>)</condition><then>
    <expr_stmt><expr><name>frompage</name> = "APR_LOCALE_CHARSET"</expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>frompage</name> == <name>SVN_APR_DEFAULT_CHARSET</name></expr>)</condition><then>
    <expr_stmt><expr><name>frompage</name> = "APR_DEFAULT_CHARSET"</expr>;</expr_stmt></then></if></else></if>

  <if>if <condition>(<expr><name>topage</name> == <name>SVN_APR_LOCALE_CHARSET</name></expr>)</condition><then>
    <expr_stmt><expr><name>topage</name> = "APR_LOCALE_CHARSET"</expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>topage</name> == <name>SVN_APR_DEFAULT_CHARSET</name></expr>)</condition><then>
    <expr_stmt><expr><name>topage</name> = "APR_DEFAULT_CHARSET"</expr>;</expr_stmt></then></if></else></if>

  <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn-utf-"</expr></argument>, <argument><expr><name>frompage</name></expr></argument>, <argument><expr>"to"</expr></argument>, <argument><expr><name>topage</name></expr></argument>,
                     <argument><expr>"-xlate-handle"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* OS400 code pages are always ints. */</comment>
  <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn-utf-%dto%d-xlate-handle"</expr></argument>, <argument><expr>(<name>int</name>)<name>frompage</name></expr></argument>,
                      <argument><expr>(<name>int</name>)<name>topage</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* Set *RET to a handle node for converting from FROMPAGE to TOPAGE,
   creating the handle node if it doesn't exist in USERDATA_KEY.
   If a node is not cached and apr_xlate_open() returns APR_EINVAL or
   APR_ENOTIMPL, set (*RET)-&gt;handle to NULL.  If fail for any other
   reason, return the error.

   Allocate *RET and its xlate handle in POOL if svn_utf_initialize()
   hasn't been called or USERDATA_KEY is NULL.  Else, allocate them
   in the pool of xlate_handle_hash. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_xlate_handle_node</name><parameter_list>(<param><decl><type><name>xlate_handle_node_t</name> **</type><name>ret</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>topage</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>frompage</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>userdata_key</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> **</type><name>old_node_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>old_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_xlate_t</name> *</type><name>handle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If we already have a handle, just return it. */</comment>
  <if>if <condition>(<expr><name>userdata_key</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>xlate_handle_hash</name></expr>)</condition><then>
        <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
          <expr_stmt><expr><name>apr_err</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name>xlate_handle_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>apr_err</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't lock charset translation mutex"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <expr_stmt><expr><name>old_node_p</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>xlate_handle_hash</name></expr></argument>, <argument><expr><name>userdata_key</name></expr></argument>,
                                    <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>old_node_p</name></expr>)</condition><then>
            <expr_stmt><expr><name>old_node</name> = *<name>old_node_p</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>old_node</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Ensure that the handle is still valid. */</comment>
              <if>if <condition>(<expr><name><name>old_node</name>-&gt;<name>valid</name></name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* Remove from the list. */</comment>
                  <expr_stmt><expr>*<name>old_node_p</name> = <name><name>old_node</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>old_node</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
                  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name>xlate_handle_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr><name>apr_err</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
                    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't unlock charset "
                                              "translation mutex"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                  <expr_stmt><expr>*<name>ret</name> = <name>old_node</name></expr>;</expr_stmt>
                  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>
          <comment type="block">/* We fall back on a per-pool cache instead. */</comment>
          <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>userdata_key</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>old_node</name> = <name>p</name></expr>;</expr_stmt>
          <comment type="block">/* Ensure that the handle is still valid. */</comment>
          <if>if <condition>(<expr><name>old_node</name> &amp;&amp; <name><name>old_node</name>-&gt;<name>valid</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr>*<name>ret</name> = <name>old_node</name></expr>;</expr_stmt>
              <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* Note that we still have the mutex locked (if it is initialized), so we
     can use the global pool for creating the new xlate handle. */</comment>

  <comment type="block">/* The error handling doesn't support the following cases, since we don't
     use them currently.  Catch this here. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
  <comment type="block">/* On OS400 V5R4 with UTF support, APR_DEFAULT_CHARSET and
   * APR_LOCALE_CHARSET are both UTF-8 (CCSID 1208), so we won't get far
   * with this assert active. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>frompage</name> != <name>SVN_APR_DEFAULT_CHARSET</name>
         &amp;&amp; <name>topage</name> != <name>SVN_APR_DEFAULT_CHARSET</name>
         &amp;&amp; (<name>frompage</name> != <name>SVN_APR_LOCALE_CHARSET</name>
             || <name>topage</name> != <name>SVN_APR_LOCALE_CHARSET</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Use the correct pool for creating the handle. */</comment>
  <if>if <condition>(<expr><name>userdata_key</name> &amp;&amp; <name>xlate_handle_hash</name></expr>)</condition><then>
    <expr_stmt><expr><name>pool</name> = <call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>xlate_handle_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Try to create a handle. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>( <argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>apr_err</name> = <call><name>svn_subr__win32_xlate_open</name><argument_list>(<argument><expr>(<name>win32_xlate_t</name> **)&amp;<name>handle</name></expr></argument>, <argument><expr><name>topage</name></expr></argument>,
                                       <argument><expr><name>frompage</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AS400</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_xlate_open</name><argument_list>(<argument><expr>&amp;<name>handle</name></expr></argument>, <argument><expr>(<name>int</name>)<name>topage</name></expr></argument>, <argument><expr>(<name>int</name>)<name>frompage</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_xlate_open</name><argument_list>(<argument><expr>&amp;<name>handle</name></expr></argument>, <argument><expr><name>topage</name></expr></argument>, <argument><expr><name>frompage</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><call><name>APR_STATUS_IS_EINVAL</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call> || <call><name>APR_STATUS_IS_ENOTIMPL</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>handle</name> = <name>NULL</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>apr_err</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errstr</name></decl>;</decl_stmt>
      <comment type="block">/* Can't use svn_error_wrap_apr here because it calls functions in
         this file, leading to infinite recursion. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
      <if>if <condition>(<expr><name>frompage</name> == <name>SVN_APR_LOCALE_CHARSET</name></expr>)</condition><then>
        <expr_stmt><expr><name>errstr</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create a character converter from "
                                "native encoding to '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>topage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><name>topage</name> == <name>SVN_APR_LOCALE_CHARSET</name></expr>)</condition><then>
        <expr_stmt><expr><name>errstr</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create a character converter from "
                                "'%s' to native encoding"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>frompage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>errstr</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create a character converter from "
                                "'%s' to '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>frompage</name></expr></argument>, <argument><expr><name>topage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* Handle the error condition normally prevented by the assert
       * above. */</comment>
      <expr_stmt><expr><name>errstr</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create a character converter from "
                              "'%i' to '%i'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>frompage</name></expr></argument>, <argument><expr><name>topage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>cleanup</name>;</goto>
    }</block></then></if></else></if>

  <comment type="block">/* Allocate and initialize the node. */</comment>
  <expr_stmt><expr>*<name>ret</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xlate_handle_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>(*<name>ret</name>)-&gt;<name>handle</name></name> = <name>handle</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>(*<name>ret</name>)-&gt;<name>valid</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>(*<name>ret</name>)-&gt;<name>frompage</name></name> = ((<name>frompage</name> != <name>SVN_APR_LOCALE_CHARSET</name>)
                      ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>frompage</name></expr></argument>)</argument_list></call> : <name>frompage</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>(*<name>ret</name>)-&gt;<name>topage</name></name> = ((<name>topage</name> != <name>SVN_APR_LOCALE_CHARSET</name>)
                    ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>topage</name></expr></argument>)</argument_list></call> : <name>topage</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>(*<name>ret</name>)-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* If we are called from inside a pool cleanup handler, the just created
     xlate handle will be closed when that handler returns by a newly
     registered cleanup handler, however, the handle is still cached by us.
     To prevent this, we register a cleanup handler that will reset the valid
     flag of our node, so we don't use an invalid handle. */</comment>
  <if>if <condition>(<expr><name>handle</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>*<name>ret</name></expr></argument>, <argument><expr><name>xlate_handle_node_cleanup</name></expr></argument>,
                              <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

 <label><name>cleanup</name>:</label>
  <comment type="block">/* Don't need the lock anymore. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <if>if <condition>(<expr><name>userdata_key</name> &amp;&amp; <name>xlate_handle_hash</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>unlock_err</name> <init>= <expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name>xlate_handle_mutex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>unlock_err</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>unlock_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't unlock charset translation mutex"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Put back NODE into the xlate handle cache for use by other calls.
   If there is no global cache, store the handle in POOL.
   Ignore errors related to locking/unlocking the mutex.
   ### Mutex errors here are very weird. Should we handle them "correctly"
   ### even if that complicates error handling in the routines below? */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>put_xlate_handle_node</name><parameter_list>(<param><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>userdata_key</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>next</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>userdata_key</name></expr>)</condition><then>
    <return>return;</return></then></if>
  <if>if <condition>(<expr><name>xlate_handle_hash</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>xlate_handle_node_t</name> **</type><name>node_p</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
      <if>if <condition>(<expr><call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name>xlate_handle_mutex</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>node_p</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>xlate_handle_hash</name></expr></argument>, <argument><expr><name>userdata_key</name></expr></argument>,
                            <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>node_p</name> == <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>userdata_key</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>xlate_handle_hash</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>userdata_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>node_p</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>xlate_handle_hash</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>node_p</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>node_p</name> = <name>NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>xlate_handle_hash</name></expr></argument>, <argument><expr><name>userdata_key</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>node_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><name><name>node</name>-&gt;<name>next</name></name> = *<name>node_p</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>node_p</name> = <name>node</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
      <if>if <condition>(<expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name>xlate_handle_mutex</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Store it in the per-pool cache. */</comment>
      <expr_stmt><expr><call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>userdata_key</name></expr></argument>, <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/* Return the apr_xlate handle for converting native characters to UTF-8. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_ntou_xlate_handle_node</name><parameter_list>(<param><decl><type><name>xlate_handle_node_t</name> **</type><name>ret</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>get_xlate_handle_node</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>SVN_APR_UTF8_CHARSET</name></expr></argument>,
                               <argument><expr><name>SVN_APR_LOCALE_CHARSET</name></expr></argument>,
                               <argument><expr><name>SVN_UTF_NTOU_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Return the apr_xlate handle for converting UTF-8 to native characters.
   Create one if it doesn't exist.  If unable to find a handle, or
   unable to create one because apr_xlate_open returned APR_EINVAL, then
   set *RET to null and return SVN_NO_ERROR; if fail for some other
   reason, return error. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_uton_xlate_handle_node</name><parameter_list>(<param><decl><type><name>xlate_handle_node_t</name> **</type><name>ret</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>get_xlate_handle_node</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>SVN_APR_LOCALE_CHARSET</name></expr></argument>,
                               <argument><expr><name>SVN_APR_UTF8_CHARSET</name></expr></argument>,
                               <argument><expr><name>SVN_UTF_UTON_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Copy LEN bytes of SRC, converting non-ASCII and zero bytes to ?\nnn
   sequences, allocating the result in POOL. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>fuzzy_escape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_orig</name> <init>= <expr><name>src</name></expr></init>, *<name>src_end</name> <init>= <expr><name>src</name> + <name>len</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>new_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>new</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_orig</name></decl>;</decl_stmt>

  <comment type="block">/* First count how big a dest string we'll need. */</comment>
  <while>while <condition>(<expr><name>src</name> &lt; <name>src_end</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr>! <call><name>svn_ctype_isascii</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call> || *<name>src</name> == '\0'</expr>)</condition><then>
        <expr_stmt><expr><name>new_len</name> += 5</expr>;</expr_stmt></then>  <comment type="block">/* 5 slots, for "?\XXX" */</comment>
      <else>else
        <expr_stmt><expr><name>new_len</name> += 1</expr>;</expr_stmt></else></if>  <comment type="block">/* one slot for the 7-bit char */</comment>

      <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
    }</block></while>

  <comment type="block">/* Allocate that amount. */</comment>
  <expr_stmt><expr><name>new</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>new_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>new_orig</name> = <name>new</name></expr>;</expr_stmt>

  <comment type="block">/* And fill it up. */</comment>
  <while>while <condition>(<expr><name>src_orig</name> &lt; <name>src_end</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr>! <call><name>svn_ctype_isascii</name><argument_list>(<argument><expr>*<name>src_orig</name></expr></argument>)</argument_list></call> || <name>src_orig</name> == '\0'</expr>)</condition><then>
        <block>{
          <comment type="block">/* This is the same format as svn_xml_fuzzy_escape uses, but that
             function escapes different characters.  Please keep in sync!
             ### If we add another fuzzy escape somewhere, we should abstract
             ### this out to a common function. */</comment>
          <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr>"?\\%03u"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>) *<name>src_orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>new</name> += 5</expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr>*<name>new</name> = *<name>src_orig</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>new</name> += 1</expr>;</expr_stmt>
        }</block></else></if>

      <expr_stmt><expr><name>src_orig</name>++</expr>;</expr_stmt>
    }</block></while>

  <expr_stmt><expr>*<name>new</name> = '\0'</expr>;</expr_stmt>

  <return>return <expr><name>new_orig</name></expr>;</return>
}</block></function>

<comment type="block">/* Convert SRC_LENGTH bytes of SRC_DATA in NODE-&gt;handle, store the result
   in *DEST, which is allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>convert_to_stringbuf</name><parameter_list>(<param><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_data</name></decl></param>,
                     <param><decl><type><name>apr_size_t</name></type> <name>src_length</name></decl></param>,
                     <param><decl><type><name>svn_stringbuf_t</name> **</type><name>dest</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>svn_subr__win32_xlate_to_stringbuf</name><argument_list>(<argument><expr>(<name>win32_xlate_t</name> *) <name><name>node</name>-&gt;<name>handle</name></name></expr></argument>,
                                               <argument><expr><name>src_data</name></expr></argument>, <argument><expr><name>src_length</name></expr></argument>,
                                               <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buflen</name> <init>= <expr><name>src_length</name> * 2</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>srclen</name> <init>= <expr><name>src_length</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>destlen</name> <init>= <expr><name>buflen</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>destbuf</name></decl>;</decl_stmt>

  <comment type="block">/* Initialize *DEST to an empty stringbuf. */</comment>
  <expr_stmt><expr>*<name>dest</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>destbuf</name> = <name>(*<name>dest</name>)-&gt;<name>data</name></name></expr>;</expr_stmt>

  <comment type="block">/* Not only does it not make sense to convert an empty string, but
     apr-iconv is quite unreasonable about not allowing that. */</comment>
  <if>if <condition>(<expr><name>src_length</name> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <do>do
    <block>{
      <comment type="block">/* A 1:2 ratio of input bytes to output bytes (as assigned above)
         should be enough for most translations, and if it turns out not
         to be enough, we'll grow the buffer again, sizing it based on a
         1:3 ratio of the remainder of the string. */</comment>

      <expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr>*<name>dest</name></expr></argument>, <argument><expr><name>buflen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set up state variables for xlate. */</comment>
      <expr_stmt><expr><name>destlen</name> = <name>buflen</name> - <name>(*<name>dest</name>)-&gt;<name>len</name></name></expr>;</expr_stmt>

      <comment type="block">/* Attempt the conversion. */</comment>
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_xlate_conv_buffer</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>handle</name></name></expr></argument>,
                                      <argument><expr><name>src_data</name> + (<name>src_length</name> - <name>srclen</name>)</expr></argument>,
                                      <argument><expr>&amp;<name>srclen</name></expr></argument>,
                                      <argument><expr><name>(*<name>dest</name>)-&gt;<name>data</name></name> + <name>(*<name>dest</name>)-&gt;<name>len</name></name></expr></argument>,
                                      <argument><expr>&amp;<name>destlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now, update the *DEST-&gt;len to track the amount of output data
         churned out so far from this loop. */</comment>
      <expr_stmt><expr><name>(*<name>dest</name>)-&gt;<name>len</name></name> += ((<name>buflen</name> - <name>(*<name>dest</name>)-&gt;<name>len</name></name>) - <name>destlen</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name>buflen</name> += <name>srclen</name> * 3</expr>;</expr_stmt> <comment type="block">/* 3 is middle ground, 2 wasn't enough
                               for all characters in the buffer, 4 is
                               maximum character size (currently) */</comment>


    }</block> while <condition>(<expr><name>apr_err</name> == <name>APR_SUCCESS</name> &amp;&amp; <name>srclen</name> != 0</expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* If we exited the loop with an error, return the error. */</comment>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errstr</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

      <comment type="block">/* Can't use svn_error_wrap_apr here because it calls functions in
         this file, leading to infinite recursion. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
      <if>if <condition>(<expr><name><name>node</name>-&gt;<name>frompage</name></name> == <name>SVN_APR_LOCALE_CHARSET</name></expr>)</condition><then>
        <expr_stmt><expr><name>errstr</name> = <call><name>apr_psprintf</name>
          <argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't convert string from native encoding to '%s':"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name><name>node</name>-&gt;<name>topage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><name><name>node</name>-&gt;<name>topage</name></name> == <name>SVN_APR_LOCALE_CHARSET</name></expr>)</condition><then>
        <expr_stmt><expr><name>errstr</name> = <call><name>apr_psprintf</name>
          <argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't convert string from '%s' to native encoding:"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name><name>node</name>-&gt;<name>frompage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>errstr</name> = <call><name>apr_psprintf</name>
          <argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't convert string from '%s' to '%s':"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name><name>node</name>-&gt;<name>frompage</name></name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>topage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* On OS400 V5R4 every possible node-&gt;topage and node-&gt;frompage
       * *really* is an int. */</comment>
      <expr_stmt><expr><name>errstr</name> = <call><name>apr_psprintf</name>
        <argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't convert string from CCSID '%i' to CCSID '%i'"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name><name>node</name>-&gt;<name>frompage</name></name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>topage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>fuzzy_escape</name><argument_list>(<argument><expr><name>src_data</name></expr></argument>,
                                                         <argument><expr><name>src_length</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <comment type="block">/* Else, exited due to success.  Trim the result buffer down to the
     right length. */</comment>
  <expr_stmt><expr><name>(*<name>dest</name>)-&gt;<name>data</name></name><index>[<expr><name>(*<name>dest</name>)-&gt;<name>len</name></name></expr>]</index> = '\0'</expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Return APR_EINVAL if the first LEN bytes of DATA contain anything
   other than seven-bit, non-control (except for whitespace) ASCII
   characters, finding the error pool from POOL.  Otherwise, return
   SVN_NO_ERROR. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_non_ascii</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data_start</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

  <for>for (<init>;</init> <condition><expr><name>len</name> &gt; 0</expr>;</condition> <incr><expr>--<name>len</name></expr>, <expr><name>data</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr>(! <call><name>apr_isascii</name><argument_list>(<argument><expr>*<name>data</name></expr></argument>)</argument_list></call>)
          || ((! <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>data</name></expr></argument>)</argument_list></call>)
              &amp;&amp; <call><name>apr_iscntrl</name><argument_list>(<argument><expr>*<name>data</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* Show the printable part of the data, followed by the
             decimal code of the questionable character.  Because if a
             user ever gets this error, she's going to have to spend
             time tracking down the non-ASCII data, so we want to help
             as much as possible.  And yes, we just call the unsafe
             data "non-ASCII", even though the actual constraint is
             somewhat more complex than that. */</comment>

          <if>if <condition>(<expr><name>data</name> - <name>data_start</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error_data</name>
                <init>= <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>data_start</name></expr></argument>, <argument><expr>(<name>data</name> - <name>data_start</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <return>return <expr><call><name>svn_error_createf</name>
                <argument_list>(<argument><expr><name>APR_EINVAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Safe data '%s' was followed by non-ASCII byte %d: "
                   "unable to convert to/from UTF-8"</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>error_data</name></expr></argument>, <argument><expr>*((const <name>unsigned</name> <name>char</name> *) <name>data</name>)</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then>
          <else>else
            <block>{
              <return>return <expr><call><name>svn_error_createf</name>
                <argument_list>(<argument><expr><name>APR_EINVAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Non-ASCII character (code %d) detected, "
                   "and unable to convert to/from UTF-8"</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr>*((const <name>unsigned</name> <name>char</name> *) <name>data</name>)</expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></then></if>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Construct an error with a suitable message to describe the invalid UTF-8
 * sequence DATA of length LEN (which may have embedded NULLs).  We can't
 * simply print the data, almost by definition we don't really know how it
 * is encoded.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>invalid_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last</name> <init>= <expr><call><name>svn_utf__last_valid</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>valid_txt</name> <init>= <expr>""</expr></init>, *<name>invalid_txt</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>valid</name></decl>, <decl><type ref="prev"/><name>invalid</name></decl>;</decl_stmt>

  <comment type="block">/* We will display at most 24 valid octets (this may split a leading
     multi-byte character) as that should fit on one 80 character line. */</comment>
  <expr_stmt><expr><name>valid</name> = <name>last</name> - <name>data</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>valid</name> &gt; 24</expr>)</condition><then>
    <expr_stmt><expr><name>valid</name> = 24</expr>;</expr_stmt></then></if>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>valid</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <expr_stmt><expr><name>valid_txt</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>valid_txt</name></expr></argument>,
                            <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>" %02x"</expr></argument>,
                                         <argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>last</name><index>[<expr><name>i</name>-<name>valid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

  <comment type="block">/* 4 invalid octets will guarantee that the faulty octet is displayed */</comment>
  <expr_stmt><expr><name>invalid</name> = <name>data</name> + <name>len</name> - <name>last</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>invalid</name> &gt; 4</expr>)</condition><then>
    <expr_stmt><expr><name>invalid</name> = 4</expr>;</expr_stmt></then></if>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>invalid</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <expr_stmt><expr><name>invalid_txt</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>invalid_txt</name></expr></argument>,
                              <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>" %02x"</expr></argument>,
                                           <argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>last</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>APR_EINVAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Valid UTF-8 data\n(hex:%s)\n"
                             "followed by invalid UTF-8 sequence\n(hex:%s)"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>valid_txt</name></expr></argument>, <argument><expr><name>invalid_txt</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Verify that the sequence DATA of length LEN is valid UTF-8 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <call><name>svn_utf__is_valid</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>invalid_utf8</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Verify that the NULL terminated sequence DATA is valid UTF-8 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_cstring_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{

  <if>if <condition>(<expr>! <call><name>svn_utf__cstring_is_valid</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>invalid_utf8</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_stringbuf_to_utf8</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>dest</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>src</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ntou_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>handle</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>convert_to_stringbuf</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <call><name>check_utf8</name><argument_list>(<argument><expr><name>(*<name>dest</name>)-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>(*<name>dest</name>)-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>check_non_ascii</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>dest</name> = <call><name>svn_stringbuf_dup</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SVN_UTF_NTOU_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_string_to_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> **</type><name>dest</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>src</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>destbuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ntou_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>handle</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>convert_to_stringbuf</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr>&amp;<name>destbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <call><name>check_utf8</name><argument_list>(<argument><expr><name><name>destbuf</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>destbuf</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>dest</name> = <call><name>svn_string_create_from_buf</name><argument_list>(<argument><expr><name>destbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>check_non_ascii</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>dest</name> = <call><name>svn_string_dup</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SVN_UTF_NTOU_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<comment type="block">/* Common implementation for svn_utf_cstring_to_utf8,
   svn_utf_cstring_to_utf8_ex, svn_utf_cstring_from_utf8 and
   svn_utf_cstring_from_utf8_ex. Convert SRC to DEST using NODE-&gt;handle as
   the translator and allocating from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>convert_cstring</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                <param><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>handle</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>destbuf</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>convert_to_stringbuf</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr>&amp;<name>destbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>dest</name> = <name><name>destbuf</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_non_ascii</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>dest</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_cstring_to_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ntou_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>convert_cstring</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SVN_UTF_NTOU_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cstring_utf8</name><argument_list>(<argument><expr>*<name>dest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_cstring_to_utf8_ex2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>frompage</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>convset_key</name> <init>= <expr><call><name>get_xlate_key</name><argument_list>(<argument><expr><name>SVN_APR_UTF8_CHARSET</name></expr></argument>, <argument><expr><name>frompage</name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>SVN_APR_UTF8_CHARSET</name></expr></argument>, <argument><expr><name>frompage</name></expr></argument>,
                                <argument><expr><name>convset_key</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>convert_cstring</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>convset_key</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cstring_utf8</name><argument_list>(<argument><expr>*<name>dest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_cstring_to_utf8_ex</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>frompage</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>convset_key</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_utf_cstring_to_utf8_ex2</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>frompage</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_stringbuf_from_utf8</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>dest</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>src</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_uton_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>handle</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>check_utf8</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <call><name>convert_to_stringbuf</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>check_non_ascii</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>dest</name> = <call><name>svn_stringbuf_dup</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SVN_UTF_UTON_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_string_from_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> **</type><name>dest</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>src</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>dbuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_uton_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>handle</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>check_utf8</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <call><name>convert_to_stringbuf</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>,
                                   <argument><expr>&amp;<name>dbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>dest</name> = <call><name>svn_string_create_from_buf</name><argument_list>(<argument><expr><name>dbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>check_non_ascii</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>dest</name> = <call><name>svn_string_dup</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SVN_UTF_UTON_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_cstring_from_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_utf8</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_uton_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>convert_cstring</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SVN_UTF_UTON_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_cstring_from_utf8_ex2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>topage</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>convset_key</name> <init>= <expr><call><name>get_xlate_key</name><argument_list>(<argument><expr><name>topage</name></expr></argument>, <argument><expr><name>SVN_APR_UTF8_CHARSET</name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_utf8</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>topage</name></expr></argument>, <argument><expr><name>SVN_APR_UTF8_CHARSET</name></expr></argument>,
                                <argument><expr><name>convset_key</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>convert_cstring</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>convset_key</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_cstring_from_utf8_ex</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>topage</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>convset_key</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_utf_cstring_from_utf8_ex2</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>topage</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_utf__cstring_from_utf8_fuzzy</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                 <param><function_decl><type><name>svn_error_t</name> *</type>(*<name>convert_from_utf8</name>)
                                 <parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> **</decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type><name>apr_pool_t</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>escaped</name></decl>, *<decl><type ref="prev"/><name>converted</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>escaped</name> = <call><name>fuzzy_escape</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Okay, now we have a *new* UTF-8 string, one that's guaranteed to
     contain only 7-bit bytes :-).  Recode to native... */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>convert_from_utf8</name><argument_list>(<argument><expr>((const <name>char</name> **) &amp;<name>converted</name>)</expr></argument>, <argument><expr><name>escaped</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>escaped</name></expr>;</return>
    }</block></then>
  <else>else
    <return>return <expr><name>converted</name></expr>;</return></else></if>

  <comment type="block">/* ### Check the client locale, maybe we can avoid that second
   * conversion!  See Ulrich Drepper's patch at
   * http://subversion.tigris.org/issues/show_bug.cgi?id=807.
   */</comment>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_utf_cstring_from_utf8_fuzzy</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_utf__cstring_from_utf8_fuzzy</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                          <argument><expr><name>svn_utf_cstring_from_utf8</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_cstring_from_utf8_stringbuf</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>src</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>destbuf</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_stringbuf_from_utf8</name><argument_list>(<argument><expr>&amp;<name>destbuf</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>dest</name> = <name><name>destbuf</name>-&gt;<name>data</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_utf_cstring_from_utf8_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>src</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>dbuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>xlate_handle_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_uton_xlate_handle_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>handle</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>check_utf8</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <call><name>convert_to_stringbuf</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>,
                                   <argument><expr>&amp;<name>dbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>dest</name> = <name><name>dbuf</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>check_non_ascii</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>dest</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <expr_stmt><expr><call><name>put_xlate_handle_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SVN_UTF_UTON_XLATE_HANDLE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>
</unit>
