<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/win32_crashrpt.c"><comment type="block">/*
 * win32_crashrpt.c : provides information after a crash
 *
 * ====================================================================
 * Copyright (c) 2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_USE_WIN32_CRASHHANDLER</name></cpp:ifdef>

<comment type="block">/*** Includes. ***/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>APR_HAVE_IPV6</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dbghelp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_version.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32_crashrpt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32_crashrpt_dll.h"</cpp:file></cpp:include>

<comment type="block">/*** Global variables ***/</comment>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>dbghelp_dll</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* email address where the crash reports should be sent too. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRASHREPORT_EMAIL</name></cpp:macro> <cpp:value>"svn-breakage@subversion.tigris.org"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBGHELP_DLL</name></cpp:macro> <cpp:value>"dbghelp.dll"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_DLL</name></cpp:macro> <cpp:value>"version.dll"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGFILE_PREFIX</name></cpp:macro> <cpp:value>"svn-crash-log"</cpp:value></cpp:define>

<comment type="block">/*** Code. ***/</comment>

<comment type="block">/* Convert a wide-character string to utf-8. This function will create a buffer
 * large enough to hold the result string, the caller should free this buffer.
 * If the string can't be converted, NULL is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>convert_wbcs_to_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>wchar_t</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>wcslen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>utf8_str</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof> * <name>len</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>len</name> = <call><name>wcstombs</name><argument_list>(<argument><expr><name>utf8_str</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>len</name> == -1</expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>utf8_str</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

  <return>return <expr><name>utf8_str</name></expr>;</return>
}</block></function>

<comment type="block">/* Convert the exception code to a string */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>exception_string</name><parameter_list>(<param><decl><type><name>int</name></type> <name>exception</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXCEPTION</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>case EXCEPTION_##x: return (#x);</cpp:value></cpp:define>

  <switch>switch <condition>(<expr><name>exception</name></expr>)</condition>
    <block>{
      <macro><name>EXCEPTION</name><argument_list>(<argument>ACCESS_VIOLATION</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>DATATYPE_MISALIGNMENT</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>BREAKPOINT</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>SINGLE_STEP</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>ARRAY_BOUNDS_EXCEEDED</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>FLT_DENORMAL_OPERAND</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>FLT_DIVIDE_BY_ZERO</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>FLT_INEXACT_RESULT</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>FLT_INVALID_OPERATION</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>FLT_OVERFLOW</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>FLT_STACK_CHECK</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>FLT_UNDERFLOW</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>INT_DIVIDE_BY_ZERO</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>INT_OVERFLOW</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>PRIV_INSTRUCTION</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>IN_PAGE_ERROR</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>ILLEGAL_INSTRUCTION</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>NONCONTINUABLE_EXCEPTION</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>STACK_OVERFLOW</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>INVALID_DISPOSITION</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>GUARD_PAGE</argument>)</argument_list></macro>
      <macro><name>EXCEPTION</name><argument_list>(<argument>INVALID_HANDLE</argument>)</argument_list></macro>

      <default>default:
        <return>return <expr>"UNKNOWN_ERROR"</expr>;</return>
    </default>}</block></switch>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>EXCEPTION</name></cpp:undef>
}</block></function>

<comment type="block">/* Write the minidump to file. The callback function will at the same time
   write the list of modules to the log file. */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>write_minidump_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>, <param><decl><type><name>PEXCEPTION_POINTERS</name></type> <name>ptrs</name></decl></param>,
                    <param><decl><type><name>MINIDUMP_CALLBACK_ROUTINE</name></type> <name>module_callback</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* open minidump file */</comment>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>minidump_file</name> <init>= <expr><call><name>CreateFile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>GENERIC_WRITE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name>CREATE_ALWAYS</name></expr></argument>,
                                    <argument><expr><name>FILE_ATTRIBUTE_NORMAL</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>minidump_file</name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>MINIDUMP_EXCEPTION_INFORMATION</name></type> <name>expt_info</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MINIDUMP_CALLBACK_INFORMATION</name></type> <name>dump_cb_info</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>expt_info</name>.<name>ThreadId</name></name> = <call><name>GetCurrentThreadId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>expt_info</name>.<name>ExceptionPointers</name></name> = <name>ptrs</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>expt_info</name>.<name>ClientPointers</name></name> = <name>FALSE</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>dump_cb_info</name>.<name>CallbackRoutine</name></name> = <name>module_callback</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dump_cb_info</name>.<name>CallbackParam</name></name> = <name>data</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>MiniDumpWriteDump_</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr><name>minidump_file</name></expr></argument>,
                         <argument><expr><name>MiniDumpNormal</name></expr></argument>,
                         <argument><expr><name>ptrs</name> ? &amp;<name>expt_info</name> : <name>NULL</name></expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr>&amp;<name>dump_cb_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>minidump_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* Write module information to the log file */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>CALLBACK</name></type>
<name>write_module_info_callback</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>,
                 <param><decl><type><name>CONST</name> <name>PMINIDUMP_CALLBACK_INPUT</name></type> <name>callback_input</name></decl></param>,
                 <param><decl><type><name>PMINIDUMP_CALLBACK_OUTPUT</name></type> <name>callback_output</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>data</name> != <name>NULL</name> &amp;&amp;
      <name>callback_input</name> != <name>NULL</name> &amp;&amp;
      <name><name>callback_input</name>-&gt;<name>CallbackType</name></name> == <name>ModuleCallback</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>FILE</name> *</type><name>log_file</name> <init>= <expr>(<name>FILE</name> *)<name>data</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>MINIDUMP_MODULE_CALLBACK</name></type> <name>module</name> <init>= <expr><name><name>callback_input</name>-&gt;<name>Module</name></name></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>convert_wbcs_to_utf8</name><argument_list>(<argument><expr><name><name>module</name>.<name>FullPath</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>"0x%08x"</expr></argument>, <argument><expr><name><name>module</name>.<name>BaseOfImage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>"  %s"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>" (%d.%d.%d.%d, %d bytes)\n"</expr></argument>,
                              <argument><expr><call><name>HIWORD</name><argument_list>(<argument><expr><name><name>module</name>.<name>VersionInfo</name>.<name>dwFileVersionMS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>LOWORD</name><argument_list>(<argument><expr><name><name>module</name>.<name>VersionInfo</name>.<name>dwFileVersionMS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>HIWORD</name><argument_list>(<argument><expr><name><name>module</name>.<name>VersionInfo</name>.<name>dwFileVersionLS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>LOWORD</name><argument_list>(<argument><expr><name><name>module</name>.<name>VersionInfo</name>.<name>dwFileVersionLS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>module</name>.<name>SizeOfImage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Write details about the current process, platform and the exception */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_process_info</name><parameter_list>(<param><decl><type><name>EXCEPTION_RECORD</name> *</type><name>exception</name></decl></param>, <param><decl><type><name>CONTEXT</name> *</type><name>context</name></decl></param>,
                   <param><decl><type><name>FILE</name> *</type><name>log_file</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>OSVERSIONINFO</name></type> <name>oi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd_line</name></decl>;</decl_stmt>

  <comment type="block">/* write the command line */</comment>
  <expr_stmt><expr><name>cmd_line</name> = <call><name>GetCommandLine</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"Cmd line: %.65s\n"</expr></argument>, <argument><expr><name>cmd_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* write the svn version number info. */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"Version:  %s, compiled %s, %s\n"</expr></argument>,
                <argument><expr><name>SVN_VERSION</name></expr></argument>, <argument><expr><name>__DATE__</name></expr></argument>, <argument><expr><name>__TIME__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* write information about the OS */</comment>
  <expr_stmt><expr><name><name>oi</name>.<name>dwOSVersionInfoSize</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>oi</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>GetVersionEx</name><argument_list>(<argument><expr>&amp;<name>oi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"Platform: Windows OS version %d.%d build %d %s\n\n"</expr></argument>,
                <argument><expr><name><name>oi</name>.<name>dwMajorVersion</name></name></expr></argument>, <argument><expr><name><name>oi</name>.<name>dwMinorVersion</name></name></expr></argument>, <argument><expr><name><name>oi</name>.<name>dwBuildNumber</name></name></expr></argument>,
                <argument><expr><name><name>oi</name>.<name>szCSDVersion</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* write the exception code */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
               <argument><expr>"Exception: %s\n\n"</expr></argument>,
               <argument><expr><call><name>exception_string</name><argument_list>(<argument><expr><name><name>exception</name>-&gt;<name>ExceptionCode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* write the register info. */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"Registers:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"eax=%08x ebx=%08x ecx=%08x edx=%08x esi=%08x edi=%08x\n"</expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>Eax</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Ebx</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Ecx</name></name></expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>Edx</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Esi</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Edi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"eip=%08x esp=%08x ebp=%08x efl=%08x\n"</expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>Eip</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Esp</name></name></expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>Ebp</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>EFlags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x\n"</expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>SegCs</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>SegSs</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>SegDs</name></name></expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>SegEs</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>SegFs</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>SegGs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"Rax=%016I64x Rcx=%016I64x Rdx=%016I64x Rbx=%016I64x\n"</expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>Rax</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Rcx</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Rdx</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Rbx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"Rsp=%016I64x Rbp=%016I64x Rsi=%016I64x Rdi=%016I64x\n"</expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>Rsp</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Rbp</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Rsi</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>Rdi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"R8= %016I64x R9= %016I64x R10= %016I64x R11=%016I64x\n"</expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>R8</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>R9</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>R10</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>R11</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"R12=%016I64x R13=%016I64x R14=%016I64x R15=%016I64x\n"</expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>R12</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>R13</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>R14</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>R15</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                <argument><expr>"cs=%04x  ss=%04x  ds=%04x  es=%04x  fs=%04x  gs=%04x  ss=%04x\n"</expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>SegCs</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>SegDs</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>SegEs</name></name></expr></argument>,
                <argument><expr><name><name>context</name>-&gt;<name>SegFs</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>SegGs</name></name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>SegSs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> Unknown processortype, please disable SVN_USE_WIN32_CRASHHANDLER</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* formats the value at address based on the specified basic type
 * (char, int, long ...). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>format_basic_type</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>basic_type</name></decl></param>, <param><decl><type><name>DWORD64</name></type> <name>length</name></decl></param>, <param><decl><type><name>void</name> *</type><name>address</name></decl></param>)</parameter_list>
<block>{
  <switch>switch<condition>(<expr><name>length</name></expr>)</condition>
    <block>{
      <case>case <expr>1</expr>:
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%x"</expr></argument>, <argument><expr>*(<name>unsigned</name> <name>char</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>2</expr>:
        <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%x"</expr></argument>, <argument><expr>*(<name>unsigned</name> <name>short</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>4</expr>:
        <switch>switch<condition>(<expr><name>basic_type</name></expr>)</condition>
          <block>{
            <case>case <expr>2</expr>:  <comment type="block">/* btChar */</comment>
              <block>{
                <if>if <condition>(<expr>!<call><name>IsBadStringPtr</name><argument_list>(<argument><expr>*(<name>PSTR</name>*)<name>address</name></expr></argument>, <argument><expr>32</expr></argument>)</argument_list></call></expr>)</condition><then>
                  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"\"%.31s\""</expr></argument>, <argument><expr>*(<name>unsigned</name> <name>long</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                  <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%x"</expr></argument>, <argument><expr>*(<name>unsigned</name> <name>long</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
              }</block>
            </case><case>case <expr>6</expr>:  <comment type="block">/* btInt */</comment>
              <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr>*(<name>int</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            </case><case>case <expr>8</expr>:  <comment type="block">/* btFloat */</comment>
              <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%f"</expr></argument>, <argument><expr>*(<name>float</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            </case><default>default:
              <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%x"</expr></argument>, <argument><expr>*(<name>unsigned</name> <name>long</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
          </default>}</block></switch>
        <break>break;</break>
      </case><case>case <expr>8</expr>:
        <if>if <condition>(<expr><name>basic_type</name> == 8</expr>)</condition><then> <comment type="block">/* btFloat */</comment>
          <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%lf"</expr></argument>, <argument><expr>*(<name>double</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
          <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%I64X"</expr></argument>, <argument><expr>*(<name>unsigned</name> <name>__int64</name> *)<name>address</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        <break>break;</break>
    </case>}</block></switch>
}</block></function>

<comment type="block">/* formats the value at address based on the type (pointer, user defined,
 * basic type). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>format_value</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>value_str</name></decl></param>, <param><decl><type><name>DWORD64</name></type> <name>mod_base</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>type</name></decl></param>, <param><decl><type><name>void</name> *</type><name>value_addr</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>DWORD</name></type> <name>tag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ptr</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>proc</name> <init>= <expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><call><name>SymGetTypeInfo_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>mod_base</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>TI_GET_SYMTAG</name></expr></argument>, <argument><expr>&amp;<name>tag</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{
      <comment type="block">/* SymTagPointerType */</comment>
      <if>if <condition>(<expr><name>tag</name> == 14</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>ptr</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SymGetTypeInfo_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>mod_base</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>TI_GET_TYPE</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <continue>continue;</continue>
        }</block></then></if>
      <break>break;</break>
    }</block></while>

  <switch>switch<condition>(<expr><name>tag</name></expr>)</condition>
    <block>{
      <case>case <expr>11</expr>: <comment type="block">/* SymTagUDT */</comment>
        <block>{
          <decl_stmt><decl><type><name>WCHAR</name> *</type><name>type_name_wbcs</name></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name>SymGetTypeInfo_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>mod_base</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>TI_GET_SYMNAME</name></expr></argument>,
                              <argument><expr>&amp;<name>type_name_wbcs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>char</name> *</type><name>type_name</name> <init>= <expr><call><name>convert_wbcs_to_utf8</name><argument_list>(<argument><expr><name>type_name_wbcs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>LocalFree</name><argument_list>(<argument><expr><name>type_name_wbcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr><name>ptr</name> == 0</expr>)</condition><then>
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr>"(%s) 0x%08x"</expr></argument>,
                        <argument><expr><name>type_name</name></expr></argument>, <argument><expr>(<name>DWORD</name> *)<name>value_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else <if>if <condition>(<expr><name>ptr</name> == 1</expr>)</condition><then>
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr>"(%s *) 0x%08x"</expr></argument>,
                        <argument><expr><name>type_name</name></expr></argument>, <argument><expr>*(<name>DWORD</name> *)<name>value_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr>"(%s **) 0x%08x"</expr></argument>,
                        <argument><expr><name>type_name</name></expr></argument>, <argument><expr>(<name>DWORD</name> *)<name>value_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

              <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>type_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block>
        <break>break;</break>
      </case><case>case <expr>16</expr>: <comment type="block">/* SymTagBaseType */</comment>
        <block>{
          <decl_stmt><decl><type><name>DWORD</name></type> <name>bt</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>ULONG64</name></type> <name>length</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SymGetTypeInfo_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>mod_base</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>TI_GET_LENGTH</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* print a char * as a string */</comment>
          <if>if <condition>(<expr><name>ptr</name> == 1 &amp;&amp; <name>length</name> == 1</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr>"0x%08x \"%s\""</expr></argument>,
                      <argument><expr>*(<name>DWORD</name> *)<name>value_addr</name></expr></argument>, <argument><expr>(<name>char</name> *)*(<name>DWORD</name>*)<name>value_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
          <if>if <condition>(<expr><name>ptr</name> &gt;= 1</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr>"0x%08x"</expr></argument>, <argument><expr>*(<name>DWORD</name> *)<name>value_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
          <if>if <condition>(<expr><call><name>SymGetTypeInfo_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>mod_base</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>TI_GET_BASETYPE</name></expr></argument>, <argument><expr>&amp;<name>bt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>format_basic_type</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr><name>bt</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>value_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
        }</block>
        <break>break;</break>
      </case><case>case <expr>12</expr>: <comment type="block">/* SymTagEnum */</comment>
          <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr>*(<name>DWORD</name> *)<name>value_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
      </case><case>case <expr>13</expr>: <comment type="block">/* SymTagFunctionType */</comment>
          <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr>"0x%08x"</expr></argument>, <argument><expr>*(<name>DWORD</name> *)<name>value_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
      </case><default>default: <break>break;</break>
    </default>}</block></switch>
}</block></function>

<comment type="block">/* Internal structure used to pass some data to the enumerate symbols
 * callback */</comment>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>STACKFRAME64</name> *</type><name>stack_frame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> *</type><name>log_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nr_of_frame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>log_params</name></decl>;</decl_stmt>
}</block></struct></type> <name>symbols_baton_t</name>;</typedef>

<comment type="block">/* write the details of one parameter or local variable to the log file */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>write_var_values</name><parameter_list>(<param><decl><type><name>PSYMBOL_INFO</name></type> <name>sym_info</name></decl></param>, <param><decl><type><name>ULONG</name></type> <name>sym_size</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>last_nr_of_frame</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD_PTR</name></type> <name>var_data</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>    <comment type="block">/* Will point to the variable's data in memory */</comment>
  <decl_stmt><decl><type><name>STACKFRAME64</name> *</type><name>stack_frame</name> <init>= <expr>((<name>symbols_baton_t</name>*)<name>baton</name>)-&gt;<name>stack_frame</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> *</type><name>log_file</name>   <init>= <expr>((<name>symbols_baton_t</name>*)<name>baton</name>)-&gt;<name>log_file</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nr_of_frame</name> <init>= <expr>((<name>symbols_baton_t</name>*)<name>baton</name>)-&gt;<name>nr_of_frame</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>log_params</name> <init>= <expr>((<name>symbols_baton_t</name>*)<name>baton</name>)-&gt;<name>log_params</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>value_str</name><index>[<expr>256</expr>]</index></name> <init>= <expr>""</expr></init></decl>;</decl_stmt>

  <comment type="block">/* get the variable's data */</comment>
  <if>if <condition>(<expr><name><name>sym_info</name>-&gt;<name>Flags</name></name> &amp; <name>SYMFLAG_REGREL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>var_data</name> = (<name>DWORD_PTR</name>)<name><name>stack_frame</name>-&gt;<name>AddrFrame</name>.<name>Offset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>var_data</name> += (<name>DWORD_PTR</name>)<name><name>sym_info</name>-&gt;<name>Address</name></name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <return>return <expr><name>FALSE</name></expr>;</return></else></if>

  <if>if <condition>(<expr><name>log_params</name> == <name>TRUE</name> &amp;&amp; <name><name>sym_info</name>-&gt;<name>Flags</name></name> &amp; <name>SYMFLAG_PARAMETER</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>last_nr_of_frame</name> == <name>nr_of_frame</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>", "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>last_nr_of_frame</name> = <name>nr_of_frame</name></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>format_value</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr><name><name>sym_info</name>-&gt;<name>ModBase</name></name></expr></argument>, <argument><expr><name><name>sym_info</name>-&gt;<name>TypeIndex</name></name></expr></argument>,
                   <argument><expr>(<name>void</name> *)<name>var_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>"%s=%s"</expr></argument>, <argument><expr><name><name>sym_info</name>-&gt;<name>Name</name></name></expr></argument>, <argument><expr><name>value_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>log_params</name> == <name>FALSE</name> &amp;&amp; <name><name>sym_info</name>-&gt;<name>Flags</name></name> &amp; <name>SYMFLAG_LOCAL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>format_value</name><argument_list>(<argument><expr><name>value_str</name></expr></argument>, <argument><expr><name><name>sym_info</name>-&gt;<name>ModBase</name></name></expr></argument>, <argument><expr><name><name>sym_info</name>-&gt;<name>TypeIndex</name></name></expr></argument>,
                   <argument><expr>(<name>void</name> *)<name>var_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>"        %s = %s\n"</expr></argument>, <argument><expr><name><name>sym_info</name>-&gt;<name>Name</name></name></expr></argument>, <argument><expr><name>value_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* write the details of one function to the log file */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_function_detail</name><parameter_list>(<param><decl><type><name>STACKFRAME64</name></type> <name>stack_frame</name></decl></param>, <param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>ULONG64</name></type> <name><name>symbolBuffer</name><index>[<expr>(<sizeof>sizeof<argument_list>(<argument><expr><name>SYMBOL_INFO</name></expr></argument>)</argument_list></sizeof> +
    <name>MAX_PATH</name> +
    <sizeof>sizeof<argument_list>(<argument><expr><name>ULONG64</name></expr></argument>)</argument_list></sizeof> - 1) /
    <sizeof>sizeof<argument_list>(<argument><expr><name>ULONG64</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>PSYMBOL_INFO</name></type> <name>pIHS</name> <init>= <expr>(<name>PSYMBOL_INFO</name>)<name>symbolBuffer</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD64</name></type> <name>func_disp</name><init>=<expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>IMAGEHLP_STACK_FRAME</name></type> <name>ih_stack_frame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>IMAGEHLP_LINE64</name></type> <name>ih_line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DWORD</name></type> <name>line_disp</name><init>=<expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>HANDLE</name></type> <name>proc</name> <init>= <expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> *</type><name>log_file</name> <init>= <expr>(<name>FILE</name> *)<name>data</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>symbols_baton_t</name></type> <name>ensym</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>nr_of_frame</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>nr_of_frame</name>++</expr>;</expr_stmt>

  <comment type="block">/* log the function name */</comment>
  <expr_stmt><expr><name><name>pIHS</name>-&gt;<name>SizeOfStruct</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>SYMBOL_INFO</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pIHS</name>-&gt;<name>MaxNameLen</name></name> = <name>MAX_PATH</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>SymFromAddr_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name></expr></argument>, <argument><expr>&amp;<name>func_disp</name></expr></argument>, <argument><expr><name>pIHS</name></expr></argument>)</argument_list></call> == <name>TRUE</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                    <argument><expr>"#%d  0x%08x in %.200s ("</expr></argument>,
                    <argument><expr><name>nr_of_frame</name></expr></argument>, <argument><expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name></expr></argument>,  <argument><expr><name><name>pIHS</name>-&gt;<name>Name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* restrict symbol enumeration to this frame only */</comment>
      <expr_stmt><expr><name><name>ih_stack_frame</name>.<name>InstructionOffset</name></name> = <name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SymSetContext_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr>&amp;<name>ih_stack_frame</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>ensym</name>.<name>log_file</name></name> = <name>log_file</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ensym</name>.<name>stack_frame</name></name> = &amp;<name>stack_frame</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ensym</name>.<name>nr_of_frame</name></name> = <name>nr_of_frame</name></expr>;</expr_stmt>

      <comment type="block">/* log all function parameters */</comment>
      <expr_stmt><expr><name><name>ensym</name>.<name>log_params</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SymEnumSymbols_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>write_var_values</name></expr></argument>, <argument><expr>&amp;<name>ensym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                    <argument><expr>"#%d  0x%08x in (unknown function)"</expr></argument>,
                    <argument><expr><name>nr_of_frame</name></expr></argument>, <argument><expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* find the source line for this function. */</comment>
  <expr_stmt><expr><name><name>ih_line</name>.<name>SizeOfStruct</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>IMAGEHLP_LINE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>SymGetLineFromAddr64_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name></expr></argument>,
                          <argument><expr>&amp;<name>line_disp</name></expr></argument>, <argument><expr>&amp;<name>ih_line</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>,
                    <argument><expr>" at %s:%d\n"</expr></argument>, <argument><expr><name><name>ih_line</name>.<name>FileName</name></name></expr></argument>, <argument><expr><name><name>ih_line</name>.<name>LineNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* log all function local variables */</comment>
  <expr_stmt><expr><name><name>ensym</name>.<name>log_params</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SymEnumSymbols_</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>write_var_values</name></expr></argument>, <argument><expr>&amp;<name>ensym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* walk over the stack and log all relevant information to the log file */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_stacktrace</name><parameter_list>(<param><decl><type><name>CONTEXT</name> *</type><name>context</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>log_file</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>_M_IA64</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>proc</name> <init>= <expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>STACKFRAME64</name></type> <name>stack_frame</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>machine</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CONTEXT</name></type> <name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>skip</name> <init>= <expr>0</expr></init>, <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* The thread information - if not supplied. */</comment>
	<if>if <condition>(<expr><name>context</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If no context is supplied, skip 1 frame */</comment>
      <expr_stmt><expr><name>skip</name> = 1</expr>;</expr_stmt>

  		<expr_stmt><expr><name><name>ctx</name>.<name>ContextFlags</name></name> = <name>CONTEXT_FULL</name></expr>;</expr_stmt>
  		<if>if <condition>(<expr><call><name>GetThreadContext</name><argument_list>(<argument><expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
		    <expr_stmt><expr><name>context</name> = &amp;<name>ctx</name></expr>;</expr_stmt></then></if>
	  }</block></then></if>

	<if>if <condition>(<expr><name>context</name> == <name>NULL</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="block">/* Write the stack trace */</comment>
  <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr>&amp;<name>stack_frame</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>STACKFRAME64</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Mode</name></name> = <name>AddrModeFlat</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrStack</name>.<name>Mode</name></name>   = <name>AddrModeFlat</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrFrame</name>.<name>Mode</name></name>   = <name>AddrModeFlat</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_IX86</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>machine</name> = <name>IMAGE_FILE_MACHINE_I386</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name>    = <name><name>context</name>-&gt;<name>Eip</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrStack</name>.<name>Offset</name></name> = <name><name>context</name>-&gt;<name>Esp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrFrame</name>.<name>Offset</name></name> = <name><name>context</name>-&gt;<name>Ebp</name></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_X64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>machine</name> = <name>IMAGE_FILE_MACHINE_AMD64</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name>     = <name><name>context</name>-&gt;<name>Rip</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrStack</name>.<name>Offset</name></name>  = <name><name>context</name>-&gt;<name>Rsp</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrFrame</name>.<name>Offset</name></name>  = <name><name>context</name>-&gt;<name>Rbp</name></name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_M_IA64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
  <expr_stmt><expr><name>machine</name> = <name>IMAGE_FILE_MACHINE_IA64</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name>     = <name><name>context</name>-&gt;<name>StIIP</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrStack</name>.<name>Offset</name></name>  = <name><name>context</name>-&gt;<name>SP</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrBStore</name>.<name>Mode</name></name>   = <name>AddrModeFlat</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stack_frame</name>.<name>AddrBStore</name>.<name>Offset</name></name> = <name><name>context</name>-&gt;<name>RsBSP</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> Unknown processortype, please disable SVN_USE_WIN32_CRASHHANDLER</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <if>if <condition>(<expr>! <call><name>StackWalk64_</name><argument_list>(<argument><expr><name>machine</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><call><name>GetCurrentThread</name><argument_list>()</argument_list></call></expr></argument>,
                         <argument><expr>&amp;<name>stack_frame</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><name>SymFunctionTableAccess64_</name></expr></argument>, <argument><expr><name>SymGetModuleBase64_</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <break>break;</break>
        }</block></then></if>

      <if>if <condition>(<expr><name>i</name> &gt;= <name>skip</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Try to include symbolic information.
             Also check that the address is not zero. Sometimes StackWalk
             returns TRUE with a frame of zero. */</comment>
          <if>if <condition>(<expr><name><name>stack_frame</name>.<name>AddrPC</name>.<name>Offset</name></name> != 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>write_function_detail</name><argument_list>(<argument><expr><name>stack_frame</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></while>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> Unknown processortype, please disable SVN_USE_WIN32_CRASHHANDLER</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* Check if a debugger is attached to this process */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>is_debugger_present</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>kernel32_dll</name> <init>= <expr><call><name>LoadLibrary</name><argument_list>(<argument><expr>"kernel32.dll"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>result</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>ISDEBUGGERPRESENT</name></type> <name>IsDebuggerPresent_</name> <init>=
          <expr>(<name>ISDEBUGGERPRESENT</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>kernel32_dll</name></expr></argument>, <argument><expr>"IsDebuggerPresent"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>IsDebuggerPresent_</name> &amp;&amp; <call><name>IsDebuggerPresent_</name><argument_list>()</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>result</name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>result</name> = <name>FALSE</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>kernel32_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* Match the version of dbghelp.dll with the minimum expected version */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>check_dbghelp_version</name><parameter_list>(<param><decl><type><name>WORD</name></type> <name>exp_major</name></decl></param>, <param><decl><type><name>WORD</name></type> <name>exp_minor</name></decl></param>, <param><decl><type><name>WORD</name></type> <name>exp_build</name></decl></param>,
                      <param><decl><type><name>WORD</name></type> <name>exp_qfe</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HANDLE</name></type> <name>version_dll</name> <init>= <expr><call><name>LoadLibrary</name><argument_list>(<argument><expr><name>VERSION_DLL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GETFILEVERSIONINFOSIZE</name></type> <name>GetFileVersionInfoSize_</name> <init>=
         <expr>(<name>GETFILEVERSIONINFOSIZE</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>version_dll</name></expr></argument>,
                                                <argument><expr>"GetFileVersionInfoSizeA"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>GETFILEVERSIONINFO</name></type> <name>GetFileVersionInfo_</name> <init>=
         <expr>(<name>GETFILEVERSIONINFO</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>version_dll</name></expr></argument>,
                                            <argument><expr>"GetFileVersionInfoA"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>VERQUERYVALUE</name></type> <name>VerQueryValue_</name> <init>=
         <expr>(<name>VERQUERYVALUE</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>version_dll</name></expr></argument>, <argument><expr>"VerQueryValueA"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>DWORD</name></type> <name>version</name>     <init>= <expr>0</expr></init>,
        <name>exp_version</name> <init>= <expr><call><name>MAKELONG</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><name>exp_qfe</name></expr></argument>, <argument><expr><name>exp_build</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><name>exp_minor</name></expr></argument>, <argument><expr><name>exp_major</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>h</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>resource_size</name> <init>= <expr><call><name>GetFileVersionInfoSize_</name><argument_list>(<argument><expr><name>DBGHELP_DLL</name></expr></argument>, <argument><expr>&amp;<name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>resource_size</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>resource_data</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>resource_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>GetFileVersionInfo_</name><argument_list>(<argument><expr><name>DBGHELP_DLL</name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>resource_size</name></expr></argument>,
                              <argument><expr><name>resource_data</name></expr></argument>)</argument_list></call> != <name>FALSE</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>void</name> *</type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>UINT</name></type> <name>len</name></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name>VerQueryValue_</name><argument_list>(<argument><expr><name>resource_data</name></expr></argument>, <argument><expr>"\\"</expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>VS_FIXEDFILEINFO</name> *</type><name>info</name> <init>= <expr>(<name>VS_FIXEDFILEINFO</name>*)<name>buf</name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>version</name> = <call><name>MAKELONG</name><argument_list>(<argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><call><name>LOWORD</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>dwFileVersionLS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>HIWORD</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>dwFileVersionLS</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>MAKEWORD</name><argument_list>(<argument><expr><call><name>LOWORD</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>dwFileVersionMS</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>HIWORD</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>dwFileVersionMS</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
      <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>resource_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

   <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>version_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

   <if>if <condition>(<expr><name>version</name> &gt;= <name>exp_version</name></expr>)</condition><then>
     <return>return <expr><name>TRUE</name></expr>;</return></then></if>

   <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* Load the dbghelp.dll file, try to find a version that matches our
   requirements. */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name></type>
<name>load_dbghelp_dll</name><parameter_list>()</parameter_list>
<block>{
  <comment type="block">/* check version of the dll, should be at least 6.6.7.5 */</comment>
  <if>if <condition>(<expr><call><name>check_dbghelp_version</name><argument_list>(<argument><expr>6</expr></argument>, <argument><expr>6</expr></argument>, <argument><expr>7</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call> == <name>FALSE</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <expr_stmt><expr><name>dbghelp_dll</name> = <call><name>LoadLibrary</name><argument_list>(<argument><expr><name>DBGHELP_DLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>dbghelp_dll</name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>DWORD</name></type> <name>opts</name></decl>;</decl_stmt>

      <comment type="block">/* load the functions */</comment>
      <expr_stmt><expr><name>MiniDumpWriteDump_</name> =
           (<name>MINIDUMPWRITEDUMP</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"MiniDumpWriteDump"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymInitialize_</name> =
           (<name>SYMINITIALIZE</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymInitialize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymSetOptions_</name> =
           (<name>SYMSETOPTIONS</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymSetOptions"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymGetOptions_</name> =
           (<name>SYMGETOPTIONS</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymGetOptions"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymCleanup_</name> =
           (<name>SYMCLEANUP</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymCleanup"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymGetTypeInfo_</name> =
           (<name>SYMGETTYPEINFO</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymGetTypeInfo"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymGetLineFromAddr64_</name> =
           (<name>SYMGETLINEFROMADDR64</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>,
                                              <argument><expr>"SymGetLineFromAddr64"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymEnumSymbols_</name> =
           (<name>SYMENUMSYMBOLS</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymEnumSymbols"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymSetContext_</name> =
           (<name>SYMSETCONTEXT</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymSetContext"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymFromAddr_</name> = (<name>SYMFROMADDR</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymFromAddr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	  <expr_stmt><expr><name>StackWalk64_</name> = (<name>STACKWALK64</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"StackWalk64"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymFunctionTableAccess64_</name> =
           (<name>SYMFUNCTIONTABLEACCESS64</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>,
                                                  <argument><expr>"SymFunctionTableAccess64"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SymGetModuleBase64_</name> =
           (<name>SYMGETMODULEBASE64</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>, <argument><expr>"SymGetModuleBase64"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! (<name>MiniDumpWriteDump_</name> &amp;&amp;
             <name>SymInitialize_</name> &amp;&amp; <name>SymSetOptions_</name>  &amp;&amp; <name>SymGetOptions_</name> &amp;&amp;
             <name>SymCleanup_</name>    &amp;&amp; <name>SymGetTypeInfo_</name> &amp;&amp; <name>SymGetLineFromAddr64_</name> &amp;&amp;
             <name>SymEnumSymbols_</name> &amp;&amp; <name>SymSetContext_</name> &amp;&amp; <name>SymFromAddr_</name> &amp;&amp;
             <name>SymGetModuleBase64_</name> &amp;&amp; <name>StackWalk64_</name> &amp;&amp;
             <name>SymFunctionTableAccess64_</name>)</expr>)</condition><then>
        <goto>goto <name>cleanup</name>;</goto></then></if>

      <comment type="block">/* initialize the symbol loading code */</comment>
      <expr_stmt><expr><name>opts</name> = <call><name>SymGetOptions_</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set the 'load lines' option to retrieve line number information;
         set the Deferred Loads option to map the debug info in memory only
         when needed. */</comment>
      <expr_stmt><expr><call><name>SymSetOptions_</name><argument_list>(<argument><expr><name>opts</name> | <name>SYMOPT_LOAD_LINES</name> | <name>SYMOPT_DEFERRED_LOADS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Initialize the debughlp DLL with the default path and automatic
         module enumeration (and loading of symbol tables) for this process.
       */</comment>
      <expr_stmt><expr><call><name>SymInitialize_</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if>

<label><name>cleanup</name>:</label>
  <if>if <condition>(<expr><name>dbghelp_dll</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* Cleanup the dbghelp.dll library */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_debughlp</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SymCleanup_</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>dbghelp_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Create a filename based on a prefix, the timestamp and an extension.
   check if the filename was already taken, retry 3 times. */</comment>
<function><type><name>BOOL</name></type>
<name>get_temp_filename</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ext</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>temp_dir</name><index>[<expr><name>MAX_PATH</name> - 64</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <call><name>GetTempPath</name><argument_list>(<argument><expr><name>MAX_PATH</name> - 64</expr></argument>, <argument><expr><name>temp_dir</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init><condition><expr><name>i</name> &lt; 3</expr>;</condition><incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>HANDLE</name></type> <name>file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>time_t</name></type> <name>now</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>time_str</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>time</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>strftime</name><argument_list>(<argument><expr><name>time_str</name></expr></argument>, <argument><expr>64</expr></argument>, <argument><expr>"%Y%m%d%H%M%S"</expr></argument>, <argument><expr><call><name>localtime</name><argument_list>(<argument><expr>&amp;<name>now</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"%s%s%s.%s"</expr></argument>, <argument><expr><name>temp_dir</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>time_str</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>file</name> = <call><name>CreateFile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>GENERIC_WRITE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CREATE_NEW</name></expr></argument>,
                        <argument><expr><name>FILE_ATTRIBUTE_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>file</name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>
    }</block></for>

   <expr_stmt><expr><name><name>filename</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
   <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* unhandled exception callback set with SetUnhandledExceptionFilter() */</comment>
<function><type><name>LONG</name> <name>WINAPI</name></type>
<name>svn__unhandled_exception_filter</name><parameter_list>(<param><decl><type><name>PEXCEPTION_POINTERS</name></type> <name>ptrs</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>dmp_filename</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>log_filename</name><index>[<expr><name>MAX_PATH</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name> *</type><name>log_file</name></decl>;</decl_stmt>

  <comment type="block">/* Check if the crash handler was already loaded (crash while handling the
     crash) */</comment>
  <if>if <condition>(<expr><name>dbghelp_dll</name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
    <return>return <expr><name>EXCEPTION_CONTINUE_SEARCH</name></expr>;</return></then></if>

  <comment type="block">/* don't log anything if we're running inside a debugger ... */</comment>
  <if>if <condition>(<expr><call><name>is_debugger_present</name><argument_list>()</argument_list></call> == <name>TRUE</name></expr>)</condition><then>
    <return>return <expr><name>EXCEPTION_CONTINUE_SEARCH</name></expr>;</return></then></if>

  <comment type="block">/* ... or if we can't create the log files ... */</comment>
  <if>if <condition>(<expr><call><name>get_temp_filename</name><argument_list>(<argument><expr><name>dmp_filename</name></expr></argument>, <argument><expr><name>LOGFILE_PREFIX</name></expr></argument>, <argument><expr>"dmp"</expr></argument>)</argument_list></call> == <name>FALSE</name> ||
      <call><name>get_temp_filename</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr><name>LOGFILE_PREFIX</name></expr></argument>, <argument><expr>"log"</expr></argument>)</argument_list></call> == <name>FALSE</name></expr>)</condition><then>
    <return>return <expr><name>EXCEPTION_CONTINUE_SEARCH</name></expr>;</return></then></if>

  <comment type="block">/* If we can't load a recent version of the dbghelp.dll, pass on this
     exception */</comment>
  <if>if <condition>(<expr><call><name>load_dbghelp_dll</name><argument_list>()</argument_list></call> == <name>FALSE</name></expr>)</condition><then>
    <return>return <expr><name>EXCEPTION_CONTINUE_SEARCH</name></expr>;</return></then></if>

  <comment type="block">/* open log file */</comment>
  <expr_stmt><expr><name>log_file</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>log_filename</name></expr></argument>, <argument><expr>"w+"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* write information about the process */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>"\nProcess info:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>write_process_info</name><argument_list>(<argument><expr><name>ptrs</name> ? <name><name>ptrs</name>-&gt;<name>ExceptionRecord</name></name> : <name>NULL</name></expr></argument>,
                     <argument><expr><name>ptrs</name> ? <name><name>ptrs</name>-&gt;<name>ContextRecord</name></name> : <name>NULL</name></expr></argument>,
                     <argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* write the stacktrace, if available */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>"\nStacktrace:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>write_stacktrace</name><argument_list>(<argument><expr><name>ptrs</name> ? <name><name>ptrs</name>-&gt;<name>ContextRecord</name></name> : <name>NULL</name></expr></argument>, <argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* write the minidump file and use the callback to write the list of modules
     to the log file */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>, <argument><expr>"\n\nLoaded modules:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>write_minidump_file</name><argument_list>(<argument><expr><name>dmp_filename</name></expr></argument>, <argument><expr><name>ptrs</name></expr></argument>,
                      <argument><expr><name>write_module_info_callback</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>log_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>cleanup_debughlp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* inform the user */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"This application has halted due to an unexpected error.\n"
                  "A crash report and minidump file were saved to disk, you"
                  " can find them here:\n"
                  "%s\n%s\n"
                  "Please send the log file to %s to help us analyse\nand "
                  "solve this problem.\n\n"
                  "NOTE: The crash report and minidump files can contain some"
                  " sensitive information\n(filenames, partial file content, "
                  "usernames and passwords etc.)\n"</expr></argument>,
                  <argument><expr><name>log_filename</name></expr></argument>,
                  <argument><expr><name>dmp_filename</name></expr></argument>,
                  <argument><expr><name>CRASHREPORT_EMAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* terminate the application */</comment>
  <return>return <expr><name>EXCEPTION_EXECUTE_HANDLER</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_USE_WIN32_CRASHHANDLER */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 */</comment>
</unit>
