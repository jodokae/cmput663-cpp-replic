<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/io.c"><comment type="block">/*
 * io.c:   shared file reading, writing, and probing code.
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APR_STATUS_IS_EPERM</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EPERM</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_STATUS_IS_EPERM</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>((s) == EPERM)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_STATUS_IS_EPERM</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_info.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_portable.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<escape char="0xc"/>
<comment type="block">/*
  Windows is 'aided' by a number of types of applications that
  follow other applications around and open up files they have
  changed for various reasons (the most intrusive are virus
  scanners).  So, if one of these other apps has glommed onto
  our file we may get an 'access denied' error.

  This retry loop does not completely solve the problem (who
  knows how long the other app is going to hold onto it for), but
  goes a long way towards minimizing it.  It is not an infinite
  loop because there might really be an error.

  Another reason for retrying delete operations on Windows
  is that they are asynchronous -- the file or directory is not
  actually deleted until the last handle to it is closed.  The
  retry loop cannot completely solve this problem either, but can
  help mitigate it.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_RETRY_LOOP</name><parameter_list>(<param><type><name>err</name></type></param>, <param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>                                        \
  <cpp:value>do                                                                       \
    {                                                                      \
      apr_status_t os_err = APR_TO_OS_ERROR(err);                       \
      int sleep_count = 1000;                                              \
      int retries;                                                         \
      for (retries = 0;                                                    \
           retries &lt; 100 &amp;&amp; (os_err == ERROR_ACCESS_DENIED                 \
                             || os_err == ERROR_SHARING_VIOLATION          \
                             || os_err == ERROR_DIR_NOT_EMPTY);            \
           ++retries, os_err = APR_TO_OS_ERROR(err))                    \
        {                                                                  \
          apr_sleep(sleep_count);                                       \
          if (sleep_count &lt; 128000)                                        \
            sleep_count *= 2;                                              \
          (err) = (expr);                                                  \
        }                                                                  \
    }                                                                      \
  while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_RETRY_LOOP</name><parameter_list>(<param><type><name>err</name></type></param>, <param><type><name>expr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>map_apr_finfo_to_node_kind</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name> *</type><name>is_special</name></decl></param>,
                           <param><decl><type><name>apr_finfo_t</name> *</type><name>finfo</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>is_special</name> = <name>FALSE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>finfo</name>-&gt;<name>filetype</name></name> == <name>APR_REG</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>kind</name> = <name>svn_node_file</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>finfo</name>-&gt;<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>kind</name> = <name>svn_node_dir</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>finfo</name>-&gt;<name>filetype</name></name> == <name>APR_LNK</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>is_special</name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>kind</name> = <name>svn_node_file</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr>*<name>kind</name> = <name>svn_node_unknown</name></expr>;</expr_stmt></else></if></else></if></else></if>
}</block></function>

<comment type="block">/* Helper for svn_io_check_path() and svn_io_check_resolved_path();
   essentially the same semantics as those two, with the obvious
   interpretation for RESOLVE_SYMLINKS. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>io_check_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_symlinks</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name> *</type><name>is_special_p</name></decl></param>,
              <param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_special</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>path</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
    <expr_stmt><expr><name>path</name> = "."</expr>;</expr_stmt></then></if>

  <comment type="block">/* Not using svn_io_stat() here because we want to check the
     apr_err return explicitly. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>flags</name> = <name>resolve_symlinks</name> ? <name>APR_FINFO_MIN</name> : (<name>APR_FINFO_MIN</name> | <name>APR_FINFO_LINK</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr>*<name>kind</name> = <name>svn_node_none</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOTDIR</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr>*<name>kind</name> = <name>svn_node_none</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't check path '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <expr_stmt><expr><call><name>map_apr_finfo_to_node_kind</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr>&amp;<name>is_special</name></expr></argument>, <argument><expr>&amp;<name>finfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if>

  <expr_stmt><expr>*<name>is_special_p</name> = <name>is_special</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Wrapper for apr_file_open() that handles CCSID problems on OS400 V5R4. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>file_open</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>f</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>,
          <param><decl><type><name>apr_int32_t</name></type> <name>flag</name></decl></param>,
          <param><decl><type><name>apr_fileperms_t</name></type> <name>perm</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AS400</name></cpp:ifdef>
<comment type="block">/* All files in OS400 are tagged with a metadata CCSID (Coded Character Set
 * Identifier) which indicates the character encoding of the file's
 * contents.  Even binary files are assigned a CCSID, typically the system
 * CCSID of the machine, which is some variant of EBCDIC (there are many
 * variants of EBCDIC: CCSID 37 - COM EUROPE EBCDIC, CCSID 273 - AUSTRIAN/
 * GERMAN EBCDIC, CCSID 284 - SPANISH EBCDIC, etc..  In this comment the
 * assumed system CCSID is 37).
 *
 * APR on OS400 V5R4 is built with what IBM calls "UTF support" which means
 * that within the application text file contents are assumed to be in CCSID
 * 1208.
 *
 * On OS400 when using apr_file_open() to read, write, and/or create a file
 * there is an interplay between the APR_BINARY flag and the file's CCSID:
 *
 * File    | APR_BINARY  | Existing | Created | Conversion | Conversion
 * Exists? | Flag        | File's   | File's  | When       | When
 *         | Passed      | CCSID    | CCSID   | Writing    | Reading
 * --------------------------------------------------------------------
 * Yes     | Yes         | 1208     | N/A     | None       | None
 * Yes     | Yes         | 37       | N/A     | None       | None
 * Yes     | No          | 1208     | N/A     | None       | None
 * Yes     | No          | 37       | N/A     | 1208--&gt;37  | 37--&gt;1208
 * No      | Yes         | N/A      | 37      | None       | None
 * No      | No          | N/A      | 1208    | None       | None
 *
 * For example: If an existing file with CCSID 37 is opened for reading
 *              without the APR_BINARY flag, the OS will attempt to convert
 *              the file's contents from EBCDIC 37 to UTF-8.
 *
 * Now for the problem...
 *
 *  - The files Subversion handles have either binary or UTF-8 content.
 *
 *  - Subversion is not structured to differentiate between text files and
 *    binary files.  It just always passes the APR_BINARY flag when calling
 *    apr_file_open().
 *
 * So when Subversion creates a new file it always has a CCSID of 37 even
 * though the file *may* contain UTF-8 encoded text.  This isn't a problem
 * for Subversion directly since it always passes APR_BINARY when opening
 * files, therefore the content is never converted when reading/writing the
 * file.
 *
 * The problem is that other OS400 applications/utilities rely on the CCSID
 * to represent the file's contents.  For example, when a text editor opens
 * a svnserve.conf file tagged with CCSID 37 but actually containing UTF-8
 * text, the OS will attempt to convert what it thinks is EBCDIC text to
 * UTF-8.  Worse, if the file is empty, the text editor would save the
 * contents as EBCDIC.  Later, when Subversion opens the conf file it's
 * reading in "UTF-8" data that is actually EBCDIC.
 *
 * The solution to this problem is to catch the case where Subversion wants
 * to create a file and make an initial call to apr_file_open() in text mode
 * (i.e. without the APR_BINARY flag), close the file, and then re-open the
 * file in binary mode (i.e. with the APR_BINARY flag).
 */</comment>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>flag</name> &amp; <name>APR_CREATE</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If we are trying to create a file on OS400 ensure its CCSID is
       * 1208. */</comment>
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>flag</name> &amp; ~<name>APR_BINARY</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><name>apr_err</name></expr>;</return></then></if>

      <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr>*<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Unset APR_EXCL so the next call to apr_file_open() doesn't
       * return an error. */</comment>
      <expr_stmt><expr><name>flag</name> &amp;= ~<name>APR_EXCL</name></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AS400 */</comment>
  <expr_stmt><expr><name>status</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>apr_file_open</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>status</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_check_resolved_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                           <param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>ignored</name></decl>;</decl_stmt>
  <return>return <expr><call><name>io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>&amp;<name>ignored</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_check_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>ignored</name></decl>;</decl_stmt>
  <return>return <expr><call><name>io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>&amp;<name>ignored</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_check_special_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name> *</type><name>is_special</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>is_special</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<struct>struct <name>temp_file_cleanup_s</name>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>temp_file_plain_cleanup_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct  <name>temp_file_cleanup_s</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>name</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_remove</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>apr_file_remove</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>apr_err</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>temp_file_child_cleanup_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct  <name>temp_file_cleanup_s</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>apr_pool_cleanup_kill</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                        <argument><expr><name>temp_file_plain_cleanup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_open_unique_file2</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>f</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>unique_name_p</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>suffix</name></decl></param>,
                         <param><decl><type><name>svn_io_file_del_t</name></type> <name>delete_when</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>unique_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>unique_name_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>temp_file_cleanup_s</name> *</type><name>baton</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> || <name>unique_name_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>delete_when</name> == <name>svn_io_file_del_on_pool_cleanup</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>baton</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>baton</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>baton</name>-&gt;<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Because cleanups are run LIFO, we need to make sure to register
         our cleanup before the apr_file_close cleanup:

         On Windows, you can't remove an open file.
      */</comment>
      <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>temp_file_plain_cleanup_handler</name></expr></argument>,
                                <argument><expr><name>temp_file_child_cleanup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= 99999</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>flag</name> <init>= <expr>(<name>APR_READ</name> | <name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_EXCL</name>
                          | <name>APR_BUFFERED</name> | <name>APR_BINARY</name>)</expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>delete_when</name> == <name>svn_io_file_del_on_close</name></expr>)</condition><then>
        <expr_stmt><expr><name>flag</name> |= <name>APR_DELONCLOSE</name></expr>;</expr_stmt></then></if>

      <comment type="block">/* Special case the first attempt -- if we can avoid having a
         generated numeric portion at all, that's best.  So first we
         try with just the suffix; then future tries add a number
         before the suffix.  (A do-while loop could avoid the repeated
         conditional, but it's not worth the clarity loss.)

         If the first attempt fails, the first number will be "2".
         This is good, since "1" would misleadingly imply that
         the second attempt was actually the first... and if someone's
         got conflicts on their conflicts, we probably don't want to
         add to their confusion :-). */</comment>
      <if>if <condition>(<expr><name>i</name> == 1</expr>)</condition><then>
        <expr_stmt><expr><name>unique_name</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s%s"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>unique_name</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s.%u%s"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <comment type="block">/* Hmmm.  Ideally, we would append to a native-encoding buf
         before starting iteration, then convert back to UTF-8 for
         return. But I suppose that would make the appending code
         sensitive to i18n in a way it shouldn't be... Oh well. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>unique_name_apr</name></expr></argument>, <argument><expr><name>unique_name</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>apr_err</name> = <call><name>file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>unique_name_apr</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>,
                          <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then>
      <else>else <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* On Win32, CreateFile failswith an "Access Denied" error
             code, rather than "File Already Exists", if the colliding
             name belongs to a directory. */</comment>
          <if>if <condition>(<expr><call><name>APR_STATUS_IS_EACCES</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err_2</name> <init>= <expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>unique_name_apr</name></expr></argument>,
                                                <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <if>if <condition>(<expr>!<name>apr_err_2</name>
                  &amp;&amp; (<name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name>)</expr>)</condition><then>
                <continue>continue;</continue></then></if>

              <comment type="block">/* Else ignore apr_err_2; better to fall through and
                 return the original error. */</comment>
            }</block></then></if>

          <if>if <condition>(<expr><name>f</name></expr>)</condition><then> <expr_stmt><expr>*<name>f</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>unique_name_p</name></expr>)</condition><then> <expr_stmt><expr>*<name>unique_name_p</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
          <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't open '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>unique_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr><name>delete_when</name> == <name>svn_io_file_del_on_pool_cleanup</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>baton</name>-&gt;<name>name</name></name> = <name>unique_name_apr</name></expr>;</expr_stmt></then></if>

          <if>if <condition>(<expr><name>f</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>f</name> = <name>file</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <if>if <condition>(<expr><name>unique_name_p</name></expr>)</condition><then> <expr_stmt><expr>*<name>unique_name_p</name> = <name>unique_name</name></expr>;</expr_stmt></then></if>

          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></else></if></else></if>
    }</block></for>

  <if>if <condition>(<expr><name>f</name></expr>)</condition><then> <expr_stmt><expr>*<name>f</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>unique_name_p</name></expr>)</condition><then> <expr_stmt><expr>*<name>unique_name_p</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unable to make name for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_open_unique_file</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>f</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>unique_name_p</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>suffix</name></decl></param>,
                        <param><decl><type><name>svn_boolean_t</name></type> <name>delete_on_close</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>unique_name_p</name></expr></argument>,
                                  <argument><expr><name>path</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>,
                                  <argument><expr><name>delete_on_close</name>
                                  ? <name>svn_io_file_del_on_close</name>
                                  : <name>svn_io_file_del_none</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_create_unique_link</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>unique_name_p</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>suffix</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>unique_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>unique_name_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AS400_UTF8</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_apr_ebcdic</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>dest_apr</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AS400_UTF8</name></cpp:ifdef>
  <comment type="block">/* On OS400 with UTF support a native cstring is UTF-8, but
   * symlink() *really* needs EBCDIC paths. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_from_utf8_ex2</name><argument_list>(<argument><expr>&amp;<name>dest_apr_ebcdic</name></expr></argument>, <argument><expr><name>dest_apr</name></expr></argument>,
                                        <argument><expr>(const <name>char</name>*)0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dest_apr</name> = <name>dest_apr_ebcdic</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= 99999</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

      <comment type="block">/* Special case the first attempt -- if we can avoid having a
         generated numeric portion at all, that's best.  So first we
         try with just the suffix; then future tries add a number
         before the suffix.  (A do-while loop could avoid the repeated
         conditional, but it's not worth the clarity loss.)

         If the first attempt fails, the first number will be "2".
         This is good, since "1" would misleadingly imply that
         the second attempt was actually the first... and if someone's
         got conflicts on their conflicts, we probably don't want to
         add to their confusion :-). */</comment>
      <if>if <condition>(<expr><name>i</name> == 1</expr>)</condition><then>
        <expr_stmt><expr><name>unique_name</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s%s"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>unique_name</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s.%u%s"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <comment type="block">/* Hmmm.  Ideally, we would append to a native-encoding buf
         before starting iteration, then convert back to UTF-8 for
         return. But I suppose that would make the appending code
         sensitive to i18n in a way it shouldn't be... Oh well. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400_UTF8</name></cpp:ifndef>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>unique_name_apr</name></expr></argument>, <argument><expr><name>unique_name</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <comment type="block">/* On OS400 with UTF support a native cstring is UTF-8,
       * but symlink() *really* needs an EBCDIC path. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_from_utf8_ex2</name><argument_list>(<argument><expr>&amp;<name>unique_name_apr</name></expr></argument>, <argument><expr><name>unique_name</name></expr></argument>,
                                            <argument><expr>(const <name>char</name>*)0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <do>do <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>symlink</name><argument_list>(<argument><expr><name>dest_apr</name></expr></argument>, <argument><expr><name>unique_name_apr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block> while <condition>(<expr><name>rv</name> == -1 &amp;&amp; <call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>

      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>rv</name> == -1 &amp;&amp; <call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then>
      <else>else <if>if <condition>(<expr><name>rv</name> == -1 &amp;&amp; <name>apr_err</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* On Win32, CreateFile fails with an "Access Denied" error
             code, rather than "File Already Exists", if the colliding
             name belongs to a directory. */</comment>
          <if>if <condition>(<expr><call><name>APR_STATUS_IS_EACCES</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err_2</name> <init>= <expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>unique_name_apr</name></expr></argument>,
                                                <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <if>if <condition>(<expr>!<name>apr_err_2</name>
                  &amp;&amp; (<name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name>)</expr>)</condition><then>
                <continue>continue;</continue></then></if>

              <comment type="block">/* Else ignore apr_err_2; better to fall through and
                 return the original error. */</comment>
            }</block></then></if>

          <expr_stmt><expr>*<name>unique_name_p</name> = <name>NULL</name></expr>;</expr_stmt>
          <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create symbolic link '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>unique_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr>*<name>unique_name_p</name> = <name>unique_name</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></else></if></else></if>
    }</block></for>

  <expr_stmt><expr>*<name>unique_name_p</name> = <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unable to make name for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Symbolic links are not supported on this "
                            "platform"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_read_link</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>dest</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_READLINK</name></cpp:ifdef>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>dest_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1025</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AS400_UTF8</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf_utf8</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400_UTF8</name></cpp:ifndef>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* On OS400 with UTF support a native cstring is UTF-8, but
   * readlink() *really* needs an EBCDIC path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_from_utf8_ex2</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>(const <name>char</name>*)0</expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <do>do <block>{
    <expr_stmt><expr><name>rv</name> = <call><name>readlink</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block> while <condition>(<expr><name>rv</name> == -1 &amp;&amp; <call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>

  <if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name>
      <argument_list>(<argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read contents of link"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>buf</name><index>[<expr><name>rv</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest_apr</name>.<name>data</name></name> = <name>buf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dest_apr</name>.<name>len</name></name> = <name>rv</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400_UTF8</name></cpp:ifndef>
  <comment type="block">/* ### Cast needed, one of these interfaces is wrong */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_string_to_utf8</name><argument_list>(<argument><expr>(const <name>svn_string_t</name> **)<name>dest</name></expr></argument>, <argument><expr>&amp;<name>dest_apr</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* The buf filled by readline() is ebcdic encoded
   * despite V5R4's UTF support. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8_ex2</name><argument_list>(<argument><expr>&amp;<name>buf_utf8</name></expr></argument>, <argument><expr><name><name>dest_apr</name>.<name>data</name></name></expr></argument>,
                                      <argument><expr>(const <name>char</name> *)0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>dest</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><name>buf_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Symbolic links are not supported on this "
                            "platform"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_copy_link</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>

<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_READLINK</name></cpp:ifdef>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>link_dest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_tmp</name></decl>;</decl_stmt>

  <comment type="block">/* Notice what the link is pointing at... */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_link</name><argument_list>(<argument><expr>&amp;<name>link_dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a tmp-link pointing at the same thing. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_create_unique_link</name><argument_list>(<argument><expr>&amp;<name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>link_dest</name>-&gt;<name>data</name></name></expr></argument>,
                                    <argument><expr>".tmp"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Move the tmp-link to link. */</comment>
  <return>return <expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Symbolic links are not supported on this "
                            "platform"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_temp_dir</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dir</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name> <init>= <expr><call><name>apr_temp_dir_get</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't find a temporary directory"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>dir</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr>*<name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr>*<name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/*** Creating, copying and appending files. ***/</comment>

<comment type="block">/* Transfer the contents of FROM_FILE to TO_FILE, using POOL for temporary
 * allocations.
 *
 * NOTE: We don't use apr_copy_file() for this, since it takes filenames
 * as parameters.  Since we want to copy to a temporary file
 * and rename for atomicity (see below), this would require an extra
 * close/open pair, which can be expensive, especially on
 * remote file systems.
 *
 *
 * Also, On OS400 apr_file_copy() attempts to convert the contents of
 * the source file from its CCSID to the CCSID of the destination
 * file.  This may corrupt the destination file's contents if the
 * files' CCSIDs differ from each other and/or the system CCSID.
 * (See comments for file_open() for more info on CCSIDs.)
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>copy_contents</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>from_file</name></decl></param>,
              <param><decl><type><name>apr_file_t</name> *</type><name>to_file</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Copy bytes till the cows come home. */</comment>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>SVN__STREAM_CHUNK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_this_time</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>read_err</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>write_err</name></decl>;</decl_stmt>

      <comment type="block">/* Read 'em. */</comment>
      <expr_stmt><expr><name>read_err</name> = <call><name>apr_file_read</name><argument_list>(<argument><expr><name>from_file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>bytes_this_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>read_err</name> &amp;&amp; !<call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>read_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <return>return <expr><name>read_err</name></expr>;</return>
        }</block></then></if>

      <comment type="block">/* Write 'em. */</comment>
      <expr_stmt><expr><name>write_err</name> = <call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>to_file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_this_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>write_err</name></expr>)</condition><then>
        <block>{
          <return>return <expr><name>write_err</name></expr>;</return>
        }</block></then></if>

      <if>if <condition>(<expr><name>read_err</name> &amp;&amp; <call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>read_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* Return the results of this close: an error, or success. */</comment>
          <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>
    }</block></while>
  <comment type="block">/* NOTREACHED */</comment>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_copy_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>copy_perms</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>from_file</name></decl>, *<decl><type ref="prev"/><name>to_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_apr</name></decl>, *<decl><type ref="prev"/><name>dst_tmp_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>err2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>src_apr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>from_file</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BINARY</name></expr></argument>,
                         <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For atomicity, we copy to a tmp file and then rename the tmp
     file over the real destination. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>to_file</name></expr></argument>, <argument><expr>&amp;<name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                   <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>dst_tmp_apr</name></expr></argument>, <argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>copy_contents</name><argument_list>(<argument><expr><name>from_file</name></expr></argument>, <argument><expr><name>to_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_error_wrap_apr</name>
            <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't copy '%s' to '%s'"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
   <else>else
     <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>err2</name> = <call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>from_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <name>err2</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><name>err2</name> = <call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>to_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <name>err2</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_remove</name><argument_list>(<argument><expr><name>dst_tmp_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>apr_file_remove</name><argument_list>(<argument><expr><name>dst_tmp_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* If copying perms, set the perms on dst_tmp now, so they will be
     atomically inherited in the upcoming rename.  But note that we
     had to wait until now to set perms, because if they say
     read-only, then we'd have failed filling dst_tmp's contents. */</comment>

  <comment type="block">/* ### FIXME: apr_file_copy with perms may fail on Win32.  We need a
     platform-specific implementation to get the permissions right. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
  <if>if <condition>(<expr><name>copy_perms</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>s</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_info_get</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>APR_FINFO_PROT</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_perms_set</name><argument_list>(<argument><expr><name>dst_tmp_apr</name></expr></argument>, <argument><expr><name><name>finfo</name>.<name>protection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* We shouldn't be able to get APR_INCOMPLETE or APR_ENOTIMPL
         here under normal circumstances, because the perms themselves
         came from a call to apr_file_info_get(), and we already know
         this is the non-Win32 case.  But if it does happen, it's not
         an error. */</comment>
      <if>if <condition>(<expr>(<name>apr_err</name> != <name>APR_SUCCESS</name>)
          &amp;&amp; (<name>apr_err</name> != <name>APR_INCOMPLETE</name>)
          &amp;&amp; (<name>apr_err</name> != <name>APR_ENOTIMPL</name>)</expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_wrap_apr</name>
            <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set permissions on '%s'"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ! WIN32 */</comment>

  <return>return <expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_append_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_apr</name></decl>, *<decl><type ref="prev"/><name>dst_apr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>src_apr</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>dst_apr</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_append</name><argument_list>(<argument><expr><name>src_apr</name></expr></argument>, <argument><expr><name>dst_apr</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't append '%s' to '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type><name>svn_io_copy_dir_recursively</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_parent</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_basename</name></decl></param>,
                                         <param><decl><type><name>svn_boolean_t</name></type> <name>copy_perms</name></decl></param>,
                                         <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                                         <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>this_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>this_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>flags</name> <init>= <expr><name>APR_FINFO_TYPE</name> | <name>APR_FINFO_NAME</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make a subpool for recursion */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The 'dst_path' is simply dst_parent/dst_basename */</comment>
  <expr_stmt><expr><name>dst_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_parent</name></expr></argument>, <argument><expr><name>dst_basename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sanity checks:  SRC and DST_PARENT are directories, and
     DST_BASENAME doesn't already exist in DST_PARENT. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_NODE_UNEXPECTED_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Source '%s' is not a directory"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>dst_parent</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_NODE_UNEXPECTED_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Destination '%s' is not a directory"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dst_parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_none</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ENTRY_EXISTS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Destination '%s' already exists"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the new directory. */</comment>
  <comment type="block">/* ### TODO: copy permissions (needs apr_file_attrs_get()) */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_make</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Loop over the dirents in SRC.  ('.' and '..' are auto-excluded) */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_open</name><argument_list>(<argument><expr>&amp;<name>this_dir</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>this_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>status</name> == <name>APR_SUCCESS</name></expr>;</condition>
       <incr><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>this_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <if>if <condition>(<expr>(<name><name>this_entry</name>.<name>name</name><index>[<expr>0</expr>]</index></name> == '.')
          &amp;&amp; ((<name><name>this_entry</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '\0')
              || ((<name><name>this_entry</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '.')
                  &amp;&amp; (<name><name>this_entry</name>.<name>name</name><index>[<expr>2</expr>]</index></name> == '\0')))</expr>)</condition><then>
        <block>{
          <continue>continue;</continue>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_target</name></decl>, *<decl><type ref="prev"/><name>entryname_utf8</name></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>cancel_func</name><argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>entryname_utf8</name></expr></argument>,
                                           <argument><expr><name><name>this_entry</name>.<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>src_target</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>entryname_utf8</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>this_entry</name>.<name>filetype</name></name> == <name>APR_REG</name></expr>)</condition><then> <comment type="block">/* regular file */</comment>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_target</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>entryname_utf8</name></expr></argument>,
                                                     <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>src_target</name></expr></argument>, <argument><expr><name>dst_target</name></expr></argument>,
                                       <argument><expr><name>copy_perms</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else <if>if <condition>(<expr><name><name>this_entry</name>.<name>filetype</name></name> == <name>APR_LNK</name></expr>)</condition><then> <comment type="block">/* symlink */</comment>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_target</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>entryname_utf8</name></expr></argument>,
                                                     <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_link</name><argument_list>(<argument><expr><name>src_target</name></expr></argument>, <argument><expr><name>dst_target</name></expr></argument>,
                                       <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else <if>if <condition>(<expr><name><name>this_entry</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then> <comment type="block">/* recurse */</comment>
            <block>{
              <comment type="block">/* Prevent infinite recursion by filtering off our
                 newly created destination path. */</comment>
              <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst_parent</name></expr></argument>)</argument_list></call> == 0
                  &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>entryname_utf8</name></expr></argument>, <argument><expr><name>dst_basename</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <continue>continue;</continue></then></if>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_dir_recursively</name>
                      <argument_list>(<argument><expr><name>src_target</name></expr></argument>,
                       <argument><expr><name>dst_path</name></expr></argument>,
                       <argument><expr><name>entryname_utf8</name></expr></argument>,
                       <argument><expr><name>copy_perms</name></expr></argument>,
                       <argument><expr><name>cancel_func</name></expr></argument>,
                       <argument><expr><name>cancel_baton</name></expr></argument>,
                       <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if></else></if>
          <comment type="block">/* ### support other APR node types someday?? */</comment>

        }</block></else></if>
    }</block></for>

  <if>if <condition>(<expr>! (<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_close</name><argument_list>(<argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error closing directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Free any memory used by recursion */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_make_dir_recursively</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>svn_path_is_empty</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <comment type="block">/* Empty path (current dir) is assumed to always exist,
       so we do nothing, per docs. */</comment>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_dir_make_recursive</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>apr_dir_make_recursive</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>,
                                                   <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't make directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type><name>svn_io_file_create</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>contents</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>f</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>written</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
                           <argument><expr>(<name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_EXCL</name>)</expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr>&amp;<name>written</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type><name>svn_io_dir_file_copy</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_path</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_path</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file_dest_path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>dest_path</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file_src_path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>file_src_path</name></expr></argument>, <argument><expr><name>file_dest_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** Modtime checking. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_affected_time</name><parameter_list>(<param><decl><type><name>apr_time_t</name> *</type><name>apr_time</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name> | <name>APR_FINFO_LINK</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>apr_time</name> = <name><name>finfo</name>.<name>mtime</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_set_file_affected_time</name><parameter_list>(<param><decl><type><name>apr_time_t</name></type> <name>apr_time</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>native_path</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AS400</name></cpp:ifdef>
  <decl_stmt><decl><type><name>apr_utimbuf_t</name></type> <name>aubuf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>native_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
  <expr_stmt><expr><name>status</name> = <call><name>apr_file_mtime_set</name><argument_list>(<argument><expr><name>native_path</name></expr></argument>, <argument><expr><name>apr_time</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* apr_file_mtime_set() isn't implemented on OS400, but IBM does provide
   * the OS400 specific function apr_utime() which can be used instead. */</comment>

  <comment type="block">/* Get the file's current access time, we don't want to change that,
   * just the mod time. */</comment>
  <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>native_path</name></expr></argument>, <argument><expr><name>APR_FINFO_ATIME</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>status</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>aubuf</name>.<name>atime</name></name> = <name><name>finfo</name>.<name>atime</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>aubuf</name>.<name>mtime</name></name> = <name>apr_time</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>status</name> = <call><name>apr_utime</name><argument_list>(<argument><expr><name>native_path</name></expr></argument>, <argument><expr>&amp;<name>aubuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name>
      <argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set access time of '%s'"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_filesizes_different_p</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>different_p</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file1</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file2</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file1_apr</name></decl>, *<decl><type ref="prev"/><name>file2_apr</name></decl>;</decl_stmt>

  <comment type="block">/* Not using svn_io_stat() because don't want to generate
     svn_error_t objects for non-error conditions. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>file1_apr</name></expr></argument>, <argument><expr><name>file1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>file2_apr</name></expr></argument>, <argument><expr><name>file2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Stat both files */</comment>
  <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo1</name></expr></argument>, <argument><expr><name>file1_apr</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If we got an error stat'ing a file, it could be because the
         file was removed... or who knows.  Whatever the case, we
         don't know if the filesizes are definitely different, so
         assume that they're not. */</comment>
      <expr_stmt><expr>*<name>different_p</name> = <name>FALSE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo2</name></expr></argument>, <argument><expr><name>file2_apr</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* See previous comment. */</comment>
      <expr_stmt><expr>*<name>different_p</name> = <name>FALSE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Examine file sizes */</comment>
  <if>if <condition>(<expr><name><name>finfo1</name>.<name>size</name></name> == <name><name>finfo2</name>.<name>size</name></name></expr>)</condition><then>
    <expr_stmt><expr>*<name>different_p</name> = <name>FALSE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>different_p</name> = <name>TRUE</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_checksum</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[]</index></name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>apr_md5_ctx_t</name></type> <name>context</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* ### The apr_md5 functions return apr_status_t, but they only
     return success, and really, what could go wrong?  So below, we
     ignore their return values. */</comment>

  <expr_stmt><expr><call><name>apr_md5_init</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>len</name> = <name>SVN__STREAM_CHUNK_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_read</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr>! <name>err</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>apr_md5_update</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> = <name>SVN__STREAM_CHUNK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_read</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while><empty_stmt>;</empty_stmt>

  <if>if <condition>(<expr><name>err</name> &amp;&amp; ! <call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>apr_md5_final</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Permissions and modes. ***/</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<comment type="block">/* Given the file specified by PATH_APR, attempt to create an
   identical version of it owned by the current user.  This is done by
   moving it to a temporary location, copying the file back to its old
   path, then deleting the temporarily moved version.  All temporary
   allocations are done in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>reown_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>unique_name</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>unique_name</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>,
                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>unique_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>unique_name</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>unique_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Determine what the read-write PERMS for PATH should be by ORing
   together the permissions of PATH and the permissions of a temporary
   file that we create.  Unfortunately, this is the only way to
   determine which combination of write bits (User/Group/World) should
   be set to restore a file from read-only to read-write.  Make
   temporary allocations in POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_default_file_perms</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_fileperms_t</name> *</type><name>perms</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>tmp_finfo</name></decl>, <decl><type ref="prev"/><name>finfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>apr_path</name></decl>;</decl_stmt>

  <comment type="block">/* Get the perms for a newly created file to find out what write
   * bits should be set. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>tmp_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_on_close</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>tmp_finfo</name></expr></argument>, <argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>APR_FINFO_PROT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't get default file perms "
                                        "for file at '%s' (file stat error)"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the perms for the original file so we'll have any other bits
   * that were already set (like the execute bits, for example). */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>apr_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr><name>apr_path</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BINARY</name></expr></argument>,
                         <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't open file at '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>apr_path</name></expr></argument>, <argument><expr><name>APR_FINFO_PROT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't get file perms for file at "
                                        "'%s' (file stat error)"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Glom the perms together. */</comment>
  <expr_stmt><expr>*<name>perms</name> = <name><name>tmp_finfo</name>.<name>protection</name></name> | <name><name>finfo</name>.<name>protection</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This is a helper function for the svn_io_set_file_read* functions
   that attempts to honor the users umask when dealing with
   permission changes.  It is a no-op when invoked on a symlink. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>io_set_file_perms</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>change_readwrite</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>enable_write</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>change_executable</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>executable</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_enoent</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_fileperms_t</name></type> <name>perms_to_set</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Try to change only a minimal amount of the perms first
     by getting the current perms and adding bits
     only on where read perms are granted.  If this fails
     fall through to just setting file attributes. */</comment>
  <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>APR_FINFO_PROT</name> | <name>APR_FINFO_LINK</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>ignore_enoent</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then>
      <else>else <if>if <condition>(<expr><name>status</name> != <name>APR_ENOTIMPL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't change perms of file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name> == <name>APR_LNK</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>perms_to_set</name> = <name><name>finfo</name>.<name>protection</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>change_readwrite</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>enable_write</name></expr>)</condition><then> <comment type="block">/* Make read-write. */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_default_file_perms</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>perms_to_set</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_UREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> &amp;= ~<name>APR_UWRITE</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_GREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> &amp;= ~<name>APR_GWRITE</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_WREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> &amp;= ~<name>APR_WWRITE</name></expr>;</expr_stmt></then></if>
        }</block></else></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>change_executable</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>executable</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_UREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> |= <name>APR_UEXECUTE</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_GREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> |= <name>APR_GEXECUTE</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_WREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> |= <name>APR_WEXECUTE</name></expr>;</expr_stmt></then></if>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_UREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> &amp;= ~<name>APR_UEXECUTE</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_GREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> &amp;= ~<name>APR_GEXECUTE</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>finfo</name>.<name>protection</name></name> &amp; <name>APR_WREAD</name></expr>)</condition><then>
            <expr_stmt><expr><name>perms_to_set</name> &amp;= ~<name>APR_WEXECUTE</name></expr>;</expr_stmt></then></if>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* If we aren't changing anything then just return, this saves
     some system calls and helps with shared working copies */</comment>
  <if>if <condition>(<expr><name>perms_to_set</name> == <name><name>finfo</name>.<name>protection</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_file_perms_set</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>perms_to_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>status</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>APR_STATUS_IS_EPERM</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* We don't have permissions to change the
         permissions!  Try a move, copy, and delete
         workaround to see if we can get the file owned by
         us.  If these succeed, try the permissions set
         again.

         Note that we only attempt this in the
         stat-available path.  This assumes that the
         move-copy workaround will only be helpful on
         platforms that implement apr_stat. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>reown_file</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>status</name> = <call><name>apr_file_perms_set</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>perms_to_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr>!<name>status</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>ignore_enoent</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>status</name> == <name>APR_ENOTIMPL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* At least try to set the attributes. */</comment>
      <decl_stmt><decl><type><name>apr_fileattrs_t</name></type> <name>attrs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_fileattrs_t</name></type> <name>attrs_values</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>change_readwrite</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>attrs</name> = <name>APR_FILE_ATTR_READONLY</name></expr>;</expr_stmt>
          <if>if <condition>(<expr>!<name>enable_write</name></expr>)</condition><then>
            <expr_stmt><expr><name>attrs_values</name> = <name>APR_FILE_ATTR_READONLY</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
      <if>if <condition>(<expr><name>change_executable</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>attrs</name> = <name>APR_FILE_ATTR_EXECUTABLE</name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>executable</name></expr>)</condition><then>
            <expr_stmt><expr><name>attrs_values</name> = <name>APR_FILE_ATTR_EXECUTABLE</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
      <expr_stmt><expr><name>status</name> = <call><name>apr_file_attrs_set</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>attrs</name></expr></argument>, <argument><expr><name>attrs_values</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't change perms of file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_set_file_read_write_carefully</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                     <param><decl><type><name>svn_boolean_t</name></type> <name>enable_write</name></decl></param>,
                                     <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_enoent</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>enable_write</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_io_set_file_read_write</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ignore_enoent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <return>return <expr><call><name>svn_io_set_file_read_only</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ignore_enoent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_set_file_read_only</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_enoent</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* On Windows, just set the file attributes -- on unix call
     our internal function which attempts to honor the umask. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
  <return>return <expr><call><name>io_set_file_perms</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                           <argument><expr><name>ignore_enoent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>apr_file_attrs_set</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>,
                              <argument><expr><name>APR_FILE_ATTR_READONLY</name></expr></argument>,
                              <argument><expr><name>APR_FILE_ATTR_READONLY</name></expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>status</name> &amp;&amp; <name>status</name> != <name>APR_ENOTIMPL</name></expr>)</condition><then>
    <if>if <condition>(<expr>!<name>ignore_enoent</name> || !<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set file '%s' read-only"</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_set_file_read_write</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_enoent</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* On Windows, just set the file attributes -- on unix call
     our internal function which attempts to honor the umask. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
  <return>return <expr><call><name>io_set_file_perms</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                           <argument><expr><name>ignore_enoent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>apr_file_attrs_set</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>,
                              <argument><expr>0</expr></argument>,
                              <argument><expr><name>APR_FILE_ATTR_READONLY</name></expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>status</name> &amp;&amp; <name>status</name> != <name>APR_ENOTIMPL</name></expr>)</condition><then>
    <if>if <condition>(<expr>!<name>ignore_enoent</name> || !<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set file '%s' read-write"</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_set_file_executable</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>executable</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_enoent</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* On Windows, just exit -- on unix call our internal function
  which attempts to honor the umask. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
  <return>return <expr><call><name>io_set_file_perms</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>executable</name></expr></argument>,
                           <argument><expr><name>ignore_enoent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_is_file_executable</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>executable</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>APR_HAS_USER</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>file_info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uid_t</name></type> <name>uid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_gid_t</name></type> <name>gid</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>executable</name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Get file and user info. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>file_info</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                      <argument><expr>(<name>APR_FINFO_PROT</name> | <name>APR_FINFO_OWNER</name>)</expr></argument>,
                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_uid_current</name><argument_list>(<argument><expr>&amp;<name>uid</name></expr></argument>, <argument><expr>&amp;<name>gid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error getting UID of process"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check executable bit for current user. */</comment>
  <if>if <condition>(<expr><call><name>apr_uid_compare</name><argument_list>(<argument><expr><name>uid</name></expr></argument>, <argument><expr><name><name>file_info</name>.<name>user</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>executable</name> = (<name><name>file_info</name>.<name>protection</name></name> &amp; <name>APR_UEXECUTE</name>)</expr>;</expr_stmt></then>

  <else>else <if>if <condition>(<expr><call><name>apr_gid_compare</name><argument_list>(<argument><expr><name>gid</name></expr></argument>, <argument><expr><name><name>file_info</name>.<name>group</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>executable</name> = (<name><name>file_info</name>.<name>protection</name></name> &amp; <name>APR_GEXECUTE</name>)</expr>;</expr_stmt></then>

  <else>else
    <expr_stmt><expr>*<name>executable</name> = (<name><name>file_info</name>.<name>protection</name></name> &amp; <name>APR_WEXECUTE</name>)</expr>;</expr_stmt></else></if></else></if>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* defined(WIN32) || !defined(APR_HAS_USER) */</comment>
  <expr_stmt><expr>*<name>executable</name> = <name>FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** File locking. ***/</comment>
<comment type="block">/* Clear all outstanding locks on ARG, an open apr_file_t *. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>svn_io__file_clear_and_close</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>f</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Remove locks. */</comment>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_unlock</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><name>apr_err</name></expr>;</return></then></if>

  <comment type="block">/* Close the file. */</comment>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><name>apr_err</name></expr>;</return></then></if>

  <return>return <expr>0</expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type><name>svn_io_file_lock</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_file</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>exclusive</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_io_file_lock2</name><argument_list>(<argument><expr><name>lock_file</name></expr></argument>, <argument><expr><name>exclusive</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type><name>svn_io_file_lock2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_file</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>exclusive</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>nonblocking</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>locktype</name> <init>= <expr><name>APR_FLOCK_SHARED</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>lockfile_handle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>flags</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>exclusive</name> == <name>TRUE</name></expr>)</condition><then>
    <expr_stmt><expr><name>locktype</name> = <name>APR_FLOCK_EXCLUSIVE</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>flags</name> = <name>APR_READ</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>locktype</name> == <name>APR_FLOCK_EXCLUSIVE</name></expr>)</condition><then>
    <expr_stmt><expr><name>flags</name> |= <name>APR_WRITE</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>nonblocking</name> == <name>TRUE</name></expr>)</condition><then>
    <expr_stmt><expr><name>locktype</name> |= <name>APR_FLOCK_NONBLOCK</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>lockfile_handle</name></expr></argument>, <argument><expr><name>lock_file</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get lock on the filehandle. */</comment>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_lock</name><argument_list>(<argument><expr><name>lockfile_handle</name></expr></argument>, <argument><expr><name>locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <block>{
      <switch>switch <condition>(<expr><name>locktype</name> &amp; <name>APR_FLOCK_TYPEMASK</name></expr>)</condition>
        <block>{
        <case>case <expr><name>APR_FLOCK_SHARED</name></expr>:
          <return>return <expr><call><name>svn_error_wrap_apr</name>
            <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't get shared lock on file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>lock_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </case><case>case <expr><name>APR_FLOCK_EXCLUSIVE</name></expr>:
          <return>return <expr><call><name>svn_error_wrap_apr</name>
            <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't get exclusive lock on file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>lock_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </case><default>default:
          <comment type="block">/* Cannot happen. */</comment>
          <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
    }</block></then></if>

  <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>lockfile_handle</name></expr></argument>,
                            <argument><expr><name>svn_io__file_clear_and_close</name></expr></argument>,
                            <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Data consistency/coherency operations. */</comment>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_io_file_wrapper_cleanup</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_status_t</name></type> <name>status</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg_no_name</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function><type><name>svn_error_t</name> *</type><name>svn_io_file_flush_to_disk</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_os_file_t</name></type> <name>filehand</name></decl>;</decl_stmt>

  <comment type="block">/* First make sure that any user-space buffered data is flushed. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_io_file_wrapper_cleanup</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>apr_file_flush</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't flush file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't flush stream"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>apr_os_file_get</name><argument_list>(<argument><expr>&amp;<name>filehand</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Call the operating system specific function to actually force the
     data to disk. */</comment>
  <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

    <if>if <condition>(<expr>! <call><name>FlushFileBuffers</name><argument_list>(<argument><expr><name>filehand</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name>
          <argument_list>(<argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't flush file to disk"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

      <do>do <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>fsync</name><argument_list>(<argument><expr><name>filehand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block> while <condition>(<expr><name>rv</name> == -1 &amp;&amp; <call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>

      <comment type="block">/* If the file is in a memory filesystem, fsync() may return
         EINVAL.  Presumably the user knows the risks, and we can just
         ignore the error. */</comment>
      <if>if <condition>(<expr><name>rv</name> == -1 &amp;&amp; <call><name>APR_STATUS_IS_EINVAL</name><argument_list>(<argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <if>if <condition>(<expr><name>rv</name> == -1</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name>
          <argument_list>(<argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't flush file to disk"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* TODO write test for these two functions, then refactor. */</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_stringbuf_from_file2</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>result</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>filename</name><index>[<expr>0</expr>]</index></name> == '-' &amp;&amp; <name><name>filename</name><index>[<expr>1</expr>]</index></name> == '\0'</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
      <if>if <condition>(<expr>(<name>apr_err</name> = <call><name>apr_file_open_stdin</name><argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't open stdin"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stringbuf_from_aprfile</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stringbuf_from_file</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>result</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>filename</name><index>[<expr>0</expr>]</index></name> == '-' &amp;&amp; <name><name>filename</name><index>[<expr>1</expr>]</index></name> == '\0'</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
        <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Reading from stdin is disallowed"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <return>return <expr><call><name>svn_stringbuf_from_file2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Get the name of FILE, or NULL if FILE is an unnamed stream. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>file_name_get</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fname_utf8</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_name_get</name><argument_list>(<argument><expr>&amp;<name>fname</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't get file name"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>fname</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr><name>fname_utf8</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>fname_utf8</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stringbuf_from_aprfile</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>result</name></decl></param>,
                           <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>res</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* XXX: We should check the incoming data for being of type binary. */</comment>

  <comment type="block">/* apr_file_read will not return data and eof in the same call. So this loop
   * is safe from missing read data.  */</comment>
  <expr_stmt><expr><name>len</name> = <name>SVN__STREAM_CHUNK_SIZE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_read</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr>! <name>err</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> = <name>SVN__STREAM_CHUNK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_read</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <comment type="block">/* Having read all the data we *expect* EOF */</comment>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; !<call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Null terminate the stringbuf. */</comment>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>data</name><index>[<expr><name><name>res</name>-&gt;<name>len</name></name></expr>]</index></name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr>*<name>result</name> = <name>res</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Deletion. */</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_remove_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
  <comment type="block">/* Set the file writable but only on Windows, because Windows
     will not allow us to remove files that are read-only. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_write</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_remove</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>apr_file_remove</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't remove file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_remove_dir</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_io_remove_dir2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 Mac OS X has a bug where if you're readding the contents of a
 directory via readdir in a loop, and you remove one of the entries in
 the directory and the directory has 338 or more files in it you will
 skip over some of the entries in the directory.  Needless to say,
 this causes problems if you are using this kind of loop inside a
 function that is recursively deleting a directory, because when you
 get around to removing the directory it will still have something in
 it.

 Similar problem has been observed on FreeBSD.

 See http://subversion.tigris.org/issues/show_bug.cgi?id=1896 for more
 discussion and an initial solution.

 To work around the problem, we do a rewinddir after we delete all files
 and see if there's anything left. We repeat the steps untill there's
 nothing left to delete.

 This workaround causes issues on Windows where delete's are asynchronous,
 however, so we never rewind if we're on Windows (the delete says it is
 complete, we rewind, we see the same file and try to delete it again,
 we fail.
*/</comment>

<comment type="block">/* Neither windows nor unix allows us to delete a non-empty
   directory.

   This is a function to perform the equivalent of 'rm -rf'. */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_io_remove_dir2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_enoent</name></decl></param>,
                   <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>, <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>this_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>this_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>flags</name> <init>= <expr><name>APR_FINFO_TYPE</name> | <name>APR_FINFO_NAME</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>need_rewind</name></decl>;</decl_stmt>

  <comment type="block">/* Check for pending cancellation request.
     If we need to bail out, do so early. */</comment>

  <if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call>(*<name>cancel_func</name>)<argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Convert path to native here and call apr_dir_open directly,
     instead of just using svn_io_dir_open, because we're going to
     need path_apr later anyway when we remove the dir itself. */</comment>

  <if>if <condition>(<expr><name><name>path</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
    <comment type="block">/* APR doesn't like "" directories; use "." instead. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr>"."</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_open</name><argument_list>(<argument><expr>&amp;<name>this_dir</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* if the directory doesn't exist, our mission is accomplished */</comment>
      <if>if <condition>(<expr><name>ignore_enoent</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then>
      <else>else
        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't open directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></then></if>

  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <do>do
    <block>{
      <expr_stmt><expr><name>need_rewind</name> = <name>FALSE</name></expr>;</expr_stmt>

      <for>for (<init><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>this_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</init>
           <condition><expr><name>status</name> == <name>APR_SUCCESS</name></expr>;</condition>
           <incr><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>this_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(<name><name>this_entry</name>.<name>filetype</name></name> == <name>APR_DIR</name>)
              &amp;&amp; ((<name><name>this_entry</name>.<name>name</name><index>[<expr>0</expr>]</index></name> == '.')
                  &amp;&amp; ((<name><name>this_entry</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '\0')
                      || ((<name><name>this_entry</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '.')
                          &amp;&amp; (<name><name>this_entry</name>.<name>name</name><index>[<expr>2</expr>]</index></name> == '\0'))))</expr>)</condition><then>
            <block>{
              <continue>continue;</continue>
            }</block></then>
          <else>else  <comment type="block">/* something other than "." or "..", so proceed */</comment>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fullpath</name></decl>, *<decl><type ref="prev"/><name>entry_utf8</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
              <expr_stmt><expr><name>need_rewind</name> = <name>TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>entry_utf8</name></expr></argument>, <argument><expr><name><name>this_entry</name>.<name>name</name></name></expr></argument>,
                                               <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><name>fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>entry_utf8</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr><name><name>this_entry</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* Don't check for cancellation, the callee
                     will immediately do so */</comment>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_dir2</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                             <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                                             <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

                  <if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call>(*<name>cancel_func</name>)<argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

                  <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                    <return>return <expr><call><name>svn_error_createf</name>
                      <argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't remove '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
                }</block></else></if>
            }</block></else></if>
        }</block></for>

      <if>if <condition>(<expr><name>need_rewind</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>status</name> = <call><name>apr_dir_rewind</name><argument_list>(<argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't rewind directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><call><name>svn_path_local_style</name> <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></then></if>
    }</block>
  while <condition>(<expr><name>need_rewind</name></expr>)</condition>;</do>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_close</name><argument_list>(<argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error closing directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_remove</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>apr_dir_remove</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't remove '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_get_dir_filenames</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>dirents</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>this_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>this_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>flags</name> <init>= <expr><name>APR_FINFO_NAME</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>dirents</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_open</name><argument_list>(<argument><expr>&amp;<name>this_dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>this_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>status</name> == <name>APR_SUCCESS</name></expr>;</condition>
       <incr><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>this_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <if>if <condition>(<expr>(<name><name>this_entry</name>.<name>name</name><index>[<expr>0</expr>]</index></name> == '.')
          &amp;&amp; ((<name><name>this_entry</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '\0')
              || ((<name><name>this_entry</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '.')
                  &amp;&amp; (<name><name>this_entry</name>.<name>name</name><index>[<expr>2</expr>]</index></name> == '\0')))</expr>)</condition><then>
        <block>{
          <continue>continue;</continue>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name><name>this_entry</name>.<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>dirents</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>

  <if>if <condition>(<expr>! (<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_close</name><argument_list>(<argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error closing directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_get_dirents2</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>dirents</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>this_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>this_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>flags</name> <init>= <expr><name>APR_FINFO_TYPE</name> | <name>APR_FINFO_NAME</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>dirents</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_open</name><argument_list>(<argument><expr>&amp;<name>this_dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>this_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>status</name> == <name>APR_SUCCESS</name></expr>;</condition>
       <incr><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>this_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <if>if <condition>(<expr>(<name><name>this_entry</name>.<name>name</name><index>[<expr>0</expr>]</index></name> == '.')
          &amp;&amp; ((<name><name>this_entry</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '\0')
              || ((<name><name>this_entry</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '.')
                  &amp;&amp; (<name><name>this_entry</name>.<name>name</name><index>[<expr>2</expr>]</index></name> == '\0')))</expr>)</condition><then>
        <block>{
          <continue>continue;</continue>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_io_dirent_t</name> *</type><name>dirent</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>dirent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name><name>this_entry</name>.<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>map_apr_finfo_to_node_kind</name><argument_list>(<argument><expr>&amp;(<name><name>dirent</name>-&gt;<name>kind</name></name>)</expr></argument>,
                                     <argument><expr>&amp;(<name><name>dirent</name>-&gt;<name>special</name></name>)</expr></argument>,
                                     <argument><expr>&amp;<name>this_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>dirents</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>dirent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>

  <if>if <condition>(<expr>! (<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_close</name><argument_list>(<argument><expr><name>this_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error closing directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_get_dirents</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>dirents</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Note that in C, padding is not allowed at the beginning of structs,
     so this is actually portable, since the kind field of svn_io_dirent_t
     is first in that struct. */</comment>
  <return>return <expr><call><name>svn_io_get_dirents2</name><argument_list>(<argument><expr><name>dirents</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Pool userdata key for the error file passed to svn_io_start_cmd(). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRFILE_KEY</name></cpp:macro> <cpp:value>"svn-io-start-cmd-errfile"</cpp:value></cpp:define>

<comment type="block">/* Handle an error from the child process (before command execution) by
   printing DESC and the error string corresponding to STATUS to stderr. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_child_process_error</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>apr_status_t</name></type> <name>status</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>desc</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>errfile</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>p</name></decl>;</decl_stmt>

  <comment type="block">/* We can't do anything if we get an error here, so just return. */</comment>
  <if>if <condition>(<expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>ERRFILE_KEY</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return;</return></then></if>
  <expr_stmt><expr><name>errfile</name> = <name>p</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>errfile</name></expr>)</condition><then>
    <comment type="block">/* What we get from APR is in native encoding. */</comment>
    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr>"%s: %s"</expr></argument>,
                    <argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>apr_strerror</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>,
                                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_start_cmd</name><parameter_list>(<param><decl><type><name>apr_proc_t</name> *</type><name>cmd_proc</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *<specifier>const</specifier> *</type><name>args</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>inherit</name></decl></param>,
                 <param><decl><type><name>apr_file_t</name> *</type><name>infile</name></decl></param>,
                 <param><decl><type><name>apr_file_t</name> *</type><name>outfile</name></decl></param>,
                 <param><decl><type><name>apr_file_t</name> *</type><name>errfile</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_procattr_t</name> *</type><name>cmdproc_attr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>num_args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>args_native</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd_apr</name></decl>;</decl_stmt>

  <comment type="block">/* Create the process attributes. */</comment>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_procattr_create</name><argument_list>(<argument><expr>&amp;<name>cmdproc_attr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name>
      <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create process '%s' attributes"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure we invoke cmd directly, not through a shell. */</comment>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_procattr_cmdtype_set</name><argument_list>(<argument><expr><name>cmdproc_attr</name></expr></argument>,
                                     <argument><expr><name>inherit</name>?<name>APR_PROGRAM_PATH</name>:<name>APR_PROGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set process '%s' cmdtype"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Set the process's working directory. */</comment>
  <if>if <condition>(<expr><name>path</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_procattr_dir_set</name><argument_list>(<argument><expr><name>cmdproc_attr</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name>
          <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set process '%s' directory"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Use requested inputs and outputs.

     ### Unfortunately each of these apr functions creates a pipe and then
     overwrites the pipe file descriptor with the descriptor we pass
     in. The pipes can then never be closed. This is an APR bug. */</comment>
  <if>if <condition>(<expr><name>infile</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_procattr_child_in_set</name><argument_list>(<argument><expr><name>cmdproc_attr</name></expr></argument>, <argument><expr><name>infile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name>
          <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set process '%s' child input"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>
  <if>if <condition>(<expr><name>outfile</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_procattr_child_out_set</name><argument_list>(<argument><expr><name>cmdproc_attr</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name>
          <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set process '%s' child outfile"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>
  <if>if <condition>(<expr><name>errfile</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_procattr_child_err_set</name><argument_list>(<argument><expr><name>cmdproc_attr</name></expr></argument>, <argument><expr><name>errfile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name>
          <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set process '%s' child errfile"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Have the child print any problems executing its program to errfile. */</comment>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr><name>errfile</name></expr></argument>, <argument><expr><name>ERRFILE_KEY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name>
      <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set process '%s' child errfile for error handler"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_procattr_child_errfn_set</name><argument_list>(<argument><expr><name>cmdproc_attr</name></expr></argument>,
                                         <argument><expr><name>handle_child_process_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name>
      <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set process '%s' error handler"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Convert cmd and args from UTF-8 */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>cmd_apr</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>num_args</name> = 0</expr>;</init> <condition><expr><name><name>args</name><index>[<expr><name>num_args</name></expr>]</index></name></expr>;</condition> <incr><expr><name>num_args</name>++</expr></incr>)
    <empty_stmt>;</empty_stmt></for>
  <expr_stmt><expr><name>args_native</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>(<name>num_args</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args_native</name><index>[<expr><name>num_args</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>num_args</name>--</expr>)</condition>
    <block>{
      <comment type="block">/* ### Well, it turns out that on APR on Windows expects all
             program args to be in UTF-8. Callers of svn_io_run_cmd
             should be aware of that. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name><name>args_native</name><index>[<expr><name>num_args</name></expr>]</index></name></expr></argument>,
                                         <argument><expr><name><name>args</name><index>[<expr><name>num_args</name></expr>]</index></name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>


  <comment type="block">/* Start the cmd command. */</comment>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_proc_create</name><argument_list>(<argument><expr><name>cmd_proc</name></expr></argument>, <argument><expr><name>cmd_apr</name></expr></argument>, <argument><expr><name>args_native</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><name>cmdproc_attr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't start process '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ERRFILE_KEY</name></cpp:undef>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_wait_for_cmd</name><parameter_list>(<param><decl><type><name>apr_proc_t</name> *</type><name>cmd_proc</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd</name></decl></param>,
                    <param><decl><type><name>int</name> *</type><name>exitcode</name></decl></param>,
                    <param><decl><type><name>apr_exit_why_e</name> *</type><name>exitwhy</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_exit_why_e</name></type> <name>exitwhy_val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>exitcode_val</name></decl>;</decl_stmt>

  <comment type="block">/* The Win32 apr_proc_wait doesn't set this... */</comment>
  <expr_stmt><expr><name>exitwhy_val</name> = <name>APR_PROC_EXIT</name></expr>;</expr_stmt>

  <comment type="block">/* Wait for the cmd command to finish. */</comment>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_proc_wait</name><argument_list>(<argument><expr><name>cmd_proc</name></expr></argument>, <argument><expr>&amp;<name>exitcode_val</name></expr></argument>, <argument><expr>&amp;<name>exitwhy_val</name></expr></argument>, <argument><expr><name>APR_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>APR_STATUS_IS_CHILD_DONE</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error waiting for process '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>exitwhy</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>exitwhy</name> = <name>exitwhy_val</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr>! <call><name>APR_PROC_CHECK_EXIT</name><argument_list>(<argument><expr><name>exitwhy_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_EXTERNAL_PROGRAM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Process '%s' failed (exitwhy %d)"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>exitwhy_val</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

  <if>if <condition>(<expr><name>exitcode</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>exitcode</name> = <name>exitcode_val</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>exitcode_val</name> != 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_EXTERNAL_PROGRAM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Process '%s' returned error exitcode %d"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>exitcode_val</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_run_cmd</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *<specifier>const</specifier> *</type><name>args</name></decl></param>,
               <param><decl><type><name>int</name> *</type><name>exitcode</name></decl></param>,
               <param><decl><type><name>apr_exit_why_e</name> *</type><name>exitwhy</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>inherit</name></decl></param>,
               <param><decl><type><name>apr_file_t</name> *</type><name>infile</name></decl></param>,
               <param><decl><type><name>apr_file_t</name> *</type><name>outfile</name></decl></param>,
               <param><decl><type><name>apr_file_t</name> *</type><name>errfile</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_proc_t</name></type> <name>cmd_proc</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_start_cmd</name><argument_list>(<argument><expr>&amp;<name>cmd_proc</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>inherit</name></expr></argument>,
                           <argument><expr><name>infile</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>errfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_wait_for_cmd</name><argument_list>(<argument><expr>&amp;<name>cmd_proc</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>exitcode</name></expr></argument>, <argument><expr><name>exitwhy</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_run_diff</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *<specifier>const</specifier> *</type><name>user_args</name></decl></param>,
                <param><decl><type><name>int</name></type> <name>num_user_args</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label1</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label2</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to</name></decl></param>,
                <param><decl><type><name>int</name> *</type><name>pexitcode</name></decl></param>,
                <param><decl><type><name>apr_file_t</name> *</type><name>outfile</name></decl></param>,
                <param><decl><type><name>apr_file_t</name> *</type><name>errfile</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff_cmd</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>exitcode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr>4</expr></init></decl>;</decl_stmt> <comment type="block">/* the diff command itself, two paths, plus a trailing NULL */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff_utf8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>diff_utf8</name></expr></argument>, <argument><expr><name>diff_cmd</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>pexitcode</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name>pexitcode</name> = &amp;<name>exitcode</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>user_args</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name>nargs</name> += <name>num_user_args</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>nargs</name> += 1</expr>;</expr_stmt></else></if> <comment type="block">/* -u */</comment>

  <if>if <condition>(<expr><name>label1</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name>nargs</name> += 2</expr>;</expr_stmt></then></if> <comment type="block">/* the -L and the label itself */</comment>
  <if>if <condition>(<expr><name>label2</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name>nargs</name> += 2</expr>;</expr_stmt></then></if> <comment type="block">/* the -L and the label itself */</comment>

  <expr_stmt><expr><name>args</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>nargs</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>diff_utf8</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>user_args</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>num_user_args</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
        <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name><name>user_args</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></for>
    }</block></then>
  <else>else
    <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = "-u"</expr>;</expr_stmt></else></if> <comment type="block">/* assume -u if the user didn't give us any args */</comment>

  <if>if <condition>(<expr><name>label1</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = "-L"</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>label1</name></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>label2</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = "-L"</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>label2</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> == <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_run_cmd</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>diff_utf8</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>pexitcode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>errfile</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The man page for (GNU) diff describes the return value as:

       "An exit status of 0 means no differences were found, 1 means
        some differences were found, and 2 means trouble."

     A return value of 2 typically occurs when diff cannot read its input
     or write to its output, but in any case we probably ought to return an
     error for anything other than 0 or 1 as the output is likely to be
     corrupt.
   */</comment>
  <if>if <condition>(<expr>*<name>pexitcode</name> != 0 &amp;&amp; *<name>pexitcode</name> != 1</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_EXTERNAL_PROGRAM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' returned %d"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>diff_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr>*<name>pexitcode</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_io_run_diff3_2</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>exitcode</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mine</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>older</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yours</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mine_label</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>older_label</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yours_label</name></decl></param>,
                   <param><decl><type><name>apr_file_t</name> *</type><name>merged</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>user_args</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>args</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></sizeof> * (13
                                                  + (<name>user_args</name>
                                                     ? <name><name>user_args</name>-&gt;<name>nelts</name></name>
                                                     : 1))</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_utf8</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
  <decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr>12</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>diff3_utf8</name></expr></argument>, <argument><expr><name>diff3_cmd</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Labels fall back to sensible defaults if not specified. */</comment>
  <if>if <condition>(<expr><name>mine_label</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name>mine_label</name> = ".working"</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>older_label</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name>older_label</name> = ".old"</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>yours_label</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name>yours_label</name> = ".new"</expr>;</expr_stmt></then></if>

  <comment type="block">/* Set up diff3 command line. */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>diff3_utf8</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>user_args</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>user_args</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
        <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>user_args</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
      <expr_stmt><expr><name>nargs</name> += <name><name>user_args</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = "-E"</expr>;</expr_stmt>             <comment type="block">/* We tried "-A" here, but that caused
                                       overlapping identical changes to
                                       conflict.  See issue #682. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
      <expr_stmt><expr>++<name>nargs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></else></if>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = "-m"</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = "-L"</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>mine_label</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = "-L"</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>older_label</name></expr>;</expr_stmt>      <comment type="block">/* note:  this label is ignored if
                                   using 2-part markers, which is the
                                   case with "-E". */</comment>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = "-L"</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>yours_label</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_DIFF3_HAS_DIFF_PROGRAM_ARG</name></cpp:ifdef>
  <block>{
    <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_arg</name></decl>;</decl_stmt>

    <comment type="block">/* ### FIXME: we really shouldn't be reading the config here;
       instead, the necessary bits should be passed in by the caller.
       But should we add another parameter to this function, when the
       whole external diff3 thing might eventually go away?  */</comment>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>config</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_config_get_config</name><argument_list>(<argument><expr>&amp;<name>config</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cfg</name> = <name>config</name> ? <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>SVN_CONFIG_CATEGORY_CONFIG</name></expr></argument>,
                                <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_config_get_bool</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>has_arg</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_HELPERS</name></expr></argument>,
                                <argument><expr><name>SVN_CONFIG_OPTION_DIFF3_HAS_PROGRAM_ARG</name></expr></argument>,
                                <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>has_arg</name></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff_cmd</name></decl>, *<decl><type ref="prev"/><name>diff_utf8</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>diff_cmd</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_HELPERS</name></expr></argument>,
                       <argument><expr><name>SVN_CONFIG_OPTION_DIFF_CMD</name></expr></argument>, <argument><expr><name>SVN_CLIENT_DIFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>diff_utf8</name></expr></argument>, <argument><expr><name>diff_cmd</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"--diff-program="</expr></argument>, <argument><expr><name>diff_utf8</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
        <expr_stmt><expr>++<name>nargs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>older</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>yours</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> == <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Run diff3, output the merged text into the scratch file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_run_cmd</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>diff3_utf8</name></expr></argument>, <argument><expr><name>args</name></expr></argument>,
                         <argument><expr><name>exitcode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><name>TRUE</name></expr></argument>, <comment type="block">/* keep environment */</comment>
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>merged</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* According to the diff3 docs, a '0' means the merge was clean, and
     '1' means conflict markers were found.  Anything else is real
     error. */</comment>
  <if>if <condition>(<expr>(*<name>exitcode</name> != 0) &amp;&amp; (*<name>exitcode</name> != 1)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_EXTERNAL_PROGRAM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error running '%s':  exitcode was %d, "
                               "args were:"
                               "\nin directory '%s', basenames:\n%s\n%s\n%s"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>diff3_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr>*<name>exitcode</name></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <comment type="block">/* Don't call svn_path_local_style() on
                                the basenames.  We don't want them to
                                be absolute, and we don't need the
                                separator conversion. */</comment>
                             <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>older</name></expr></argument>, <argument><expr><name>yours</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_run_diff3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mine</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>older</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yours</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mine_label</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>older_label</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yours_label</name></decl></param>,
                 <param><decl><type><name>apr_file_t</name> *</type><name>merged</name></decl></param>,
                 <param><decl><type><name>int</name> *</type><name>exitcode</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_io_run_diff3_2</name><argument_list>(<argument><expr><name>exitcode</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>older</name></expr></argument>, <argument><expr><name>yours</name></expr></argument>,
                            <argument><expr><name>mine_label</name></expr></argument>, <argument><expr><name>older_label</name></expr></argument>, <argument><expr><name>yours_label</name></expr></argument>,
                            <argument><expr><name>merged</name></expr></argument>, <argument><expr><name>diff3_cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_parse_mimetypes_file</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>type_map</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetypes_file</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>types</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eof</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>types_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>mimetypes_stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>types_file</name></expr></argument>, <argument><expr><name>mimetypes_file</name></expr></argument>,
                           <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mimetypes_stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>types_file</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>tokens</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Read a line. */</comment>
      <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>mimetypes_stream</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>,
                                     <argument><expr><name>APR_EOL_STR</name></expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="block">/* Only pay attention to non-empty, non-comment lines. */</comment>
      <if>if <condition>(<expr><name><name>buf</name>-&gt;<name>len</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>buf</name>-&gt;<name>data</name><index>[<expr>0</expr>]</index></name> == '#'</expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Tokenize (into our return pool). */</comment>
          <expr_stmt><expr><name>tokens</name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name><name>buf</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>" \t"</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>tokens</name>-&gt;<name>nelts</name></name> &lt; 2</expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* The first token in a multi-token line is the media type.
             Subsequent tokens are filename extensions associated with
             that media type. */</comment>
          <expr_stmt><expr><name>type</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>tokens</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ext</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>tokens</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><name>ext</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
      <if>if <condition>(<expr><name>eof</name></expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></while>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there was an error above, close the file (ignoring any error
     from *that*) and return the originally error. */</comment>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>mimetypes_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Close the stream (which closes the underlying file, too). */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>mimetypes_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>type_map</name> = <name>types</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_detect_mimetype2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>mimetype</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>,
                        <param><decl><type><name>apr_hash_t</name> *</type><name>mimetype_map</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name>generic_binary</name> <init>= <expr>"application/octet-stream"</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fh</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>block</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>amt_read</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Default return value is NULL. */</comment>
  <expr_stmt><expr>*<name>mimetype</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* See if this file even exists, and make sure it really is a file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_FILENAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't detect MIME type of non-file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If there is a mimetype_map provided, we'll first try to look up
     our file's extension in the map.  Failing that, we'll run the
     heuristic. */</comment>
  <if>if <condition>(<expr><name>mimetype_map</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type_from_map</name></decl>, *<decl><type ref="prev"/><name>path_ext</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_path_splitext</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>path_ext</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name>type_from_map</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mimetype_map</name></expr></argument>, <argument><expr><name>path_ext</name></expr></argument>,
                                        <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>mimetype</name> = <name>type_from_map</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>fh</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read a block of data from FILE. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_read</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr>&amp;<name>amt_read</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; ! <call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now close the file.  No use keeping it open any more.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Right now, this function is going to be really stupid.  It's
     going to examine the first block of data, and make sure that 85%
     of the bytes are such that their value is in the ranges 0x07-0x0D
     or 0x20-0x7F, and that 100% of those bytes is not 0x00.

     If those criteria are not met, we're calling it binary. */</comment>
  <if>if <condition>(<expr><name>amt_read</name> &gt; 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>binary_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

      <comment type="block">/* Run through the data we've read, counting the 'binary-ish'
         bytes.  HINT: If we see a 0x00 byte, we'll set our count to its
         max and stop reading the file. */</comment>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>amt_read</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <if>if <condition>(<expr><name><name>block</name><index>[<expr><name>i</name></expr>]</index></name> == 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>binary_count</name> = <name>amt_read</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
          <if>if <condition>(<expr>(<name><name>block</name><index>[<expr><name>i</name></expr>]</index></name> &lt; 0x07)
              || ((<name><name>block</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 0x0D) &amp;&amp; (<name><name>block</name><index>[<expr><name>i</name></expr>]</index></name> &lt; 0x20))
              || (<name><name>block</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 0x7F)</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>binary_count</name>++</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

      <if>if <condition>(<expr>((<name>binary_count</name> * 1000) / <name>amt_read</name>) &gt; 850</expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>mimetype</name> = <name>generic_binary</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_detect_mimetype</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>mimetype</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_io_detect_mimetype2</name><argument_list>(<argument><expr><name>mimetype</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_open</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>new_file</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>,
                 <param><decl><type><name>apr_int32_t</name></type> <name>flag</name></decl></param>, <param><decl><type><name>apr_fileperms_t</name></type> <name>perm</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>fname_apr</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> = <call><name>file_open</name><argument_list>(<argument><expr><name>new_file</name></expr></argument>, <argument><expr><name>fname_apr</name></expr></argument>, <argument><expr><name>flag</name> | <name>APR_BINARY</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't open file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></else></if>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_io_file_wrapper_cleanup</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_status_t</name></type> <name>status</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg_no_name</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>status</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>err</name> = <call><name>file_name_get</name><argument_list>(<argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>name</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>name</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>msg_no_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_close</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_io_file_wrapper_cleanup</name>
    <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't close file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't close stream"</expr></argument>)</argument_list></call></expr></argument>,
      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_getc</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>ch</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_io_file_wrapper_cleanup</name>
    <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>apr_file_getc</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't read file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't read stream"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_info_get</name><parameter_list>(<param><decl><type><name>apr_finfo_t</name> *</type><name>finfo</name></decl></param>, <param><decl><type><name>apr_int32_t</name></type> <name>wanted</name></decl></param>,
                     <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_io_file_wrapper_cleanup</name>
    <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>apr_file_info_get</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>wanted</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't get attribute information from file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't get attribute information from stream"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_read</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buf</name></decl></param>,
                 <param><decl><type><name>apr_size_t</name> *</type><name>nbytes</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_io_file_wrapper_cleanup</name>
    <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>apr_file_read</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't read file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't read stream"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_read_full</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>void</name> *</type><name>buf</name></decl></param>,
                      <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>bytes_read</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_io_file_wrapper_cleanup</name>
    <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>apr_file_read_full</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>bytes_read</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't read file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't read stream"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_seek</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_seek_where_t</name></type> <name>where</name></decl></param>,
                 <param><decl><type><name>apr_off_t</name> *</type><name>offset</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_io_file_wrapper_cleanup</name>
    <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>apr_file_seek</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't set position pointer in file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't set position pointer in stream"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_write</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>buf</name></decl></param>,
                  <param><decl><type><name>apr_size_t</name> *</type><name>nbytes</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_io_file_wrapper_cleanup</name>
    <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>apr_file_write</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't write to file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't write to stream"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_write_full</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>buf</name></decl></param>,
                       <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>bytes_written</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXBUFSIZE</name></cpp:macro> <cpp:value>30*1024</cpp:value></cpp:define>
  <if>if <condition>(<expr><name>rv</name> == <call><name>APR_FROM_OS_ERROR</name><argument_list>(<argument><expr><name>ERROR_NOT_ENOUGH_MEMORY</name></expr></argument>)</argument_list></call>
      &amp;&amp; <name>nbytes</name> &gt; <name>MAXBUFSIZE</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bw</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr>*<name>bytes_written</name> = 0</expr>;</expr_stmt>

      <do>do <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
                                 <argument><expr><name>nbytes</name> &gt; <name>MAXBUFSIZE</name> ? <name>MAXBUFSIZE</name> : <name>nbytes</name></expr></argument>, <argument><expr>&amp;<name>bw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>bytes_written</name> += <name>bw</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> = (<name>char</name> *)<name>buf</name> + <name>bw</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>nbytes</name> -= <name>bw</name></expr>;</expr_stmt>
      }</block> while <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name> &amp;&amp; <name>nbytes</name> &gt; 0</expr>)</condition>;</do>
    }</block></then></if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAXBUFSIZE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><call><name>do_io_file_wrapper_cleanup</name>
    <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't write to file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>N_</name><argument_list>(<argument><expr>"Can't write to stream"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_read_length_line</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>limit</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; *<name>limit</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Note: this error could be APR_EOF, which
         is totally fine.  The caller should be aware of
         this. */</comment>

      <if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
          <expr_stmt><expr>*<name>limit</name> = <name>i</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>

  <expr_stmt><expr><name>err</name> = <call><name>file_name_get</name><argument_list>(<argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>name</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>name</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_MALFORMED_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read length line in file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_MALFORMED_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read length line in stream"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_stat</name><parameter_list>(<param><decl><type><name>apr_finfo_t</name> *</type><name>finfo</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>,
            <param><decl><type><name>apr_int32_t</name></type> <name>wanted</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname_apr</name></decl>;</decl_stmt>

  <comment type="block">/* APR doesn't like "" directories */</comment>
  <if>if <condition>(<expr><name><name>fname</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
    <expr_stmt><expr><name>fname</name> = "."</expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>fname_apr</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>fname_apr</name></expr></argument>, <argument><expr><name>wanted</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't stat '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_rename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path_apr</name></decl>, *<decl><type ref="prev"/><name>to_path_apr</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
  <comment type="block">/* Set the destination file writable but only on Windows, because
     Windows will not allow us to rename over files that are read-only. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_write</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>from_path_apr</name></expr></argument>, <argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>to_path_apr</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>apr_file_rename</name><argument_list>(<argument><expr><name>from_path_apr</name></expr></argument>, <argument><expr><name>to_path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                   <argument><expr><call><name>apr_file_rename</name><argument_list>(<argument><expr><name>from_path_apr</name></expr></argument>, <argument><expr><name>to_path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't move '%s' to '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_file_move</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EXDEV</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_to_path</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmp_to_path</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>,
                                       <argument><expr>"tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>err</name> = <call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>tmp_to_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <goto>goto <name>failed_tmp</name>;</goto></then></if>

      <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>tmp_to_path</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <goto>goto <name>failed_tmp</name>;</goto></then></if>

      <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>err</name></expr>;</return>

    <label><name>failed_tmp</name>:</label>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>tmp_to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Common implementation of svn_io_dir_make and svn_io_dir_make_hidden.
   HIDDEN determines if the hidden attribute
   should be set on the newly created directory. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>dir_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_fileperms_t</name></type> <name>perm</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>hidden</name></decl></param>, <param><decl><type><name>svn_boolean_t</name></type> <name>sgid</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* APR doesn't like "" directories */</comment>
  <if>if <condition>(<expr><name><name>path_apr</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
    <expr_stmt><expr><name>path_apr</name> = "."</expr>;</expr_stmt></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>APR_OS_DEFAULT</name> &amp; <name>APR_WSTICKY</name>)</expr></cpp:if>
  <comment type="block">/* The APR shipped with httpd 2.0.50 contains a bug where
     APR_OS_DEFAULT encompasses the setuid, setgid, and sticky bits.
     There is a special case for file creation, but not directory
     creation, so directories wind up getting created with the sticky
     bit set.  (There is no such thing as a setuid directory, and the
     setgid bit is apparently ignored at mkdir() time.)  If we detect
     this problem, work around it by unsetting those bits if we are
     passed APR_OS_DEFAULT. */</comment>
  <if>if <condition>(<expr><name>perm</name> == <name>APR_OS_DEFAULT</name></expr>)</condition><then>
    <expr_stmt><expr><name>perm</name> &amp;= ~(<name>APR_USETID</name> | <name>APR_GSETID</name> | <name>APR_WSTICKY</name>)</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_make</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>apr_dir_make</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>APR_FILE_ATTR_HIDDEN</name></cpp:ifdef>
  <if>if <condition>(<expr><name>hidden</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>status</name> = <call><name>apr_file_attrs_set</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>,
                                  <argument><expr><name>APR_FILE_ATTR_HIDDEN</name></expr></argument>,
                                  <argument><expr><name>APR_FILE_ATTR_HIDDEN</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't hide directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name>sgid</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

      <comment type="block">/* Per our contract, don't do error-checking.  Some filesystems
       * don't support the sgid bit, and that's okay. */</comment>
      <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>APR_FINFO_PROT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>!<name>status</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_file_perms_set</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name><name>finfo</name>.<name>protection</name></name> | <name>APR_GSETID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_dir_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_fileperms_t</name></type> <name>perm</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>dir_make</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_dir_make_hidden</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_fileperms_t</name></type> <name>perm</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>dir_make</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_dir_make_sgid</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_fileperms_t</name></type> <name>perm</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>dir_make</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_dir_open</name><parameter_list>(<param><decl><type><name>apr_dir_t</name> **</type><name>new_dir</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname_apr</name></decl>;</decl_stmt>

  <comment type="block">/* APR doesn't like "" directories */</comment>
  <if>if <condition>(<expr><name><name>dirname</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
    <expr_stmt><expr><name>dirname</name> = "."</expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>dirname_apr</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_open</name><argument_list>(<argument><expr><name>new_dir</name></expr></argument>, <argument><expr><name>dirname_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't open directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_dir_remove_nonrecursive</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname_apr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>dirname_apr</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_remove</name><argument_list>(<argument><expr><name>dirname_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>WIN32_RETRY_LOOP</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>apr_dir_remove</name><argument_list>(<argument><expr><name>dirname_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't remove directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_dir_read</name><parameter_list>(<param><decl><type><name>apr_finfo_t</name> *</type><name>finfo</name></decl></param>,
                <param><decl><type><name>apr_int32_t</name></type> <name>wanted</name></decl></param>,
                <param><decl><type><name>apr_dir_t</name> *</type><name>thedir</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr><name>finfo</name></expr></argument>, <argument><expr><name>wanted</name></expr></argument>, <argument><expr><name>thedir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read directory"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>finfo</name>-&gt;<name>fname</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name><name>finfo</name>-&gt;<name>fname</name></name></expr></argument>, <argument><expr><name><name>finfo</name>-&gt;<name>fname</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name><name>finfo</name>-&gt;<name>name</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name><name>finfo</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>finfo</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_dir_walk</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname</name></decl></param>,
                <param><decl><type><name>apr_int32_t</name></type> <name>wanted</name></decl></param>,
                <param><decl><type><name>svn_io_walk_func_t</name></type> <name>walk_func</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>walk_baton</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>handle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname_apr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>wanted</name> |= <name>APR_FINFO_TYPE</name> | <name>APR_FINFO_NAME</name></expr>;</expr_stmt>

  <comment type="block">/* The documentation for apr_dir_read used to state that "." and ".."
     will be returned as the first two files, but it doesn't
     work that way in practice, in particular ext3 on Linux-2.6 doesn't
     follow the rules.  For details see
     http://subversion.tigris.org/servlets/ReadMsg?list=dev&amp;msgNo=56666

     If APR ever does implement "dot-first" then it would be possible to
     remove the svn_io_stat and walk_func calls and use the walk_func
     inside the loop.

     Note: apr_stat doesn't handle FINFO_NAME but svn_io_dir_walk is
     documented to provide it, so we have to do a bit extra. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>wanted</name> &amp; ~<name>APR_FINFO_NAME</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name><name>finfo</name>.<name>name</name></name></expr></argument>,
                                     <argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>finfo</name>.<name>valid</name></name> |= <name>APR_FINFO_NAME</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call>(*<name>walk_func</name>)<argument_list>(<argument><expr><name>walk_baton</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>dirname_apr</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_dir_open</name><argument_list>(<argument><expr>&amp;<name>handle</name></expr></argument>, <argument><expr><name>dirname_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't open directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* iteration subpool */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name_utf8</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>wanted</name></expr></argument>, <argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then>
      <else>else <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_wrap_apr</name>
            <argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read directory entry in '%s'"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></else></if>

      <if>if <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>finfo</name>.<name>name</name><index>[<expr>0</expr>]</index></name> == '.'
              &amp;&amp; (<name><name>finfo</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '\0'
                  || (<name><name>finfo</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '.' &amp;&amp; <name><name>finfo</name>.<name>name</name><index>[<expr>2</expr>]</index></name> == '\0'))</expr>)</condition><then>
            <comment type="block">/* skip "." and ".." */</comment>
            <continue>continue;</continue></then></if>

          <comment type="block">/* some other directory. recurse. it will be passed to the
             callback inside the recursion. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>name_utf8</name></expr></argument>, <argument><expr><name><name>finfo</name>.<name>name</name></name></expr></argument>,
                                           <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>name_utf8</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_walk</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>,
                                  <argument><expr><name>wanted</name></expr></argument>,
                                  <argument><expr><name>walk_func</name></expr></argument>,
                                  <argument><expr><name>walk_baton</name></expr></argument>,
                                  <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name> == <name>APR_REG</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* some other directory. pass it to the callback. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>name_utf8</name></expr></argument>, <argument><expr><name><name>finfo</name>.<name>name</name></name></expr></argument>,
                                           <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>name_utf8</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call>(*<name>walk_func</name>)<argument_list>(<argument><expr><name>walk_baton</name></expr></argument>,
                               <argument><expr><name>full_path</name></expr></argument>,
                               <argument><expr>&amp;<name>finfo</name></expr></argument>,
                               <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
      <comment type="block">/* else:
         some other type of file; skip it.
      */</comment>

    }</block></while>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_dir_close</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error closing directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/**
 * Determine if a directory is empty or not.
 * @param Return APR_SUCCESS if the dir is empty, else APR_ENOTEMPTY if not.
 * @param path The directory.
 * @param pool Used for temporary allocation.
 * @remark If path is not a directory, or some other error occurs,
 * then return the appropriate apr status code.
 *
 * (This function is written in APR style, in anticipation of
 * perhaps someday being moved to APR as 'apr_dir_is_empty'.)
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>dir_is_empty</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>dir_handle</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>retval</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* APR doesn't like "" directories */</comment>
  <if>if <condition>(<expr><name><name>dir</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
    <expr_stmt><expr><name>dir</name> = "."</expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_dir_open</name><argument_list>(<argument><expr>&amp;<name>dir_handle</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
    <return>return <expr><name>apr_err</name></expr>;</return></then></if>

  <for>for (<init><expr><name>apr_err</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>APR_FINFO_NAME</name></expr></argument>, <argument><expr><name>dir_handle</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>apr_err</name> == <name>APR_SUCCESS</name></expr>;</condition>
       <incr><expr><name>apr_err</name> = <call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>APR_FINFO_NAME</name></expr></argument>, <argument><expr><name>dir_handle</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <comment type="block">/* Ignore entries for this dir and its parent, robustly.
         (APR promises that they'll come first, so technically
         this guard could be moved outside the loop.  But Ryan Bloom
         says he doesn't believe it, and I believe him. */</comment>
      <if>if <condition>(<expr>! (<name><name>finfo</name>.<name>name</name><index>[<expr>0</expr>]</index></name> == '.'
             &amp;&amp; (<name><name>finfo</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '\0'
                 || (<name><name>finfo</name>.<name>name</name><index>[<expr>1</expr>]</index></name> == '.' &amp;&amp; <name><name>finfo</name>.<name>name</name><index>[<expr>2</expr>]</index></name> == '\0')))</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>retval</name> = <name>APR_ENOTEMPTY</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Make sure we broke out of the loop for the right reason. */</comment>
  <if>if <condition>(<expr><name>apr_err</name> &amp;&amp; ! <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>apr_err</name></expr>;</return></then></if>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_dir_close</name><argument_list>(<argument><expr><name>dir_handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
    <return>return <expr><name>apr_err</name></expr>;</return></then></if>

  <return>return <expr><name>retval</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_dir_empty</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>is_empty_p</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>dir_is_empty</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>status</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>is_empty_p</name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOTEMPTY</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr>*<name>is_empty_p</name> = <name>FALSE</name></expr>;</expr_stmt></then>
  <else>else
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't check directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Version/format files ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_io_write_version_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>int</name></type> <name>version</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>format_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format_contents</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%d\n"</expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* We only promise to handle non-negative integers. */</comment>
  <if>if <condition>(<expr><name>version</name> &lt; 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Version %d is not non-negative"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create a temporary file to write the data to */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>format_file</name></expr></argument>, <argument><expr>&amp;<name>path_tmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                   <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ...dump out our version number string... */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>format_file</name></expr></argument>, <argument><expr><name>format_contents</name></expr></argument>,
                                 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>format_contents</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ...and close the file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>format_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
  <comment type="block">/* make the destination writable, but only on Windows, because
     Windows does not let us replace read-only files. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_write</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 */</comment>

  <comment type="block">/* rename the temp file as the real destination */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>path_tmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* And finally remove the perms to make it read only */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_only</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_io_read_version_file</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>version</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>format_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* Read a chunk of data from PATH */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>format_file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_read</name><argument_list>(<argument><expr><name>format_file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close the file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>format_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there was no data in PATH, return an error. */</comment>
  <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_UNEXPECTED_EOF</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Reading '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check that the first line contains only digits. */</comment>
  <block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
      <block>{
        <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; (<name>c</name> == '\r' || <name>c</name> == '\n')</expr>)</condition><then>
          <break>break;</break></then></if>
        <if>if <condition>(<expr>! <call><name>apr_isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_BAD_VERSION_FILE_FORMAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"First line of '%s' contains non-digit"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      }</block></for>
  }</block>

  <comment type="block">/* Convert to integer. */</comment>
  <expr_stmt><expr>*<name>version</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* Do a byte-for-byte comparison of FILE1 and FILE2. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>contents_identical_p</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>identical_p</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file1</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file2</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_read1</name></decl>, <decl><type ref="prev"/><name>bytes_read2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf1</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf2</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file1_h</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file2_h</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file1_h</name></expr></argument>, <argument><expr><name>file1</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file2_h</name></expr></argument>, <argument><expr><name>file2</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>identical_p</name> = <name>TRUE</name></expr>;</expr_stmt>  <comment type="block">/* assume TRUE, until disproved below */</comment>
  <do>do
    <block>{
      <expr_stmt><expr><name>err1</name> = <call><name>svn_io_file_read_full</name><argument_list>(<argument><expr><name>file1_h</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>,
                                   <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>, <argument><expr>&amp;<name>bytes_read1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err1</name> &amp;&amp; !<call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err1</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>err1</name></expr>;</return></then></if>

      <expr_stmt><expr><name>err2</name> = <call><name>svn_io_file_read_full</name><argument_list>(<argument><expr><name>file2_h</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>,
                                   <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>, <argument><expr>&amp;<name>bytes_read2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err2</name> &amp;&amp; !<call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err2</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>err2</name></expr>;</return>
        }</block></then></if>

      <if>if <condition>(<expr>(<name>bytes_read1</name> != <name>bytes_read2</name>)
          || (<call><name>memcmp</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>bytes_read1</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>identical_p</name> = <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
    }</block> while <condition>(<expr>! <name>err1</name> &amp;&amp; ! <name>err2</name></expr>)</condition>;</do>

  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file1_h</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file2_h</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_io_files_contents_same_p</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>same</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file1</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file2</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>q</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_filesizes_different_p</name><argument_list>(<argument><expr>&amp;<name>q</name></expr></argument>, <argument><expr><name>file1</name></expr></argument>, <argument><expr><name>file2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>q</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>same</name> = 0</expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>contents_identical_p</name><argument_list>(<argument><expr>&amp;<name>q</name></expr></argument>, <argument><expr><name>file1</name></expr></argument>, <argument><expr><name>file2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>q</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>same</name> = 1</expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>same</name> = 0</expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
