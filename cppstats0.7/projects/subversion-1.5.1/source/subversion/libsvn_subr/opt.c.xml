<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/opt.c"><comment type="block">/*
 * opt.c :  option and argument parsing for Subversion command lines
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_info.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_cmdline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/*** Code. ***/</comment>

<function><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type>
<name>svn_opt_get_canonical_subcommand2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>table</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd_name</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>cmd_name</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <while>while <condition>(<expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
      <return>return <expr><name>table</name> + <name>i</name></expr>;</return></then></if>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr>(<name>j</name> &lt; <name>SVN_OPT_MAX_ALIASES</name>) &amp;&amp; <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>aliases</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>aliases</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><name>table</name> + <name>i</name></expr>;</return></then></if></for>

    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
  }</block></while>

  <comment type="block">/* If we get here, there was no matching subcommand name or alias. */</comment>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type>
<name>svn_opt_get_canonical_subcommand</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>table</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd_name</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>cmd_name</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <while>while <condition>(<expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
      <return>return <expr><name>table</name> + <name>i</name></expr>;</return></then></if>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr>(<name>j</name> &lt; <name>SVN_OPT_MAX_ALIASES</name>) &amp;&amp; <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>aliases</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>aliases</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><name>table</name> + <name>i</name></expr>;</return></then></if></for>

    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
  }</block></while>

  <comment type="block">/* If we get here, there was no matching subcommand name or alias. */</comment>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type>
<name>svn_opt_get_option_from_code2</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>option_table</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>command</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>option_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>optch</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <if>if <condition>(<expr><name><name>option_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>optch</name> == <name>code</name></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>command</name></expr>)</condition><then>
          <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr>((<name>j</name> &lt; <name>SVN_OPT_MAX_OPTIONS</name>) &amp;&amp;
                       <name><name>command</name>-&gt;<name>desc_overrides</name><index>[<expr><name>j</name></expr>]</index></name>.<name>optch</name>)</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
            <if>if <condition>(<expr><name><name>command</name>-&gt;<name>desc_overrides</name><index>[<expr><name>j</name></expr>]</index></name>.<name>optch</name> == <name>code</name></expr>)</condition><then>
              <block>{
                <decl_stmt><decl><type><name>apr_getopt_option_t</name> *</type><name>tmpopt</name> <init>=
                    <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>tmpopt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr>*<name>tmpopt</name> = <name><name>option_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tmpopt</name>-&gt;<name>description</name></name> = <name><name>command</name>-&gt;<name>desc_overrides</name><index>[<expr><name>j</name></expr>]</index></name>.<name>desc</name></expr>;</expr_stmt>
                <return>return <expr><name>tmpopt</name></expr>;</return>
              }</block></then></if></for></then></if>
        <return>return <expr>&amp;(<name><name>option_table</name><index>[<expr><name>i</name></expr>]</index></name>)</expr>;</return>
      }</block></then></if></for>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type>
<name>svn_opt_get_option_from_code</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>option_table</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>option_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>optch</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <if>if <condition>(<expr><name><name>option_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>optch</name> == <name>code</name></expr>)</condition><then>
      <return>return <expr>&amp;(<name><name>option_table</name><index>[<expr><name>i</name></expr>]</index></name>)</expr>;</return></then></if></for>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_opt_subcommand_takes_option3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>command</name></decl></param>,
                                 <param><decl><type><name>int</name></type> <name>option_code</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>int</name> *</type><name>global_options</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_OPT_MAX_OPTIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <if>if <condition>(<expr><name><name>command</name>-&gt;<name>valid_options</name><index>[<expr><name>i</name></expr>]</index></name> == <name>option_code</name></expr>)</condition><then>
      <return>return <expr><name>TRUE</name></expr>;</return></then></if></for>

  <if>if <condition>(<expr><name>global_options</name></expr>)</condition><then>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>global_options</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <if>if <condition>(<expr><name><name>global_options</name><index>[<expr><name>i</name></expr>]</index></name> == <name>option_code</name></expr>)</condition><then>
        <return>return <expr><name>TRUE</name></expr>;</return></then></if></for></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<function><type><name>svn_boolean_t</name></type>
<name>svn_opt_subcommand_takes_option2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>command</name></decl></param>,
                                 <param><decl><type><name>int</name></type> <name>option_code</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_opt_subcommand_takes_option3</name><argument_list>(<argument><expr><name>command</name></expr></argument>,
                                          <argument><expr><name>option_code</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_opt_subcommand_takes_option</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>command</name></decl></param>,
                                <param><decl><type><name>int</name></type> <name>option_code</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_OPT_MAX_OPTIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <if>if <condition>(<expr><name><name>command</name>-&gt;<name>valid_options</name><index>[<expr><name>i</name></expr>]</index></name> == <name>option_code</name></expr>)</condition><then>
      <return>return <expr><name>TRUE</name></expr>;</return></then></if></for>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<comment type="block">/* Print the canonical command name for CMD, and all its aliases, to
   STREAM.  If HELP is set, print CMD's help string too, in which case
   obtain option usage from OPTIONS_TABLE. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>print_command_info2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>cmd</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>options_table</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>int</name> *</type><name>global_options</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>help</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                    <param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>first_time</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Print the canonical command name. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Print the list of aliases. */</comment>
  <expr_stmt><expr><name>first_time</name> = <name>TRUE</name></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_OPT_MAX_ALIASES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>aliases</name><index>[<expr><name>i</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <if>if <condition>(<expr><name>first_time</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>" ("</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>first_time</name> = <name>FALSE</name></expr>;</expr_stmt>
      }</block></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>", "</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>aliases</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <if>if <condition>(<expr>! <name>first_time</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>")"</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>help</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>option</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>have_options</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>": %s"</expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>help</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Loop over all valid option codes attached to the subcommand */</comment>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_OPT_MAX_OPTIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>valid_options</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name>have_options</name> == <name>FALSE</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr>"\nValid options:\n"</expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name>have_options</name> = <name>TRUE</name></expr>;</expr_stmt>
                }</block></then></if>

              <comment type="block">/* convert each option code into an option */</comment>
              <expr_stmt><expr><name>option</name> =
                <call><name>svn_opt_get_option_from_code2</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>valid_options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                              <argument><expr><name>options_table</name></expr></argument>,
                                              <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* print the option's docstring */</comment>
              <if>if <condition>(<expr><name>option</name> &amp;&amp; <name><name>option</name>-&gt;<name>description</name></name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>optstr</name></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>svn_opt_format_option</name><argument_list>(<argument><expr>&amp;<name>optstr</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"  %s\n"</expr></argument>,
                                              <argument><expr><name>optstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></for>
      <comment type="block">/* And global options too */</comment>
      <if>if <condition>(<expr><name>global_options</name> &amp;&amp; *<name>global_options</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr>"\nGlobal options:\n"</expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>have_options</name> = <name>TRUE</name></expr>;</expr_stmt>

          <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>global_options</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
              
              <comment type="block">/* convert each option code into an option */</comment>
              <expr_stmt><expr><name>option</name> =
                <call><name>svn_opt_get_option_from_code2</name><argument_list>(<argument><expr><name><name>global_options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                              <argument><expr><name>options_table</name></expr></argument>,
                                              <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              
              <comment type="block">/* print the option's docstring */</comment>
              <if>if <condition>(<expr><name>option</name> &amp;&amp; <name><name>option</name>-&gt;<name>description</name></name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>optstr</name></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>svn_opt_format_option</name><argument_list>(<argument><expr>&amp;<name>optstr</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"  %s\n"</expr></argument>,
                                              <argument><expr><name>optstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
          
      <if>if <condition>(<expr><name>have_options</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Same as print_command_info2(), but with deprecated struct revision. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>print_command_info</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>cmd</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>options_table</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>help</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                   <param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>first_time</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Print the canonical command name. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Print the list of aliases. */</comment>
  <expr_stmt><expr><name>first_time</name> = <name>TRUE</name></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_OPT_MAX_ALIASES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>aliases</name><index>[<expr><name>i</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <if>if <condition>(<expr><name>first_time</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>" ("</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>first_time</name> = <name>FALSE</name></expr>;</expr_stmt>
      }</block></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>", "</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>aliases</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <if>if <condition>(<expr>! <name>first_time</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>")"</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>help</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>option</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>have_options</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>": %s"</expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>help</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Loop over all valid option codes attached to the subcommand */</comment>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_OPT_MAX_OPTIONS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>valid_options</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name>have_options</name> == <name>FALSE</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr>"\nValid options:\n"</expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name>have_options</name> = <name>TRUE</name></expr>;</expr_stmt>
                }</block></then></if>

              <comment type="block">/* convert each option code into an option */</comment>
              <expr_stmt><expr><name>option</name> =
                <call><name>svn_opt_get_option_from_code</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>valid_options</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                             <argument><expr><name>options_table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* print the option's docstring */</comment>
              <if>if <condition>(<expr><name>option</name> &amp;&amp; <name><name>option</name>-&gt;<name>description</name></name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>optstr</name></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>svn_opt_format_option</name><argument_list>(<argument><expr>&amp;<name>optstr</name></expr></argument>, <argument><expr><name>option</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"  %s\n"</expr></argument>,
                                              <argument><expr><name>optstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></for>

      <if>if <condition>(<expr><name>have_options</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name>svn_opt_print_generic_help2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>cmd_table</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>opt_table</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>footer</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>header</name></expr>)</condition><then>
    <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
      <goto>goto <name>print_error</name>;</goto></then></if></then></if>

  <while>while <condition>(<expr><name><name>cmd_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"   "</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)
          || (<name>err</name> = <call><name>print_command_info2</name><argument_list>(<argument><expr><name>cmd_table</name> + <name>i</name></expr></argument>, <argument><expr><name>opt_table</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call>)
          || (<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <goto>goto <name>print_error</name>;</goto></then></if>
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></while>

  <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <goto>goto <name>print_error</name>;</goto></then></if>

  <if>if <condition>(<expr><name>footer</name></expr>)</condition><then>
    <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><name>footer</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
      <goto>goto <name>print_error</name>;</goto></then></if></then></if>

  <return>return;</return>

 <label><name>print_error</name>:</label>
  <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_opt_print_generic_help</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>cmd_table</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>opt_table</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>footer</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>header</name></expr>)</condition><then>
    <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
      <goto>goto <name>print_error</name>;</goto></then></if></then></if>

  <while>while <condition>(<expr><name><name>cmd_table</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"   "</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)
          || (<name>err</name> = <call><name>print_command_info</name><argument_list>(<argument><expr><name>cmd_table</name> + <name>i</name></expr></argument>, <argument><expr><name>opt_table</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call>)
          || (<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <goto>goto <name>print_error</name>;</goto></then></if>
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></while>

  <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <goto>goto <name>print_error</name>;</goto></then></if>

  <if>if <condition>(<expr><name>footer</name></expr>)</condition><then>
    <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><name>footer</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
      <goto>goto <name>print_error</name>;</goto></then></if></then></if>

  <return>return;</return>

 <label><name>print_error</name>:</label>
  <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_opt_format_option</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>string</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>opt</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>doc</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>opts</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>opt</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>string</name> = "?"</expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>

  <comment type="block">/* We have a valid option which may or may not have a "short
     name" (a single-character alias for the long option). */</comment>
  <if>if <condition>(<expr><name><name>opt</name>-&gt;<name>optch</name></name> &lt;= 255</expr>)</condition><then>
    <expr_stmt><expr><name>opts</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"-%c [--%s]"</expr></argument>, <argument><expr><name><name>opt</name>-&gt;<name>optch</name></name></expr></argument>, <argument><expr><name><name>opt</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>opts</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"--%s"</expr></argument>, <argument><expr><name><name>opt</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name><name>opt</name>-&gt;<name>has_arg</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>opts</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>" ARG"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>doc</name></expr>)</condition><then>
    <expr_stmt><expr><name>opts</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%-24s : %s"</expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name><name>opt</name>-&gt;<name>description</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr>*<name>string</name> = <name>opts</name></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_opt_subcommand_help3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>subcommand</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>table</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>options_table</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>int</name> *</type><name>global_options</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>cmd</name> <init>=
    <expr><call><name>svn_opt_get_canonical_subcommand2</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>subcommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>cmd</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>print_command_info2</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>, <argument><expr><name>global_options</name></expr></argument>,
                              <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>err</name> = <call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"\"%s\": unknown command.\n\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subcommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>svn_opt_subcommand_help2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>subcommand</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>table</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>options_table</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>svn_opt_subcommand_help3</name><argument_list>(<argument><expr><name>subcommand</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_opt_subcommand_help</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>subcommand</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>table</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>options_table</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>cmd</name> <init>=
    <expr><call><name>svn_opt_get_canonical_subcommand</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>subcommand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>cmd</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>print_command_info</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>err</name> = <call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"\"%s\": unknown command.\n\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subcommand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Parsing revision and date options. ***/</comment>

<escape char="0xc"/>
<comment type="block">/** Parsing "X:Y"-style arguments. **/</comment>

<comment type="block">/* If WORD matches one of the special revision descriptors,
 * case-insensitively, set *REVISION accordingly:
 *
 *   - For "head", set REVISION-&gt;kind to svn_opt_revision_head.
 *
 *   - For "prev", set REVISION-&gt;kind to svn_opt_revision_previous.
 *
 *   - For "base", set REVISION-&gt;kind to svn_opt_revision_base.
 *
 *   - For "committed", set REVISION-&gt;kind to svn_opt_revision_committed.
 *
 * If match, return 0, else return -1 and don't touch REVISION.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>revision_from_word</name><parameter_list>(<param><decl><type><name>svn_opt_revision_t</name> *</type><name>revision</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>word</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr>"head"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>revision</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_head</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr>"prev"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>revision</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_previous</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr>"base"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>revision</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_base</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr>"committed"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>revision</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_committed</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <return>return <expr>-1</expr>;</return></else></if></else></if></else></if></else></if>

  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Parse one revision specification.  Return pointer to character
   after revision, or NULL if the revision is invalid.  Modifies
   str, so make sure to pass a copy of anything precious.  Uses
   POOL for temporary allocation. */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>parse_one_rev</name><parameter_list>(<param><decl><type><name>svn_opt_revision_t</name> *</type><name>revision</name></decl></param>, <param><decl><type><name>char</name> *</type><name>str</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>, <decl><type ref="prev"/><name>save</name></decl>;</decl_stmt>

  <comment type="block">/* Allow any number of 'r's to prefix a revision number, because
     that way if a script pastes svn output into another svn command
     (like "svn log -r${REV_COPIED_FROM_OUTPUT}"), it'll Just Work,
     even when compounded.

     As it happens, none of our special revision words begins with
     "r".  If any ever do, then this code will have to get smarter.

     Incidentally, this allows "r{DATE}".  We could avoid that with
     some trivial code rearrangement, but it's not clear what would
     be gained by doing so. */</comment>
  <while>while <condition>(<expr>*<name>str</name> == 'r'</expr>)</condition>
    <expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>

  <if>if <condition>(<expr>*<name>str</name> == '{'</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>matched</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_time_t</name></type> <name>tm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

      <comment type="block">/* Brackets denote a date. */</comment>
      <expr_stmt><expr><name>str</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>end</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>'}'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>end</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
      <expr_stmt><expr>*<name>end</name> = '\0'</expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_parse_date</name><argument_list>(<argument><expr>&amp;<name>matched</name></expr></argument>, <argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr>!<name>matched</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
      <expr_stmt><expr><name><name>revision</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_date</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>revision</name>-&gt;<name>value</name>.<name>date</name></name> = <name>tm</name></expr>;</expr_stmt>
      <return>return <expr><name>end</name> + 1</expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* It's a number. */</comment>
      <expr_stmt><expr><name>end</name> = <name>str</name> + 1</expr>;</expr_stmt>
      <while>while <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr><name>end</name>++</expr>;</expr_stmt></while>
      <expr_stmt><expr><name>save</name> = *<name>end</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>end</name> = '\0'</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>revision</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>revision</name>-&gt;<name>value</name>.<name>number</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>end</name> = <name>save</name></expr>;</expr_stmt>
      <return>return <expr><name>end</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>apr_isalpha</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>end</name> = <name>str</name> + 1</expr>;</expr_stmt>
      <while>while <condition>(<expr><call><name>apr_isalpha</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr><name>end</name>++</expr>;</expr_stmt></while>
      <expr_stmt><expr><name>save</name> = *<name>end</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>end</name> = '\0'</expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>revision_from_word</name><argument_list>(<argument><expr><name>revision</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
      <expr_stmt><expr>*<name>end</name> = <name>save</name></expr>;</expr_stmt>
      <return>return <expr><name>end</name></expr>;</return>
    }</block></then>
  <else>else
    <return>return <expr><name>NULL</name></expr>;</return></else></if></else></if></else></if>
}</block></function>


<function><type><name>int</name></type>
<name>svn_opt_parse_revision</name><parameter_list>(<param><decl><type><name>svn_opt_revision_t</name> *</type><name>start_revision</name></decl></param>,
                       <param><decl><type><name>svn_opt_revision_t</name> *</type><name>end_revision</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>left_rev</name></decl>, *<decl><type ref="prev"/><name>right_rev</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>

  <comment type="block">/* Operate on a copy of the argument. */</comment>
  <expr_stmt><expr><name>left_rev</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>right_rev</name> = <call><name>parse_one_rev</name><argument_list>(<argument><expr><name>start_revision</name></expr></argument>, <argument><expr><name>left_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>right_rev</name> &amp;&amp; *<name>right_rev</name> == ':'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>right_rev</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>end</name> = <call><name>parse_one_rev</name><argument_list>(<argument><expr><name>end_revision</name></expr></argument>, <argument><expr><name>right_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>end</name> || *<name>end</name> != '\0'</expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr>!<name>right_rev</name> || *<name>right_rev</name> != '\0'</expr>)</condition><then>
    <return>return <expr>-1</expr>;</return></then></if></else></if>

  <return>return <expr>0</expr>;</return>
}</block></function>


<function><type><name>int</name></type>
<name>svn_opt_parse_revision_to_range</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>opt_ranges</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_opt_revision_range_t</name> *</type><name>range</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>svn_opt_parse_revision</name><argument_list>(<argument><expr>&amp;(<name><name>range</name>-&gt;<name>start</name></name>)</expr></argument>, <argument><expr>&amp;(<name><name>range</name>-&gt;<name>end</name></name>)</expr></argument>,
                             <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
    <return>return <expr>-1</expr>;</return></then></if>

  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>opt_ranges</name></expr></argument>, <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_resolve_revisions</name><parameter_list>(<param><decl><type><name>svn_opt_revision_t</name> *</type><name>peg_rev</name></decl></param>,
                          <param><decl><type><name>svn_opt_revision_t</name> *</type><name>op_rev</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>is_url</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>notice_local_mods</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>peg_rev</name>-&gt;<name>kind</name></name> == <name>svn_opt_revision_unspecified</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>is_url</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>peg_rev</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_head</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr><name>notice_local_mods</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>peg_rev</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_working</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>peg_rev</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_base</name></expr>;</expr_stmt></else></if>
        }</block></else></if>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>op_rev</name>-&gt;<name>kind</name></name> == <name>svn_opt_revision_unspecified</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>op_rev</name> = *<name>peg_rev</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** Parsing arguments. ***/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ARRAY_SIZE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>


<comment type="block">/* Copy STR into POOL and push the copy onto ARRAY. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>array_push_str</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>array</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* ### Not sure if this function is still necessary.  It used to
     convert str to svn_stringbuf_t * and push it, but now it just
     dups str in pool and pushes the copy.  So its only effect is
     transfer str's lifetime to pool.  Is that something callers are
     depending on? */</comment>

  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_opt_push_implicit_dot_target</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>targets</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>targets</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>array_push_str</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> <comment type="block">/* Ha! "", not ".", is the canonical */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>targets</name>-&gt;<name>nelts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_parse_num_args</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>args_p</name></decl></param>,
                       <param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
                       <param><decl><type><name>int</name></type> <name>num_args</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>args</name>
    <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>DEFAULT_ARRAY_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* loop for num_args and add each arg to the args array */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_args</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &gt;= <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_INSUFFICIENT_ARGS</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
      <expr_stmt><expr><call><name>array_push_str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr>*<name>args_p</name> = <name>args</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_parse_all_args</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>args_p</name></decl></param>,
                       <param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>args</name>
    <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>DEFAULT_ARRAY_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &gt; <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <while>while <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &lt; <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>array_push_str</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <expr_stmt><expr>*<name>args_p</name> = <name>args</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_parse_path</name><parameter_list>(<param><decl><type><name>svn_opt_revision_t</name> *</type><name>rev</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>truepath</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param> <comment type="block">/* UTF-8! */</comment>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* scanning from right to left, just to be friendly to any
     screwed-up filenames that might *actually* contain @-signs.  :-) */</comment>
  <for>for (<init><expr><name>i</name> = (<call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> - 1)</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
    <block>{
      <comment type="block">/* If we hit a path separator, stop looking. */</comment>
      <comment type="block">/* This is OK only because our revision specifiers can't contain '/'. */</comment>
      <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
        <break>break;</break></then></if>

      <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '@'</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>start_revision</name></decl>, <decl><type ref="prev"/><name>end_revision</name></decl>;</decl_stmt>

          <expr_stmt><expr><name><name>end_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name> + 1</expr>]</index></name> == '\0'</expr>)</condition><then>  <comment type="block">/* looking at empty peg revision */</comment>
            <block>{
              <expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
              <expr_stmt><expr><name><name>start_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
            }</block></then>
          <else>else  <comment type="block">/* looking at non-empty peg revision */</comment>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_str</name> <init>= <expr><name>path</name> + <name>i</name> + 1</expr></init></decl>;</decl_stmt>

              <comment type="block">/* URLs get treated differently from wc paths. */</comment>
              <if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <comment type="block">/* URLs are URI-encoded, so we look for dates with
                     URI-encoded delimeters.  */</comment>
                  <decl_stmt><decl><type><name>int</name></type> <name>rev_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>rev_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <if>if <condition>(<expr><name>rev_len</name> &gt; 6
                      &amp;&amp; <name><name>rev_str</name><index>[<expr>0</expr>]</index></name> == '%'
                      &amp;&amp; <name><name>rev_str</name><index>[<expr>1</expr>]</index></name> == '7'
                      &amp;&amp; (<name><name>rev_str</name><index>[<expr>2</expr>]</index></name> == 'B'
                          || <name><name>rev_str</name><index>[<expr>2</expr>]</index></name> == 'b')
                      &amp;&amp; <name><name>rev_str</name><index>[<expr><name>rev_len</name>-3</expr>]</index></name> == '%'
                      &amp;&amp; <name><name>rev_str</name><index>[<expr><name>rev_len</name>-2</expr>]</index></name> == '7'
                      &amp;&amp; (<name><name>rev_str</name><index>[<expr><name>rev_len</name>-1</expr>]</index></name> == 'D'
                          || <name><name>rev_str</name><index>[<expr><name>rev_len</name>-1</expr>]</index></name> == 'd')</expr>)</condition><then>
                    <block>{
                      <expr_stmt><expr><name>rev_str</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>rev_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
              <expr_stmt><expr><name>ret</name> = <call><name>svn_opt_parse_revision</name><argument_list>(<argument><expr>&amp;<name>start_revision</name></expr></argument>,
                                           <argument><expr>&amp;<name>end_revision</name></expr></argument>,
                                           <argument><expr><name>rev_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

          <if>if <condition>(<expr><name>ret</name> || <name><name>end_revision</name>.<name>kind</name></name> != <name>svn_opt_revision_unspecified</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Syntax error parsing revision '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>path</name> + <name>i</name> + 1</expr></argument>)</argument_list></call></expr>;</return></then></if>

          <expr_stmt><expr>*<name>truepath</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rev</name>-&gt;<name>kind</name></name> = <name><name>start_revision</name>.<name>kind</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rev</name>-&gt;<name>value</name></name> = <name><name>start_revision</name>.<name>value</name></name></expr>;</expr_stmt>

          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Didn't find an @-sign. */</comment>
  <expr_stmt><expr>*<name>truepath</name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rev</name>-&gt;<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_args_to_target_array2</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>targets_p</name></decl></param>,
                              <param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
                              <param><decl><type><name>apr_array_header_t</name> *</type><name>known_targets</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_opt_args_to_target_array3</name><argument_list>(<argument><expr><name>targets_p</name></expr></argument>, <argument><expr><name>os</name></expr></argument>, 
                                                   <argument><expr><name>known_targets</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_RESERVED_FILENAME_SPECIFIED</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_args_to_target_array3</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>targets_p</name></decl></param>,
                              <param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
                              <param><decl><type><name>apr_array_header_t</name> *</type><name>known_targets</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>input_targets</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>DEFAULT_ARRAY_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>output_targets</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>DEFAULT_ARRAY_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Step 1:  create a master array of targets that are in UTF-8
     encoding, and come from concatenating the targets left by apr_getopt,
     plus any extra targets (e.g., from the --targets switch.) */</comment>

  <for>for (<init>;</init> <condition><expr><name><name>os</name>-&gt;<name>ind</name></name> &lt; <name><name>os</name>-&gt;<name>argc</name></name></expr>;</condition> <incr><expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr></incr>)
    <block>{
      <comment type="block">/* The apr_getopt targets are still in native encoding. */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>raw_target</name> <init>= <expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name>
              <argument_list>(<argument><expr>(const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>input_targets</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>raw_target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <if>if <condition>(<expr><name>known_targets</name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>known_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <comment type="block">/* The --targets array have already been converted to UTF-8,
             because we needed to split up the list with svn_cstring_split. */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>utf8_target</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>known_targets</name></expr></argument>,
                                                  <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>input_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>utf8_target</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Step 2:  process each target.  */</comment>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>input_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>utf8_target</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>input_targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>peg_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* pointer to the peg revision, if any */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>;</decl_stmt>      <comment type="block">/* after all processing is finished */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

      <comment type="block">/* Remove a peg revision, if any, in the target so that it can
         be properly canonicalized, otherwise the canonicalization
         does not treat a ".@BASE" as a "." with a BASE peg revision,
         and it is not canonicalized to "@BASE".  If any peg revision
         exists, it is appended to the final canonicalized path or
         URL.  Do not use svn_opt_parse_path() because the resulting
         peg revision is a structure that would have to be converted
         back into a string.  Converting from a string date to the
         apr_time_t field in the svn_opt_revision_value_t and back to
         a string would not necessarily preserve the exact bytes of
         the input date, so its easier just to keep it in string
         form. */</comment>
      <for>for (<init><expr><name>j</name> = (<call><name>strlen</name><argument_list>(<argument><expr><name>utf8_target</name></expr></argument>)</argument_list></call> - 1)</expr>;</init> <condition><expr><name>j</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>j</name></expr></incr>)
        <block>{
          <comment type="block">/* If we hit a path separator, stop looking.  This is OK
              only because our revision specifiers can't contain
              '/'. */</comment>
          <if>if <condition>(<expr><name><name>utf8_target</name><index>[<expr><name>j</name></expr>]</index></name> == '/'</expr>)</condition><then>
            <break>break;</break></then></if>
          <if>if <condition>(<expr><name><name>utf8_target</name><index>[<expr><name>j</name></expr>]</index></name> == '@'</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>peg_start</name> = <name>utf8_target</name> + <name>j</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
        }</block></for>
      <if>if <condition>(<expr><name>peg_start</name></expr>)</condition><then>
        <expr_stmt><expr><name>utf8_target</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                     <argument><expr><name>utf8_target</name></expr></argument>,
                                     <argument><expr><name>peg_start</name> - <name>utf8_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* URLs and wc-paths get treated differently. */</comment>
      <if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>utf8_target</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* No need to canonicalize a URL's case or path separators. */</comment>

          <comment type="block">/* Convert to URI. */</comment>
          <expr_stmt><expr><name>target</name> = <call><name>svn_path_uri_from_iri</name><argument_list>(<argument><expr><name>utf8_target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* Auto-escape some ASCII characters. */</comment>
          <expr_stmt><expr><name>target</name> = <call><name>svn_path_uri_autoescape</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* The above doesn't guarantee a valid URI. */</comment>
          <if>if <condition>(<expr>! <call><name>svn_path_is_uri_safe</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"URL '%s' is not properly URI-encoded"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>utf8_target</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* Verify that no backpaths are present in the URL. */</comment>
          <if>if <condition>(<expr><call><name>svn_path_is_backpath_present</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"URL '%s' contains a '..' element"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>utf8_target</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* strip any trailing '/' */</comment>
          <expr_stmt><expr><name>target</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else  <comment type="block">/* not a url, so treat as a path */</comment>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>apr_target</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>char</name> *</type><name>truenamed_target</name></decl>;</decl_stmt> <comment type="block">/* APR-encoded */</comment>
          <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

          <comment type="block">/* canonicalize case, and change all separators to '/'. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>apr_target</name></expr></argument>, <argument><expr><name>utf8_target</name></expr></argument>,
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>apr_err</name> = <call><name>apr_filepath_merge</name><argument_list>(<argument><expr>&amp;<name>truenamed_target</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>apr_target</name></expr></argument>,
                                       <argument><expr><name>APR_FILEPATH_TRUENAME</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr>!<name>apr_err</name></expr>)</condition><then>
            <comment type="block">/* We have a canonicalized APR-encoded target now. */</comment>
            <expr_stmt><expr><name>apr_target</name> = <name>truenamed_target</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <comment type="block">/* It's okay for the file to not exist, that just means we
               have to accept the case given to the client. We'll use
               the original APR-encoded target. */</comment>
            <empty_stmt>;</empty_stmt></then>
          <else>else
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error resolving case of '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>utf8_target</name></expr></argument>,
                                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>

          <comment type="block">/* convert back to UTF-8. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>target</name></expr></argument>, <argument><expr><name>apr_target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>target</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If the target has the same name as a Subversion
             working copy administrative dir, skip it. */</comment>
          <expr_stmt><expr><name>base_name</name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* FIXME:
             The canonical list of administrative directory names is
             maintained in libsvn_wc/adm_files.c:svn_wc_set_adm_dir().
             That list can't be used here, because that use would
             create a circular dependency between libsvn_wc and
             libsvn_subr.  Make sure changes to the lists are always
             synchronized! */</comment>
          <if>if <condition>(<expr>0 == <call><name>strcmp</name><argument_list>(<argument><expr><name>base_name</name></expr></argument>, <argument><expr>".svn"</expr></argument>)</argument_list></call>
              || 0 == <call><name>strcmp</name><argument_list>(<argument><expr><name>base_name</name></expr></argument>, <argument><expr>"_svn"</expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>err</name> = <call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_RESERVED_FILENAME_SPECIFIED</name></expr></argument>,
                                      <argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' ends in a reserved name"</expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then></if>
        }</block></else></if>

      <comment type="block">/* Append the peg revision back to the canonicalized target if
         there was a peg revision. */</comment>
      <if>if <condition>(<expr><name>peg_start</name></expr>)</condition><then>
        <expr_stmt><expr><name>target</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>peg_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>output_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>target</name></expr>;</expr_stmt>
    }</block></for>


  <comment type="block">/* kff todo: need to remove redundancies from targets before
     passing it to the cmd_func. */</comment>

  <expr_stmt><expr>*<name>targets_p</name> = <name>output_targets</name></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_args_to_target_array</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>targets_p</name></decl></param>,
                             <param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
                             <param><decl><type><name>apr_array_header_t</name> *</type><name>known_targets</name></decl></param>,
                             <param><decl><type><name>svn_opt_revision_t</name> *</type><name>start_revision</name></decl></param>,
                             <param><decl><type><name>svn_opt_revision_t</name> *</type><name>end_revision</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>extract_revisions</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>output_targets</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_args_to_target_array2</name><argument_list>(<argument><expr>&amp;<name>output_targets</name></expr></argument>, <argument><expr><name>os</name></expr></argument>,
                                        <argument><expr><name>known_targets</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>extract_revisions</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>temprev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>output_targets</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>path</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>output_targets</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_parse_path</name><argument_list>(<argument><expr>&amp;<name>temprev</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>temprev</name>.<name>kind</name></name> != <name>svn_opt_revision_unspecified</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>output_targets</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>path</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>start_revision</name>-&gt;<name>kind</name></name> = <name><name>temprev</name>.<name>kind</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>start_revision</name>-&gt;<name>value</name></name> = <name><name>temprev</name>.<name>value</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
      <if>if <condition>(<expr><name><name>output_targets</name>-&gt;<name>nelts</name></name> &gt; 1</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>path</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>output_targets</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_parse_path</name><argument_list>(<argument><expr>&amp;<name>temprev</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>temprev</name>.<name>kind</name></name> != <name>svn_opt_revision_unspecified</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>output_targets</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>path</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>end_revision</name>-&gt;<name>kind</name></name> = <name><name>temprev</name>.<name>kind</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>end_revision</name>-&gt;<name>value</name></name> = <name><name>temprev</name>.<name>value</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr>*<name>targets_p</name> = <name>output_targets</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print version info for PGM_NAME.  If QUIET is  true, print in
 * brief.  Else if QUIET is not true, print the version more
 * verbosely, and if FOOTER is non-null, print it following the
 * version information.
 *
 * Use POOL for temporary allocations.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>print_version_info</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pgm_name</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>footer</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>quiet</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>quiet</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>SVN_VER_NUMBER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"%s, version %s\n"
                                     "   compiled %s, %s\n\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgm_name</name></expr></argument>,
                             <argument><expr><name>SVN_VERSION</name></expr></argument>, <argument><expr><name>__DATE__</name></expr></argument>, <argument><expr><name>__TIME__</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Copyright (C) 2000-2008 CollabNet.\n"
                              "Subversion is open source software, see"
                              " http://subversion.tigris.org/\n"
                              "This product includes software developed by "
                              "CollabNet (http://www.Collab.Net/).\n\n"</expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>footer</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>footer</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_print_help3</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pgm_name</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>print_version</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>quiet</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version_footer</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>cmd_table</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>option_table</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>int</name> *</type><name>global_options</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>footer</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>targets</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>os</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_parse_all_args</name><argument_list>(<argument><expr>&amp;<name>targets</name></expr></argument>, <argument><expr><name>os</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>os</name> &amp;&amp; <name><name>targets</name>-&gt;<name>nelts</name></name></expr>)</condition><then>  <comment type="block">/* help on subcommand(s) requested */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <expr_stmt><expr><call><name>svn_opt_subcommand_help3</name><argument_list>(<argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>cmd_table</name></expr></argument>, <argument><expr><name>option_table</name></expr></argument>,
                                 <argument><expr><name>global_options</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for></then>
  <else>else <if>if <condition>(<expr><name>print_version</name></expr>)</condition><then>   <comment type="block">/* just --version */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_version_info</name><argument_list>(<argument><expr><name>pgm_name</name></expr></argument>, <argument><expr><name>version_footer</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>os</name> &amp;&amp; !<name><name>targets</name>-&gt;<name>nelts</name></name></expr>)</condition><then>            <comment type="block">/* `-h', `--help', or `help' */</comment>
    <expr_stmt><expr><call><name>svn_opt_print_generic_help2</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
                                <argument><expr><name>cmd_table</name></expr></argument>,
                                <argument><expr><name>option_table</name></expr></argument>,
                                <argument><expr><name>footer</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else                                       <comment type="block">/* unknown option or cmd */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Type '%s help' for usage.\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgm_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_print_help2</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pgm_name</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>print_version</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>quiet</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version_footer</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>cmd_table</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>option_table</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>footer</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_opt_print_help3</name><argument_list>(<argument><expr><name>os</name></expr></argument>,
                             <argument><expr><name>pgm_name</name></expr></argument>,
                             <argument><expr><name>print_version</name></expr></argument>,
                             <argument><expr><name>quiet</name></expr></argument>,
                             <argument><expr><name>version_footer</name></expr></argument>,
                             <argument><expr><name>header</name></expr></argument>,
                             <argument><expr><name>cmd_table</name></expr></argument>,
                             <argument><expr><name>option_table</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>footer</name></expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_opt_print_help</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pgm_name</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>print_version</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>quiet</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version_footer</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>cmd_table</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>option_table</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>footer</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>targets</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>os</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_parse_all_args</name><argument_list>(<argument><expr>&amp;<name>targets</name></expr></argument>, <argument><expr><name>os</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>os</name> &amp;&amp; <name><name>targets</name>-&gt;<name>nelts</name></name></expr>)</condition><then>  <comment type="block">/* help on subcommand(s) requested */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <expr_stmt><expr><call><name>svn_opt_subcommand_help</name><argument_list>(<argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>cmd_table</name></expr></argument>, <argument><expr><name>option_table</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for></then>
  <else>else <if>if <condition>(<expr><name>print_version</name></expr>)</condition><then>   <comment type="block">/* just --version */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_version_info</name><argument_list>(<argument><expr><name>pgm_name</name></expr></argument>, <argument><expr><name>version_footer</name></expr></argument>, <argument><expr><name>quiet</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>os</name> &amp;&amp; !<name><name>targets</name>-&gt;<name>nelts</name></name></expr>)</condition><then>            <comment type="block">/* `-h', `--help', or `help' */</comment>
    <expr_stmt><expr><call><name>svn_opt_print_generic_help</name><argument_list>(<argument><expr><name>header</name></expr></argument>,
                               <argument><expr><name>cmd_table</name></expr></argument>,
                               <argument><expr><name>option_table</name></expr></argument>,
                               <argument><expr><name>footer</name></expr></argument>,
                               <argument><expr><name>pool</name></expr></argument>,
                               <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else                                       <comment type="block">/* unknown option or cmd */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Type '%s help' for usage.\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pgm_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
