<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_ra_neon/merge.c"><comment type="block">/*
 * merge.c :  routines for performing a MERGE server requests
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_xml.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_dav_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ra_neon.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_ra_neon__xml_elm_t</name></type> <name><name>merge_elements</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"updated-set"</expr>, <expr><name>ELEM_updated_set</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"merged-set"</expr>, <expr><name>ELEM_merged_set</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"ignored-set"</expr>, <expr><name>ELEM_ignored_set</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"href"</expr>, <expr><name>ELEM_href</name></expr>, <expr><name>SVN_RA_NEON__XML_CDATA</name></expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"merge-response"</expr>, <expr><name>ELEM_merge_response</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"checked-in"</expr>, <expr><name>ELEM_checked_in</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"response"</expr>, <expr><name>ELEM_response</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"propstat"</expr>, <expr><name>ELEM_propstat</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"status"</expr>, <expr><name>ELEM_status</name></expr>, <expr><name>SVN_RA_NEON__XML_CDATA</name></expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"responsedescription"</expr>, <expr><name>ELEM_responsedescription</name></expr>,
    <expr><name>SVN_RA_NEON__XML_CDATA</name></expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"prop"</expr>, <expr><name>ELEM_prop</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"resourcetype"</expr>, <expr><name>ELEM_resourcetype</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"collection"</expr>, <expr><name>ELEM_collection</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"baseline"</expr>, <expr><name>ELEM_baseline</name></expr>, <expr>0</expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr><name>SVN_DAV__VERSION_NAME</name></expr>, <expr><name>ELEM_version_name</name></expr>, <expr><name>SVN_RA_NEON__XML_CDATA</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"post-commit-err"</expr>,
    <expr><name>ELEM_post_commit_err</name></expr>, <expr><name>SVN_RA_NEON__XML_CDATA</name></expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr><name>SVN_DAV__CREATIONDATE</name></expr>, <expr><name>ELEM_creationdate</name></expr>, <expr><name>SVN_RA_NEON__XML_CDATA</name></expr> }</block></expr>,
  <expr><block>{ <expr>"DAV:"</expr>, <expr>"creator-displayname"</expr>, <expr><name>ELEM_creator_displayname</name></expr>,
    <expr><name>SVN_RA_NEON__XML_CDATA</name></expr> }</block></expr>,

  <expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<enum>enum <name>merge_rtype</name> <block>{
  <decl><name>RTYPE_UNKNOWN</name></decl>,    <comment type="block">/* unknown (haven't seen it in the response yet) */</comment>
  <decl><name>RTYPE_REGULAR</name></decl>,    <comment type="block">/* a regular (member) resource */</comment>
  <decl><name>RTYPE_COLLECTION</name></decl>, <comment type="block">/* a collection resource */</comment>
  <decl><name>RTYPE_BASELINE</name></decl>    <comment type="block">/* a baseline resource */</comment>
}</block>;</enum>

<typedef>typedef <type><struct>struct <block>{
  <comment type="block">/*WARNING: WANT_CDATA should stay the first element in the baton:
    svn_ra_neon__xml_collect_cdata() assumes the baton starts with a stringbuf.
  */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>want_cdata</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>cdata</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <comment type="block">/* a clearable subpool of pool, for loops.  Do not use for anything
     that must persist beyond the scope of your function! */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>scratchpool</name></decl>;</decl_stmt>

  <comment type="block">/* the BASE_HREF contains the merge target. as resources are specified in
     the merge response, we make their URLs relative to this URL, thus giving
     us a path for use in the commit callbacks. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_href</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>        <comment type="block">/* the new/target revision number for this commit */</comment>

  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>response_has_error</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>response_parent</name></decl>;</decl_stmt>     <comment type="block">/* what element did DAV:response appear within? */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>href_parent</name></decl>;</decl_stmt>         <comment type="block">/* what element is the DAV:href appearing within? */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>href</name></decl>;</decl_stmt>   <comment type="block">/* current response */</comment>

  <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>              <comment type="block">/* HTTP status for this DAV:propstat */</comment>
  <enum>enum <name>merge_rtype</name> <name>rtype</name>;</enum>  <comment type="block">/* DAV:resourcetype of this resource */</comment>

  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>vsn_name</name></decl>;</decl_stmt>       <comment type="block">/* DAV:version-name for this resource */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>vsn_url</name></decl>;</decl_stmt>        <comment type="block">/* DAV:checked-in for this resource */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>committed_date</name></decl>;</decl_stmt> <comment type="block">/* DAV:creationdate for this resource */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>last_author</name></decl>;</decl_stmt>    <comment type="block">/* DAV:creator-displayname for this
                                      resource */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>post_commit_err</name></decl>;</decl_stmt><comment type="block">/* SVN_XML_NAMESPACE:post-commit hook's
                                      stderr */</comment>

  <comment type="block">/* We only invoke set_prop() on targets listed in valid_targets.
     Some entities (such as directories that have had changes
     committed underneath but are not themselves targets) will be
     mentioned in the merge response but not appear in
     valid_targets. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>valid_targets</name></decl>;</decl_stmt>

  <comment type="block">/* Client callbacks */</comment>
  <decl_stmt><decl><type><name>svn_ra_push_wc_prop_func_t</name></type> <name>push_prop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>cb_baton</name></decl>;</decl_stmt>  <comment type="block">/* baton for above */</comment>

}</block></struct></type> <name>merge_ctx_t</name>;</typedef>


<function><type><specifier>static</specifier> <name>void</name></type> <name>add_ignored</name><parameter_list>(<param><decl><type><name>merge_ctx_t</name> *</type><name>mc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cdata</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* ### the server didn't check in the file(!) */</comment>
  <comment type="block">/* ### remember the file and issue a report/warning later */</comment>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type> <name>okay_to_bump_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                       <param><decl><type><name>apr_hash_t</name> *</type><name>valid_targets</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <enum>enum <name>svn_recurse_kind</name> <name>r</name>;</enum>

  <comment type="block">/* Easy check:  if path itself is in the hash, then it's legit. */</comment>
  <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>valid_targets</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>
  <comment type="block">/* Otherwise, this path is bumpable IFF one of its parents is in the
     hash and marked with a 'recursion' flag. */</comment>
  <expr_stmt><expr><name>parent_path</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <do>do <block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name><name>parent_path</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>svn_path_remove_component</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len</name> == <name><name>parent_path</name>-&gt;<name>len</name></name></expr>)</condition><then>
      <break>break;</break></then></if>
    <expr_stmt><expr><name>r</name> = (enum <name>svn_recurse_kind</name>) <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>valid_targets</name></expr></argument>,
                                             <argument><expr><name><name>parent_path</name>-&gt;<name>data</name></name></expr></argument>,
                                             <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>r</name> == <name>svn_recursive</name></expr>)</condition><then>
      <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  }</block> while <condition>(<expr>! <call><name>svn_path_is_empty</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

  <comment type="block">/* Default answer: if we get here, don't allow the bumping. */</comment>
  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<comment type="block">/* If committed PATH appears in MC-&gt;valid_targets, and an MC-&gt;push_prop
 * function exists, then store VSN_URL as the SVN_RA_NEON__LP_VSN_URL
 * property on PATH.  Use POOL for all allocations.
 *
 * Otherwise, just return SVN_NO_ERROR.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>bump_resource</name><parameter_list>(<param><decl><type><name>merge_ctx_t</name> *</type><name>mc</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                  <param><decl><type><name>char</name> *</type><name>vsn_url</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* no sense in doing any more work if there's no property setting
     function at our disposal. */</comment>
  <if>if <condition>(<expr><name><name>mc</name>-&gt;<name>push_prop</name></name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Only invoke a client callback on PATH if PATH counts as a
     committed target.  The commit-tracking editor built this list for
     us, and took care not to include directories unless they were
     directly committed (i.e., received a property change). */</comment>
  <if>if <condition>(<expr>! <call><name>okay_to_bump_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>valid_targets</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Okay, NOW set the new version url. */</comment>
  <block>{
    <decl_stmt><decl><type><name>svn_string_t</name></type> <name>vsn_url_str</name></decl>;</decl_stmt>  <comment type="block">/* prop setter wants an svn_string_t */</comment>

    <expr_stmt><expr><name><name>vsn_url_str</name>.<name>data</name></name> = <name>vsn_url</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vsn_url_str</name>.<name>len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>vsn_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call>(*<name><name>mc</name>-&gt;<name>push_prop</name></name>)<argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>cb_baton</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                             <argument><expr><name>SVN_RA_NEON__LP_VSN_URL</name></expr></argument>, <argument><expr>&amp;<name>vsn_url_str</name></expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type> <name>handle_resource</name><parameter_list>(<param><decl><type><name>merge_ctx_t</name> *</type><name>mc</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>mc</name>-&gt;<name>response_has_error</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### what to do? */</comment>
      <comment type="block">/* ### return "no error", presuming whatever set response_has_error
         ### has already handled the problem. */</comment>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>mc</name>-&gt;<name>response_parent</name></name> == <name>ELEM_merged_set</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### shouldn't have happened. we told the server "don't merge" */</comment>
      <comment type="block">/* ### need something better than APR_EGENERAL */</comment>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>APR_EGENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Protocol error: we told the server not to "
                                 "auto-merge any resources, but it said that "
                                 "'%s' was merged"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>href</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>mc</name>-&gt;<name>response_parent</name></name> != <name>ELEM_updated_set</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### unknown parent for this response(!) */</comment>
      <comment type="block">/* ### need something better than APR_EGENERAL */</comment>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>APR_EGENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Internal error: there is an unknown parent "
                                 "(%d) for the 'DAV:response' element within"
                                 " the MERGE response"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>response_parent</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  <comment type="block">/* ### right now, the server isn't sending everything for all resources.
     ### just skip this requirement. */</comment>
  if (mc-&gt;href-&gt;len == 0
      || mc-&gt;vsn_name-&gt;len == 0
      || mc-&gt;vsn_url-&gt;len == 0
      || mc-&gt;rtype == RTYPE_UNKNOWN)
    {
      <comment type="block">/* one or more properties were missing in the DAV:response for the
         resource. */</comment>
      return svn_error_createf(APR_EGENERAL, NULL,
                               _("Protocol error: the MERGE response for the "
                                 "'%s' resource did not return all of the "
                                 "properties that we asked for (and need to "
                                 "complete the commit)"), mc-&gt;href-&gt;data);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr><name><name>mc</name>-&gt;<name>rtype</name></name> == <name>RTYPE_BASELINE</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* cool. the DAV:version-name tells us the new revision */</comment>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>rev</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>vsn_name</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* a collection or regular resource */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>base_href</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>href</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### need something better than APR_EGENERAL */</comment>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>APR_EGENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"A MERGE response for '%s' is not a child "
                                 "of the destination ('%s')"</expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>mc</name>-&gt;<name>href</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>base_href</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* given HREF of the form: BASE "/" RELATIVE, extract the relative portion */</comment>
  <expr_stmt><expr><name>relative</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>base_href</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>href</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>relative</name></expr>)</condition><then> <comment type="block">/* the paths are equal */</comment>
    <expr_stmt><expr><name>relative</name> = ""</expr>;</expr_stmt></then></if>

  <comment type="block">/* bump the resource */</comment>
  <expr_stmt><expr><name>relative</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>relative</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>bump_resource</name><argument_list>(<argument><expr><name>mc</name></expr></argument>, <argument><expr><name>relative</name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>vsn_url</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Determine whether we're receiving the expected XML response.
   Return CHILD when interested in receiving the child's contents
   or one of SVN_RA_NEON__XML_INVALID and SVN_RA_NEON__XML_DECLINE
   when respectively this is the incorrect response or
   the element (and its children) are uninteresting */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>validate_element</name><parameter_list>(<param><decl><type><name>svn_ra_neon__xml_elmid</name></type> <name>parent</name></decl></param>,
                            <param><decl><type><name>svn_ra_neon__xml_elmid</name></type> <name>child</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>(<name>child</name> == <name>ELEM_collection</name> || <name>child</name> == <name>ELEM_baseline</name>)
      &amp;&amp; <name>parent</name> != <name>ELEM_resourcetype</name></expr>)</condition><then> <block>{
    <comment type="block">/* ### technically, they could occur elsewhere, but screw it */</comment>
    <return>return <expr><name>SVN_RA_NEON__XML_INVALID</name></expr>;</return>
  }</block></then></if>

  <switch>switch <condition>(<expr><name>parent</name></expr>)</condition>
    <block>{
    <case>case <expr><name>ELEM_root</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_merge_response</name></expr>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_INVALID</name></expr>;</return></else></if>

    </case><case>case <expr><name>ELEM_merge_response</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_updated_set</name>
          || <name>child</name> == <name>ELEM_merged_set</name>
          || <name>child</name> == <name>ELEM_ignored_set</name></expr>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></else></if> <comment type="block">/* any child is allowed */</comment>

    </case><case>case <expr><name>ELEM_updated_set</name></expr>:
    </case><case>case <expr><name>ELEM_merged_set</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_response</name></expr>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></else></if> <comment type="block">/* ignore if something else
                                           was in there */</comment>

    </case><case>case <expr><name>ELEM_ignored_set</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_href</name></expr>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></else></if> <comment type="block">/* ignore if something else
                                           was in there */</comment>

    </case><case>case <expr><name>ELEM_response</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_href</name>
          || <name>child</name> == <name>ELEM_status</name>
          || <name>child</name> == <name>ELEM_propstat</name></expr>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else <if>if <condition>(<expr><name>child</name> == <name>ELEM_responsedescription</name></expr>)</condition><then>
        <comment type="block">/* ### I think we want this... to save a message for the user */</comment>
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></then> <comment type="block">/* valid, but we don't need to see it */</comment>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></else></if></else></if> <comment type="block">/* ignore if something else
                                           was in there */</comment>

    </case><case>case <expr><name>ELEM_propstat</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_prop</name> || <name>child</name> == <name>ELEM_status</name></expr>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else <if>if <condition>(<expr><name>child</name> == <name>ELEM_responsedescription</name></expr>)</condition><then>
        <comment type="block">/* ### I think we want this... to save a message for the user */</comment>
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></then> <comment type="block">/* valid, but we don't need to see it */</comment>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></else></if></else></if> <comment type="block">/* ignore if something else
                                           was in there */</comment>

    </case><case>case <expr><name>ELEM_prop</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_checked_in</name>
          || <name>child</name> == <name>ELEM_resourcetype</name>
          || <name>child</name> == <name>ELEM_version_name</name>
          || <name>child</name> == <name>ELEM_creationdate</name>
          || <name>child</name> == <name>ELEM_creator_displayname</name>
          || <name>child</name> == <name>ELEM_post_commit_err</name></expr>
          <comment type="block">/* other props */</comment>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></else></if> <comment type="block">/* ignore other props */</comment>

    </case><case>case <expr><name>ELEM_checked_in</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_href</name></expr>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></else></if> <comment type="block">/* ignore if something else
                                           was in there */</comment>

    </case><case>case <expr><name>ELEM_resourcetype</name></expr>:
      <if>if <condition>(<expr><name>child</name> == <name>ELEM_collection</name> || <name>child</name> == <name>ELEM_baseline</name></expr>)</condition><then>
        <return>return <expr><name>child</name></expr>;</return></then>
      <else>else
        <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return></else></if> <comment type="block">/* ignore if something else
                                           was in there */</comment>

    </case><default>default:
      <return>return <expr><name>SVN_RA_NEON__XML_DECLINE</name></expr>;</return>
    </default>}</block></switch>

  <comment type="block">/* NOTREACHED */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>start_element</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>elem</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>int</name></type> <name>parent</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>nspace</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_ra_neon__xml_elm_t</name> *</type><name>elm</name>
    <init>= <expr><call><name>svn_ra_neon__lookup_xml_elem</name><argument_list>(<argument><expr><name>merge_elements</name></expr></argument>, <argument><expr><name>nspace</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>merge_ctx_t</name> *</type><name>mc</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>elem</name> = <name>elm</name> ? <call><name>validate_element</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>elm</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call> : <name>SVN_RA_NEON__XML_DECLINE</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>*<name>elem</name> &lt; 1</expr>)</condition><then> <comment type="block">/* not a valid element */</comment>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <switch>switch <condition>(<expr><name><name>elm</name>-&gt;<name>id</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>ELEM_response</name></expr>:
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>response_has_error</name></name> = <name>FALSE</name></expr>;</expr_stmt>

      <comment type="block">/* for each response (which corresponds to one resource), note that we
         haven't seen its resource type yet */</comment>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>rtype</name></name> = <name>RTYPE_UNKNOWN</name></expr>;</expr_stmt>

      <comment type="block">/* and we haven't seen these elements yet */</comment>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>href</name>-&gt;<name>len</name></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>vsn_name</name>-&gt;<name>len</name></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>vsn_url</name>-&gt;<name>len</name></name> = 0</expr>;</expr_stmt>

      <comment type="block">/* FALLTHROUGH */</comment>

    </case><case>case <expr><name>ELEM_ignored_set</name></expr>:
    </case><case>case <expr><name>ELEM_checked_in</name></expr>:
      <comment type="block">/* if we see an href "soon", then its parent is ELM */</comment>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>href_parent</name></name> = <name><name>elm</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_updated_set</name></expr>:
    </case><case>case <expr><name>ELEM_merged_set</name></expr>:
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>response_parent</name></name> = <name><name>elm</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_propstat</name></expr>:
      <comment type="block">/* initialize the status so we can figure out if we ever saw a
         status element in the propstat */</comment>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>status</name></name> = 0</expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_resourcetype</name></expr>:
      <comment type="block">/* we've seen a DAV:resourcetype, so it will be "regular" unless we
         see something within this element */</comment>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>rtype</name></name> = <name>RTYPE_REGULAR</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_collection</name></expr>:
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>rtype</name></name> = <name>RTYPE_COLLECTION</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_baseline</name></expr>:
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>rtype</name></name> = <name>RTYPE_BASELINE</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <comment type="block">/* one of: ELEM_href, ELEM_status, ELEM_prop,
         ELEM_version_name */</comment>
      <break>break;</break>
    </default>}</block></switch>

  <switch>switch <condition>(<expr><name><name>elm</name>-&gt;<name>id</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>ELEM_href</name></expr>:
    </case><case>case <expr><name>ELEM_status</name></expr>:
    </case><case>case <expr><name>ELEM_version_name</name></expr>:
    </case><case>case <expr><name>ELEM_post_commit_err</name></expr>:
    </case><case>case <expr><name>ELEM_creationdate</name></expr>:
    </case><case>case <expr><name>ELEM_creator_displayname</name></expr>:
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>want_cdata</name></name> = <name><name>mc</name>-&gt;<name>cdata</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_setempty</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>cdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>want_cdata</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break>
    </default>}</block></switch>


  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>end_element</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>int</name></type> <name>state</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>nspace</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>merge_ctx_t</name> *</type><name>mc</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>state</name></expr>)</condition>
    <block>{
    <case>case <expr><name>ELEM_href</name></expr>:
      <switch>switch <condition>(<expr><name><name>mc</name>-&gt;<name>href_parent</name></name></expr>)</condition>
        <block>{
        <case>case <expr><name>ELEM_ignored_set</name></expr>:
          <expr_stmt><expr><call><name>add_ignored</name><argument_list>(<argument><expr><name>mc</name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>cdata</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>ELEM_response</name></expr>:
          <comment type="block">/* we're now working on this href... */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_neon__copy_href</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>href</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>cdata</name>-&gt;<name>data</name></name></expr></argument>,
                                         <argument><expr><name><name>mc</name>-&gt;<name>scratchpool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>ELEM_checked_in</name></expr>:
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_neon__copy_href</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>vsn_url</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>cdata</name>-&gt;<name>data</name></name></expr></argument>,
                                         <argument><expr><name><name>mc</name>-&gt;<name>scratchpool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case>}</block></switch>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_responsedescription</name></expr>:
      <comment type="block">/* ### I don't think we'll see this right now, due to validate_element */</comment>
      <comment type="block">/* ### remember this for error messages? */</comment>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_status</name></expr>:
      <block>{
        <decl_stmt><decl><type><name>ne_status</name></type> <name>hs</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>ne_parse_statusline</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>cdata</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>hs</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
          <expr_stmt><expr><name><name>mc</name>-&gt;<name>response_has_error</name></name> = <name>TRUE</name></expr>;</expr_stmt></then>
        <else>else
          <block>{
            <expr_stmt><expr><name><name>mc</name>-&gt;<name>status</name></name> = <name><name>hs</name>.<name>code</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>hs</name>.<name>code</name></name> != 200</expr>)</condition><then>
              <block>{
                <comment type="block">/* ### create an error structure? */</comment>
                <expr_stmt><expr><name><name>mc</name>-&gt;<name>response_has_error</name></name> = <name>TRUE</name></expr>;</expr_stmt>
              }</block></then></if>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>hs</name>.<name>reason_phrase</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        <if>if <condition>(<expr><name><name>mc</name>-&gt;<name>response_has_error</name></name></expr>)</condition><then>
          <block>{
            <comment type="block">/* ### fix this error value */</comment>
            <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>APR_EGENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The MERGE property response had an "
                                      "error status"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
          }</block></then></if>
      }</block>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_propstat</name></expr>:
      <comment type="block">/* ### does Neon have a symbol for 200? */</comment>
      <if>if <condition>(<expr><name><name>mc</name>-&gt;<name>status</name></name> == 200</expr> <comment type="block">/* OK */</comment>)</condition><then>
        <block>{
          <comment type="block">/* ### what to do? reset all the data? */</comment>
        }</block></then></if>
      <comment type="block">/* ### else issue an error? status==0 means we never saw one */</comment>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_response</name></expr>:
      <block>{
        <comment type="block">/* the end of a DAV:response means that we've seen all the information
           related to this resource. process it. */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>handle_resource</name><argument_list>(<argument><expr><name>mc</name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>scratchpool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>scratchpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_checked_in</name></expr>:
      <comment type="block">/* When we leave a DAV:checked-in element, the parents are DAV:prop,
         DAV:propstat, then DAV:response. If we see a DAV:href "on the way
         out", then it is going to belong to the DAV:response. */</comment>
      <expr_stmt><expr><name><name>mc</name>-&gt;<name>href_parent</name></name> = <name>ELEM_response</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_version_name</name></expr>:
      <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>vsn_name</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>cdata</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_post_commit_err</name></expr>:
      <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>post_commit_err</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>cdata</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_creationdate</name></expr>:
      <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>committed_date</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>cdata</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>ELEM_creator_displayname</name></expr>:
      <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name><name>mc</name>-&gt;<name>last_author</name></name></expr></argument>, <argument><expr><name><name>mc</name>-&gt;<name>cdata</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <comment type="block">/* one of: ELEM_updated_set, ELEM_merged_set, ELEM_ignored_set,
         ELEM_prop, ELEM_resourcetype, ELEM_collection, ELEM_baseline */</comment>
      <break>break;</break>
    </default>}</block></switch>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type> <name>svn_ra_neon__assemble_locktoken_body</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>body</name></decl></param>,
                                                   <param><decl><type><name>apr_hash_t</name> *</type><name>lock_tokens</name></decl></param>,
                                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buf_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>closing_tag</name> <init>= <expr>"&lt;/S:lock-token-list&gt;"</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>closing_tag_size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>closing_tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>tmppool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>xml_locks</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>tmppool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>lockbuf</name> <init>= <expr><call><name>svn_stringbuf_create</name>
    <argument_list>(<argument><expr>"&lt;S:lock-token-list xmlns:S=\"" <name>SVN_XML_NAMESPACE</name> "\"&gt;" <name>DEBUG_CR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>buf_size</name> = <name><name>lockbuf</name>-&gt;<name>len</name></name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK</name></cpp:macro> <cpp:value>"&lt;S:lock&gt;" DEBUG_CR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_LEN</name></cpp:macro> <cpp:value>sizeof(SVN_LOCK)-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_CLOSE</name></cpp:macro> <cpp:value>"&lt;/S:lock&gt;" DEBUG_CR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_CLOSE_LEN</name></cpp:macro> <cpp:value>sizeof(SVN_LOCK_CLOSE)-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_PATH</name></cpp:macro> <cpp:value>"&lt;S:lock-path&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_PATH_LEN</name></cpp:macro> <cpp:value>sizeof(SVN_LOCK_PATH)-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_PATH_CLOSE</name></cpp:macro> <cpp:value>"&lt;/S:lock-path&gt;" DEBUG_CR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_PATH_CLOSE_LEN</name></cpp:macro> <cpp:value>sizeof(SVN_LOCK_CLOSE)-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_TOKEN</name></cpp:macro> <cpp:value>"&lt;S:lock-token&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_TOKEN_LEN</name></cpp:macro> <cpp:value>sizeof(SVN_LOCK_TOKEN)-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_TOKEN_CLOSE</name></cpp:macro> <cpp:value>"&lt;/S:lock-token&gt;" DEBUG_CR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LOCK_TOKEN_CLOSE_LEN</name></cpp:macro> <cpp:value>sizeof(SVN_LOCK_TOKEN_CLOSE)-1</cpp:value></cpp:define>

  <comment type="block">/* First, figure out how much string data we're talking about,
     and allocate a stringbuf big enough to hold it all... we *never*
     want have the stringbuf do an auto-reallocation.  While here,
     we'll be copying our hash of paths -&gt; tokens into a hash of
     xml-escaped-paths -&gt; tokens.  */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>tmppool</name></expr></argument>, <argument><expr><name>lock_tokens</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name></type> <name>lock_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>lock_path_xml</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* XML-escape our key and store it in our temporary hash. */</comment>
      <expr_stmt><expr><name><name>lock_path</name>.<name>data</name></name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lock_path</name>.<name>len</name></name> = <name>klen</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_xml_escape_cdata_string</name><argument_list>(<argument><expr>&amp;<name>lock_path_xml</name></expr></argument>, <argument><expr>&amp;<name>lock_path</name></expr></argument>, <argument><expr><name>tmppool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>xml_locks</name></expr></argument>, <argument><expr><name><name>lock_path_xml</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>lock_path_xml</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now, on with the stringbuf calculations. */</comment>
      <expr_stmt><expr><name>buf_size</name> += <name>SVN_LOCK_LEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>buf_size</name> += <name>SVN_LOCK_PATH_LEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>buf_size</name> += <name><name>lock_path_xml</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>buf_size</name> += <name>SVN_LOCK_PATH_CLOSE_LEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>buf_size</name> += <name>SVN_LOCK_TOKEN_LEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>buf_size</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>buf_size</name> += <name>SVN_LOCK_TOKEN_CLOSE_LEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>buf_size</name> += <name>SVN_LOCK_CLOSE_LEN</name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><name>buf_size</name> += <name>closing_tag_size</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>buf_size</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now append all the temporary hash's keys and values into the
     stringbuf.  This is better than doing apr_pstrcat() in a loop,
     because (1) there's no need to constantly re-alloc, and (2) the
     stringbuf already knows the end of the buffer, so there's no
     seek-time to the end of the string when appending. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>tmppool</name></expr></argument>, <argument><expr><name>xml_locks</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>SVN_LOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>SVN_LOCK_PATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>SVN_LOCK_PATH_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>SVN_LOCK_TOKEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>SVN_LOCK_TOKEN_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>SVN_LOCK_CLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>lockbuf</name></expr></argument>, <argument><expr><name>closing_tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_LEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_CLOSE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_CLOSE_LEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_PATH</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_PATH_LEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_PATH_CLOSE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_PATH_CLOSE_LEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_TOKEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_TOKEN_LEN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_TOKEN_CLOSE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SVN_LOCK_TOKEN_CLOSE_LEN</name></cpp:undef>

  <expr_stmt><expr>*<name>body</name> = <name>lockbuf</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>tmppool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type> <name>svn_ra_neon__merge_activity</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>new_rev</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>committed_date</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>committed_author</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>post_commit_err</name></decl></param>,
                                          <param><decl><type><name>svn_ra_neon__session_t</name> *</type><name>ras</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_url</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activity_url</name></decl></param>,
                                          <param><decl><type><name>apr_hash_t</name> *</type><name>valid_targets</name></decl></param>,
                                          <param><decl><type><name>apr_hash_t</name> *</type><name>lock_tokens</name></decl></param>,
                                          <param><decl><type><name>svn_boolean_t</name></type> <name>keep_locks</name></decl></param>,
                                          <param><decl><type><name>svn_boolean_t</name></type> <name>disable_merge_response</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>merge_ctx_t</name></type> <name>mc</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>body</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>extra_headers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>lockbuf</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>mc</name>.<name>cdata</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>scratchpool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>base_href</name></name> = <name>repos_url</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>mc</name>.<name>valid_targets</name></name> = <name>valid_targets</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>push_prop</name></name> = <name><name>ras</name>-&gt;<name>callbacks</name>-&gt;<name>push_wc_prop</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>cb_baton</name></name> = <name><name>ras</name>-&gt;<name>callback_baton</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>mc</name>.<name>href</name></name> = <call><name>MAKE_BUFFER</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>vsn_name</name></name> = <call><name>MAKE_BUFFER</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>vsn_url</name></name> = <call><name>MAKE_BUFFER</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>committed_date</name></name> = <call><name>MAKE_BUFFER</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mc</name>.<name>last_author</name></name> = <call><name>MAKE_BUFFER</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>post_commit_err</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>mc</name>.<name>post_commit_err</name></name> = <call><name>MAKE_BUFFER</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>disable_merge_response</name>
      || (! <name>keep_locks</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>value</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s %s"</expr></argument>,
                           <argument><expr><name>disable_merge_response</name> ?
                              <name>SVN_DAV_OPTION_NO_MERGE_RESPONSE</name> : ""</expr></argument>,
                           <argument><expr><name>keep_locks</name> ?
                              "" : <name>SVN_DAV_OPTION_RELEASE_LOCKS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <name>extra_headers</name></expr>)</condition><then>
        <expr_stmt><expr><name>extra_headers</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>extra_headers</name></expr></argument>, <argument><expr><name>SVN_DAV_OPTIONS_HEADER</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                   <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Need to marshal the whole [path-&gt;token] hash to the server as
     a string within the body of the MERGE request. */</comment>
  <if>if <condition>(<expr>(<name>lock_tokens</name> != <name>NULL</name>)
      &amp;&amp; (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>lock_tokens</name></expr></argument>)</argument_list></call> &gt; 0)</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_neon__assemble_locktoken_body</name><argument_list>(<argument><expr>&amp;<name>lockbuf</name></expr></argument>, <argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>body</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                      <argument><expr>"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;"
                      "&lt;D:merge xmlns:D=\"DAV:\"&gt;"
                      "&lt;D:source&gt;&lt;D:href&gt;%s&lt;/D:href&gt;&lt;/D:source&gt;"
                      "&lt;D:no-auto-merge/&gt;&lt;D:no-checkout/&gt;"
                      "&lt;D:prop&gt;&lt;D:checked-in/&gt;"
                      "&lt;D:" <name>SVN_DAV__VERSION_NAME</name> "/&gt;&lt;D:resourcetype/&gt;"
                      "&lt;D:" <name>SVN_DAV__CREATIONDATE</name> "/&gt;&lt;D:creator-displayname/&gt;"
                      "&lt;/D:prop&gt;"
                      "%s"
                      "&lt;/D:merge&gt;"</expr></argument>,
                      <argument><expr><name>activity_url</name></expr></argument>, <argument><expr><name><name>lockbuf</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_neon__parsed_request</name><argument_list>(<argument><expr><name>ras</name></expr></argument>, <argument><expr>"MERGE"</expr></argument>, <argument><expr><name>repos_url</name></expr></argument>,
                                      <argument><expr><name>body</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr><name>start_element</name></expr></argument>,
                                      <argument><expr><name>svn_ra_neon__xml_collect_cdata</name></expr></argument>,
                                      <argument><expr><name>end_element</name></expr></argument>, <argument><expr>&amp;<name>mc</name></expr></argument>, <argument><expr><name>extra_headers</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* return some commit properties to the caller. */</comment>
  <if>if <condition>(<expr><name>new_rev</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>new_rev</name> = <name><name>mc</name>.<name>rev</name></name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>committed_date</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>committed_date</name> = <name><name>mc</name>.<name>committed_date</name>-&gt;<name>len</name></name>
                      ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>mc</name>.<name>committed_date</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>committed_author</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>committed_author</name> = <name><name>mc</name>.<name>last_author</name>-&gt;<name>len</name></name>
                        ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>mc</name>.<name>last_author</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>post_commit_err</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>post_commit_err</name> = <name><name>mc</name>.<name>post_commit_err</name>-&gt;<name>len</name></name>
                        ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>mc</name>.<name>post_commit_err</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>mc</name>.<name>scratchpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
</unit>
