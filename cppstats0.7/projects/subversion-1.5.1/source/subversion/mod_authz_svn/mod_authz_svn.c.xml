<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/mod_authz_svn/mod_authz_svn.c"><comment type="block">/*
 * mod_authz_svn.c: an Apache mod_dav_svn sub-module to provide path
 *                  based authorization for a Subversion repository.
 *
 * ====================================================================
 * Copyright (c) 2003-2005 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_config.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_request.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_protocol.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ap_config.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ap_provider.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_uri.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mod_dav.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_dav_svn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_authz_svn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>extern</specifier> <name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>authz_svn_module</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>authoritative</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>anonymous</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>no_auth_when_anon_ok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>access_file</name></decl>;</decl_stmt>
}</block></struct></type> <name>authz_svn_config_rec</name>;</typedef>

<comment type="block">/*
 * Configuration
 */</comment>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_authz_svn_dir_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>d</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>authz_svn_config_rec</name> *</type><name>conf</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>conf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>conf</name>-&gt;<name>base_path</name></name> = <name>d</name></expr>;</expr_stmt>

    <comment type="block">/* By default keep the fortress secure */</comment>
    <expr_stmt><expr><name><name>conf</name>-&gt;<name>authoritative</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>conf</name>-&gt;<name>anonymous</name></name> = 1</expr>;</expr_stmt>

    <return>return <expr><name>conf</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>authz_svn_cmds</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><call><name>AP_INIT_FLAG</name><argument_list>(<argument><expr>"AuthzSVNAuthoritative"</expr></argument>, <argument><expr><name>ap_set_flag_slot</name></expr></argument>,
                 <argument><expr>(<name>void</name> *)<call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>authz_svn_config_rec</name></expr></argument>, <argument><expr><name>authoritative</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>OR_AUTHCFG</name></expr></argument>,
                 <argument><expr>"Set to 'Off' to allow access control to be passed along to "
                 "lower modules. (default is On.)"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"AuthzSVNAccessFile"</expr></argument>, <argument><expr><name>ap_set_file_slot</name></expr></argument>,
                  <argument><expr>(<name>void</name> *)<call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>authz_svn_config_rec</name></expr></argument>, <argument><expr><name>access_file</name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><name>OR_AUTHCFG</name></expr></argument>,
                  <argument><expr>"Text file containing permissions of repository paths."</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_FLAG</name><argument_list>(<argument><expr>"AuthzSVNAnonymous"</expr></argument>, <argument><expr><name>ap_set_flag_slot</name></expr></argument>,
                 <argument><expr>(<name>void</name> *)<call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>authz_svn_config_rec</name></expr></argument>, <argument><expr><name>anonymous</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>OR_AUTHCFG</name></expr></argument>,
                 <argument><expr>"Set to 'Off' to disable two special-case behaviours of "
                 "this module: (1) interaction with the 'Satisfy Any' "
                 "directive, and (2) enforcement of the authorization "
                 "policy even when no 'Require' directives are present. "
                 "(default is On.)"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_FLAG</name><argument_list>(<argument><expr>"AuthzSVNNoAuthWhenAnonymousAllowed"</expr></argument>, <argument><expr><name>ap_set_flag_slot</name></expr></argument>,
                 <argument><expr>(<name>void</name> *)<call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>authz_svn_config_rec</name></expr></argument>,
                                      <argument><expr><name>no_auth_when_anon_ok</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>OR_AUTHCFG</name></expr></argument>,
                 <argument><expr>"Set to 'On' to suppress authentication and authorization "
                 "for requests which anonymous users are allowed to perform. "
                 "(default is Off.)"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Get the, possibly cached, svn_authz_t for this request.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_authz_t</name> *</type><name>get_access_conf</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                    <param><decl><type><name>authz_svn_config_rec</name> *</type><name>conf</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cache_key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>user_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_authz_t</name> *</type><name>access_conf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>svn_err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cache_key</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"mod_authz_svn:"</expr></argument>,
                            <argument><expr><name><name>conf</name>-&gt;<name>access_file</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>user_data</name></expr></argument>, <argument><expr><name>cache_key</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>access_conf</name> = <name>user_data</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>access_conf</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>svn_err</name> = <call><name>svn_repos_authz_read</name><argument_list>(<argument><expr>&amp;<name>access_conf</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>access_file</name></name></expr></argument>,
                                       <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>svn_err</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>,
                          <comment type="block">/* If it is an error code that APR can make sense
                             of, then show it, otherwise, pass zero to avoid
                             putting "APR does not understand this error code"
                             in the error log. */</comment>
                          <argument><expr>((<name><name>svn_err</name>-&gt;<name>apr_err</name></name> &gt;= <name>APR_OS_START_USERERR</name> &amp;&amp;
                            <name><name>svn_err</name>-&gt;<name>apr_err</name></name> &lt; <name>APR_OS_START_CANONERR</name>) ?
                          0 : <name><name>svn_err</name>-&gt;<name>apr_err</name></name>)</expr></argument>,
                          <argument><expr><name>r</name></expr></argument>, <argument><expr>"Failed to load the AuthzSVNAccessFile: %s"</expr></argument>,
                          <argument><expr><call><name>svn_err_best_message</name><argument_list>(<argument><expr><name>svn_err</name></expr></argument>,
                                               <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>svn_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>access_conf</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <comment type="block">/* Cache the open repos for the next request on this connection */</comment>
            <expr_stmt><expr><call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr><name>access_conf</name></expr></argument>, <argument><expr><name>cache_key</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
    <return>return <expr><name>access_conf</name></expr>;</return>
}</block></function>

<comment type="block">/* Check if the current request R is allowed.  Upon exit *REPOS_PATH_REF
 * will contain the path and repository name that an operation was requested
 * on in the form 'name:path'.  *DEST_REPOS_PATH_REF will contain the
 * destination path if the requested operation was a MOVE or a COPY.
 * Returns OK when access is allowed, DECLINED when it isn't, or an HTTP_
 * error code when an error occurred.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>req_check_access</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                            <param><decl><type><name>authz_svn_config_rec</name> *</type><name>conf</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>repos_path_ref</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dest_repos_path_ref</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>parsed_dest_uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cleaned_uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>trailing_slash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_repos_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_repos_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>dav_err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_repos_authz_access_t</name></type> <name>authz_svn_type</name> <init>= <expr><name>svn_authz_none</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>authz_access_granted</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_authz_t</name> *</type><name>access_conf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>svn_err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name></expr>)</condition> <block>{
    <comment type="block">/* All methods requiring read access to all subtrees of r-&gt;uri */</comment>
    <case>case <expr><name>M_COPY</name></expr>:
      <expr_stmt><expr><name>authz_svn_type</name> |= <name>svn_authz_recursive</name></expr>;</expr_stmt>

    <comment type="block">/* All methods requiring read access to r-&gt;uri */</comment>
    </case><case>case <expr><name>M_OPTIONS</name></expr>:
    </case><case>case <expr><name>M_GET</name></expr>:
    </case><case>case <expr><name>M_PROPFIND</name></expr>:
    </case><case>case <expr><name>M_REPORT</name></expr>:
      <expr_stmt><expr><name>authz_svn_type</name> |= <name>svn_authz_read</name></expr>;</expr_stmt>
      <break>break;</break>

    <comment type="block">/* All methods requiring write access to all subtrees of r-&gt;uri */</comment>
    </case><case>case <expr><name>M_MOVE</name></expr>:
    </case><case>case <expr><name>M_DELETE</name></expr>:
      <expr_stmt><expr><name>authz_svn_type</name> |= <name>svn_authz_recursive</name></expr>;</expr_stmt>

    <comment type="block">/* All methods requiring write access to r-&gt;uri */</comment>
    </case><case>case <expr><name>M_MKCOL</name></expr>:
    </case><case>case <expr><name>M_PUT</name></expr>:
    </case><case>case <expr><name>M_PROPPATCH</name></expr>:
    </case><case>case <expr><name>M_CHECKOUT</name></expr>:
    </case><case>case <expr><name>M_MERGE</name></expr>:
    </case><case>case <expr><name>M_MKACTIVITY</name></expr>:
    </case><case>case <expr><name>M_LOCK</name></expr>:
    </case><case>case <expr><name>M_UNLOCK</name></expr>:
      <expr_stmt><expr><name>authz_svn_type</name> |= <name>svn_authz_write</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <comment type="block">/* Require most strict access for unknown methods */</comment>
      <expr_stmt><expr><name>authz_svn_type</name> |= <name>svn_authz_write</name> | <name>svn_authz_recursive</name></expr>;</expr_stmt>
      <break>break;</break>
    </default>}</block></switch>

    <expr_stmt><expr><name>dav_err</name> = <call><name>dav_svn_split_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
                                <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>,
                                <argument><expr><name><name>conf</name>-&gt;<name>base_path</name></name></expr></argument>,
                                <argument><expr>&amp;<name>cleaned_uri</name></expr></argument>,
                                <argument><expr>&amp;<name>trailing_slash</name></expr></argument>,
                                <argument><expr>&amp;<name>repos_name</name></expr></argument>,
                                <argument><expr>&amp;<name>relative_path</name></expr></argument>,
                                <argument><expr>&amp;<name>repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>dav_err</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                      <argument><expr>"%s  [%d, #%d]"</expr></argument>,
                      <argument><expr><name><name>dav_err</name>-&gt;<name>desc</name></name></expr></argument>, <argument><expr><name><name>dav_err</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr><name><name>dav_err</name>-&gt;<name>error_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Ensure that we never allow access by dav_err-&gt;status */</comment>
        <return>return <expr>(<name><name>dav_err</name>-&gt;<name>status</name></name> != <name>OK</name> &amp;&amp; <name><name>dav_err</name>-&gt;<name>status</name></name> != <name>DECLINED</name>) ?
            <name><name>dav_err</name>-&gt;<name>status</name></name> : <name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Ignore the URI passed to MERGE, like mod_dav_svn does.
     * See issue #1821.
     * XXX: When we start accepting a broader range of DeltaV MERGE
     * XXX: requests, this should be revisited.
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_MERGE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>repos_path</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>repos_path</name></expr>)</condition><then>
        <expr_stmt><expr><name>repos_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr>*<name>repos_path_ref</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_MOVE</name> || <name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_COPY</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dest_uri</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Destination"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Decline MOVE or COPY when there is no Destination uri, this will
         * cause failure.
         */</comment>
        <if>if <condition>(<expr>!<name>dest_uri</name></expr>)</condition><then>
            <return>return <expr><name>DECLINED</name></expr>;</return></then></if>

        <expr_stmt><expr><call><name>apr_uri_parse</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>dest_uri</name></expr></argument>, <argument><expr>&amp;<name>parsed_dest_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ap_unescape_url</name><argument_list>(<argument><expr><name><name>parsed_dest_uri</name>.<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dest_uri</name> = <name><name>parsed_dest_uri</name>.<name>path</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>dest_uri</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>base_path</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>conf</name>-&gt;<name>base_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* If it is not the same location, then we don't allow it.
             * XXX: Instead we could compare repository uuids, but that
             * XXX: seems a bit over the top.
             */</comment>
            <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>dav_err</name> = <call><name>dav_svn_split_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
                                    <argument><expr><name>dest_uri</name></expr></argument>,
                                    <argument><expr><name><name>conf</name>-&gt;<name>base_path</name></name></expr></argument>,
                                    <argument><expr>&amp;<name>cleaned_uri</name></expr></argument>,
                                    <argument><expr>&amp;<name>trailing_slash</name></expr></argument>,
                                    <argument><expr>&amp;<name>dest_repos_name</name></expr></argument>,
                                    <argument><expr>&amp;<name>relative_path</name></expr></argument>,
                                    <argument><expr>&amp;<name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>dav_err</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                          <argument><expr>"%s  [%d, #%d]"</expr></argument>,
                          <argument><expr><name><name>dav_err</name>-&gt;<name>desc</name></name></expr></argument>, <argument><expr><name><name>dav_err</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr><name><name>dav_err</name>-&gt;<name>error_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* Ensure that we never allow access by dav_err-&gt;status */</comment>
            <return>return <expr>(<name><name>dav_err</name>-&gt;<name>status</name></name> != <name>OK</name> &amp;&amp; <name><name>dav_err</name>-&gt;<name>status</name></name> != <name>DECLINED</name>) ?
                <name><name>dav_err</name>-&gt;<name>status</name></name> : <name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>dest_repos_path</name></expr>)</condition><then>
            <expr_stmt><expr><name>dest_repos_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><name>dest_repos_path</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr>*<name>dest_repos_path_ref</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>dest_repos_name</name></expr></argument>, <argument><expr>":"</expr></argument>,
                                           <argument><expr><name>dest_repos_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Retrieve/cache authorization file */</comment>
    <expr_stmt><expr><name>access_conf</name> = <call><name>get_access_conf</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>access_conf</name> == <name>NULL</name></expr>)</condition><then>
        <block>{
            <return>return <expr><name>DECLINED</name></expr>;</return>
        }</block></then></if>

    <comment type="block">/* Perform authz access control.
     *
     * First test the special case where repos_path == NULL, and skip
     * calling the authz routines in that case.  This is an oddity of
     * the DAV RA method: some requests have no repos_path, but apache
     * still triggers an authz lookup for the URI.
     *
     * However, if repos_path == NULL and the request requires write
     * access, then perform a global authz lookup.  The request is
     * denied if the user commiting isn't granted any access anywhere
     * in the repository.  This is to avoid operations that involve no
     * paths (commiting an empty revision, leaving a dangling
     * transaction in the FS) being granted by default, letting
     * unauthenticated users write some changes to the repository.
     * This was issue #2388.
     *
     * XXX: For now, requesting access to the entire repository always
     * XXX: succeeds, until we come up with a good way of figuring
     * XXX: this out.
     */</comment>
    <if>if <condition>(<expr><name>repos_path</name>
        || (!<name>repos_path</name> &amp;&amp; (<name>authz_svn_type</name> &amp; <name>svn_authz_write</name>))</expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>svn_err</name> = <call><name>svn_repos_authz_check_access</name><argument_list>(<argument><expr><name>access_conf</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>,
                                               <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>user</name></name></expr></argument>,
                                               <argument><expr><name>authz_svn_type</name></expr></argument>,
                                               <argument><expr>&amp;<name>authz_access_granted</name></expr></argument>,
                                               <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>svn_err</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>,
                        <comment type="block">/* If it is an error code that APR can make
                           sense of, then show it, otherwise, pass
                           zero to avoid putting "APR does not
                           understand this error code" in the error
                           log. */</comment>
                        <argument><expr>((<name><name>svn_err</name>-&gt;<name>apr_err</name></name> &gt;= <name>APR_OS_START_USERERR</name> &amp;&amp;
                          <name><name>svn_err</name>-&gt;<name>apr_err</name></name> &lt; <name>APR_OS_START_CANONERR</name>) ?
                         0 : <name><name>svn_err</name>-&gt;<name>apr_err</name></name>)</expr></argument>,
                        <argument><expr><name>r</name></expr></argument>, <argument><expr>"Failed to perform access control: %s"</expr></argument>,
                        <argument><expr><call><name>svn_err_best_message</name><argument_list>(<argument><expr><name>svn_err</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>svn_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>DECLINED</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>authz_access_granted</name></expr>)</condition><then>
          <return>return <expr><name>DECLINED</name></expr>;</return></then></if>
      }</block></then></if>

    <comment type="block">/* XXX: MKCOL, MOVE, DELETE
     * XXX: Require write access to the parent dir of repos_path.
     */</comment>

    <comment type="block">/* XXX: PUT
     * XXX: If the path doesn't exist, require write access to the
     * XXX: parent dir of repos_path.
     */</comment>

    <comment type="block">/* Only MOVE and COPY have a second uri we have to check access to. */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> != <name>M_MOVE</name>
        &amp;&amp; <name><name>r</name>-&gt;<name>method_number</name></name> != <name>M_COPY</name></expr>)</condition><then> <block>{
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Check access on the destination repos_path.  Again, skip this if
       repos_path == NULL (see above for explanations) */</comment>
    <if>if <condition>(<expr><name>repos_path</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>svn_err</name> = <call><name>svn_repos_authz_check_access</name><argument_list>(<argument><expr><name>access_conf</name></expr></argument>,
                                               <argument><expr><name>dest_repos_name</name></expr></argument>,
                                               <argument><expr><name>dest_repos_path</name></expr></argument>,
                                               <argument><expr><name><name>r</name>-&gt;<name>user</name></name></expr></argument>,
                                               <argument><expr><name>svn_authz_write</name>
                                               |<name>svn_authz_recursive</name></expr></argument>,
                                               <argument><expr>&amp;<name>authz_access_granted</name></expr></argument>,
                                               <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>svn_err</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>,
                        <comment type="block">/* If it is an error code that APR can make sense
                           of, then show it, otherwise, pass zero to avoid
                           putting "APR does not understand this error code"
                           in the error log. */</comment>
                        <argument><expr>((<name><name>svn_err</name>-&gt;<name>apr_err</name></name> &gt;= <name>APR_OS_START_USERERR</name> &amp;&amp;
                          <name><name>svn_err</name>-&gt;<name>apr_err</name></name> &lt; <name>APR_OS_START_CANONERR</name>) ?
                         0 : <name><name>svn_err</name>-&gt;<name>apr_err</name></name>)</expr></argument>,
                        <argument><expr><name>r</name></expr></argument>, <argument><expr>"Failed to perform access control: %s"</expr></argument>,
                        <argument><expr><call><name>svn_err_best_message</name><argument_list>(<argument><expr><name>svn_err</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>svn_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <return>return <expr><name>DECLINED</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>authz_access_granted</name></expr>)</condition><then>
          <return>return <expr><name>DECLINED</name></expr>;</return></then></if>
      }</block></then></if>

    <comment type="block">/* XXX: MOVE and COPY, if the path doesn't exist yet, also
     * XXX: require write access to the parent dir of dest_repos_path.
     */</comment>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/* Log a message indicating the access control decision made about a
 * request.  FILE and LINE should be supplied via the APLOG_MARK macro.
 * ALLOWED is boolean.  REPOS_PATH and DEST_REPOS_PATH are information
 * about the request.  DEST_REPOS_PATH may be NULL. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>log_access_verdict</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>, <param><decl><type><name>int</name></type> <name>line</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>request_rec</name> *</type><name>r</name></decl></param>,
                               <param><decl><type><name>int</name></type> <name>allowed</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_repos_path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><name>allowed</name> ? <name>APLOG_INFO</name> : <name>APLOG_ERR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>verdict</name> <init>= <expr><name>allowed</name> ? "granted" : "denied"</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>r</name>-&gt;<name>user</name></name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>dest_repos_path</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                        <argument><expr>"Access %s: '%s' %s %s %s"</expr></argument>, <argument><expr><name>verdict</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>user</name></name></expr></argument>,
                        <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
          <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                        <argument><expr>"Access %s: '%s' %s %s"</expr></argument>, <argument><expr><name>verdict</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>user</name></name></expr></argument>,
                        <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr><name>repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
  }</block></then>
  <else>else <block>{
      <if>if <condition>(<expr><name>dest_repos_path</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                        <argument><expr>"Access %s: - %s %s %s"</expr></argument>, <argument><expr><name>verdict</name></expr></argument>,
                        <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then>
      <else>else <block>{
          <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                        <argument><expr>"Access %s: - %s %s"</expr></argument>, <argument><expr><name>verdict</name></expr></argument>,
                        <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr><name>repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
  }</block></else></if>
}</block></function>

<comment type="block">/*
 * This function is used as a provider to allow mod_dav_svn to bypass the
 * generation of an apache request when checking GET access from
 * "mod_dav_svn/authz.c" .
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>subreq_bypass</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>svn_err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_authz_t</name> *</type><name>access_conf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>authz_svn_config_rec</name> *</type><name>conf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>authz_access_granted</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                <argument><expr>&amp;<name>authz_svn_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If configured properly, this should never be true, but just in case. */</comment>
    <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>anonymous</name></name> || !<name><name>conf</name>-&gt;<name>access_file</name></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>log_access_verdict</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Retrieve authorization file */</comment>
    <expr_stmt><expr><name>access_conf</name> = <call><name>get_access_conf</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>access_conf</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return></then></if>

    <comment type="block">/* Perform authz access control.
     * See similarly labeled comment in req_check_access.
     */</comment>
    <if>if <condition>(<expr><name>repos_path</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>svn_err</name> = <call><name>svn_repos_authz_check_access</name><argument_list>(<argument><expr><name>access_conf</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>,
                                               <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>user</name></name></expr></argument>,
                                               <argument><expr><name>svn_authz_none</name>|<name>svn_authz_read</name></expr></argument>,
                                               <argument><expr>&amp;<name>authz_access_granted</name></expr></argument>,
                                               <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>svn_err</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>,
                        <comment type="block">/* If it is an error code that APR can make
                           sense of, then show it, otherwise, pass
                           zero to avoid putting "APR does not
                           understand this error code" in the error
                           log. */</comment>
                        <argument><expr>((<name><name>svn_err</name>-&gt;<name>apr_err</name></name> &gt;= <name>APR_OS_START_USERERR</name> &amp;&amp;
                          <name><name>svn_err</name>-&gt;<name>apr_err</name></name> &lt; <name>APR_OS_START_CANONERR</name>) ?
                         0 : <name><name>svn_err</name>-&gt;<name>apr_err</name></name>)</expr></argument>,
                        <argument><expr><name>r</name></expr></argument>, <argument><expr>"Failed to perform access control: %s"</expr></argument>,
                        <argument><expr><call><name>svn_err_best_message</name><argument_list>(<argument><expr><name>svn_err</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>svn_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>authz_access_granted</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>log_access_verdict</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>log_access_verdict</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Hooks
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>access_checker</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>authz_svn_config_rec</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                      <argument><expr>&amp;<name>authz_svn_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_repos_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <comment type="block">/* We are not configured to run */</comment>
    <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>anonymous</name></name> || !<name><name>conf</name>-&gt;<name>access_file</name></name></expr>)</condition><then>
        <return>return <expr><name>DECLINED</name></expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>ap_some_auth_required</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* It makes no sense to check if a location is both accessible
         * anonymous and by an authenticated user (in the same request!).
         */</comment>
        <if>if <condition>(<expr><call><name>ap_satisfies</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> != <name>SATISFY_ANY</name></expr>)</condition><then>
            <return>return <expr><name>DECLINED</name></expr>;</return></then></if>

        <comment type="block">/* If the user is trying to authenticate, let him.  If anonymous
         * access is allowed, so is authenticated access, by definition
         * of the meaning of '*' in the access file.
         */</comment>
        <if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>,
                          <argument><expr>(<name>PROXYREQ_PROXY</name> == <name><name>r</name>-&gt;<name>proxyreq</name></name>)
                          ? "Proxy-Authorization" : "Authorization"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Given Satisfy Any is in effect, we have to forbid access
             * to let the auth_checker hook have a go at it.
             */</comment>
            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If anon access is allowed, return OK */</comment>
    <expr_stmt><expr><name>status</name> = <call><name>req_check_access</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>conf</name></expr></argument>, <argument><expr>&amp;<name>repos_path</name></expr></argument>, <argument><expr>&amp;<name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> == <name>DECLINED</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>authoritative</name></name></expr>)</condition><then>
            <return>return <expr><name>DECLINED</name></expr>;</return></then></if>

        <if>if <condition>(<expr>!<call><name>ap_some_auth_required</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_access_verdict</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>status</name> != <name>OK</name></expr>)</condition><then>
        <return>return <expr><name>status</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>log_access_verdict</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_user_id</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>authz_svn_config_rec</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                      <argument><expr>&amp;<name>authz_svn_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_repos_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <comment type="block">/* We are not configured to run, or, an earlier module has already
     * authenticated this request. */</comment>
    <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>access_file</name></name> || !<name><name>conf</name>-&gt;<name>no_auth_when_anon_ok</name></name> || <name><name>r</name>-&gt;<name>user</name></name></expr>)</condition><then>
        <return>return <expr><name>DECLINED</name></expr>;</return></then></if>

    <comment type="block">/* If anon access is allowed, return OK, preventing later modules
     * from issuing an HTTP_UNAUTHORIZED.  Also pass a note to our
     * auth_checker hook that access has already been checked. */</comment>
    <expr_stmt><expr><name>status</name> = <call><name>req_check_access</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>conf</name></expr></argument>, <argument><expr>&amp;<name>repos_path</name></expr></argument>, <argument><expr>&amp;<name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> == <name>OK</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"authz_svn-anon-ok"</expr></argument>, <argument><expr>(const <name>char</name>*)1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>log_access_verdict</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>auth_checker</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>authz_svn_config_rec</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                      <argument><expr>&amp;<name>authz_svn_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_repos_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <comment type="block">/* We are not configured to run */</comment>
    <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>access_file</name></name></expr>)</condition><then>
        <return>return <expr><name>DECLINED</name></expr>;</return></then></if>

    <comment type="block">/* Previous hook (check_user_id) already did all the work,
     * and, as a sanity check, r-&gt;user hasn't been set since then? */</comment>
    <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>user</name></name> &amp;&amp; <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"authz_svn-anon-ok"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>status</name> = <call><name>req_check_access</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>conf</name></expr></argument>, <argument><expr>&amp;<name>repos_path</name></expr></argument>, <argument><expr>&amp;<name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> == <name>DECLINED</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>authoritative</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>log_access_verdict</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_note_auth_failure</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>

        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>status</name> != <name>OK</name></expr>)</condition><then>
        <return>return <expr><name>status</name></expr>;</return></then></if>

    <expr_stmt><expr><call><name>log_access_verdict</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>dest_repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Module flesh
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>mod_ssl</name><index>[]</index></name> <init>= <expr><block>{ <expr>"mod_ssl.c"</expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_hook_access_checker</name><argument_list>(<argument><expr><name>access_checker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Our check_user_id hook must be before any module which will return
     * HTTP_UNAUTHORIZED (mod_auth_basic, etc.), but after mod_ssl, to
     * give SSLOptions +FakeBasicAuth a chance to work. */</comment>
    <expr_stmt><expr><call><name>ap_hook_check_user_id</name><argument_list>(<argument><expr><name>check_user_id</name></expr></argument>, <argument><expr><name>mod_ssl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_auth_checker</name><argument_list>(<argument><expr><name>auth_checker</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_register_provider</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                         <argument><expr><name>AUTHZ_SVN__SUBREQ_BYPASS_PROV_GRP</name></expr></argument>,
                         <argument><expr><name>AUTHZ_SVN__SUBREQ_BYPASS_PROV_NAME</name></expr></argument>,
                         <argument><expr><name>AUTHZ_SVN__SUBREQ_BYPASS_PROV_VER</name></expr></argument>,
                         <argument><expr>(<name>void</name>*)<name>subreq_bypass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>authz_svn_module</name> <init>=
<expr><block>{
    <expr><name>STANDARD20_MODULE_STUFF</name></expr>,
    <expr><name>create_authz_svn_dir_config</name></expr>,     <comment type="block">/* dir config creater */</comment>
    <expr><name>NULL</name></expr>,                            <comment type="block">/* dir merger --- default is to override */</comment>
    <expr><name>NULL</name></expr>,                            <comment type="block">/* server config */</comment>
    <expr><name>NULL</name></expr>,                            <comment type="block">/* merge server config */</comment>
    <expr><name>authz_svn_cmds</name></expr>,                  <comment type="block">/* command apr_table_t */</comment>
    <expr><name>register_hooks</name></expr>                   <comment type="block">/* register hooks */</comment>
}</block></expr></init></decl>;</decl_stmt>
</unit>
