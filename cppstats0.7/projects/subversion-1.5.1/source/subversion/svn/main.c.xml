<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/svn/main.c"><comment type="block">/*
 * main.c:  Subversion command line client.
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<comment type="block">/* ==================================================================== */</comment>


<escape char="0xc"/>
<comment type="block">/*** Includes. ***/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_cmdline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cl.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/*** Option Processing ***/</comment>

<comment type="block">/* Add an identifier here for long options that don't have a short
   option. Options that have both long and short options should just
   use the short option letter as identifier.  */</comment>
<typedef>typedef <type><enum>enum <block>{
  <decl><name>opt_ancestor_path</name> <init>= <expr><name>SVN_OPT_FIRST_LONGOPT_ID</name></expr></init></decl>,
  <decl><name>opt_auth_password</name></decl>,
  <decl><name>opt_auth_username</name></decl>,
  <decl><name>opt_autoprops</name></decl>,
  <decl><name>opt_changelist</name></decl>,
  <decl><name>opt_config_dir</name></decl>,
  <decl><name>opt_diff_cmd</name></decl>,
  <decl><name>opt_dry_run</name></decl>,
  <decl><name>opt_editor_cmd</name></decl>,
  <decl><name>opt_encoding</name></decl>,
  <decl><name>opt_force_log</name></decl>,
  <decl><name>opt_force</name></decl>,
  <decl><name>opt_keep_changelists</name></decl>,
  <decl><name>opt_ignore_ancestry</name></decl>,
  <decl><name>opt_ignore_externals</name></decl>,
  <decl><name>opt_incremental</name></decl>,
  <decl><name>opt_merge_cmd</name></decl>,
  <decl><name>opt_native_eol</name></decl>,
  <decl><name>opt_new_cmd</name></decl>,
  <decl><name>opt_no_auth_cache</name></decl>,
  <decl><name>opt_no_autoprops</name></decl>,
  <decl><name>opt_no_diff_deleted</name></decl>,
  <decl><name>opt_no_ignore</name></decl>,
  <decl><name>opt_no_unlock</name></decl>,
  <decl><name>opt_non_interactive</name></decl>,
  <decl><name>opt_notice_ancestry</name></decl>,
  <decl><name>opt_old_cmd</name></decl>,
  <decl><name>opt_record_only</name></decl>,
  <decl><name>opt_relocate</name></decl>,
  <decl><name>opt_remove</name></decl>,
  <decl><name>opt_revprop</name></decl>,
  <decl><name>opt_stop_on_copy</name></decl>,
  <decl><name>opt_strict</name></decl>,
  <decl><name>opt_summarize</name></decl>,
  <decl><name>opt_targets</name></decl>,
  <decl><name>opt_depth</name></decl>,
  <decl><name>opt_set_depth</name></decl>,
  <decl><name>opt_version</name></decl>,
  <decl><name>opt_xml</name></decl>,
  <decl><name>opt_keep_local</name></decl>,
  <decl><name>opt_with_revprop</name></decl>,
  <decl><name>opt_with_all_revprops</name></decl>,
  <decl><name>opt_parents</name></decl>,
  <decl><name>opt_accept</name></decl>,
  <decl><name>opt_show_revs</name></decl>,
  <decl><name>opt_reintegrate</name></decl>
}</block></enum></type> <name>svn_cl__longopt_t</name>;</typedef>

<comment type="block">/* Option codes and descriptions for the command line client.
 *
 * The entire list must be terminated with an entry of nulls.
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name></type> <name><name>svn_cl__options</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><block>{<expr>"force"</expr>,         <expr><name>opt_force</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"force operation to run"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"force-log"</expr>,     <expr><name>opt_force_log</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"force validity of log message source"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"help"</expr>,          <expr>'h'</expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"show help on a subcommand"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr><name>NULL</name></expr>,            <expr>'?'</expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"show help on a subcommand"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"message"</expr>,       <expr>'m'</expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"specify log message ARG"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"quiet"</expr>,         <expr>'q'</expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"print nothing, or only summary information"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"recursive"</expr>,     <expr>'R'</expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"descend recursively, same as --depth=infinity"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"non-recursive"</expr>, <expr>'N'</expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"obsolete; try --depth=files or --depth=immediates"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"change"</expr>,        <expr>'c'</expr>, <expr>1</expr>, <macro><name>N_</name>
   <argument_list>(<argument>"the change made by revision ARG (like -r ARG-1:ARG)\n"
    "                             If ARG is negative this is like -r ARG:ARG-1"</argument>)</argument_list></macro>
  }</block></expr>,
  <expr><block>{<expr>"revision"</expr>,      <expr>'r'</expr>, <expr>1</expr>, <macro><name>N_</name>
   <argument_list>(<argument>"ARG (some commands also take ARG1:ARG2 range)\n"
    "                             A revision argument can be one of:\n"
    "                                NUMBER       revision number\n"
    "                                '{' DATE '}' revision at start of the date\n"
    "                                'HEAD'       latest in repository\n"
    "                                'BASE'       base rev of item's working copy\n"
    "                                'COMMITTED'  last commit at or before BASE\n"
    "                                'PREV'       revision just before COMMITTED"</argument>)</argument_list></macro>
   <comment type="block">/* spacing corresponds to svn_opt_format_option */</comment>
  }</block></expr>,
  <expr><block>{<expr>"file"</expr>,          <expr>'F'</expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"read log message from file ARG"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"incremental"</expr>,   <expr><name>opt_incremental</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"give output suitable for concatenation"</argument>)</argument_list></macro>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
  <expr><block>{<expr>"encoding"</expr>,      <expr><name>opt_encoding</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"treat value as being in charset encoding ARG"</argument>)</argument_list></macro>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><block>{<expr>"version"</expr>,       <expr><name>opt_version</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"show program version information"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"verbose"</expr>,       <expr>'v'</expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"print extra information"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"show-updates"</expr>,  <expr>'u'</expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"display update information"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"username"</expr>,      <expr><name>opt_auth_username</name></expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"specify a username ARG"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"password"</expr>,      <expr><name>opt_auth_password</name></expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"specify a password ARG"</argument>)</argument_list></macro>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
  <expr><block>{<expr>"extensions"</expr>,    <expr>'x'</expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"Default: '-u'. When Subversion is invoking an\n"
                       "                            "
                       " external diff program, ARG is simply passed along\n"
                       "                            "
                       " to the program. But when Subversion is using its\n"
                       "                            "
                       " default internal diff implementation, or when\n"
                       "                            "
                       " Subversion is displaying blame annotations, ARG\n"
                       "                            "
                       " could be any of the following:\n"
                       "                            "
                       "    -u (--unified):\n"
                       "                            "
                       "       Output 3 lines of unified context.\n"
                       "                            "
                       "    -b (--ignore-space-change):\n"
                       "                            "
                       "       Ignore changes in the amount of white space.\n"
                       "                            "
                       "    -w (--ignore-all-space):\n"
                       "                            "
                       "       Ignore all white space.\n"
                       "                            "
                       "    --ignore-eol-style:\n"
                       "                            "
                       "       Ignore changes in EOL style\n"
                       "                            "
                       "    -p (--show-c-function):\n"
                       "                            "
                       "       Show C function name in diff output."</argument>)</argument_list></macro>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><block>{<expr>"targets"</expr>,       <expr><name>opt_targets</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"pass contents of file ARG as additional args"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"depth"</expr>,         <expr><name>opt_depth</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"limit operation by depth ARG ('empty', 'files',\n"
                       "                            "
                       "'immediates', or 'infinity')"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"set-depth"</expr>,     <expr><name>opt_set_depth</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"set new working copy depth to ARG ('empty',\n"
                       "                            "
                       "'files', 'immediates', or 'infinity')"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"xml"</expr>,           <expr><name>opt_xml</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"output in XML"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"strict"</expr>,        <expr><name>opt_strict</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"use strict semantics"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"stop-on-copy"</expr>,  <expr><name>opt_stop_on_copy</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"do not cross copies while traversing history"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"no-ignore"</expr>,     <expr><name>opt_no_ignore</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"disregard default and svn:ignore property ignores"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"no-auth-cache"</expr>, <expr><name>opt_no_auth_cache</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"do not cache authentication tokens"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"non-interactive"</expr>, <expr><name>opt_non_interactive</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"do no interactive prompting"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"dry-run"</expr>,       <expr><name>opt_dry_run</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"try operation but make no changes"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"no-diff-deleted"</expr>, <expr><name>opt_no_diff_deleted</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"do not print differences for deleted files"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"notice-ancestry"</expr>, <expr><name>opt_notice_ancestry</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"notice ancestry when calculating differences"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"ignore-ancestry"</expr>, <expr><name>opt_ignore_ancestry</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"ignore ancestry when calculating merges"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"ignore-externals"</expr>, <expr><name>opt_ignore_externals</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"ignore externals definitions"</argument>)</argument_list></macro>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
  <expr><block>{<expr>"diff-cmd"</expr>,      <expr><name>opt_diff_cmd</name></expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"use ARG as diff command"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"diff3-cmd"</expr>,     <expr><name>opt_merge_cmd</name></expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"use ARG as merge command"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"editor-cmd"</expr>,    <expr><name>opt_editor_cmd</name></expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"use ARG as external editor"</argument>)</argument_list></macro>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr><block>{<expr>"record-only"</expr>,   <expr><name>opt_record_only</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"mark revisions as merged (use with -r)"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"old"</expr>,           <expr><name>opt_old_cmd</name></expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"use ARG as the older target"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"new"</expr>,           <expr><name>opt_new_cmd</name></expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"use ARG as the newer target"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"revprop"</expr>,       <expr><name>opt_revprop</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"operate on a revision property (use with -r)"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"relocate"</expr>,      <expr><name>opt_relocate</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"relocate via URL-rewriting"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"config-dir"</expr>,    <expr><name>opt_config_dir</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"read user configuration files from directory ARG"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"auto-props"</expr>,    <expr><name>opt_autoprops</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"enable automatic properties"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"no-auto-props"</expr>, <expr><name>opt_no_autoprops</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"disable automatic properties"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"native-eol"</expr>,    <expr><name>opt_native_eol</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"use a different EOL marker than the standard\n"
                       "                             "
                       "system marker for files with the svn:eol-style\n"
                       "                             "
                       "property set to 'native'.\n"
                       "                             "
                       "ARG may be one of 'LF', 'CR', 'CRLF'"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"limit"</expr>,         <expr>'l'</expr>, <expr>1</expr>, <macro><name>N_</name><argument_list>(<argument>"maximum number of log entries"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"no-unlock"</expr>,     <expr><name>opt_no_unlock</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"don't unlock the targets"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"summarize"</expr>,     <expr><name>opt_summarize</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"show a summary of the results"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"remove"</expr>,         <expr><name>opt_remove</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"remove changelist association"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"changelist"</expr>,    <expr><name>opt_changelist</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"operate only on members of changelist ARG\n"
                       "                             "
                       "[aliases: --cl]"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"keep-changelists"</expr>, <expr><name>opt_keep_changelists</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"don't delete changelists after commit"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"keep-local"</expr>,    <expr><name>opt_keep_local</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"keep path in working copy"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"with-all-revprops"</expr>,  <expr><name>opt_with_all_revprops</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"retrieve all revision properties"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"with-revprop"</expr>,  <expr><name>opt_with_revprop</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"set revision property ARG in new revision\n"
                       "                             "
                       "using the name[=value] format"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"parents"</expr>,       <expr><name>opt_parents</name></expr>, <expr>0</expr>, <macro><name>N_</name><argument_list>(<argument>"make intermediate directories"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"use-merge-history"</expr>, <expr>'g'</expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"use/display additional information from merge\n"
                       "                             "
                       "history"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"accept"</expr>,        <expr><name>opt_accept</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"specify automatic conflict resolution action\n"
                       "                            "
                       "('postpone', 'base', 'mine-full', 'theirs-full',\n"
                       "                            "
                       " 'edit', 'launch')"</argument>)</argument_list></macro>}</block></expr>,
                       <comment type="block">/* 'mine-conflict' and 'theirs-conflict' are not
                          implemented yet, so don't waste the user's time
                          with them. */</comment>
  <expr><block>{<expr>"show-revs"</expr>,     <expr><name>opt_show_revs</name></expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"specify which collection of revisions to display\n"
                       "                             "
                       "('merged', 'eligible')"</argument>)</argument_list></macro>}</block></expr>,
  <expr><block>{<expr>"reintegrate"</expr>,   <expr><name>opt_reintegrate</name></expr>, <expr>0</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"lump-merge all of source URL's unmerged changes"</argument>)</argument_list></macro>}</block></expr>,

  <comment type="block">/* Long-opt Aliases
   *
   * These have NULL desriptions, but an option code that matches some
   * other option (whose description should probably mention its aliases).
  */</comment>

  <expr><block>{<expr>"cl"</expr>,            <expr><name>opt_changelist</name></expr>, <expr>1</expr>, <expr><name>NULL</name></expr>}</block></expr>,

  <expr><block>{<expr>0</expr>,               <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>


<escape char="0xc"/>
<comment type="block">/*** Command dispatch. ***/</comment>

<comment type="block">/* Our array of available subcommands.
 *
 * The entire list must be terminated with an entry of nulls.
 *
 * In most of the help text "PATH" is used where a working copy path is
 * required, "URL" where a repository URL is required and "TARGET" when
 * either a path or an url can be used.  Hmm, should this be part of the
 * help text?
 */</comment>

<comment type="block">/* Options that apply to all commands.  (While not every command may
   currently require authentication or be interactive, allowing every
   command to take these arguments allows scripts to just pass them
   willy-nilly to every invocation of 'svn') . */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>svn_cl__global_options</name><index>[]</index></name> <init>=
<expr><block>{ <expr><name>opt_auth_username</name></expr>, <expr><name>opt_auth_password</name></expr>, <expr><name>opt_no_auth_cache</name></expr>, <expr><name>opt_non_interactive</name></expr>,
  <expr><name>opt_config_dir</name></expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Options for giving a log message.  (Some of these also have other uses.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_CL__LOG_MSG_OPTIONS</name></cpp:macro> <cpp:value>'m', 'F', \
                                opt_force_log, \
                                opt_editor_cmd, \
                                opt_encoding, \
                                opt_with_revprop</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name></type> <name><name>svn_cl__cmd_table</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><block>{ <expr>"add"</expr>, <expr><name>svn_cl__add</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Put files and directories under version control, scheduling\n"
     "them for addition to repository.  They will be added in next commit.\n"
     "usage: add PATH...\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>opt_targets</name></expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr>'q'</expr>, <expr><name>opt_force</name></expr>, <expr><name>opt_no_ignore</name></expr>, <expr><name>opt_autoprops</name></expr>,
     <expr><name>opt_no_autoprops</name></expr>, <expr><name>opt_parents</name></expr> }</block></expr>,
     <expr><block>{<expr><block>{<expr><name>opt_parents</name></expr>, <macro><name>N_</name><argument_list>(<argument>"add intermediate parents"</argument>)</argument_list></macro>}</block></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"blame"</expr>, <expr><name>svn_cl__blame</name></expr>, <expr><block>{<expr>"praise"</expr>, <expr>"annotate"</expr>, <expr>"ann"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Output the content of specified files or\n"
     "URLs with revision and author information in-line.\n"
     "usage: blame TARGET[@REV]...\n"
     "\n"
     "  If specified, REV determines in which revision the target is first\n"
     "  looked up.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'v'</expr>, <expr>'g'</expr>, <expr><name>opt_incremental</name></expr>, <expr><name>opt_xml</name></expr>, <expr>'x'</expr>, <expr><name>opt_force</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"cat"</expr>, <expr><name>svn_cl__cat</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Output the content of specified files or URLs.\n"
     "usage: cat TARGET[@REV]...\n"
     "\n"
     "  If specified, REV determines in which revision the target is first\n"
     "  looked up.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"changelist"</expr>, <expr><name>svn_cl__changelist</name></expr>, <expr><block>{<expr>"cl"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Associate (or dissociate) changelist CLNAME with the named files.\n"
     "usage: 1. changelist CLNAME TARGET...\n"
     "       2. changelist --remove TARGET...\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{ <expr>'q'</expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_remove</name></expr>, <expr><name>opt_targets</name></expr>, <expr><name>opt_changelist</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"checkout"</expr>, <expr><name>svn_cl__checkout</name></expr>, <expr><block>{<expr>"co"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Check out a working copy from a repository.\n"
     "usage: checkout URL[@REV]... [PATH]\n"
     "\n"
     "  If specified, REV determines in which revision the URL is first\n"
     "  looked up.\n"
     "\n"
     "  If PATH is omitted, the basename of the URL will be used as\n"
     "  the destination. If multiple URLs are given each will be checked\n"
     "  out into a sub-directory of PATH, with the name of the sub-directory\n"
     "  being the basename of the URL.\n"
     "\n"
     "  If --force is used, unversioned obstructing paths in the working\n"
     "  copy destination do not automatically cause the check out to fail.\n"
     "  If the obstructing path is the same type (file or directory) as the\n"
     "  corresponding path in the repository it becomes versioned but its\n"
     "  contents are left 'as-is' in the working copy.  This means that an\n"
     "  obstructing directory's unversioned children may also obstruct and\n"
     "  become versioned.  For files, any content differences between the\n"
     "  obstruction and the repository are treated like a local modification\n"
     "  to the working copy.  All properties from the repository are applied\n"
     "  to the obstructing path.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'q'</expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_force</name></expr>, <expr><name>opt_ignore_externals</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"cleanup"</expr>, <expr><name>svn_cl__cleanup</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Recursively clean up the working copy, removing locks, resuming\n"
     "unfinished operations, etc.\n"
     "usage: cleanup [PATH...]\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>opt_merge_cmd</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"commit"</expr>, <expr><name>svn_cl__commit</name></expr>, <expr><block>{<expr>"ci"</expr>}</block></expr>,
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
    <expr><call><name>N_</name><argument_list>(<argument><expr>"Send changes from your working copy to the repository.\n"
       "usage: commit [PATH...]\n"
       "\n"
       "  A log message must be provided, but it can be empty.  If it is not\n"
       "  given by a --message or --file option, an editor will be started.\n"
       "  If any targets are (or contain) locked items, those will be\n"
       "  unlocked after a successful commit.\n"</expr></argument>)</argument_list></call></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr><call><name>N_</name><argument_list>(<argument><expr>"Send changes from your working copy to the repository.\n"
       "usage: commit [PATH...]\n"
       "\n"
       "  A log message must be provided, but it can be empty.\n"
       "  OS400 does not support the starting of an editor,\n"
       "  so --message or --file must be used. If any targets are\n"
       "  (or contain) locked items, those will be unlocked after a\n"
       "  successful commit.\n"</expr></argument>)</argument_list></call></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><block>{<expr>'q'</expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_targets</name></expr>, <expr><name>opt_no_unlock</name></expr>, <expr><name>SVN_CL__LOG_MSG_OPTIONS</name></expr>,
     <expr><name>opt_changelist</name></expr>, <expr><name>opt_keep_changelists</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"copy"</expr>, <expr><name>svn_cl__copy</name></expr>, <expr><block>{<expr>"cp"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Duplicate something in working copy or repository, remembering\n"
     "history.\n"
     "usage: copy SRC[@REV]... DST\n"
     "\n"
     "When copying multiple sources, they will be added as children of DST,\n"
     "which must be a directory.\n"
     "\n"
     "  SRC and DST can each be either a working copy (WC) path or URL:\n"
     "    WC  -&gt; WC:   copy and schedule for addition (with history)\n"
     "    WC  -&gt; URL:  immediately commit a copy of WC to URL\n"
     "    URL -&gt; WC:   check out URL into WC, schedule for addition\n"
     "    URL -&gt; URL:  complete server-side copy;  used to branch and tag\n"
     "  All the SRCs must be of the same type.\n"
     "\n"
     "WARNING: For compatibility with previous versions of Subversion,\n"
     "copies performed using two working copy paths (WC -&gt; WC) will not\n"
     "contact the repository.  As such, they may not, by default, be able\n"
     "to propagate merge tracking information from the source of the copy\n"
     "to the destination.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'q'</expr>, <expr><name>opt_parents</name></expr>, <expr><name>SVN_CL__LOG_MSG_OPTIONS</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"delete"</expr>, <expr><name>svn_cl__delete</name></expr>, <expr><block>{<expr>"del"</expr>, <expr>"remove"</expr>, <expr>"rm"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Remove files and directories from version control.\n"
     "usage: 1. delete PATH...\n"
     "       2. delete URL...\n"
     "\n"
     "  1. Each item specified by a PATH is scheduled for deletion upon\n"
     "    the next commit.  Files, and directories that have not been\n"
     "    committed, are immediately removed from the working copy\n"
     "    unless the --keep-local option is given.\n"
     "    PATHs that are, or contain, unversioned or modified items will\n"
     "    not be removed unless the --force option is given.\n"
     "\n"
     "  2. Each item specified by a URL is deleted from the repository\n"
     "    via an immediate commit.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>opt_force</name></expr>, <expr>'q'</expr>, <expr><name>opt_targets</name></expr>, <expr><name>SVN_CL__LOG_MSG_OPTIONS</name></expr>, <expr><name>opt_keep_local</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"diff"</expr>, <expr><name>svn_cl__diff</name></expr>, <expr><block>{<expr>"di"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Display the differences between two revisions or paths.\n"
     "usage: 1. diff [-c M | -r N[:M]] [TARGET[@REV]...]\n"
     "       2. diff [-r N[:M]] --old=OLD-TGT[@OLDREV] [--new=NEW-TGT[@NEWREV]] \\\n"
     "               [PATH...]\n"
     "       3. diff OLD-URL[@OLDREV] NEW-URL[@NEWREV]\n"
     "\n"
     "  1. Display the changes made to TARGETs as they are seen in REV between\n"
     "     two revisions.  TARGETs may be all working copy paths or all URLs.\n"
     "     If TARGETs are working copy paths, N defaults to BASE and M to the\n"
     "     working copy; if URLs, N must be specified and M defaults to HEAD.\n"
     "     The '-c M' option is equivalent to '-r N:M' where N = M-1.\n"
     "     Using '-c -M' does the reverse: '-r M:N' where N = M-1.\n"
     "\n"
     "  2. Display the differences between OLD-TGT as it was seen in OLDREV and\n"
     "     NEW-TGT as it was seen in NEWREV.  PATHs, if given, are relative to\n"
     "     OLD-TGT and NEW-TGT and restrict the output to differences for those\n"
     "     paths.  OLD-TGT and NEW-TGT may be working copy paths or URL[@REV].\n"
     "     NEW-TGT defaults to OLD-TGT if not specified.  -r N makes OLDREV default\n"
     "     to N, -r N:M makes OLDREV default to N and NEWREV default to M.\n"
     "\n"
     "  3. Shorthand for 'svn diff --old=OLD-URL[@OLDREV] --new=NEW-URL[@NEWREV]'\n"
     "\n"
     "  Use just 'svn diff' to display local modifications in a working copy.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'c'</expr>, <expr><name>opt_old_cmd</name></expr>, <expr><name>opt_new_cmd</name></expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_diff_cmd</name></expr>, <expr>'x'</expr>,
     <expr><name>opt_no_diff_deleted</name></expr>, <expr><name>opt_notice_ancestry</name></expr>, <expr><name>opt_summarize</name></expr>, <expr><name>opt_changelist</name></expr>, 
     <expr><name>opt_force</name></expr>, <expr><name>opt_xml</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"export"</expr>, <expr><name>svn_cl__export</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Create an unversioned copy of a tree.\n"
     "usage: 1. export [-r REV] URL[@PEGREV] [PATH]\n"
     "       2. export [-r REV] PATH1[@PEGREV] [PATH2]\n"
     "\n"
     "  1. Exports a clean directory tree from the repository specified by\n"
     "     URL, at revision REV if it is given, otherwise at HEAD, into\n"
     "     PATH. If PATH is omitted, the last component of the URL is used\n"
     "     for the local directory name.\n"
     "\n"
     "  2. Exports a clean directory tree from the working copy specified by\n"
     "     PATH1, at revision REV if it is given, otherwise at WORKING, into\n"
     "     PATH2.  If PATH2 is omitted, the last component of the PATH1 is used\n"
     "     for the local directory name. If REV is not specified, all local\n"
     "     changes will be preserved.  Files not under version control will\n"
     "     not be copied.\n"
     "\n"
     "  If specified, PEGREV determines in which revision the target is first\n"
     "  looked up.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'q'</expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_force</name></expr>, <expr><name>opt_native_eol</name></expr>, <expr><name>opt_ignore_externals</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"help"</expr>, <expr><name>svn_cl__help</name></expr>, <expr><block>{<expr>"?"</expr>, <expr>"h"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Describe the usage of this program or its subcommands.\n"
     "usage: help [SUBCOMMAND...]\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>,
  <comment type="block">/* This command is also invoked if we see option "--help", "-h" or "-?". */</comment>

  <expr><block>{ <expr>"import"</expr>, <expr><name>svn_cl__import</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Commit an unversioned file or tree into the repository.\n"
     "usage: import [PATH] URL\n"
     "\n"
     "  Recursively commit a copy of PATH to URL.\n"
     "  If PATH is omitted '.' is assumed.\n"
     "  Parent directories are created as necessary in the repository.\n"
     "  If PATH is a directory, the contents of the directory are added\n"
     "  directly under URL.\n"
     "  Unversionable items such as device files and pipes are ignored\n"
     "  if --force is specified.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'q'</expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_autoprops</name></expr>, <expr><name>opt_force</name></expr>, <expr><name>opt_no_autoprops</name></expr>,
     <expr><name>SVN_CL__LOG_MSG_OPTIONS</name></expr>, <expr><name>opt_no_ignore</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"info"</expr>, <expr><name>svn_cl__info</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Display information about a local or remote item.\n"
     "usage: info [TARGET[@REV]...]\n"
     "\n"
     "  Print information about each TARGET (default: '.')\n"
     "  TARGET may be either a working-copy path or URL.  If specified, REV\n"
     "  determines in which revision the target is first looked up.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_targets</name></expr>, <expr><name>opt_incremental</name></expr>, <expr><name>opt_xml</name></expr>, <expr><name>opt_changelist</name></expr>}</block></expr>
  }</block></expr>,

  <expr><block>{ <expr>"list"</expr>, <expr><name>svn_cl__list</name></expr>, <expr><block>{<expr>"ls"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"List directory entries in the repository.\n"
     "usage: list [TARGET[@REV]...]\n"
     "\n"
     "  List each TARGET file and the contents of each TARGET directory as\n"
     "  they exist in the repository.  If TARGET is a working copy path, the\n"
     "  corresponding repository URL will be used. If specified, REV determines\n"
     "  in which revision the target is first looked up.\n"
     "\n"
     "  The default TARGET is '.', meaning the repository URL of the current\n"
     "  working directory.\n"
     "\n"
     "  With --verbose, the following fields will be shown for each item:\n"
     "\n"
     "    Revision number of the last commit\n"
     "    Author of the last commit\n"
     "    If locked, the letter 'O'.  (Use 'svn info URL' to see details)\n"
     "    Size (in bytes)\n"
     "    Date and time of the last commit\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'v'</expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_incremental</name></expr>, <expr><name>opt_xml</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"lock"</expr>, <expr><name>svn_cl__lock</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Lock working copy paths or URLs in the repository, so that\n"
     "no other user can commit changes to them.\n"
     "usage: lock TARGET...\n"
     "\n"
     "  Use --force to steal the lock from another user or working copy.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{ <expr><name>opt_targets</name></expr>, <expr>'m'</expr>, <expr>'F'</expr>, <expr><name>opt_force_log</name></expr>, <expr><name>opt_encoding</name></expr>, <expr><name>opt_force</name></expr> }</block></expr>,
    <expr><block>{<expr><block>{<expr>'F'</expr>, <macro><name>N_</name><argument_list>(<argument>"read lock comment from file ARG"</argument>)</argument_list></macro>}</block></expr>,
     <expr><block>{<expr>'m'</expr>, <macro><name>N_</name><argument_list>(<argument>"specify lock comment ARG"</argument>)</argument_list></macro>}</block></expr>,
     <expr><block>{<expr><name>opt_force_log</name></expr>, <macro><name>N_</name><argument_list>(<argument>"force validity of lock comment source"</argument>)</argument_list></macro>}</block></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"log"</expr>, <expr><name>svn_cl__log</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Show the log messages for a set of revision(s) and/or file(s).\n"
     "usage: 1. log [PATH]\n"
     "       2. log URL[@REV] [PATH...]\n"
     "\n"
     "  1. Print the log messages for a local PATH (default: '.').\n"
     "     The default revision range is BASE:1.\n"
     "\n"
     "  2. Print the log messages for the PATHs (default: '.') under URL.\n"
     "     If specified, REV determines in which revision the URL is first\n"
     "     looked up, and the default revision range is REV:1; otherwise,\n"
     "     the URL is looked up in HEAD, and the default revision range is\n"
     "     HEAD:1.\n"
     "\n"
     "  With -v, also print all affected paths with each log message.\n"
     "  With -q, don't print the log message body itself (note that this is\n"
     "  compatible with -v).\n"
     "\n"
     "  Each log message is printed just once, even if more than one of the\n"
     "  affected paths for that revision were explicitly requested.  Logs\n"
     "  follow copy history by default.  Use --stop-on-copy to disable this\n"
     "  behavior, which can be useful for determining branchpoints.\n"
     "\n"
     "  Examples:\n"
     "    svn log\n"
     "    svn log foo.c\n"
     "    svn log http://www.example.com/repo/project/foo.c\n"
     "    svn log http://www.example.com/repo/project foo.c bar.c\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'q'</expr>, <expr>'v'</expr>, <expr>'g'</expr>, <expr>'c'</expr>, <expr><name>opt_targets</name></expr>, <expr><name>opt_stop_on_copy</name></expr>, <expr><name>opt_incremental</name></expr>,
     <expr><name>opt_xml</name></expr>, <expr>'l'</expr>, <expr><name>opt_with_all_revprops</name></expr>, <expr><name>opt_with_revprop</name></expr>}</block></expr>,
    <expr><block>{<expr><block>{<expr><name>opt_with_revprop</name></expr>, <macro><name>N_</name><argument_list>(<argument>"retrieve revision property ARG"</argument>)</argument_list></macro>}</block></expr>,
     <expr><block>{<expr>'c'</expr>, <macro><name>N_</name><argument_list>(<argument>"the change made by ARG"</argument>)</argument_list></macro>}</block></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"merge"</expr>, <expr><name>svn_cl__merge</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Apply the differences between two sources to a working copy path.\n"
     "usage: 1. merge sourceURL1[@N] sourceURL2[@M] [WCPATH]\n"
     "       2. merge sourceWCPATH1@N sourceWCPATH2@M [WCPATH]\n"
     "       3. merge [-c M[,N...] | -r N:M ...] SOURCE[@REV] [WCPATH]\n"
     "\n"
     "  1. In the first form, the source URLs are specified at revisions\n"
     "     N and M.  These are the two sources to be compared.  The revisions\n"
     "     default to HEAD if omitted.\n"
     "\n"
     "  2. In the second form, the URLs corresponding to the source working\n"
     "     copy paths define the sources to be compared.  The revisions must\n"
     "     be specified.\n"
     "\n"
     "  3. In the third form, SOURCE can be either a URL or a working copy\n"
     "     path (in which case its corresponding URL is used).  SOURCE (in\n"
     "     revision REV) is compared as it existed between revisions N and M\n"
     "     for each revision range provided.  If REV is not specified, HEAD\n"
     "     is assumed.  '-c M' is equivalent to '-r &lt;M-1&gt;:M', and '-c -M'\n"
     "     does the reverse: '-r M:&lt;M-1&gt;'.  If no revision ranges are\n"
     "     specified, the default range of 0:REV is used.  Multiple '-c'\n"
     "     and/or '-r' instances may be specified, and mixing of forward\n"
     "     and reverse ranges is allowed.\n"
     "\n"
     "  WCPATH is the working copy path that will receive the changes.\n"
     "  If WCPATH is omitted, a default value of '.' is assumed, unless\n"
     "  the sources have identical basenames that match a file within '.':\n"
     "  in which case, the differences will be applied to that file.\n"
     "\n"
     "  NOTE:  Subversion will only record metadata to track the merge\n"
     "  if the two sources are on the same line of history -- if the\n"
     "  first source is an ancestor of the second, or vice-versa.  This is\n"
     "  guaranteed to be the case when using the third form listed above.\n"
     "  The --ignore-ancestry option overrides this, forcing Subversion to\n"
     "  regard the sources as unrelated and not to track the merge.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'c'</expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr>'q'</expr>, <expr><name>opt_force</name></expr>, <expr><name>opt_dry_run</name></expr>, <expr><name>opt_merge_cmd</name></expr>,
     <expr><name>opt_record_only</name></expr>, <expr>'x'</expr>, <expr><name>opt_ignore_ancestry</name></expr>, <expr><name>opt_accept</name></expr>, <expr><name>opt_reintegrate</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"mergeinfo"</expr>, <expr><name>svn_cl__mergeinfo</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Display merge-related information.\n"
     "usage: mergeinfo SOURCE[@REV] [TARGET[@REV]]\n"
     "\n"
     "  Display information related to merges (or potential merges) between\n"
     "  SOURCE and TARGET (default: '.').  If the --show-revs option\n"
     "  is not provided, display revisions which have been merged from\n"
     "  SOURCE to TARGET; otherwise, display the type of information\n"
     "  specified by the --show-revs option.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr><name>opt_show_revs</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"mkdir"</expr>, <expr><name>svn_cl__mkdir</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Create a new directory under version control.\n"
     "usage: 1. mkdir PATH...\n"
     "       2. mkdir URL...\n"
     "\n"
     "  Create version controlled directories.\n"
     "\n"
     "  1. Each directory specified by a working copy PATH is created locally\n"
     "    and scheduled for addition upon the next commit.\n"
     "\n"
     "  2. Each directory specified by a URL is created in the repository via\n"
     "    an immediate commit.\n"
     "\n"
     "  In both cases, all the intermediate directories must already exist,\n"
     "  unless the --parents option is given.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'q'</expr>, <expr><name>opt_parents</name></expr>, <expr><name>SVN_CL__LOG_MSG_OPTIONS</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"move"</expr>, <expr><name>svn_cl__move</name></expr>, <expr><block>{<expr>"mv"</expr>, <expr>"rename"</expr>, <expr>"ren"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Move and/or rename something in working copy or repository.\n"
     "usage: move SRC... DST\n"
     "\n"
     "When moving multiple sources, they will be added as children of DST,\n"
     "which must be a directory.\n"
     "\n"
     "  Note:  this subcommand is equivalent to a 'copy' and 'delete'.\n"
     "  Note:  the --revision option has no use and is deprecated.\n"
     "\n"
     "  SRC and DST can both be working copy (WC) paths or URLs:\n"
     "    WC  -&gt; WC:   move and schedule for addition (with history)\n"
     "    URL -&gt; URL:  complete server-side rename.\n"
     "  All the SRCs must be of the same type.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'q'</expr>, <expr><name>opt_force</name></expr>, <expr><name>opt_parents</name></expr>, <expr><name>SVN_CL__LOG_MSG_OPTIONS</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"propdel"</expr>, <expr><name>svn_cl__propdel</name></expr>, <expr><block>{<expr>"pdel"</expr>, <expr>"pd"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Remove a property from files, dirs, or revisions.\n"
     "usage: 1. propdel PROPNAME [PATH...]\n"
     "       2. propdel PROPNAME --revprop -r REV [TARGET]\n"
     "\n"
     "  1. Removes versioned props in working copy.\n"
     "  2. Removes unversioned remote prop on repos revision.\n"
     "     TARGET only determines which repository to access.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'q'</expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr>'r'</expr>, <expr><name>opt_revprop</name></expr>, <expr><name>opt_changelist</name></expr>}</block></expr> }</block></expr>,

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
  <expr><block>{ <expr>"propedit"</expr>, <expr><name>svn_cl__propedit</name></expr>, <expr><block>{<expr>"pedit"</expr>, <expr>"pe"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Edit a property with an external editor.\n"
     "usage: 1. propedit PROPNAME TARGET...\n"
     "       2. propedit PROPNAME --revprop -r REV [TARGET]\n"
     "\n"
     "  1. Edits versioned prop in working copy or repository.\n"
     "  2. Edits unversioned remote prop on repos revision.\n"
     "     TARGET only determines which repository to access.\n"
     "\n"
     "See 'svn help propset' for more on property setting.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr><name>opt_revprop</name></expr>, <expr><name>SVN_CL__LOG_MSG_OPTIONS</name></expr>, <expr><name>opt_force</name></expr>}</block></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr><block>{ <expr>"propget"</expr>, <expr><name>svn_cl__propget</name></expr>, <expr><block>{<expr>"pget"</expr>, <expr>"pg"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Print the value of a property on files, dirs, or revisions.\n"
     "usage: 1. propget PROPNAME [TARGET[@REV]...]\n"
     "       2. propget PROPNAME --revprop -r REV [TARGET]\n"
     "\n"
     "  1. Prints versioned props. If specified, REV determines in which\n"
     "     revision the target is first looked up.\n"
     "  2. Prints unversioned remote prop on repos revision.\n"
     "     TARGET only determines which repository to access.\n"
     "\n"
     "  By default, this subcommand will add an extra newline to the end\n"
     "  of the property values so that the output looks pretty.  Also,\n"
     "  whenever there are multiple paths involved, each property value\n"
     "  is prefixed with the path with which it is associated.  Use\n"
     "  the --strict option to disable these beautifications (useful,\n"
     "  for example, when redirecting binary property values to a file).\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr>'r'</expr>, <expr><name>opt_revprop</name></expr>, <expr><name>opt_strict</name></expr>, <expr><name>opt_xml</name></expr>, <expr><name>opt_changelist</name></expr> }</block></expr> }</block></expr>,

  <expr><block>{ <expr>"proplist"</expr>, <expr><name>svn_cl__proplist</name></expr>, <expr><block>{<expr>"plist"</expr>, <expr>"pl"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"List all properties on files, dirs, or revisions.\n"
     "usage: 1. proplist [TARGET[@REV]...]\n"
     "       2. proplist --revprop -r REV [TARGET]\n"
     "\n"
     "  1. Lists versioned props. If specified, REV determines in which\n"
     "     revision the target is first looked up.\n"
     "  2. Lists unversioned remote props on repos revision.\n"
     "     TARGET only determines which repository to access.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'v'</expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr>'r'</expr>, <expr>'q'</expr>, <expr><name>opt_revprop</name></expr>, <expr><name>opt_xml</name></expr>, <expr><name>opt_changelist</name></expr> }</block></expr> }</block></expr>,

  <expr><block>{ <expr>"propset"</expr>, <expr><name>svn_cl__propset</name></expr>, <expr><block>{<expr>"pset"</expr>, <expr>"ps"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Set the value of a property on files, dirs, or revisions.\n"
     "usage: 1. propset PROPNAME PROPVAL PATH...\n"
     "       2. propset PROPNAME --revprop -r REV PROPVAL [TARGET]\n"
     "\n"
     "  1. Creates a versioned, local propchange in working copy.\n"
     "  2. Creates an unversioned, remote propchange on repos revision.\n"
     "     TARGET only determines which repository to access.\n"
     "\n"
     "  The value may be provided with the --file option instead of PROPVAL.\n"
     "\n"
     "  Note: svn recognizes the following special versioned properties\n"
     "  but will store any arbitrary properties set:\n"
     "    svn:ignore     - A newline separated list of file patterns to ignore.\n"
     "    svn:keywords   - Keywords to be expanded.  Valid keywords are:\n"
     "      URL, HeadURL             - The URL for the head version of the object.\n"
     "      Author, LastChangedBy    - The last person to modify the file.\n"
     "      Date, LastChangedDate    - The date/time the object was last modified.\n"
     "      Rev, Revision,           - The last revision the object changed.\n"
     "      LastChangedRevision\n"
     "      Id                       - A compressed summary of the previous\n"
     "                                   4 keywords.\n"
     "    svn:executable - If present, make the file executable.  Use\n"
     "      'svn propdel svn:executable PATH...' to clear.\n"
     "    svn:eol-style  - One of 'native', 'LF', 'CR', 'CRLF'.\n"
     "    svn:mime-type  - The mimetype of the file.  Used to determine\n"
     "      whether to merge the file, and how to serve it from Apache.\n"
     "      A mimetype beginning with 'text/' (or an absent mimetype) is\n"
     "      treated as text.  Anything else is treated as binary.\n"
     "    svn:externals  - A newline separated list of module specifiers,\n"
     "      each of which consists of a relative directory path, optional\n"
     "      revision flags and an URL.  The ordering of the three elements\n"
     "      implements different behavior.  Subversion 1.4 and earlier only\n"
     "      support the following formats and the URLs cannot have peg\n"
     "      revisions:\n"
     "        foo             http://example.com/repos/zig\n"
     "        foo/bar -r 1234 http://example.com/repos/zag\n"
     "      Subversion 1.5 and greater support the above formats and the\n"
     "      following formats where the URLs may have peg revisions:\n"
     "                http://example.com/repos/zig foo\n"
     "        -r 1234 http://example.com/repos/zig foo/bar\n"
     "      Relative URLs are supported in Subversion 1.5 and greater for\n"
     "      all above formats and are indicated by starting the URL with one\n"
     "      of the following strings\n"
     "        ../  to the parent directory of the extracted external\n"
     "        ^/   to the repository root\n"
     "        //   to the scheme\n"
     "        /    to the server root\n"
     "      The ambiguous format 'relative_path relative_path' is taken as\n"
     "      'relative_url relative_path' with peg revision support.\n"
     "    svn:needs-lock - If present, indicates that the file should be locked\n"
     "      before it is modified.  Makes the working copy file read-only\n"
     "      when it is not locked.  Use 'svn propdel svn:needs-lock PATH...'\n"
     "      to clear.\n"
     "\n"
     "  The svn:keywords, svn:executable, svn:eol-style, svn:mime-type and\n"
     "  svn:needs-lock properties cannot be set on a directory.  A non-recursive\n"
     "  attempt will fail, and a recursive attempt will set the property\n"
     "  only on the file children of the directory.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'F'</expr>, <expr><name>opt_encoding</name></expr>, <expr>'q'</expr>, <expr>'r'</expr>, <expr><name>opt_targets</name></expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_revprop</name></expr>, 
     <expr><name>opt_force</name></expr>, <expr><name>opt_changelist</name></expr> }</block></expr>,
    <expr><block>{<expr><block>{<expr>'F'</expr>, <macro><name>N_</name><argument_list>(<argument>"read property value from file ARG"</argument>)</argument_list></macro>}</block></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"resolve"</expr>, <expr><name>svn_cl__resolve</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Resolve conflicts on working copy files or directories.\n"
     "usage: resolve [PATH...]\n"
     "\n"
     "  Note:  the --accept option is currently required.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>opt_targets</name></expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr>'q'</expr>, <expr><name>opt_accept</name></expr>}</block></expr>,
    <expr><block>{<expr><block>{<expr><name>opt_accept</name></expr>, <macro><name>N_</name><argument_list>(<argument>"specify automatic conflict resolution source\n"
                             "                            "
                             "('base', 'working', 'mine-full', 'theirs-full')"</argument>)</argument_list></macro>}</block></expr>}</block></expr> }</block></expr>,
                             <comment type="block">/* 'mine-conflict' and 'theirs-conflict' are
			        not implemented yet, so don't waste
			        the user's time with them. */</comment>

  <expr><block>{ <expr>"resolved"</expr>, <expr><name>svn_cl__resolved</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Remove 'conflicted' state on working copy files or directories.\n"
     "usage: resolved PATH...\n"
     "\n"
     "  Note:  this subcommand does not semantically resolve conflicts or\n"
     "  remove conflict markers; it merely removes the conflict-related\n"
     "  artifact files and allows PATH to be committed again.  It has been\n"
     "  deprecated in favor of running 'svn resolve --accept working'.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>opt_targets</name></expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr>'q'</expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"revert"</expr>, <expr><name>svn_cl__revert</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Restore pristine working copy file (undo most local edits).\n"
     "usage: revert PATH...\n"
     "\n"
     "  Note:  this subcommand does not require network access, and resolves\n"
     "  any conflicted states.  However, it does not restore removed directories.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>opt_targets</name></expr>, <expr>'R'</expr>, <expr><name>opt_depth</name></expr>, <expr>'q'</expr>, <expr><name>opt_changelist</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"status"</expr>, <expr><name>svn_cl__status</name></expr>, <expr><block>{<expr>"stat"</expr>, <expr>"st"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Print the status of working copy files and directories.\n"
     "usage: status [PATH...]\n"
     "\n"
     "  With no args, print only locally modified items (no network access).\n"
     "  With -q, print only summary information about locally modified items.\n"
     "  With -u, add working revision and server out-of-date information.\n"
     "  With -v, print full revision information on every item.\n"
     "\n"
     "  The first six columns in the output are each one character wide:\n"
     "    First column: Says if item was added, deleted, or otherwise changed\n"
     "      ' ' no modifications\n"
     "      'A' Added\n"
     "      'C' Conflicted\n"
     "      'D' Deleted\n"
     "      'I' Ignored\n"
     "      'M' Modified\n"
     "      'R' Replaced\n"
     "      'X' item is unversioned, but is used by an externals definition\n"
     "      '?' item is not under version control\n"
     "      '!' item is missing (removed by non-svn command) or incomplete\n"
     "      '~' versioned item obstructed by some item of a different kind\n"
     "    Second column: Modifications of a file's or directory's properties\n"
     "      ' ' no modifications\n"
     "      'C' Conflicted\n"
     "      'M' Modified\n"
     "    Third column: Whether the working copy directory is locked\n"
     "      ' ' not locked\n"
     "      'L' locked\n"
     "    Fourth column: Scheduled commit will contain addition-with-history\n"
     "      ' ' no history scheduled with commit\n"
     "      '+' history scheduled with commit\n"
     "    Fifth column: Whether the item is switched relative to its parent\n"
     "      ' ' normal\n"
     "      'S' switched\n"
     "    Sixth column: Repository lock token\n"
     "      (without -u)\n"
     "      ' ' no lock token\n"
     "      'K' lock token present\n"
     "      (with -u)\n"
     "      ' ' not locked in repository, no lock token\n"
     "      'K' locked in repository, lock toKen present\n"
     "      'O' locked in repository, lock token in some Other working copy\n"
     "      'T' locked in repository, lock token present but sTolen\n"
     "      'B' not locked in repository, lock token present but Broken\n"
     "\n"
     "  The out-of-date information appears in the eighth column (with -u):\n"
     "      '*' a newer revision exists on the server\n"
     "      ' ' the working copy is up to date\n"
     "\n"
     "  Remaining fields are variable width and delimited by spaces:\n"
     "    The working revision (with -u or -v)\n"
     "    The last committed revision and last committed author (with -v)\n"
     "    The working copy path is always the final field, so it can\n"
     "      include spaces.\n"
     "\n"
     "  Example output:\n"
     "    svn status wc\n"
     "     M     wc/bar.c\n"
     "    A  +   wc/qax.c\n"
     "\n"
     "    svn status -u wc\n"
     "     M           965    wc/bar.c\n"
     "           *     965    wc/foo.c\n"
     "    A  +         965    wc/qax.c\n"
     "    Status against revision:   981\n"
     "\n"
     "    svn status --show-updates --verbose wc\n"
     "     M           965       938 kfogel       wc/bar.c\n"
     "           *     965       922 sussman      wc/foo.c\n"
     "    A  +         965       687 joe          wc/qax.c\n"
     "                 965       687 joe          wc/zig.c\n"
     "    Status against revision:   981\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{ <expr>'u'</expr>, <expr>'v'</expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr>'q'</expr>, <expr><name>opt_no_ignore</name></expr>, <expr><name>opt_incremental</name></expr>, <expr><name>opt_xml</name></expr>,
      <expr><name>opt_ignore_externals</name></expr>, <expr><name>opt_changelist</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"switch"</expr>, <expr><name>svn_cl__switch</name></expr>, <expr><block>{<expr>"sw"</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Update the working copy to a different URL.\n"
     "usage: 1. switch URL[@PEGREV] [PATH]\n"
     "       2. switch --relocate FROM TO [PATH...]\n"
     "\n"
     "  1. Update the working copy to mirror a new URL within the repository.\n"
     "     This behaviour is similar to 'svn update', and is the way to\n"
     "     move a working copy to a branch or tag within the same repository.\n"
     "     If specified, PEGREV determines in which revision the target is first\n"
     "     looked up.\n"
     "\n"
     "     If --force is used, unversioned obstructing paths in the working\n"
     "     copy do not automatically cause a failure if the switch attempts to\n"
     "     add the same path.  If the obstructing path is the same type (file\n"
     "     or directory) as the corresponding path in the repository it becomes\n"
     "     versioned but its contents are left 'as-is' in the working copy.\n"
     "     This means that an obstructing directory's unversioned children may\n"
     "     also obstruct and become versioned.  For files, any content differences\n"
     "     between the obstruction and the repository are treated like a local\n"
     "     modification to the working copy.  All properties from the repository\n"
     "     are applied to the obstructing path.\n"
     "\n"
     "     Use the --set-depth option to set a new working copy depth on the\n"
     "     targets of this operation.  Currently, the depth of a working copy\n"
     "     directory can only be increased (telescoped more deeply); you cannot\n"
     "     make a directory more shallow.\n"
     "\n"
     "  2. Rewrite working copy URL metadata to reflect a syntactic change only.\n"
     "     This is used when repository's root URL changes (such as a scheme\n"
     "     or hostname change) but your working copy still reflects the same\n"
    "     directory within the same repository.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{ <expr>'r'</expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_set_depth</name></expr>, <expr>'q'</expr>, <expr><name>opt_merge_cmd</name></expr>, <expr><name>opt_relocate</name></expr>, 
      <expr><name>opt_ignore_externals</name></expr>, <expr><name>opt_force</name></expr>, <expr><name>opt_accept</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr>"unlock"</expr>, <expr><name>svn_cl__unlock</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Unlock working copy paths or URLs.\n"
     "usage: unlock TARGET...\n"
     "\n"
     "  Use --force to break the lock.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{ <expr><name>opt_targets</name></expr>, <expr><name>opt_force</name></expr> }</block></expr> }</block></expr>,

  <expr><block>{ <expr>"update"</expr>, <expr><name>svn_cl__update</name></expr>, <expr><block>{<expr>"up"</expr>}</block></expr>,  <expr><call><name>N_</name>
    <argument_list>(<argument><expr>"Bring changes from the repository into the working copy.\n"
     "usage: update [PATH...]\n"
     "\n"
     "  If no revision given, bring working copy up-to-date with HEAD rev.\n"
     "  Else synchronize working copy to revision given by -r.\n"
     "\n"
     "  For each updated item a line will start with a character reporting the\n"
     "  action taken.  These characters have the following meaning:\n"
     "\n"
     "    A  Added\n"
     "    D  Deleted\n"
     "    U  Updated\n"
     "    C  Conflict\n"
     "    G  Merged\n"
     "    E  Existed\n"
     "\n"
     "  A character in the first column signifies an update to the actual file,\n"
     "  while updates to the file's properties are shown in the second column.\n"
     "  A 'B' in the third column signifies that the lock for the file has\n"
     "  been broken or stolen.\n"
     "\n"
     "  If --force is used, unversioned obstructing paths in the working\n"
     "  copy do not automatically cause a failure if the update attempts to\n"
     "  add the same path.  If the obstructing path is the same type (file\n"
     "  or directory) as the corresponding path in the repository it becomes\n"
     "  versioned but its contents are left 'as-is' in the working copy.\n"
     "  This means that an obstructing directory's unversioned children may\n"
     "  also obstruct and become versioned.  For files, any content differences\n"
     "  between the obstruction and the repository are treated like a local\n"
     "  modification to the working copy.  All properties from the repository\n"
     "  are applied to the obstructing path.  Obstructing paths are reported\n"
     "  in the first column with code 'E'.\n"
     "\n"
     "  Use the --set-depth option to set a new working copy depth on the\n"
     "  targets of this operation.  Currently, the depth of a working copy\n"
     "  directory can only be increased (telescoped more deeply); you cannot\n"
     "  make a directory more shallow.\n"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr>'r'</expr>, <expr>'N'</expr>, <expr><name>opt_depth</name></expr>, <expr><name>opt_set_depth</name></expr>, <expr>'q'</expr>, <expr><name>opt_merge_cmd</name></expr>, <expr><name>opt_force</name></expr>, 
     <expr><name>opt_ignore_externals</name></expr>, <expr><name>opt_changelist</name></expr>, <expr><name>opt_editor_cmd</name></expr>, <expr><name>opt_accept</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Version compatibility check */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_lib_versions</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_version_checklist_t</name></type> <name><name>checklist</name><index>[]</index></name> <init>=
    <expr><block>{
      <expr><block>{ <expr>"svn_subr"</expr>,   <expr><name>svn_subr_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_client"</expr>, <expr><name>svn_client_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_wc"</expr>,     <expr><name>svn_wc_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_ra"</expr>,     <expr><name>svn_ra_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_delta"</expr>,  <expr><name>svn_delta_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_diff"</expr>,   <expr><name>svn_diff_version</name></expr> }</block></expr>,
      <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_VERSION_DEFINE</name><argument_list>(<argument><expr><name>my_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_ver_check_list</name><argument_list>(<argument><expr>&amp;<name>my_version</name></expr></argument>, <argument><expr><name>checklist</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* A flag to see if we've been cancelled by the client or not. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>cancelled</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* A signal handler to support cancellation. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_handler</name><parameter_list>(<param><decl><type><name>int</name></type> <name>signum</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cancelled</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Our cancellation callback. */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_cl__check_cancel</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>cancelled</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CANCELLED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Caught signal"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></else></if>
}</block></function>


<comment type="block">/* Parse REVPROP_PAIR as name[=value], adding it to *revprop_table_p, using
 * POOL for all allocations.  *REVPROP_TABLE_P may be NULL, in which case
 * it is created.. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>parse_revprop</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>revprop_table_p</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>revprop_pair</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl>, *<decl><type ref="prev"/><name>propname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>propval</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! *<name>revprop_pair</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Revision property pair is empty"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr>! *<name>revprop_table_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>revprop_table_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>sep</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>revprop_pair</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>sep</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>propname</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>revprop_pair</name></expr></argument>, <argument><expr><name>sep</name> - <name>revprop_pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>propname</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>propval</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><name>sep</name> + 1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>propname</name></expr></argument>, <argument><expr><name>revprop_pair</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>propval</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr>!<call><name>svn_prop_name_is_valid</name><argument_list>(<argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_PROPERTY_NAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a valid Subversion property name"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>revprop_table_p</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>propval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Main. ***/</comment>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>opt_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_cl__opt_state_t</name></type> <name>opt_state</name> <init>= <expr><block>{ <expr>0</expr>, <expr><block>{ <expr>0</expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>received_opts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name> *</type><name>subcommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dash_m_arg</name> <init>= <expr><name>NULL</name></expr></init>, *<name>dash_F_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_utf8</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_cl__cmd_baton_t</name></type> <name>command_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_auth_baton_t</name> *</type><name>ab</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>descend</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>interactive_conflicts</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changelists</name></decl>;</decl_stmt>

  <comment type="block">/* Initialize the app. */</comment>
  <if>if <condition>(<expr><call><name>svn_cmdline_init</name><argument_list>(<argument><expr>"svn"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call> != <name>EXIT_SUCCESS</name></expr>)</condition><then>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></then></if>

  <comment type="block">/* Create our top-level pool.  Use a seperate mutexless allocator,
   * given this application is single threaded.
   */</comment>
  <if>if <condition>(<expr><call><name>apr_allocator_create</name><argument_list>(<argument><expr>&amp;<name>allocator</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>apr_allocator_max_free_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>SVN_ALLOCATOR_RECOMMENDED_MAX_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pool</name> = <call><name>svn_pool_create_ex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_allocator_owner_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>received_opts</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_OPT_MAX_OPTIONS</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check library versions */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>check_lib_versions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Set the working copy administrative directory name. */</comment>
  <if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr>"SVN_ASP_DOT_NET_HACK"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_wc_set_adm_dir</name><argument_list>(<argument><expr>"_svn"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Initialize the RA library. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_ra_initialize</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Init our changelists hash. */</comment>
  <expr_stmt><expr><name>changelists</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Begin processing arguments. */</comment>
  <expr_stmt><expr><name><name>opt_state</name>.<name>start_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>end_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>revision_ranges</name></name> =
    <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>depth</name></name> = <name>svn_depth_unknown</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>set_depth</name></name> = <name>svn_depth_unknown</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>accept_which</name></name> = <name>svn_cl__accept_unspecified</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>show_revs</name></name> = <name>svn_cl__show_revs_merged</name></expr>;</expr_stmt>

  <comment type="block">/* No args?  Show usage. */</comment>
  <if>if <condition>(<expr><name>argc</name> &lt;= 1</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_cl__help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Else, parse options. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_cmdline__getopt_init</name><argument_list>(<argument><expr>&amp;<name>os</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>os</name>-&gt;<name>interleave</name></name> = 1</expr>;</expr_stmt>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>opt_arg</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>utf8_opt_arg</name></decl>;</decl_stmt>

      <comment type="block">/* Parse the next option. */</comment>
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_getopt_long</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><name>svn_cl__options</name></expr></argument>, <argument><expr>&amp;<name>opt_id</name></expr></argument>, <argument><expr>&amp;<name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then>
      <else>else <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_cl__help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then></if></else></if>

      <comment type="block">/* Stash the option code in an array before parsing it. */</comment>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>received_opts</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call> = <name>opt_id</name></expr>;</expr_stmt>

      <switch>switch <condition>(<expr><name>opt_id</name></expr>)</condition> <block>{
      <case>case <expr>'l'</expr>:
        <block>{
          <decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>opt_state</name>.<name>limit</name></name> = <call><name>strtol</name><argument_list>(<argument><expr><name>opt_arg</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>end</name> == <name>opt_arg</name> || *<name>end</name> != '\0'</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Non-numeric limit argument given"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
          <if>if <condition>(<expr><name><name>opt_state</name>.<name>limit</name></name> &lt;= 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Argument to --limit must be positive"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block>
        <break>break;</break>
      </case><case>case <expr>'m'</expr>:
        <comment type="block">/* Note that there's no way here to detect if the log message
           contains a zero byte -- if it does, then opt_arg will just
           be shorter than the user intended.  Oh well. */</comment>
        <expr_stmt><expr><name><name>opt_state</name>.<name>message</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dash_m_arg</name> = <name>opt_arg</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'c'</expr>:
        <block>{
          <decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>changeno</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_opt_revision_range_t</name> *</type><name>range</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>change_revs</name> <init>= 
            <expr><call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>opt_arg</name></expr></argument>, <argument><expr>", \n\r\t\v"</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name><name>opt_state</name>.<name>old_target</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name>
                <argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't specify -c with --old"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

          <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>change_revs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>change_str</name> <init>= 
                <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>change_revs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <comment type="block">/* Allow any number of 'r's to prefix a revision number.
                 ### TODO: Any reason we're not just using opt.c's
                 ### revision-parsing code here?  Then -c could take
                 ### "{DATE}" and the special words. */</comment> 
              <while>while <condition>(<expr>*<name>change_str</name> == 'r'</expr>)</condition>
                <expr_stmt><expr><name>change_str</name>++</expr>;</expr_stmt></while>
              <expr_stmt><expr><name>changeno</name> = <call><name>strtol</name><argument_list>(<argument><expr><name>change_str</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>end</name> == <name>change_str</name> || *<name>end</name> != '\0'</expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>err</name> = <call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Non-numeric change argument (%s) "
                                            "given to -c"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>change_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>

              <if>if <condition>(<expr><name>changeno</name> == 0</expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"There is no change 0"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>

              <comment type="block">/* Figure out the range:
                    -c N  -&gt; -r N-1:N
                    -c -N -&gt; -r N:N-1 */</comment>
              <expr_stmt><expr><name>range</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>changeno</name> &gt; 0</expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>value</name>.<name>number</name></name> = <name>changeno</name> - 1</expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>value</name>.<name>number</name></name> = <name>changeno</name></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><name>changeno</name> = -<name>changeno</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>value</name>.<name>number</name></name> = <name>changeno</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>value</name>.<name>number</name></name> = <name>changeno</name> - 1</expr>;</expr_stmt>
                }</block></else></if>
              <expr_stmt><expr><name><name>opt_state</name>.<name>used_change_arg</name></name> = <name>TRUE</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>opt_state</name>.<name>revision_ranges</name></name></expr></argument>,
                             <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
            }</block></for>
        }</block>
        <break>break;</break>
      </case><case>case <expr>'r'</expr>:
        <if>if <condition>(<expr><call><name>svn_opt_parse_revision_to_range</name><argument_list>(<argument><expr><name><name>opt_state</name>.<name>revision_ranges</name></name></expr></argument>,
                                            <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
          <block>{
            <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>utf8_opt_arg</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
              <expr_stmt><expr><name>err</name> = <call><name>svn_error_createf</name>
                <argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Syntax error in revision argument '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>utf8_opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
          }</block></then></if>
        <break>break;</break>
      </case><case>case <expr>'v'</expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>verbose</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'u'</expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>update</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'h'</expr>:
      </case><case>case <expr>'?'</expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>help</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'q'</expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>quiet</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_incremental</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>incremental</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'F'</expr>:
        <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>utf8_opt_arg</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
          <expr_stmt><expr><name>err</name> = <call><name>svn_stringbuf_from_file</name><argument_list>(<argument><expr>&amp;(<name><name>opt_state</name>.<name>filedata</name></name>)</expr></argument>,
                                        <argument><expr><name>utf8_opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <expr_stmt><expr><name>dash_F_arg</name> = <name>opt_arg</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_targets</name></expr>:
        <block>{
          <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>buffer</name></decl>, *<decl><type ref="prev"/><name>buffer_utf8</name></decl>;</decl_stmt>

          <comment type="block">/* We need to convert to UTF-8 now, even before we divide
             the targets into an array, because otherwise we wouldn't
             know what delimiter to use for svn_cstring_split().  */</comment>

          <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>utf8_opt_arg</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
            <expr_stmt><expr><name>err</name> = <call><name>svn_stringbuf_from_file</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr><name>utf8_opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
            <expr_stmt><expr><name>err</name> = <call><name>svn_utf_stringbuf_to_utf8</name><argument_list>(<argument><expr>&amp;<name>buffer_utf8</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
          <expr_stmt><expr><name><name>opt_state</name>.<name>targets</name></name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name><name>buffer_utf8</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>"\n\r"</expr></argument>,
                                                <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
        <break>break;</break>
      </case><case>case <expr><name>opt_force</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>force</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_force_log</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>force_log</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_dry_run</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>dry_run</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_revprop</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>revprop</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'R'</expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>depth</name></name> = <call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'N'</expr>:
        <expr_stmt><expr><name>descend</name> = <name>FALSE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_depth</name></expr>:
        <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>utf8_opt_arg</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name>
            <argument_list>(<argument><expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error converting depth "
                                 "from locale to UTF8"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <expr_stmt><expr><name><name>opt_state</name>.<name>depth</name></name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>utf8_opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>opt_state</name>.<name>depth</name></name> == <name>svn_depth_unknown</name>
            || <name><name>opt_state</name>.<name>depth</name></name> == <name>svn_depth_exclude</name></expr>)</condition><then>
          <block>{
            <return>return <expr><call><name>svn_cmdline_handle_exit_error</name>
              <argument_list>(<argument><expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a valid depth; try "
                                   "'empty', 'files', 'immediates', "
                                   "or 'infinity'"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>utf8_opt_arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
          }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_set_depth</name></expr>:
        <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>utf8_opt_arg</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name>
            <argument_list>(<argument><expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error converting depth "
                                 "from locale to UTF8"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <expr_stmt><expr><name><name>opt_state</name>.<name>set_depth</name></name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>utf8_opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>opt_state</name>.<name>set_depth</name></name> == <name>svn_depth_unknown</name>
            || <name><name>opt_state</name>.<name>set_depth</name></name> == <name>svn_depth_exclude</name></expr>)</condition><then>
          <block>{
            <return>return <expr><call><name>svn_cmdline_handle_exit_error</name>
              <argument_list>(<argument><expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a valid depth; try "
                                   "'empty', 'files', 'immediates', "
                                   "or 'infinity'"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>utf8_opt_arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
          }</block></then></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_version</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>version</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_auth_username</name></expr>:
        <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name><name>opt_state</name>.<name>auth_username</name></name></expr></argument>,
                                      <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_auth_password</name></expr>:
        <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name><name>opt_state</name>.<name>auth_password</name></name></expr></argument>,
                                      <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_encoding</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>encoding</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_xml</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>xml</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_stop_on_copy</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>stop_on_copy</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_strict</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>strict</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_no_ignore</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>no_ignore</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_no_auth_cache</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>no_auth_cache</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_non_interactive</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>non_interactive</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_no_diff_deleted</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>no_diff_deleted</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_notice_ancestry</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>notice_ancestry</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_ignore_ancestry</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>ignore_ancestry</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_ignore_externals</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>ignore_externals</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_relocate</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>relocate</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'x'</expr>:
        <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name><name>opt_state</name>.<name>extensions</name></name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_diff_cmd</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>diff_cmd</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_merge_cmd</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>merge_cmd</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_record_only</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>record_only</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_editor_cmd</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>editor_cmd</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_old_cmd</name></expr>:
        <if>if <condition>(<expr><name><name>opt_state</name>.<name>used_change_arg</name></name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name>
              <argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't specify -c with --old"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
          }</block></then></if>
        <expr_stmt><expr><name><name>opt_state</name>.<name>old_target</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_new_cmd</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>new_target</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_config_dir</name></expr>:
        <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>path_utf8</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>opt_state</name>.<name>config_dir</name></name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_autoprops</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>autoprops</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_no_autoprops</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>no_autoprops</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_native_eol</name></expr>:
        <if>if <condition>( <expr>!<call><name>strcmp</name><argument_list>(<argument><expr>"LF"</expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr>"CR"</expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call> ||
             !<call><name>strcmp</name><argument_list>(<argument><expr>"CRLF"</expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name><name>opt_state</name>.<name>native_eol</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
          <block>{
            <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>utf8_opt_arg</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
              <expr_stmt><expr><name>err</name> = <call><name>svn_error_createf</name>
                <argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Syntax error in native-eol argument '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>utf8_opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
          }</block></else></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_no_unlock</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>no_unlock</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_summarize</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>summarize</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_remove</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>remove</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_changelist</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>changelist</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>changelists</name></expr></argument>, <argument><expr><name><name>opt_state</name>.<name>changelist</name></name></expr></argument>,
                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>(<name>void</name> *)1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_keep_changelists</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>keep_changelists</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_keep_local</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>keep_local</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_with_all_revprops</name></expr>:
        <comment type="block">/* If --with-all-revprops is specified along with one or more
         * --with-revprops options, --with-all-revprops takes precedence. */</comment>
        <expr_stmt><expr><name><name>opt_state</name>.<name>all_revprops</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_with_revprop</name></expr>:
        <expr_stmt><expr><name>err</name> = <call><name>parse_revprop</name><argument_list>(<argument><expr>&amp;<name><name>opt_state</name>.<name>revprop_table</name></name></expr></argument>, <argument><expr><name>opt_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name> != <name>SVN_NO_ERROR</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_parents</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>parents</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr>'g'</expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>use_merge_history</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>opt_accept</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>accept_which</name></name> = <call><name>svn_cl__accept_from_word</name><argument_list>(<argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>opt_state</name>.<name>accept_which</name></name> == <name>svn_cl__accept_invalid</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name>
            <argument_list>(<argument><expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a valid --accept value"</expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_show_revs</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>show_revs</name></name> = <call><name>svn_cl__show_revs_from_word</name><argument_list>(<argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>opt_state</name>.<name>show_revs</name></name> == <name>svn_cl__show_revs_invalid</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name>
            <argument_list>(<argument><expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a valid --show-revs value"</expr></argument>)</argument_list></call></expr></argument>, 
                               <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        <break>break;</break>
      </case><case>case <expr><name>opt_reintegrate</name></expr>:
        <expr_stmt><expr><name><name>opt_state</name>.<name>reintegrate</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <comment type="block">/* Hmmm. Perhaps this would be a good place to squirrel away
           opts that commands like svn diff might need. Hmmm indeed. */</comment>
        <break>break;</break>
      </default>}</block></switch>
    }</block></while>

  <comment type="block">/* Turn our hash of changelists into an array of unique ones. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_hash_keys</name><argument_list>(<argument><expr>&amp;(<name><name>opt_state</name>.<name>changelists</name></name>)</expr></argument>, <argument><expr><name>changelists</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* ### This really belongs in libsvn_client.  The trouble is,
     there's no one place there to run it from, no
     svn_client_init().  We'd have to add it to all the public
     functions that a client might call.  It's unmaintainable to do
     initialization from within libsvn_client itself, but it seems
     burdensome to demand that all clients call svn_client_init()
     before calling any other libsvn_client function... On the other
     hand, the alternative is effectively to demand that they call
     svn_config_ensure() instead, so maybe we should have a generic
     init function anyway.  Thoughts?  */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_config_ensure</name><argument_list>(<argument><expr><name><name>opt_state</name>.<name>config_dir</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If the user asked for help, then the rest of the arguments are
     the names of subcommands to get help on (if any), or else they're
     just typos/mistakes.  Whatever the case, the subcommand to
     actually run is svn_cl__help(). */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>help</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>subcommand</name> = <call><name>svn_opt_get_canonical_subcommand2</name><argument_list>(<argument><expr><name>svn_cl__cmd_table</name></expr></argument>, <argument><expr>"help"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If we're not running the `help' subcommand, then look for a
     subcommand in the first argument. */</comment>
  <if>if <condition>(<expr><name>subcommand</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &gt;= <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>opt_state</name>.<name>version</name></name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Use the "help" subcommand to handle the "--version" option. */</comment>
              <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_opt_subcommand_desc2_t</name></type> <name>pseudo_cmd</name> <init>=
                <expr><block>{ <expr>"--version"</expr>, <expr><name>svn_cl__help</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr>""</expr>,
                  <expr><block>{<expr><name>opt_version</name></expr>,    <comment type="block">/* must accept its own option */</comment>
                   <expr>'q'</expr>,            <comment type="block">/* brief output */</comment>
                   <expr><name>opt_config_dir</name></expr>  <comment type="block">/* all commands accept this */</comment>
                  }</block></expr> }</block></expr></init></decl>;</decl_stmt>

              <expr_stmt><expr><name>subcommand</name> = &amp;<name>pseudo_cmd</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name>
                <argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Subcommand argument required\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_cl__help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
            }</block></else></if>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>first_arg</name> <init>= <expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>subcommand</name> = <call><name>svn_opt_get_canonical_subcommand2</name><argument_list>(<argument><expr><name>svn_cl__cmd_table</name></expr></argument>,
                                                         <argument><expr><name>first_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>subcommand</name> == <name>NULL</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>first_arg_utf8</name></decl>;</decl_stmt>
              <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>first_arg_utf8</name></expr></argument>, <argument><expr><name>first_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
              <expr_stmt><expr><call><name>svn_error_clear</name>
                <argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unknown command: '%s'\n"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>first_arg_utf8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_cl__help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* Check that the subcommand wasn't passed any inappropriate options. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>received_opts</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>opt_id</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>received_opts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* All commands implicitly accept --help, so just skip over this
         when we see it. Note that we don't want to include this option
         in their "accepted options" list because it would be awfully
         redundant to display it in every commands' help text. */</comment>
      <if>if <condition>(<expr><name>opt_id</name> == 'h' || <name>opt_id</name> == '?'</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr>! <call><name>svn_opt_subcommand_takes_option3</name><argument_list>(<argument><expr><name>subcommand</name></expr></argument>, <argument><expr><name>opt_id</name></expr></argument>,
                                             <argument><expr><name>svn_cl__global_options</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>optstr</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>badopt</name> <init>=
            <expr><call><name>svn_opt_get_option_from_code2</name><argument_list>(<argument><expr><name>opt_id</name></expr></argument>, <argument><expr><name>svn_cl__options</name></expr></argument>,
                                          <argument><expr><name>subcommand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>svn_opt_format_option</name><argument_list>(<argument><expr>&amp;<name>optstr</name></expr></argument>, <argument><expr><name>badopt</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>name</name><index>[<expr>0</expr>]</index></name> == '-'</expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_cl__help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_error_clear</name>
              <argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name>
               <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Subcommand '%s' doesn't accept option '%s'\n"
                                "Type 'svn help %s' for usage.\n"</expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>subcommand</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>optstr</name></expr></argument>, <argument><expr><name><name>subcommand</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Only merge supports multiple revisions/revision ranges. */</comment>
  <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>svn_cl__merge</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>opt_state</name>.<name>revision_ranges</name>-&gt;<name>nelts</name></name> &gt; 1</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Multiple revision arguments "
                                   "encountered; can't specify -c twice, "
                                   "or both -c and -r"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Merge doesn't support specifying a revision range
     when using --reintegrate. */</comment>
  <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__merge</name>
      &amp;&amp; <name><name>opt_state</name>.<name>revision_ranges</name>-&gt;<name>nelts</name></name>
      &amp;&amp; <name><name>opt_state</name>.<name>reintegrate</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"-r and -c can't be used with --reintegrate"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Disallow simultaneous use of both --depth and --set-depth. */</comment>
  <if>if <condition>(<expr>(<name><name>opt_state</name>.<name>depth</name></name> != <name>svn_depth_unknown</name>)
      &amp;&amp; (<name><name>opt_state</name>.<name>set_depth</name></name> != <name>svn_depth_unknown</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"--depth and --set-depth are mutually "
                               "exclusive"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Ensure that 'revision_ranges' has at least one item, and that
     'start_revision' and 'end_revision' match that item. */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>revision_ranges</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_opt_revision_range_t</name> *</type><name>range</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>opt_state</name>.<name>revision_ranges</name></name></expr></argument>,
                     <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
    }</block></then></if>
  <expr_stmt><expr><name><name>opt_state</name>.<name>start_revision</name></name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>opt_state</name>.<name>revision_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                           <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call>-&gt;<name>start</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>end_revision</name></name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>opt_state</name>.<name>revision_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                         <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call>-&gt;<name>end</name></expr>;</expr_stmt>

  <comment type="block">/* If we're running a command that could result in a commit, verify
     that any log message we were given on the command line makes
     sense (unless we've also been instructed not to care). */</comment>
  <if>if <condition>(<expr>(! <name><name>opt_state</name>.<name>force_log</name></name>)
      &amp;&amp; (<name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__commit</name>
          || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__copy</name>
          || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__delete</name>
          || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__import</name>
          || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__mkdir</name>
          || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__move</name>
          || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__lock</name>
          || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__propedit</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* If the -F argument is a file that's under revision control,
         that's probably not what the user intended. */</comment>
      <if>if <condition>(<expr><name>dash_F_arg</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>e</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname_utf8</name> <init>= <expr><call><name>svn_path_internal_style</name><argument_list>(<argument><expr><name>dash_F_arg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_probe_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fname_utf8</name></expr></argument>,
                                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
            <expr_stmt><expr><name>err</name> = <call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>e</name></expr></argument>, <argument><expr><name>fname_utf8</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr>(<name>err</name> == <name>SVN_NO_ERROR</name>) &amp;&amp; <name>e</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>svn_cl__lock</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name>
                    <argument_list>(<argument><expr><name>SVN_ERR_CL_LOG_MESSAGE_IS_VERSIONED_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Log message file is a versioned file; "
                       "use '--force-log' to override"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name>
                    <argument_list>(<argument><expr><name>SVN_ERR_CL_LOG_MESSAGE_IS_VERSIONED_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Lock comment file is a versioned file; "
                       "use '--force-log' to override"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
              <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* If the -m argument is a file at all, that's probably not what
         the user intended. */</comment>
      <if>if <condition>(<expr><name>dash_m_arg</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>dash_m_arg</name></expr></argument>,
                       <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>svn_cl__lock</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name>
                    <argument_list>(<argument><expr><name>SVN_ERR_CL_LOG_MESSAGE_IS_PATHNAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The log message is a pathname "
                       "(was -F intended?); use '--force-log' to override"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name>
                    <argument_list>(<argument><expr><name>SVN_ERR_CL_LOG_MESSAGE_IS_PATHNAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The lock comment is a pathname "
                       "(was -F intended?); use '--force-log' to override"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
              <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>opt_state</name>.<name>relocate</name></name> &amp;&amp; (<name><name>opt_state</name>.<name>depth</name></name> != <name>svn_depth_unknown</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"--relocate and --depth are mutually "
                               "exclusive"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Only a few commands can accept a revision range; the rest can take at
     most one revision number. */</comment>
  <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>svn_cl__blame</name>
      &amp;&amp; <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>svn_cl__diff</name>
      &amp;&amp; <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>svn_cl__log</name>
      &amp;&amp; <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>svn_cl__merge</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>opt_state</name>.<name>end_revision</name>.<name>kind</name></name> != <name>svn_opt_revision_unspecified</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_REVISION_RANGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* -N has a different meaning depending on the command */</comment>
  <if>if <condition>(<expr><name>descend</name> == <name>FALSE</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__status</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>opt_state</name>.<name>depth</name></name> = <call><name>SVN_DEPTH_INFINITY_OR_IMMEDIATES</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__revert</name>
               || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__add</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* In pre-1.5 Subversion, some commands treated -N like
             --depth=empty, so .  Also, with revert it makes sense to be
             especially conservative, since revert can lose data. */</comment>
          <expr_stmt><expr><name><name>opt_state</name>.<name>depth</name></name> = <name>svn_depth_empty</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name><name>opt_state</name>.<name>depth</name></name> = <call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></then></if>
  <comment type="block">/* Create a client context object. */</comment>
  <expr_stmt><expr><name><name>command_baton</name>.<name>opt_state</name></name> = &amp;<name>opt_state</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_client_create_context</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name><name>command_baton</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_config_get_config</name><argument_list>(<argument><expr>&amp;(<name><name>ctx</name>-&gt;<name>config</name></name>)</expr></argument>,
                              <argument><expr><name><name>opt_state</name>.<name>config_dir</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Fallback to default config if the config directory isn't readable. */</comment>
      <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>APR_EACCES</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_handle_warning</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></then></if>

  <expr_stmt><expr><name>cfg</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>SVN_CONFIG_CATEGORY_CONFIG</name></expr></argument>,
                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the options in the config */</comment>
  <comment type="block">/* XXX: Only diff_cmd for now, overlay rest later and stop passing
     opt_state altogether? */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>diff_cmd</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_config_set</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_HELPERS</name></expr></argument>,
                   <argument><expr><name>SVN_CONFIG_OPTION_DIFF_CMD</name></expr></argument>, <argument><expr><name><name>opt_state</name>.<name>diff_cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>merge_cmd</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_config_set</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_HELPERS</name></expr></argument>,
                   <argument><expr><name>SVN_CONFIG_OPTION_DIFF3_CMD</name></expr></argument>, <argument><expr><name><name>opt_state</name>.<name>merge_cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Check for mutually exclusive args --auto-props and --no-auto-props */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>autoprops</name></name> &amp;&amp; <name><name>opt_state</name>.<name>no_autoprops</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"--auto-props and --no-auto-props are "
                               "mutually exclusive"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* The --reintegrate option is mutually exclusive with both
     --ignore-ancestry and --record-only. */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>reintegrate</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>opt_state</name>.<name>ignore_ancestry</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>opt_state</name>.<name>record_only</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"--reintegrate cannot be used with "
                                       "--ignore-ancestry or "
                                       "--record-only"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"--reintegrate cannot be used with "
                                       "--ignore-ancestry"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>
          }</block></then>
      <else>else <if>if <condition>(<expr><name><name>opt_state</name>.<name>record_only</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"--reintegrate cannot be used with "
                                   "--record-only"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></else></if>
    }</block></then></if>

  <comment type="block">/* Update auto-props-enable option, and populate the MIME types map,
     for add/import commands */</comment>
  <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__add</name>
      || <name><name>subcommand</name>-&gt;<name>cmd_func</name></name> == <name>svn_cl__import</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetypes_file</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>mimetypes_file</name></expr></argument>,
                     <argument><expr><name>SVN_CONFIG_SECTION_MISCELLANY</name></expr></argument>,
                     <argument><expr><name>SVN_CONFIG_OPTION_MIMETYPES_FILE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mimetypes_file</name> &amp;&amp; *<name>mimetypes_file</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_io_parse_mimetypes_file</name><argument_list>(<argument><expr>&amp;(<name><name>ctx</name>-&gt;<name>mimetypes_map</name></name>)</expr></argument>,
                                                 <argument><expr><name>mimetypes_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>

      <if>if <condition>(<expr><name><name>opt_state</name>.<name>autoprops</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_config_set_bool</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_MISCELLANY</name></expr></argument>,
                              <argument><expr><name>SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <if>if <condition>(<expr><name><name>opt_state</name>.<name>no_autoprops</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_config_set_bool</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_MISCELLANY</name></expr></argument>,
                              <argument><expr><name>SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Update the 'keep-locks' runtime option */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>no_unlock</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_config_set_bool</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_MISCELLANY</name></expr></argument>,
                        <argument><expr><name>SVN_CONFIG_OPTION_NO_UNLOCK</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Set the log message callback function.  Note that individual
     subcommands will populate the ctx-&gt;log_msg_baton3. */</comment>
  <expr_stmt><expr><name><name>ctx</name>-&gt;<name>log_msg_func3</name></name> = <name>svn_cl__get_log_message</name></expr>;</expr_stmt>

  <comment type="block">/* Set up our cancellation support. */</comment>
  <expr_stmt><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name> = <name>svn_cl__check_cancel</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBREAK</name></cpp:ifdef>
  <comment type="block">/* SIGBREAK is a Win32 specific signal generated by ctrl-break. */</comment>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGBREAK</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGHUP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTERM</name></cpp:ifdef>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
  <comment type="block">/* Disable SIGPIPE generation for the platforms that have it. */</comment>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXFSZ</name></cpp:ifdef>
  <comment type="block">/* Disable SIGXFSZ generation for the platforms that have it, otherwise
   * working with large files when compiled against an APR that doesn't have
   * large file support will crash the program, which is uncool. */</comment>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Set up Authentication stuff. */</comment>
  <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_cmdline_setup_auth_baton</name><argument_list>(<argument><expr>&amp;<name>ab</name></expr></argument>,
                                          <argument><expr><name><name>opt_state</name>.<name>non_interactive</name></name></expr></argument>,
                                          <argument><expr><name><name>opt_state</name>.<name>auth_username</name></name></expr></argument>,
                                          <argument><expr><name><name>opt_state</name>.<name>auth_password</name></name></expr></argument>,
                                          <argument><expr><name><name>opt_state</name>.<name>config_dir</name></name></expr></argument>,
                                          <argument><expr><name><name>opt_state</name>.<name>no_auth_cache</name></name></expr></argument>,
                                          <argument><expr><name>cfg</name></expr></argument>,
                                          <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                          <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name><name>ctx</name>-&gt;<name>auth_baton</name></name> = <name>ab</name></expr>;</expr_stmt>

  <comment type="block">/* Set up conflict resolution callback. */</comment>
  <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_config_get_bool</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>interactive_conflicts</name></expr></argument>,
                                 <argument><expr><name>SVN_CONFIG_SECTION_MISCELLANY</name></expr></argument>,
                                 <argument><expr><name>SVN_CONFIG_OPTION_INTERACTIVE_CONFLICTS</name></expr></argument>,
                                 <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>  <comment type="block">/* ### interactivity on by default.
                                                 we can change this. */</comment>
    <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>(<name><name>opt_state</name>.<name>accept_which</name></name> == <name>svn_cl__accept_unspecified</name>
       &amp;&amp; (!<name>interactive_conflicts</name> || <name><name>opt_state</name>.<name>non_interactive</name></name>))
      || <name><name>opt_state</name>.<name>accept_which</name></name> == <name>svn_cl__accept_postpone</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If no --accept option at all and we're non-interactive, we're
         leaving the conflicts behind, so don't need the callback.  Same if
         the user said to postpone. */</comment>
      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>conflict_func</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>conflict_baton</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>svn_cmdline_prompt_baton_t</name> *</type><name>pb</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>pb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>pb</name>-&gt;<name>cancel_func</name></name> = <name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pb</name>-&gt;<name>cancel_baton</name></name> = <name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>opt_state</name>.<name>non_interactive</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>opt_state</name>.<name>accept_which</name></name> == <name>svn_cl__accept_edit</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_cmdline_handle_exit_error</name>
              <argument_list>(<argument><expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"--accept=%s incompatible with"
                                   " --non-interactive"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SVN_CL__ACCEPT_EDIT</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
          <if>if <condition>(<expr><name><name>opt_state</name>.<name>accept_which</name></name> == <name>svn_cl__accept_launch</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_cmdline_handle_exit_error</name>
              <argument_list>(<argument><expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"--accept=%s incompatible with"
                                   " --non-interactive"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>SVN_CL__ACCEPT_LAUNCH</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></then></if>

      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>conflict_func</name></name> = <name>svn_cl__conflict_handler</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>conflict_baton</name></name> = <call><name>svn_cl__conflict_baton_make</name><argument_list>(
          <argument><expr><name><name>opt_state</name>.<name>accept_which</name></name></expr></argument>,
          <argument><expr><name><name>ctx</name>-&gt;<name>config</name></name></expr></argument>,
          <argument><expr><name><name>opt_state</name>.<name>editor_cmd</name></name></expr></argument>,
          <argument><expr><name>pb</name></expr></argument>,
          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* And now we finally run the subcommand. */</comment>
  <expr_stmt><expr><name>err</name> = <call>(*<name><name>subcommand</name>-&gt;<name>cmd_func</name></name>)<argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr>&amp;<name>command_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>tmp_err</name></decl>;</decl_stmt>

      <comment type="block">/* For argument-related problems, suggest using the 'help'
         subcommand. */</comment>
      <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CL_INSUFFICIENT_ARGS</name>
          || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>svn_error_quick_wrap</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Try 'svn help' for more info"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Tell the user about 'svn cleanup' if any error on the stack
         was about locked working copies. */</comment>
      <for>for (<init><expr><name>tmp_err</name> = <name>err</name></expr>;</init> <condition><expr><name>tmp_err</name></expr>;</condition> <incr><expr><name>tmp_err</name> = <name><name>tmp_err</name>-&gt;<name>child</name></name></expr></incr>)
        <if>if <condition>(<expr><name><name>tmp_err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_LOCKED</name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr><call><name>svn_error_clear</name>
              <argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr>"svn: run 'svn cleanup' to remove locks "
                                   "(type 'svn help cleanup' for details)\n"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if></for>

      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Ensure that stdout is flushed, so the user will see any write errors.
         This makes sure that output is not silently lost. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_cmdline_fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>
    }</block></else></if>
}</block></function>
</unit>
