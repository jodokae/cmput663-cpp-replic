<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/svnlook/main.c"><comment type="block">/*
 * main.c: Subversion server inspection tool.
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_signal.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STDIO</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_cmdline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error_codes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_subst.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_diff.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/*** Some convenience macros and types. ***/</comment>

<escape char="0xc"/>
<comment type="block">/* Option handling. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>svn_opt_subcommand_t</name></type>
  <name>subcommand_author</name></decl>,
  <decl><type ref="prev"/><name>subcommand_cat</name></decl>,
  <decl><type ref="prev"/><name>subcommand_changed</name></decl>,
  <decl><type ref="prev"/><name>subcommand_date</name></decl>,
  <decl><type ref="prev"/><name>subcommand_diff</name></decl>,
  <decl><type ref="prev"/><name>subcommand_dirschanged</name></decl>,
  <decl><type ref="prev"/><name>subcommand_help</name></decl>,
  <decl><type ref="prev"/><name>subcommand_history</name></decl>,
  <decl><type ref="prev"/><name>subcommand_info</name></decl>,
  <decl><type ref="prev"/><name>subcommand_lock</name></decl>,
  <decl><type ref="prev"/><name>subcommand_log</name></decl>,
  <decl><type ref="prev"/><name>subcommand_pget</name></decl>,
  <decl><type ref="prev"/><name>subcommand_plist</name></decl>,
  <decl><type ref="prev"/><name>subcommand_tree</name></decl>,
  <decl><type ref="prev"/><name>subcommand_uuid</name></decl>,
  <decl><type ref="prev"/><name>subcommand_youngest</name></decl>;</decl_stmt>

<comment type="block">/* Option codes and descriptions. */</comment>
<enum>enum
  <block>{
    <decl><name>svnlook__version</name> <init>= <expr><name>SVN_OPT_FIRST_LONGOPT_ID</name></expr></init></decl>,
    <decl><name>svnlook__show_ids</name></decl>,
    <decl><name>svnlook__no_diff_deleted</name></decl>,
    <decl><name>svnlook__no_diff_added</name></decl>,
    <decl><name>svnlook__diff_copy_from</name></decl>,
    <decl><name>svnlook__revprop_opt</name></decl>,
    <decl><name>svnlook__full_paths</name></decl>,
    <decl><name>svnlook__copy_info</name></decl>
  }</block>;</enum>

<comment type="block">/*
 * The entire list must be terminated with an entry of nulls.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>apr_getopt_option_t</name></type> <name><name>options_table</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><block>{<expr><name>NULL</name></expr>,                <expr>'?'</expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"show help on a subcommand"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"copy-info"</expr>,         <expr><name>svnlook__copy_info</name></expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"show details for copies"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"diff-copy-from"</expr>,    <expr><name>svnlook__diff_copy_from</name></expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"print differences against the copy source"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"full-paths"</expr>,        <expr><name>svnlook__full_paths</name></expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"show full paths instead of indenting them"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"help"</expr>,              <expr>'h'</expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"show help on a subcommand"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"limit"</expr>,             <expr>'l'</expr>, <expr>1</expr>,
   <macro><name>N_</name><argument_list>(<argument>"maximum number of history entries"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"no-diff-added"</expr>,     <expr><name>svnlook__no_diff_added</name></expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"do not print differences for added files"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"no-diff-deleted"</expr>,   <expr><name>svnlook__no_diff_deleted</name></expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"do not print differences for deleted files"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"non-recursive"</expr>,     <expr>'N'</expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"operate on single directory only"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"revision"</expr>,          <expr>'r'</expr>, <expr>1</expr>,
   <macro><name>N_</name><argument_list>(<argument>"specify revision number ARG"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"revprop"</expr>,           <expr><name>svnlook__revprop_opt</name></expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"operate on a revision property (use with -r or -t)"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"show-ids"</expr>,          <expr><name>svnlook__show_ids</name></expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"show node revision ids for each path"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"transaction"</expr>,       <expr>'t'</expr>, <expr>1</expr>,
   <macro><name>N_</name><argument_list>(<argument>"specify transaction name ARG"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"verbose"</expr>,           <expr>'v'</expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"be verbose"</argument>)</argument_list></macro>}</block></expr>,

  <expr><block>{<expr>"version"</expr>,           <expr><name>svnlook__version</name></expr>, <expr>0</expr>,
   <macro><name>N_</name><argument_list>(<argument>"show program version information"</argument>)</argument_list></macro>}</block></expr>,

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AS400</name></cpp:ifndef>
  <expr><block>{<expr>"extensions"</expr>,    <expr>'x'</expr>, <expr>1</expr>,
                    <macro><name>N_</name><argument_list>(<argument>"Default: '-u'. When Subversion is invoking an\n"
                       "                            "
                       " external diff program, ARG is simply passed along\n"
                       "                            "
                       " to the program. But when Subversion is using its\n"
                       "                            "
                       " default internal diff implementation, or when\n"
                       "                            "
                       " Subversion is displaying blame annotations, ARG\n"
                       "                            "
                       " could be any of the following:\n"
                       "                            "
                       "    -u (--unified):\n"
                       "                            "
                       "       Output 3 lines of unified context.\n"
                       "                            "
                       "    -b (--ignore-space-change):\n"
                       "                            "
                       "       Ignore changes in the amount of white space.\n"
                       "                            "
                       "    -w (--ignore-all-space):\n"
                       "                            "
                       "       Ignore all white space.\n"
                       "                            "
                       "    --ignore-eol-style:\n"
                       "                            "
                       "       Ignore changes in EOL style"</argument>)</argument_list></macro>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr><block>{<expr>0</expr>,                   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Array of available subcommands.
 * The entire list must be terminated with an entry of nulls.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name></type> <name><name>cmd_table</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><block>{<expr>"author"</expr>, <expr><name>subcommand_author</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook author REPOS_PATH\n\n"
      "Print the author.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"cat"</expr>, <expr><name>subcommand_cat</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook cat REPOS_PATH FILE_PATH\n\n"
      "Print the contents of a file.  Leading '/' on FILE_PATH is optional.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"changed"</expr>, <expr><name>subcommand_changed</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook changed REPOS_PATH\n\n"
      "Print the paths that were changed.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>, <expr><name>svnlook__copy_info</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"date"</expr>, <expr><name>subcommand_date</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook date REPOS_PATH\n\n"
      "Print the datestamp.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"diff"</expr>, <expr><name>subcommand_diff</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook diff REPOS_PATH\n\n"
      "Print GNU-style diffs of changed files and properties.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>, <expr><name>svnlook__no_diff_deleted</name></expr>, <expr><name>svnlook__no_diff_added</name></expr>,
    <expr><name>svnlook__diff_copy_from</name></expr>, <expr>'x'</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"dirs-changed"</expr>, <expr><name>subcommand_dirschanged</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook dirs-changed REPOS_PATH\n\n"
      "Print the directories that were themselves changed (property edits)\n"
      "or whose file children were changed.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"help"</expr>, <expr><name>subcommand_help</name></expr>, <expr><block>{<expr>"?"</expr>, <expr>"h"</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook help [SUBCOMMAND...]\n\n"
      "Describe the usage of this program or its subcommands.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"history"</expr>, <expr><name>subcommand_history</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook history REPOS_PATH [PATH_IN_REPOS]\n\n"
      "Print information about the history of a path in the repository (or\n"
      "the root directory if no path is supplied).\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr><name>svnlook__show_ids</name></expr>, <expr>'l'</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"info"</expr>, <expr><name>subcommand_info</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook info REPOS_PATH\n\n"
      "Print the author, datestamp, log message size, and log message.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"lock"</expr>, <expr><name>subcommand_lock</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook lock REPOS_PATH PATH_IN_REPOS\n\n"
      "If a lock exists on a path in the repository, describe it.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"log"</expr>, <expr><name>subcommand_log</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook log REPOS_PATH\n\n"
      "Print the log message.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"propget"</expr>, <expr><name>subcommand_pget</name></expr>, <expr><block>{<expr>"pget"</expr>, <expr>"pg"</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook propget REPOS_PATH PROPNAME [PATH_IN_REPOS]\n\n"
      "Print the raw value of a property on a path in the repository.\n"
      "With --revprop, prints the raw value of a revision property.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>, <expr><name>svnlook__revprop_opt</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"proplist"</expr>, <expr><name>subcommand_plist</name></expr>, <expr><block>{<expr>"plist"</expr>, <expr>"pl"</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook proplist REPOS_PATH [PATH_IN_REPOS]\n\n"
      "List the properties of a path in the repository, or\n"
      "with the --revprop option, revision properties.\n"
      "With -v, show the property values too.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>, <expr>'v'</expr>, <expr><name>svnlook__revprop_opt</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"tree"</expr>, <expr><name>subcommand_tree</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook tree REPOS_PATH [PATH_IN_REPOS]\n\n"
      "Print the tree, starting at PATH_IN_REPOS (if supplied, at the root\n"
      "of the tree otherwise), optionally showing node revision ids.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>'r'</expr>, <expr>'t'</expr>, <expr>'N'</expr>, <expr><name>svnlook__show_ids</name></expr>, <expr><name>svnlook__full_paths</name></expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"uuid"</expr>, <expr><name>subcommand_uuid</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook uuid REPOS_PATH\n\n"
      "Print the repository's UUID.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>,

  <expr><block>{<expr>"youngest"</expr>, <expr><name>subcommand_youngest</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
   <expr><call><name>N_</name><argument_list>(<argument><expr>"usage: svnlook youngest REPOS_PATH\n\n"
      "Print the youngest revision number.\n"</expr></argument>)</argument_list></call></expr>,
   <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>,

  <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Baton for passing option/argument state to a subcommand function. */</comment>
<struct>struct <name>svnlook_opt_state</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>  <comment type="block">/* 'arg0' is always the path to the repository. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name></decl>;</decl_stmt>        <comment type="block">/* Usually an fs path, a propname, or NULL. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg2</name></decl>;</decl_stmt>        <comment type="block">/* Usually an fs path or NULL. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>version</name></decl>;</decl_stmt>          <comment type="block">/* --version */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>show_ids</name></decl>;</decl_stmt>         <comment type="block">/* --show-ids */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>limit</name></decl>;</decl_stmt>               <comment type="block">/* --limit */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>help</name></decl>;</decl_stmt>             <comment type="block">/* --help */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>no_diff_deleted</name></decl>;</decl_stmt>  <comment type="block">/* --no-diff-deleted */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>no_diff_added</name></decl>;</decl_stmt>    <comment type="block">/* --no-diff-added */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>diff_copy_from</name></decl>;</decl_stmt>   <comment type="block">/* --diff-copy-from */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>verbose</name></decl>;</decl_stmt>          <comment type="block">/* --verbose */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>revprop</name></decl>;</decl_stmt>          <comment type="block">/* --revprop */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>full_paths</name></decl>;</decl_stmt>       <comment type="block">/* --full-paths */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>copy_info</name></decl>;</decl_stmt>        <comment type="block">/* --copy-info */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>non_recursive</name></decl>;</decl_stmt>    <comment type="block">/* --non-recursive */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>extensions</name></decl>;</decl_stmt>         <comment type="block">/* diff extension args (UTF-8!) */</comment>
}</block>;</struct>


<typedef>typedef <type><struct>struct <name>svnlook_ctxt_t</name>
<block>{
  <decl_stmt><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>show_ids</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>limit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>no_diff_deleted</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>no_diff_added</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>diff_copy_from</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>full_paths</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>copy_info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl> <comment type="block">/* UTF-8! */</comment>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>diff_options</name></decl>;</decl_stmt>

}</block></struct></type> <name>svnlook_ctxt_t</name>;</typedef>

<comment type="block">/* A flag to see if we've been cancelled by the client or not. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>cancelled</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/*** Helper functions. ***/</comment>

<comment type="block">/* A signal handler to support cancellation. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>signal_handler</name><parameter_list>(<param><decl><type><name>int</name></type> <name>signum</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>signum</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cancelled</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Our cancellation callback. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_cancel</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>cancelled</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CANCELLED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Caught signal"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></else></if>
}</block></function>


<comment type="block">/* Version compatibility check */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_lib_versions</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_version_checklist_t</name></type> <name><name>checklist</name><index>[]</index></name> <init>=
    <expr><block>{
      <expr><block>{ <expr>"svn_subr"</expr>,  <expr><name>svn_subr_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_repos"</expr>, <expr><name>svn_repos_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_fs"</expr>,    <expr><name>svn_fs_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_delta"</expr>, <expr><name>svn_delta_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_diff"</expr>,  <expr><name>svn_diff_version</name></expr> }</block></expr>,
      <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_VERSION_DEFINE</name><argument_list>(<argument><expr><name>my_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_ver_check_list</name><argument_list>(<argument><expr>&amp;<name>my_version</name></expr></argument>, <argument><expr><name>checklist</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Get revision or transaction property PROP_NAME for the revision or
   transaction specified in C, allocating in in POOL and placing it in
   *PROP_VALUE. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_property</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>prop_value</name></decl></param>,
             <param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_name</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>raw_value</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch transaction property... */</comment>
  <if>if <condition>(<expr>! <name><name>c</name>-&gt;<name>is_revision</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_txn_prop</name><argument_list>(<argument><expr>&amp;<name>raw_value</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>prop_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

  <comment type="block">/* ...or revision property -- it's your call. */</comment>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_prop</name><argument_list>(<argument><expr>&amp;<name>raw_value</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>,
                                 <argument><expr><name>prop_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr>*<name>prop_value</name> = <name>raw_value</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_root</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root</name></decl></param>,
         <param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Open up the appropriate root (revision or transaction). */</comment>
  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>is_revision</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If we didn't get a valid revision number, we'll look at the
         youngest revision. */</comment>
      <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;(<name><name>c</name>-&gt;<name>rev_id</name></name>)</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_txn_root</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Tree Routines ***/</comment>

<comment type="block">/* Generate a generic delta tree. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>generate_delta_tree</name><parameter_list>(<param><decl><type><name>svn_repos_node_t</name> **</type><name>tree</name></decl></param>,
                    <param><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl></param>,
                    <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>base_rev</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>use_copy_history</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>base_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>edit_pool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_repos_fs</name><argument_list>(<argument><expr><name>repos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the base root. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>base_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>base_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Request our editor. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_node_editor</name><argument_list>(<argument><expr>&amp;<name>editor</name></expr></argument>, <argument><expr>&amp;<name>edit_baton</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>,
                                <argument><expr><name>base_root</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>edit_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Drive our editor. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_replay2</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                            <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>edit_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return the tree we just built. */</comment>
  <expr_stmt><expr>*<name>tree</name> = <call><name>svn_repos_node_from_baton</name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>edit_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Tree Printing Routines ***/</comment>

<comment type="block">/* Recursively print only directory nodes that either a) have property
   mods, or b) contains files that have changed. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>print_dirs_changed_tree</name><parameter_list>(<param><decl><type><name>svn_repos_node_t</name> *</type><name>node</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param> <comment type="block">/* UTF-8! */</comment>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>tmp_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>print_me</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cancel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>node</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Not a directory?  We're not interested. */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Got prop mods?  Excellent. */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>prop_mod</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>print_me</name> = 1</expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>! <name>print_me</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Fly through the list of children, checking for modified files. */</comment>
      <expr_stmt><expr><name>tmp_node</name> = <name><name>node</name>-&gt;<name>child</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>tmp_node</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>(<name><name>tmp_node</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>)
              || (<name><name>tmp_node</name>-&gt;<name>text_mod</name></name>)
              || (<name><name>tmp_node</name>-&gt;<name>action</name></name> == 'A')
              || (<name><name>tmp_node</name>-&gt;<name>action</name></name> == 'D')</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>print_me</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
          <while>while <condition>(<expr><name><name>tmp_node</name>-&gt;<name>sibling</name></name> &amp;&amp; (! <name>print_me</name> )</expr>)</condition>
            <block>{
              <expr_stmt><expr><name>tmp_node</name> = <name><name>tmp_node</name>-&gt;<name>sibling</name></name></expr>;</expr_stmt>
              <if>if <condition>(<expr>(<name><name>tmp_node</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>)
                  || (<name><name>tmp_node</name>-&gt;<name>text_mod</name></name>)
                  || (<name><name>tmp_node</name>-&gt;<name>action</name></name> == 'A')
                  || (<name><name>tmp_node</name>-&gt;<name>action</name></name> == 'D')</expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>print_me</name> = 1</expr>;</expr_stmt>
                }</block></then></if>
            }</block></while>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Print the node if it qualifies. */</comment>
  <if>if <condition>(<expr><name>print_me</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s/\n"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Return here if the node has no children. */</comment>
  <expr_stmt><expr><name>tmp_node</name> = <name><name>node</name>-&gt;<name>child</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>tmp_node</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Recursively handle the node's children. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>tmp_node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_dirs_changed_tree</name><argument_list>(<argument><expr><name>tmp_node</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>tmp_node</name>-&gt;<name>sibling</name></name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>tmp_node</name> = <name><name>tmp_node</name>-&gt;<name>sibling</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>tmp_node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_dirs_changed_tree</name><argument_list>(<argument><expr><name>tmp_node</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Recursively print all nodes in the tree that have been modified
   (do not include directories affected only by "bubble-up"). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>print_changed_tree</name><parameter_list>(<param><decl><type><name>svn_repos_node_t</name> *</type><name>node</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param> <comment type="block">/* UTF-8! */</comment>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>copy_info</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>status</name><index>[<expr>4</expr>]</index></name> <init>= <expr>"_  "</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>print_me</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cancel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>node</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Print the node. */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>action</name></name> == 'A'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>status</name><index>[<expr>0</expr>]</index></name> = 'A'</expr>;</expr_stmt>
      <if>if <condition>(<expr><name>copy_info</name> &amp;&amp; <name><name>node</name>-&gt;<name>copyfrom_path</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>status</name><index>[<expr>2</expr>]</index></name> = '+'</expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>node</name>-&gt;<name>action</name></name> == 'D'</expr>)</condition><then>
    <expr_stmt><expr><name><name>status</name><index>[<expr>0</expr>]</index></name> = 'D'</expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>node</name>-&gt;<name>action</name></name> == 'R'</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>(! <name><name>node</name>-&gt;<name>text_mod</name></name>) &amp;&amp; (! <name><name>node</name>-&gt;<name>prop_mod</name></name>)</expr>)</condition><then>
        <expr_stmt><expr><name>print_me</name> = 0</expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name><name>node</name>-&gt;<name>text_mod</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>status</name><index>[<expr>0</expr>]</index></name> = 'U'</expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name><name>node</name>-&gt;<name>prop_mod</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>status</name><index>[<expr>1</expr>]</index></name> = 'U'</expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>print_me</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if>

  <comment type="block">/* Print this node unless told to skip it. */</comment>
  <if>if <condition>(<expr><name>print_me</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s %s%s\n"</expr></argument>,
                                 <argument><expr><name>status</name></expr></argument>,
                                 <argument><expr><name>path</name></expr></argument>,
                                 <argument><expr><name><name>node</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name> ? "/" : ""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>copy_info</name> &amp;&amp; <name><name>node</name>-&gt;<name>copyfrom_path</name></name></expr>)</condition><then>
        <comment type="block">/* Remove the leading slash from the copyfrom path for consistency
           with the rest of the output. */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"    (from %s%s:r%ld)\n"</expr></argument>,
                                   <argument><expr>(<name><name>node</name>-&gt;<name>copyfrom_path</name><index>[<expr>0</expr>]</index></name> == '/'
                                    ? <name><name>node</name>-&gt;<name>copyfrom_path</name></name> + 1
                                    : <name><name>node</name>-&gt;<name>copyfrom_path</name></name>)</expr></argument>,
                                   <argument><expr>(<name><name>node</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name> ? "/" : "")</expr></argument>,
                                   <argument><expr><name><name>node</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* Return here if the node has no children. */</comment>
  <expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>child</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>node</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Recursively handle the node's children. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_changed_tree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>copy_info</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>node</name>-&gt;<name>sibling</name></name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>sibling</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_changed_tree</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>copy_info</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>dump_contents</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>fh</name></decl></param>,
              <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param> <comment type="block">/* UTF-8! */</comment>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>contents</name></decl>, *<decl><type ref="prev"/><name>file_stream</name></decl>;</decl_stmt>

  <comment type="block">/* Grab the contents and copy them into fh. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_contents</name><argument_list>(<argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>file_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_copy</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>file_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Prepare temporary files *TMPFILE1 and *TMPFILE2 for diffing
   PATH1@ROOT1 versus PATH2@ROOT2.  If either ROOT1 or ROOT2 is NULL,
   the temporary file for its path/root will be an empty one.
   Otherwise, its temporary file will contain the contents of that
   path/root in the repository.

   An exception to this is when either path/root has an svn:mime-type
   property set on it which indicates that the file contains
   non-textual data -- in this case, the *IS_BINARY flag is set and no
   temporary files are created.

   Use POOL for all that allocation goodness. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prepare_tmpfiles</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>tmpfile1</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>tmpfile2</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name> *</type><name>is_binary</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmpdir</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mimetype</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fh</name></decl>;</decl_stmt>

  <comment type="block">/* Init the return values. */</comment>
  <expr_stmt><expr>*<name>tmpfile1</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>tmpfile2</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>is_binary</name> = <name>FALSE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>path1</name> &amp;&amp; <name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for binary mimetypes.  If either file has a binary
     mimetype, get outta here.  */</comment>
  <if>if <condition>(<expr><name>root1</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_prop</name><argument_list>(<argument><expr>&amp;<name>mimetype</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>,
                               <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mimetype</name> &amp;&amp; <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name><name>mimetype</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>is_binary</name> = <name>TRUE</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
  <if>if <condition>(<expr><name>root2</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_prop</name><argument_list>(<argument><expr>&amp;<name>mimetype</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>,
                               <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mimetype</name> &amp;&amp; <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name><name>mimetype</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>is_binary</name> = <name>TRUE</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Now, prepare the two temporary files, each of which will either
     be empty, or will have real contents.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>fh</name></expr></argument>, <argument><expr><name>tmpfile2</name></expr></argument>,
                                   <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s/diff"</expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>root2</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dump_contents</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The second file is constructed from the first one's path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>fh</name></expr></argument>, <argument><expr><name>tmpfile1</name></expr></argument>, <argument><expr>*<name>tmpfile2</name></expr></argument>,
                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>root1</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dump_contents</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Generate a diff label for PATH in ROOT, allocating in POOL.
   ROOT may be NULL, in which case revision 0 is used. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>generate_label</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>label</name></decl></param>,
               <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>date</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>datestr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>root</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_root_fs</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>svn_fs_is_revision_root</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>rev</name> = <call><name>svn_fs_revision_root_revision</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_prop</name><argument_list>(<argument><expr>&amp;<name>date</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                                       <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>name</name> = <call><name>svn_fs_txn_root_name</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_open_txn</name><argument_list>(<argument><expr>&amp;<name>txn</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_txn_prop</name><argument_list>(<argument><expr>&amp;<name>date</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>rev</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>date</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr><name>date</name></expr>)</condition><then>
    <expr_stmt><expr><name>datestr</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%.10s %.8s UTC"</expr></argument>, <argument><expr><name><name>date</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>date</name>-&gt;<name>data</name></name> + 11</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>datestr</name> = "                       "</expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>name</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>label</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s\t%s (txn %s)"</expr></argument>,
                          <argument><expr><name>path</name></expr></argument>, <argument><expr><name>datestr</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>label</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s\t%s (rev %ld)"</expr></argument>,
                          <argument><expr><name>path</name></expr></argument>, <argument><expr><name>datestr</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * Constant diff output separator strings
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>equal_string</name><index>[]</index></name> <init>=
  <expr>"==================================================================="</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>under_string</name><index>[]</index></name> <init>=
  <expr>"___________________________________________________________________"</expr></init></decl>;</decl_stmt>


<comment type="block">/* Helper function to display differences in properties of a file */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>display_prop_diffs</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>prop_diffs</name></decl></param>,
                   <param><decl><type><name>apr_hash_t</name> *</type><name>orig_props</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"\nProperty changes on: %s\n%s\n"</expr></argument>,
                             <argument><expr><name>path</name></expr></argument>, <argument><expr><name>under_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>prop_diffs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header_fmt</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>orig_value</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>pc</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>prop_diffs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cancel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>orig_props</name></expr>)</condition><then>
        <expr_stmt><expr><name>orig_value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>orig_props</name></expr></argument>, <argument><expr><name><name>pc</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>orig_value</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

      <if>if <condition>(<expr>! <name>orig_value</name></expr>)</condition><then>
        <expr_stmt><expr><name>header_fmt</name> = <call><name>_</name><argument_list>(<argument><expr>"Added: %s\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>! <name><name>pc</name>-&gt;<name>value</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>header_fmt</name> = <call><name>_</name><argument_list>(<argument><expr>"Deleted: %s\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>header_fmt</name> = <call><name>_</name><argument_list>(<argument><expr>"Modified: %s\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>header_fmt</name></expr></argument>, <argument><expr><name><name>pc</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* For now, we have a rather simple heuristic: if this is an
         "svn:" property, then assume the value is UTF-8 and must
         therefore be converted before printing.  Otherwise, just
         print whatever's there and hope for the best.
         ### We don't use svn_cmdline_printf here, since we don't know if the
         values are UTF-8. */</comment>
      <block>{
        <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>val_to_utf8</name> <init>= <expr><call><name>svn_prop_is_svn_prop</name><argument_list>(<argument><expr><name><name>pc</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>printable_val</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>orig_value</name> != <name>NULL</name></expr>)</condition><then>
          <block>{
            <if>if <condition>(<expr><name>val_to_utf8</name></expr>)</condition><then>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>printable_val</name></expr></argument>,
                                                    <argument><expr><name><name>orig_value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
              <expr_stmt><expr><name>printable_val</name> = <name><name>orig_value</name>-&gt;<name>data</name></name></expr>;</expr_stmt></else></if>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"   - %s\n"</expr></argument>, <argument><expr><name>printable_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>

        <if>if <condition>(<expr><name><name>pc</name>-&gt;<name>value</name></name> != <name>NULL</name></expr>)</condition><then>
          <block>{
            <if>if <condition>(<expr><name>val_to_utf8</name></expr>)</condition><then>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_cstring_from_utf8</name>
                      <argument_list>(<argument><expr>&amp;<name>printable_val</name></expr></argument>, <argument><expr><name><name>pc</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else
              <expr_stmt><expr><name>printable_val</name> = <name><name>pc</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr>;</expr_stmt></else></if>
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"   + %s\n"</expr></argument>, <argument><expr><name>printable_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
      }</block>
    }</block></for>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_cmdline_fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<comment type="block">/* Recursively print all nodes in the tree that have been modified
   (do not include directories affected only by "bubble-up"). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>print_diff_tree</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                <param><decl><type><name>svn_fs_root_t</name> *</type><name>base_root</name></decl></param>,
                <param><decl><type><name>svn_repos_node_t</name> *</type><name>node</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param> <comment type="block">/* UTF-8! */</comment>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_path</name></decl></param> <comment type="block">/* UTF-8! */</comment>,
                <param><decl><type><specifier>const</specifier> <name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmpdir</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>orig_path</name> <init>= <expr><name>NULL</name></expr></init>, *<name>new_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>do_diff</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>orig_empty</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_copy</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>binary</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>header</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cancel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>node</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>header</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Print copyfrom history for the top node of a copied tree. */</comment>
  <if>if <condition>(<expr>(<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>)</argument_list></call>)
      &amp;&amp; (<name><name>node</name>-&gt;<name>copyfrom_path</name></name> != <name>NULL</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* This is ... a copy. */</comment>
      <expr_stmt><expr><name>is_copy</name> = <name>TRUE</name></expr>;</expr_stmt>

      <comment type="block">/* Propagate the new base.  Copyfrom paths usually start with a
         slash; we remove it for consistency with the target path.
         ### Yes, it would be *much* better for something in the path
             library to be taking care of this! */</comment>
      <if>if <condition>(<expr><name><name>node</name>-&gt;<name>copyfrom_path</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
        <expr_stmt><expr><name>base_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>copyfrom_path</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>base_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>copyfrom_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name>
        <argument_list>(<argument><expr><name>header</name></expr></argument>,
         <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Copied: %s (from rev %ld, %s)\n"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>base_root</name></expr></argument>,
                                   <argument><expr><call><name>svn_fs_root_fs</name><argument_list>(<argument><expr><name>base_root</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name><name>node</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/*** First, we'll just print file content diffs. ***/</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Here's the generalized way we do our diffs:

         - First, we'll check for svn:mime-type properties on the old
           and new files.  If either has such a property, and it
           represents a binary type, we won't actually be doing a real
           diff.

         - Second, dump the contents of the new version of the file
           into the temporary directory.

         - Then, dump the contents of the old version of the file into
           the temporary directory.

         - Next, we run 'diff', passing the repository paths as the
           labels.

         - Finally, we delete the temporary files.  */</comment>
      <if>if <condition>(<expr><name><name>node</name>-&gt;<name>action</name></name> == 'R' &amp;&amp; <name><name>node</name>-&gt;<name>text_mod</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>do_diff</name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prepare_tmpfiles</name><argument_list>(<argument><expr>&amp;<name>orig_path</name></expr></argument>, <argument><expr>&amp;<name>new_path</name></expr></argument>, <argument><expr>&amp;<name>binary</name></expr></argument>,
                                   <argument><expr><name>base_root</name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                   <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>c</name>-&gt;<name>diff_copy_from</name></name> &amp;&amp; <name><name>node</name>-&gt;<name>action</name></name> == 'A' &amp;&amp; <name>is_copy</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>node</name>-&gt;<name>text_mod</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>do_diff</name> = <name>TRUE</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prepare_tmpfiles</name><argument_list>(<argument><expr>&amp;<name>orig_path</name></expr></argument>, <argument><expr>&amp;<name>new_path</name></expr></argument>, <argument><expr>&amp;<name>binary</name></expr></argument>,
                                       <argument><expr><name>base_root</name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                       <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
      <else>else <if>if <condition>(<expr>! <name><name>c</name>-&gt;<name>no_diff_added</name></name> &amp;&amp; <name><name>node</name>-&gt;<name>action</name></name> == 'A'</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>do_diff</name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>orig_empty</name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prepare_tmpfiles</name><argument_list>(<argument><expr>&amp;<name>orig_path</name></expr></argument>, <argument><expr>&amp;<name>new_path</name></expr></argument>, <argument><expr>&amp;<name>binary</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                   <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>! <name><name>c</name>-&gt;<name>no_diff_deleted</name></name> &amp;&amp; <name><name>node</name>-&gt;<name>action</name></name> == 'D'</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>do_diff</name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prepare_tmpfiles</name><argument_list>(<argument><expr>&amp;<name>orig_path</name></expr></argument>, <argument><expr>&amp;<name>new_path</name></expr></argument>, <argument><expr>&amp;<name>binary</name></expr></argument>,
                                   <argument><expr><name>base_root</name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                   <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if></else></if>

      <comment type="block">/* The header for the copy case has already been created, and we don't
         want a header here for files with only property modifications. */</comment>
      <if>if <condition>(<expr><name><name>header</name>-&gt;<name>len</name></name> == 0
          &amp;&amp; (<name><name>node</name>-&gt;<name>action</name></name> != 'R' || <name><name>node</name>-&gt;<name>text_mod</name></name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name>
            <argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s: %s\n"</expr></argument>,
                                  <argument><expr>((<name><name>node</name>-&gt;<name>action</name></name> == 'A') ? <call><name>_</name><argument_list>(<argument><expr>"Added"</expr></argument>)</argument_list></call> :
                                   ((<name><name>node</name>-&gt;<name>action</name></name> == 'D') ? <call><name>_</name><argument_list>(<argument><expr>"Deleted"</expr></argument>)</argument_list></call> :
                                    ((<name><name>node</name>-&gt;<name>action</name></name> == 'R') ? <call><name>_</name><argument_list>(<argument><expr>"Modified"</expr></argument>)</argument_list></call>
                                     : <call><name>_</name><argument_list>(<argument><expr>"Index"</expr></argument>)</argument_list></call>)))</expr></argument>,
                                  <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>do_diff</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>equal_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>binary</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"(Binary files differ)\n\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>header</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>          
      <else>else
        <block>{
          <decl_stmt><decl><type><name>svn_diff_t</name> *</type><name>diff</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_diff_file_options_t</name> *</type><name>opts</name> <init>= <expr><call><name>svn_diff_file_options_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name><name>c</name>-&gt;<name>diff_options</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_diff_file_options_parse</name><argument_list>(<argument><expr><name>opts</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>diff_options</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_diff_file_diff_2</name><argument_list>(<argument><expr>&amp;<name>diff</name></expr></argument>, <argument><expr><name>orig_path</name></expr></argument>,
                                       <argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>opts</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><call><name>svn_diff_contains_diffs</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>ostream</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>orig_label</name></decl>, *<decl><type ref="prev"/><name>new_label</name></decl>;</decl_stmt>

              <comment type="block">/* Print diff header. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>header</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_for_stdout</name><argument_list>(<argument><expr>&amp;<name>ostream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr><name>orig_empty</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>generate_label</name><argument_list>(<argument><expr>&amp;<name>orig_label</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>generate_label</name><argument_list>(<argument><expr>&amp;<name>orig_label</name></expr></argument>, <argument><expr><name>base_root</name></expr></argument>,
                                       <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>generate_label</name><argument_list>(<argument><expr>&amp;<name>new_label</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_diff_file_output_unified2</name>
                      <argument_list>(<argument><expr><name>ostream</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name>orig_path</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>,
                       <argument><expr><name>orig_label</name></expr></argument>, <argument><expr><name>new_label</name></expr></argument>,
                       <argument><expr><call><name>svn_cmdline_output_encoding</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>ostream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Make sure we delete any temporary files. */</comment>
  <if>if <condition>(<expr><name>orig_path</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>orig_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>new_path</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/*** Now handle property diffs ***/</comment>
  <if>if <condition>(<expr>(<name><name>node</name>-&gt;<name>prop_mod</name></name>) &amp;&amp; (<name><name>node</name>-&gt;<name>action</name></name> != 'D')</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>local_proptable</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>base_proptable</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>propchanges</name></decl>, *<decl><type ref="prev"/><name>props</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>local_proptable</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>c</name>-&gt;<name>diff_copy_from</name></name> &amp;&amp; <name><name>node</name>-&gt;<name>action</name></name> == 'A' &amp;&amp; <name>is_copy</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>base_proptable</name></expr></argument>, <argument><expr><name>base_root</name></expr></argument>,
                                     <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><name><name>node</name>-&gt;<name>action</name></name> == 'A'</expr>)</condition><then>
        <expr_stmt><expr><name>base_proptable</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else  <comment type="block">/* node-&gt;action == 'R' */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>base_proptable</name></expr></argument>, <argument><expr><name>base_root</name></expr></argument>,
                                     <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>propchanges</name></expr></argument>, <argument><expr><name>local_proptable</name></expr></argument>,
                             <argument><expr><name>base_proptable</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_categorize_props</name><argument_list>(<argument><expr><name>propchanges</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>props</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>display_prop_diffs</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>base_proptable</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* Return here if the node has no children. */</comment>
  <expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>child</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>node</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Recursively handle the node's children. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_diff_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>base_root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                          <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>base_path</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>node</name>-&gt;<name>sibling</name></name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>sibling</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_diff_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>base_root</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                              <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>base_path</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print a repository directory, maybe recursively, possibly showing
   the node revision ids, and optionally using full paths.

   ROOT is the revision or transaction root used to build that tree.
   PATH and ID are the current path and node revision id being
   printed, and INDENTATION the number of spaces to prepent to that
   path's printed output.  ID may be NULL if SHOW_IDS is FALSE (in
   which case, ids won't be printed at all).  If RECURSE is TRUE,
   then print the tree recursively; otherwise, we'll stop after the
   first level (and use INDENTATION to keep track of how deep we are).

   Use POOL for all allocations.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>print_tree</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param> <comment type="block">/* UTF-8! */</comment>,
           <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl></param>,
           <param><decl><type><name>int</name></type> <name>indentation</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>show_ids</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>full_paths</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cancel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Print the indentation. */</comment>
  <if>if <condition>(<expr>!<name>full_paths</name></expr>)</condition><then>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>indentation</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>" "</expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>

  <comment type="block">/* Print the node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s%s"</expr></argument>,
                             <argument><expr><name>full_paths</name> ? <name>path</name> : <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>is_dir</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call> ? "/" : ""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>show_ids</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>unparsed_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>id</name></expr>)</condition><then>
        <expr_stmt><expr><name>unparsed_id</name> = <call><name>svn_fs_unparse_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>" &lt;%s&gt;"</expr></argument>,
                                 <argument><expr><name>unparsed_id</name>
                                 ? <name><name>unparsed_id</name>-&gt;<name>data</name></name>
                                 : <call><name>_</name><argument_list>(<argument><expr>"unknown"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return here if PATH is not a directory. */</comment>
  <if>if <condition>(<expr>! <name>is_dir</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Recursively handle the node's children. */</comment>
  <if>if <condition>(<expr><name>recurse</name> || (<name>indentation</name> == 0)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>entry</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>entry</name> = <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr>(<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)</expr></argument>,
                             <argument><expr><name>indentation</name> + 1</expr></argument>, <argument><expr><name>show_ids</name></expr></argument>, <argument><expr><name>full_paths</name></expr></argument>,
                             <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Subcommand handlers. ***/</comment>

<comment type="block">/* Print the revision's log message to stdout, followed by a newline. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_log</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>, <param><decl><type><name>svn_boolean_t</name></type> <name>print_size</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>prop_value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_value_eol</name></decl>, *<decl><type ref="prev"/><name>prop_value_native</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_property</name><argument_list>(<argument><expr>&amp;<name>prop_value</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_LOG</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! (<name>prop_value</name> &amp;&amp; <name><name>prop_value</name>-&gt;<name>data</name></name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>print_size</name> ? "0" : ""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* We immitate what svn_cmdline_printf does here, since we need the byte
     size of what we are going to print. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_translate_cstring2</name><argument_list>(<argument><expr><name><name>prop_value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>prop_value_eol</name></expr></argument>,
                                       <argument><expr><name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_cmdline_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>prop_value_native</name></expr></argument>, <argument><expr><name>prop_value_eol</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>prop_value_native</name> = <call><name>svn_cmdline_cstring_from_utf8_fuzzy</name><argument_list>(<argument><expr><name>prop_value_eol</name></expr></argument>,
                                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prop_value_native</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>print_size</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%" <name>APR_SIZE_T_FMT</name> "\n"</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Use a stream to bypass all stdio translations. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_for_stdout</name><argument_list>(<argument><expr>&amp;<name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>prop_value_native</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stdout</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print the timestamp of the commit (in the revision case) or the
   empty string (in the transaction case) to stdout, followed by a
   newline. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_date</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>prop_value</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_property</name><argument_list>(<argument><expr>&amp;<name>prop_value</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>prop_value</name> &amp;&amp; <name><name>prop_value</name>-&gt;<name>data</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Convert the date for humans. */</comment>
      <decl_stmt><decl><type><name>apr_time_t</name></type> <name>aprtime</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>time_utf8</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;<name>aprtime</name></expr></argument>, <argument><expr><name><name>prop_value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>time_utf8</name> = <call><name>svn_time_to_human_cstring</name><argument_list>(<argument><expr><name>aprtime</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>time_utf8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print the author of the commit to stdout, followed by a newline. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_author</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>prop_value</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_property</name><argument_list>(<argument><expr>&amp;<name>prop_value</name></expr></argument>, <argument><expr><name>c</name></expr></argument>,
                       <argument><expr><name>SVN_PROP_REVISION_AUTHOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>prop_value</name> &amp;&amp; <name><name>prop_value</name>-&gt;<name>data</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>prop_value</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print a list of all directories in which files, or directory
   properties, have been modified. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_dirs_changed</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>base_rev_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>tree</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>is_revision</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>base_rev_id</name> = <name><name>c</name>-&gt;<name>rev_id</name></name> - 1</expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>base_rev_id</name> = <call><name>svn_fs_txn_base_revision</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>txn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>base_rev_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Transaction '%s' is not based on a revision; how odd"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name><name>c</name>-&gt;<name>txn_name</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>generate_delta_tree</name><argument_list>(<argument><expr>&amp;<name>tree</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>base_rev_id</name></expr></argument>,
                              <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>tree</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_dirs_changed_tree</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *KIND to PATH's kind, if PATH exists.
 *
 * If PATH does not exist, then error; the text of the error depends
 * on whether PATH looks like a URL or not.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>verify_path</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
            <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_check_path</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>*<name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>  <comment type="block">/* check for a common mistake. */</comment>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is a URL, probably should be a path"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then>
      <else>else
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' does not exist"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print the contents of the file at PATH in the repository.
   Error with SVN_ERR_FS_NOT_FOUND if PATH does not exist, or with
   SVN_ERR_FS_NOT_FILE if PATH exists but is not a file. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_cat</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>fstream</name></decl>, *<decl><type ref="prev"/><name>stdout_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Else. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_contents</name><argument_list>(<argument><expr>&amp;<name>fstream</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_for_stdout</name><argument_list>(<argument><expr>&amp;<name>stdout_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cancel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>fstream</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stdout_stream</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
  while <condition>(<expr><name>len</name> == <name>SVN__STREAM_CHUNK_SIZE</name></expr>)</condition>;</do>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print a list of all paths modified in a format compatible with `svn
   update'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_changed</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>base_rev_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>tree</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>is_revision</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>base_rev_id</name> = <name><name>c</name>-&gt;<name>rev_id</name></name> - 1</expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>base_rev_id</name> = <call><name>svn_fs_txn_base_revision</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>txn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>base_rev_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Transaction '%s' is not based on a revision; how odd"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name><name>c</name>-&gt;<name>txn_name</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>generate_delta_tree</name><argument_list>(<argument><expr>&amp;<name>tree</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>base_rev_id</name></expr></argument>,
                              <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>tree</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_changed_tree</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>copy_info</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print some diff-y stuff in a TBD way. :-) */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_diff</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>, *<decl><type ref="prev"/><name>base_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>base_rev_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>tree</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>is_revision</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>base_rev_id</name> = <name><name>c</name>-&gt;<name>rev_id</name></name> - 1</expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>base_rev_id</name> = <call><name>svn_fs_txn_base_revision</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>txn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>base_rev_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Transaction '%s' is not based on a revision; how odd"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name><name>c</name>-&gt;<name>txn_name</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>generate_delta_tree</name><argument_list>(<argument><expr>&amp;<name>tree</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>base_rev_id</name></expr></argument>,
                              <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>tree</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmpdir</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>base_root</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>base_rev_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_temp_dir</name><argument_list>(<argument><expr>&amp;<name>tmpdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_diff_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>base_root</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>""</expr></argument>,
                              <argument><expr><name>c</name></expr></argument>, <argument><expr><name>tmpdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* Callback baton for print_history() (and do_history()). */</comment>
<struct>struct <name>print_history_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>show_ids</name></decl>;</decl_stmt>    <comment type="block">/* whether to show node IDs */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>limit</name></decl>;</decl_stmt>          <comment type="block">/* max number of history items */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>count</name></decl>;</decl_stmt>          <comment type="block">/* number of history items processed */</comment>
}</block>;</struct>

<comment type="block">/* Implements svn_repos_history_func_t interface.  Print the history
   that's reported through this callback, possibly finding and
   displaying node-rev-ids. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>print_history</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>print_history_baton</name> *</type><name>phb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cancel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>phb</name>-&gt;<name>show_ids</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>rev_root</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_string</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>rev_root</name></expr></argument>, <argument><expr><name><name>phb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_id</name><argument_list>(<argument><expr>&amp;<name>node_id</name></expr></argument>, <argument><expr><name>rev_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>id_string</name> = <call><name>svn_fs_unparse_id</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%8ld   %s &lt;%s&gt;\n"</expr></argument>,
                                 <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>id_string</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%8ld   %s\n"</expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr><name><name>phb</name>-&gt;<name>limit</name></name> &gt; 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>phb</name>-&gt;<name>count</name></name>++</expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>phb</name>-&gt;<name>count</name></name> &gt;= <name><name>phb</name>-&gt;<name>limit</name></name></expr>)</condition><then>
        <comment type="block">/* Not L10N'd, since this error is supressed by the caller. */</comment>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CEASE_INVOCATION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr>"History item limit reached"</expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print a tabular display of history location points for PATH in
   revision C-&gt;rev_id.  Optionally, SHOW_IDS.  Use POOL for
   allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_history</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>print_history_baton</name></type> <name>args</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>show_ids</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"REVISION   PATH &lt;ID&gt;\n"
                                         "--------   ---------\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"REVISION   PATH\n"
                                         "--------   ----\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Call our history crawler.  We want the whole lifetime of the path
     (prior to the user-supplied revision, of course), across all
     copies. */</comment>
  <expr_stmt><expr><name><name>args</name>.<name>fs</name></name> = <name><name>c</name>-&gt;<name>fs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>show_ids</name></name> = <name><name>c</name>-&gt;<name>show_ids</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>limit</name></name> = <name><name>c</name>-&gt;<name>limit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>count</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_history2</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>print_history</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print the value of property PROPNAME on PATH in the repository.
   Error with SVN_ERR_FS_NOT_FOUND if PATH does not exist, or with
   SVN_ERR_PROPERTY_NOT_FOUND if no such property on PATH.
   If PATH is NULL, operate on a revision property. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_pget</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>prop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stdout_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>path</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_prop</name><argument_list>(<argument><expr>&amp;<name>prop</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_property</name><argument_list>(<argument><expr>&amp;<name>prop</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>prop</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
       <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err_msg</name></decl>;</decl_stmt>
       <if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then>
         <block>{
           <comment type="block">/* We're operating on a revprop (e.g. c-&gt;is_revision). */</comment>
           <expr_stmt><expr><name>err_msg</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Property '%s' not found on revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         }</block></then>
       <else>else
         <block>{
           <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
             <expr_stmt><expr><name>err_msg</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Property '%s' not found on path '%s' "
                                      "in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
           <else>else
             <expr_stmt><expr><name>err_msg</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Property '%s' not found on path '%s' "
                                      "in transaction %s"</expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>txn_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
         }</block></else></if>
       <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_PROPERTY_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Else. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_for_stdout</name><argument_list>(<argument><expr>&amp;<name>stdout_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Unlike the command line client, we don't translate the property
     value or print a trailing newline here.  We just output the raw
     bytes of whatever's in the repository, as svnlook is more likely
     to be used for automated inspections. */</comment>
  <expr_stmt><expr><name>len</name> = <name><name>prop</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stdout_stream</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Print the property names of all properties on PATH in the repository.
   If VERBOSE, print their values too.
   Error with SVN_ERR_FS_NOT_FOUND if PATH does not exist, or with
   SVN_ERR_PROPERTY_NOT_FOUND if no such property on PATH.
   If PATH is NULL, operate on a revision properties. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_plist</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>verbose</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stdout_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_for_stdout</name><argument_list>(<argument><expr>&amp;<name>stdout_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>path</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_proplist</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pname</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>propval</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_cancel</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pname</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>propval</name> = <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* Since we're already adding a trailing newline (and possible a
         colon and some spaces) anyway, just mimic the output of the
         command line client proplist.   Compare to 'svnlook propget',
         which sends the raw bytes to stdout, untranslated. */</comment>
      <comment type="block">/* We leave printf calls here, since we don't always know the encoding
         of the prop value. */</comment>
      <if>if <condition>(<expr><call><name>svn_prop_needs_translation</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_detranslate_string</name><argument_list>(<argument><expr>&amp;<name>propval</name></expr></argument>, <argument><expr><name>propval</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name>verbose</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pname_stdout</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>pname_stdout</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  %s : %s\n"</expr></argument>, <argument><expr><name>pname_stdout</name></expr></argument>, <argument><expr><name><name>propval</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"  %s\n"</expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_tree</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
        <param><decl><type><name>svn_boolean_t</name></type> <name>show_ids</name></decl></param>,
        <param><decl><type><name>svn_boolean_t</name></type> <name>full_paths</name></decl></param>,
        <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_id</name><argument_list>(<argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_is_dir</name><argument_list>(<argument><expr>&amp;<name>is_dir</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>print_tree</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>show_ids</name></expr></argument>, <argument><expr><name>full_paths</name></expr></argument>,
                     <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Custom filesystem warning function. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>warning_func</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
             <param><decl><type><name>svn_error_t</name> *</type><name>err</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
    <return>return;</return></then></if>
  <expr_stmt><expr><call><name>svn_handle_error2</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>"svnlook: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Factory function for the context baton. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_ctxt_baton</name><parameter_list>(<param><decl><type><name>svnlook_ctxt_t</name> **</type><name>baton_p</name></decl></param>,
               <param><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>baton</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_open</name><argument_list>(<argument><expr>&amp;(<name><name>baton</name>-&gt;<name>repos</name></name>)</expr></argument>, <argument><expr><name><name>opt_state</name>-&gt;<name>repos_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>fs</name></name> = <call><name>svn_repos_fs</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>repos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_fs_set_warning_func</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>warning_func</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>show_ids</name></name> = <name><name>opt_state</name>-&gt;<name>show_ids</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>limit</name></name> = <name><name>opt_state</name>-&gt;<name>limit</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>no_diff_deleted</name></name> = <name><name>opt_state</name>-&gt;<name>no_diff_deleted</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>no_diff_added</name></name> = <name><name>opt_state</name>-&gt;<name>no_diff_added</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>diff_copy_from</name></name> = <name><name>opt_state</name>-&gt;<name>diff_copy_from</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>full_paths</name></name> = <name><name>opt_state</name>-&gt;<name>full_paths</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>copy_info</name></name> = <name><name>opt_state</name>-&gt;<name>copy_info</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>is_revision</name></name> = <name><name>opt_state</name>-&gt;<name>txn</name></name> ? <name>FALSE</name> : <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>rev_id</name></name> = <name><name>opt_state</name>-&gt;<name>rev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>txn_name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>opt_state</name>-&gt;<name>txn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>diff_options</name></name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name><name>opt_state</name>-&gt;<name>extensions</name></name>
                                          ? <name><name>opt_state</name>-&gt;<name>extensions</name></name> : ""</expr></argument>,
                                          <argument><expr>" \t\n\r"</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>baton</name>-&gt;<name>txn_name</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_open_txn</name><argument_list>(<argument><expr>&amp;(<name><name>baton</name>-&gt;<name>txn</name></name>)</expr></argument>, <argument><expr><name><name>baton</name>-&gt;<name>fs</name></name></expr></argument>,
                            <argument><expr><name><name>baton</name>-&gt;<name>txn_name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>baton</name>-&gt;<name>rev_id</name></name> == <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;(<name><name>baton</name>-&gt;<name>rev_id</name></name>)</expr></argument>, <argument><expr><name><name>baton</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

  <expr_stmt><expr>*<name>baton_p</name> = <name>baton</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Subcommands. ***/</comment>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_author</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_author</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_cat</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>opt_state</name>-&gt;<name>arg1</name></name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_CL_INSUFFICIENT_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing repository path argument"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_cat</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>opt_state</name>-&gt;<name>arg1</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_changed</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_changed</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_date</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_date</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_diff</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_diff</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_dirschanged</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_dirs_changed</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_help</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name> <init>=
    <expr><call><name>_</name><argument_list>(<argument><expr>"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS &amp; OPTIONS ...]\n"
      "Note: any subcommand which takes the '--revision' and '--transaction'\n"
      "      options will, if invoked without one of those options, act on\n"
      "      the repository's youngest revision.\n"
      "Type 'svnlook help &lt;subcommand&gt;' for help on a specific subcommand.\n"
      "Type 'svnlook --version' to see the program version and FS modules.\n"
      "\n"
      "Available subcommands:\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_desc_start</name>
    <init>= <expr><call><name>_</name><argument_list>(<argument><expr>"The following repository back-end (FS) modules are available:\n\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>version_footer</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>version_footer</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>fs_desc_start</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_print_modules</name><argument_list>(<argument><expr><name>version_footer</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_print_help</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr>"svnlook"</expr></argument>,
                             <argument><expr><name>opt_state</name> ? <name><name>opt_state</name>-&gt;<name>version</name></name> : <name>FALSE</name></expr></argument>,
                             <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>version_footer</name>-&gt;<name>data</name></name></expr></argument>,
                             <argument><expr><name>header</name></expr></argument>, <argument><expr><name>cmd_table</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_history</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr>"/"</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>opt_state</name>-&gt;<name>arg1</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>path</name> = <name><name>opt_state</name>-&gt;<name>arg1</name></name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_history</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_lock</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>lock</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>opt_state</name>-&gt;<name>arg1</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>path</name> = <name><name>opt_state</name>-&gt;<name>arg1</name></name></expr>;</expr_stmt></then>
  <else>else
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_INSUFFICIENT_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing path argument"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_lock</name><argument_list>(<argument><expr>&amp;<name>lock</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>lock</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cr_date</name></decl>, *<decl><type ref="prev"/><name>exp_date</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>comment_lines</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>cr_date</name> = <call><name>svn_time_to_human_cstring</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>creation_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>expiration_date</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>exp_date</name> = <call><name>svn_time_to_human_cstring</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>expiration_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>comment</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>comment_lines</name> = <call><name>svn_cstring_count_newlines</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>comment</name></name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"UUID Token: %s\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>token</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Owner: %s\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>owner</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Created: %s\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cr_date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Expires: %s\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exp_date</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                 <argument><expr>(<name>comment_lines</name> != 1)
                                 ? <call><name>_</name><argument_list>(<argument><expr>"Comment (%i lines):\n%s\n"</expr></argument>)</argument_list></call>
                                 : <call><name>_</name><argument_list>(<argument><expr>"Comment (%i line):\n%s\n"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>comment_lines</name></expr></argument>,
                                 <argument><expr><name><name>lock</name>-&gt;<name>comment</name></name> ? <name><name>lock</name>-&gt;<name>comment</name></name> : ""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_info</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_author</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_date</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_log</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_log</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_log</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_pget</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>opt_state</name>-&gt;<name>arg1</name></name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_CL_INSUFFICIENT_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><name><name>opt_state</name>-&gt;<name>revprop</name></name> ?  <call><name>_</name><argument_list>(<argument><expr>"Missing propname argument"</expr></argument>)</argument_list></call> :
         <call><name>_</name><argument_list>(<argument><expr>"Missing propname and repository path arguments"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr>!<name><name>opt_state</name>-&gt;<name>revprop</name></name> &amp;&amp; <name><name>opt_state</name>-&gt;<name>arg2</name></name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name>
        <argument_list>(<argument><expr><name>SVN_ERR_CL_INSUFFICIENT_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing propname or repository path argument"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_pget</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>opt_state</name>-&gt;<name>arg1</name></name></expr></argument>,
                  <argument><expr><name><name>opt_state</name>-&gt;<name>revprop</name></name> ? <name>NULL</name> : <name><name>opt_state</name>-&gt;<name>arg2</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_plist</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name><name>opt_state</name>-&gt;<name>revprop</name></name> &amp;&amp; <name><name>opt_state</name>-&gt;<name>arg1</name></name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_CL_INSUFFICIENT_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing repository path argument"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_plist</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>opt_state</name>-&gt;<name>revprop</name></name> ? <name>NULL</name> : <name><name>opt_state</name>-&gt;<name>arg1</name></name></expr></argument>,
                   <argument><expr><name><name>opt_state</name>-&gt;<name>verbose</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_tree</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_tree</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>opt_state</name>-&gt;<name>arg1</name></name> ? <name><name>opt_state</name>-&gt;<name>arg1</name></name> : ""</expr></argument>,
                  <argument><expr><name><name>opt_state</name>-&gt;<name>show_ids</name></name></expr></argument>, <argument><expr><name><name>opt_state</name>-&gt;<name>full_paths</name></name></expr></argument>,
                  <argument><expr><name><name>opt_state</name>-&gt;<name>non_recursive</name></name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_youngest</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld\n"</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>rev_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `svn_opt_subcommand_t'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_uuid</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svnlook_ctxt_t</name> *</type><name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_ctxt_baton</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_uuid</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>&amp;<name>uuid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_printf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Main. ***/</comment>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>subcommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>svnlook_opt_state</name></type> <name>opt_state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>opt_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>received_opts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Initialize the app. */</comment>
  <if>if <condition>(<expr><call><name>svn_cmdline_init</name><argument_list>(<argument><expr>"svnlook"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call> != <name>EXIT_SUCCESS</name></expr>)</condition><then>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></then></if>

  <comment type="block">/* Create our top-level pool.  Use a seperate mutexless allocator,
   * given this application is single threaded.
   */</comment>
  <if>if <condition>(<expr><call><name>apr_allocator_create</name><argument_list>(<argument><expr>&amp;<name>allocator</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>apr_allocator_max_free_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>SVN_ALLOCATOR_RECOMMENDED_MAX_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pool</name> = <call><name>svn_pool_create_ex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_allocator_owner_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>received_opts</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_OPT_MAX_OPTIONS</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check library versions */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>check_lib_versions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svnlook: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Initialize the FS library. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_fs_initialize</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svnlook: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>argc</name> &lt;= 1</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Initialize opt_state. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>opt_state</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opt_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* Parse options. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_cmdline__getopt_init</name><argument_list>(<argument><expr>&amp;<name>os</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svnlook: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>os</name>-&gt;<name>interleave</name></name> = 1</expr>;</expr_stmt>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>opt_arg</name></decl>;</decl_stmt>

      <comment type="block">/* Parse the next option. */</comment>
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_getopt_long</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>, <argument><expr>&amp;<name>opt_id</name></expr></argument>, <argument><expr>&amp;<name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then>
      <else>else <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then></if></else></if>

      <comment type="block">/* Stash the option code in an array before parsing it. */</comment>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>received_opts</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call> = <name>opt_id</name></expr>;</expr_stmt>

      <switch>switch <condition>(<expr><name>opt_id</name></expr>)</condition>
        <block>{
        <case>case <expr>'r'</expr>:
          <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>digits_end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>opt_state</name>.<name>rev</name></name> = <call><name>strtol</name><argument_list>(<argument><expr><name>opt_arg</name></expr></argument>, <argument><expr>&amp;<name>digits_end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>opt_state</name>.<name>rev</name></name></expr></argument>)</argument_list></call>)
                || (! <name>digits_end</name>)
                || *<name>digits_end</name></expr>)</condition><then>
              <expr_stmt><expr><call><name>SVN_INT_ERR</name><argument_list>(<argument><expr><call><name>svn_error_create</name>
                          <argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid revision number supplied"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          }</block>
          <break>break;</break>

        </case><case>case <expr>'t'</expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>txn</name></name> = <name>opt_arg</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr>'N'</expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>non_recursive</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr>'v'</expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>verbose</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr>'h'</expr>:
        </case><case>case <expr>'?'</expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>help</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svnlook__revprop_opt</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>revprop</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svnlook__version</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>version</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svnlook__show_ids</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>show_ids</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr>'l'</expr>:
          <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>opt_state</name>.<name>limit</name></name> = <call><name>strtol</name><argument_list>(<argument><expr><name>opt_arg</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>end</name> == <name>opt_arg</name> || *<name>end</name> != '\0'</expr>)</condition><then>
              <block>{
                <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Non-numeric limit argument given"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svnlook: "</expr></argument>)</argument_list></call></expr>;</return>
              }</block></then></if>
            <if>if <condition>(<expr><name><name>opt_state</name>.<name>limit</name></name> &lt;= 0</expr>)</condition><then>
              <block>{
                <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Argument to --limit must be positive"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svnlook: "</expr></argument>)</argument_list></call></expr>;</return>
              }</block></then></if>
          }</block>
          <break>break;</break>

        </case><case>case <expr><name>svnlook__no_diff_deleted</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>no_diff_deleted</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svnlook__no_diff_added</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>no_diff_added</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svnlook__diff_copy_from</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>diff_copy_from</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svnlook__full_paths</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>full_paths</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svnlook__copy_info</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>copy_info</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr>'x'</expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>extensions</name></name> = <name>opt_arg</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><default>default:
          <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>

        </default>}</block></switch>
    }</block></while>

  <comment type="block">/* The --transaction and --revision options may not co-exist. */</comment>
  <if>if <condition>(<expr>(<name><name>opt_state</name>.<name>rev</name></name> != <name>SVN_INVALID_REVNUM</name>) &amp;&amp; <name><name>opt_state</name>.<name>txn</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_INT_ERR</name><argument_list>(<argument><expr><call><name>svn_error_create</name>
                <argument_list>(<argument><expr><name>SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The '--transaction' (-t) and '--revision' (-r) arguments "
                   "can not co-exist"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If the user asked for help, then the rest of the arguments are
     the names of subcommands to get help on (if any), or else they're
     just typos/mistakes.  Whatever the case, the subcommand to
     actually run is subcommand_help(). */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>help</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>subcommand</name> = <call><name>svn_opt_get_canonical_subcommand</name><argument_list>(<argument><expr><name>cmd_table</name></expr></argument>, <argument><expr>"help"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If we're not running the `help' subcommand, then look for a
     subcommand in the first argument. */</comment>
  <if>if <condition>(<expr><name>subcommand</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &gt;= <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>opt_state</name>.<name>version</name></name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Use the "help" subcommand to handle the "--version" option. */</comment>
              <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name></type> <name>pseudo_cmd</name> <init>=
                <expr><block>{ <expr>"--version"</expr>, <expr><name>subcommand_help</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr>""</expr>,
                  <expr><block>{<expr><name>svnlook__version</name></expr>,  <comment type="block">/* must accept its own option */</comment>
                  }</block></expr> }</block></expr></init></decl>;</decl_stmt>

              <expr_stmt><expr><name>subcommand</name> = &amp;<name>pseudo_cmd</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name>
                <argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Subcommand argument required\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
            }</block></else></if>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>first_arg</name> <init>= <expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>subcommand</name> = <call><name>svn_opt_get_canonical_subcommand</name><argument_list>(<argument><expr><name>cmd_table</name></expr></argument>, <argument><expr><name>first_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>subcommand</name> == <name>NULL</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>first_arg_utf8</name></decl>;</decl_stmt>
              <expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>first_arg_utf8</name></expr></argument>, <argument><expr><name>first_arg</name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svnlook: "</expr></argument>)</argument_list></call></expr>;</return></then></if>
              <expr_stmt><expr><call><name>svn_error_clear</name>
                <argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unknown command: '%s'\n"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>first_arg_utf8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* If there's a second argument, it's the repository.  There may be
     more arguments following the repository; usually the next one is
     a path within the repository, or it's a propname and the one
     after that is the path.  Since we don't know, we just call them
     arg1 and arg2, meaning the first and second arguments following
     the repository. */</comment>
  <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>subcommand_help</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg1</name> <init>= <expr><name>NULL</name></expr></init>, *<name>arg2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Get the repository. */</comment>
      <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &lt; <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_INT_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>repos_path</name></expr></argument>,
                                              <argument><expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>repos_path</name> = <call><name>svn_path_internal_style</name><argument_list>(<argument><expr><name>repos_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr><name>repos_path</name> == <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name>
            <argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Repository argument required\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then>
      <else>else <if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>repos_path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name>
            <argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is a URL when it should be a path\n"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>repos_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then></if></else></if>

      <expr_stmt><expr><name><name>opt_state</name>.<name>repos_path</name></name> = <name>repos_path</name></expr>;</expr_stmt>

      <comment type="block">/* Get next arg (arg1), if any. */</comment>
      <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &lt; <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_INT_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name>
                      <argument_list>(<argument><expr>&amp;<name>arg1</name></expr></argument>, <argument><expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>arg1</name> = <call><name>svn_path_internal_style</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><name><name>opt_state</name>.<name>arg1</name></name> = <name>arg1</name></expr>;</expr_stmt>

      <comment type="block">/* Get next arg (arg2), if any. */</comment>
      <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &lt; <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_INT_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name>
                      <argument_list>(<argument><expr>&amp;<name>arg2</name></expr></argument>, <argument><expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>arg2</name> = <call><name>svn_path_internal_style</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><name><name>opt_state</name>.<name>arg2</name></name> = <name>arg2</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Check that the subcommand wasn't passed any inappropriate options. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>received_opts</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>opt_id</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>received_opts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* All commands implicitly accept --help, so just skip over this
         when we see it. Note that we don't want to include this option
         in their "accepted options" list because it would be awfully
         redundant to display it in every commands' help text. */</comment>
      <if>if <condition>(<expr><name>opt_id</name> == 'h' || <name>opt_id</name> == '?'</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr>! <call><name>svn_opt_subcommand_takes_option</name><argument_list>(<argument><expr><name>subcommand</name></expr></argument>, <argument><expr><name>opt_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>optstr</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>badopt</name> <init>=
            <expr><call><name>svn_opt_get_option_from_code</name><argument_list>(<argument><expr><name>opt_id</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>svn_opt_format_option</name><argument_list>(<argument><expr>&amp;<name>optstr</name></expr></argument>, <argument><expr><name>badopt</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>name</name><index>[<expr>0</expr>]</index></name> == '-'</expr>)</condition><then>
            <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_error_clear</name>
              <argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name>
               <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Subcommand '%s' doesn't accept option '%s'\n"
                  "Type 'svnlook help %s' for usage.\n"</expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>subcommand</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>optstr</name></expr></argument>, <argument><expr><name><name>subcommand</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Set up our cancellation support. */</comment>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBREAK</name></cpp:ifdef>
  <comment type="block">/* SIGBREAK is a Win32 specific signal generated by ctrl-break. */</comment>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGBREAK</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGHUP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGTERM</name></cpp:ifdef>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGPIPE</name></cpp:ifdef>
  <comment type="block">/* Disable SIGPIPE generation for the platforms that have it. */</comment>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGXFSZ</name></cpp:ifdef>
  <comment type="block">/* Disable SIGXFSZ generation for the platforms that have it, otherwise
   * working with large files when compiled against an APR that doesn't have
   * large file support will crash the program, which is uncool. */</comment>
  <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGXFSZ</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Run the subcommand. */</comment>
  <expr_stmt><expr><name>err</name> = <call>(*<name><name>subcommand</name>-&gt;<name>cmd_func</name></name>)<argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr>&amp;<name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* For argument-related problems, suggest using the 'help'
         subcommand. */</comment>
      <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CL_INSUFFICIENT_ARGS</name>
          || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>svn_error_quick_wrap</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Try 'svnlook help' for more info"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svnlook: "</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Ensure everything is printed on stdout, so the user sees any
         print errors. */</comment>
      <expr_stmt><expr><call><name>SVN_INT_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>
    }</block></else></if>
}</block></function>
</unit>
