<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_client/externals.c"><comment type="block">/*
 * externals.c:  handle the svn:externals property
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<comment type="block">/* ==================================================================== */</comment>


<escape char="0xc"/>
<comment type="block">/*** Includes. ***/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_uri.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"client.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/* Closure for handle_external_item_change. */</comment>
<struct>struct <name>handle_external_item_change_baton</name>
<block>{
  <comment type="block">/* As returned by svn_wc_parse_externals_description(). */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>new_desc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>old_desc</name></decl>;</decl_stmt>

  <comment type="block">/* The directory that has this externals property. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl>;</decl_stmt>

  <comment type="block">/* The URL for the directory that has this externals property. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir_url</name></decl>;</decl_stmt>

  <comment type="block">/* The URL for the repository root. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_root_url</name></decl>;</decl_stmt>

  <comment type="block">/* Passed through to svn_client_* functions. */</comment>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>

  <comment type="block">/* If set, then run update on items that didn't change. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>update_unchanged</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name> *</type><name>timestamp_sleep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_export</name></decl>;</decl_stmt>

  <comment type="block">/* A scratchwork pool -- do not put anything in here that needs to
     outlive the hash diffing callback! */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Return true if NEW_ITEM and OLD_ITEM represent the same external
   item at the same revision checked out into the same target subdir,
   else return false.

   ### If this returned the nature of the difference, we could use it
   to update externals more efficiently.  For example, if we know
   that only the revision number changed, but the target URL did not,
   we could get away with an "update -r" on the external, instead of
   a re-checkout. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>compare_external_items</name><parameter_list>(<param><decl><type><name>svn_wc_external_item2_t</name> *</type><name>new_item</name></decl></param>,
                       <param><decl><type><name>svn_wc_external_item2_t</name> *</type><name>old_item</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name><name>new_item</name>-&gt;<name>target_dir</name></name></expr></argument>, <argument><expr><name><name>old_item</name>-&gt;<name>target_dir</name></name></expr></argument>)</argument_list></call> != 0)
      || (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>new_item</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name><name>old_item</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call> != 0)
      || (! <call><name>svn_client__compare_revisions</name><argument_list>(<argument><expr>&amp;(<name><name>new_item</name>-&gt;<name>revision</name></name>)</expr></argument>,
                                          <argument><expr>&amp;(<name><name>old_item</name>-&gt;<name>revision</name></name>)</expr></argument>)</argument_list></call>)
      || (! <call><name>svn_client__compare_revisions</name><argument_list>(<argument><expr>&amp;(<name><name>new_item</name>-&gt;<name>peg_revision</name></name>)</expr></argument>,
                                          <argument><expr>&amp;(<name><name>old_item</name>-&gt;<name>peg_revision</name></name>)</expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* Else. */</comment>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<comment type="block">/* Remove PATH from revision control, and do the same to any revision
 * controlled directories underneath PATH (including directories not
 * referred to by parent svn administrative areas); then if PATH is
 * empty afterwards, remove it, else rename it to a unique name in the
 * same parent directory.
 *
 * Pass CANCEL_FUNC, CANCEL_BATON to svn_wc_remove_from_revision_control.
 *
 * Use POOL for all temporary allocation.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>relegate_external</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                  <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>,
                           <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_wc_remove_from_revision_control</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>,
                                            <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>,
                                            <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                            <argument><expr><name>cancel_func</name></expr></argument>,
                                            <argument><expr><name>cancel_baton</name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### Ugly. Unlock only if not going to return an error. Revisit */</comment>
  <if>if <condition>(<expr>!<name>err</name> || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_LEFT_LOCAL_MOD</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_LEFT_LOCAL_MOD</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_path</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Reserve the new dir name. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name>
              <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>new_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>".OLD"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Sigh...  We must fall ever so slightly from grace.

         Ideally, there would be no window, however brief, when we
         don't have a reservation on the new name.  Unfortunately,
         at least in the Unix (Linux?) version of apr_file_rename(),
         you can't rename a directory over a file, because it's just
         calling stdio rename(), which says:

            ENOTDIR
              A  component used as a directory in oldpath or newpath
              path is not, in fact, a directory.  Or, oldpath  is
              a directory, and newpath exists but is not a directory

         So instead, we get the name, then remove the file (ugh), then
         rename the directory, hoping that nobody has gotten that name
         in the meantime -- which would never happen in real life, so
         no big deal.
      */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* It's not clear why this is ignored, is
                                 it because the rename will catch it? */</comment>

      <comment type="block">/* Rename. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Try to update an external PATH to URL at REVISION.
   Use POOL for temporary allocations, and use the client context CTX. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>switch_external</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>peg_revision</name></decl></param>,
                <param><decl><type><name>svn_boolean_t</name> *</type><name>timestamp_sleep</name></decl></param>,
                <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First notify that we're about to handle an external. */</comment>
  <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name><name>ctx</name>-&gt;<name>notify_func2</name></name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>,
                      <argument><expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_update_external</name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If path is a directory, try to update/switch to the correct URL
     and revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>0</expr></argument>,
                               <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                           <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>url</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If we have what appears to be a version controlled
             subdir, and its top-level URL matches that of our
             externals definition, perform an update. */</comment>
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__update_internal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>,
                                                  <argument><expr><name>svn_depth_unknown</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                  <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                  <argument><expr><name>timestamp_sleep</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
            }</block></then>
          <else>else <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>repos</name></name></expr>)</condition><then>
            <block>{
              <comment type="block">/* URLs don't match.  Try to relocate (if necessary) and then
                 switch. */</comment>
              <if>if <condition>(<expr>! <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_root</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl>;</decl_stmt>

                  <comment type="block">/* Get the repos root of the new URL. */</comment>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name>
                          <argument_list>(<argument><expr>&amp;<name>ra_session</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                           <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>repos_root</name></expr></argument>,
                                                 <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <expr_stmt><expr><name>err</name> = <call><name>svn_client_relocate</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>repos_root</name></expr></argument>,
                                            <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <comment type="block">/* If the relocation failed because the new URL points
                     to another repository, then we need to relegate and
                     check out a new WC. */</comment>
                  <if>if <condition>(<expr><name>err</name>
                      &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_INVALID_RELOCATION</name>
                          || (<name><name>err</name>-&gt;<name>apr_err</name></name>
                              == <name>SVN_ERR_CLIENT_INVALID_RELOCATION</name>))</expr>)</condition><then>
                    <block>{
                      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <goto>goto <name>relegate</name>;</goto>
                    }</block></then>
                  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>
                }</block></then></if>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__switch_internal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>url</name></expr></argument>,
                                                  <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>,
                                                  <argument><expr><name>svn_depth_infinity</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                  <argument><expr><name>timestamp_sleep</name></expr></argument>,
                                                  <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
            }</block></then></if></else></if>
        }</block></then></if>
    }</block></then></if>

 <label><name>relegate</name>:</label>

  <comment type="block">/* Fall back on removing the WC and checking out a new one. */</comment>

  <comment type="block">/* Ensure that we don't have any RA sessions or WC locks from failed
     operations above. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <comment type="block">/* Buh-bye, old and busted ... */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>relegate_external</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                              <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                              <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <block>{
      <comment type="block">/* The target dir might have multiple components.  Guarantee
         the path leading down to the last component. */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent</name> <init>= <expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* ... Hello, new hotness. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__checkout_internal</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>,
                                        <argument><expr><name>revision</name></expr></argument>,
                                        <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>timestamp_sleep</name></expr></argument>,
                                        <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Return the scheme of @a uri in @a scheme allocated from @a pool.
   If @a uri does not appear to be a valid URI, then @a scheme will
   not be updated.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>uri_scheme</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>scheme</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>uri</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>uri</name><index>[<expr><name>i</name></expr>]</index></name> != ':'</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <if>if <condition>(<expr><name><name>uri</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
      <goto>goto <name>error</name>;</goto></then></if></for>

  <if>if <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name><name>uri</name><index>[<expr><name>i</name></expr>]</index></name> == ':' &amp;&amp; <name><name>uri</name><index>[<expr><name>i</name>+1</expr>]</index></name> == '/' &amp;&amp; <name><name>uri</name><index>[<expr><name>i</name>+2</expr>]</index></name> == '/'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>scheme</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

<label><name>error</name>:</label>
  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"URL '%s' does not begin with a scheme"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* If the URL for @a item is relative, then using the repository root
   URL @a repos_root_url and the parent directory URL @parent_dir_url,
   resolve it into an absolute URL and save it in @a item.

   Regardless if the URL is absolute or not, if there are no errors,
   the URL in @a item will be canonicalized.

   The following relative URL formats are supported:

     ../    relative to the parent directory of the external
     ^/     relative to the repository root
     //     relative to the scheme
     /      relative to the server's hostname

   The ../ and ^/ relative URLs may use .. to remove path elements up
   to the server root.

   The external URL should not be canonicalized otherwise the scheme
   relative URL '//host/some/path' would have been canonicalized to
   '/host/some/path' and we would not be able to match on the leading
   '//'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>resolve_relative_external_url</name><parameter_list>(<param><decl><type><name>svn_wc_external_item2_t</name> *</type><name>item</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_root_url</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir_url</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uncanonicalized_url</name> <init>= <expr><name><name>item</name>-&gt;<name>url</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>canonicalized_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>parent_dir_parsed_uri</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>canonicalized_url</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>uncanonicalized_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the URL is already absolute, there is nothing to do. */</comment>
  <if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>canonicalized_url</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>item</name>-&gt;<name>url</name></name> = <name>canonicalized_url</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Parse the parent directory URL into its parts. */</comment>
  <expr_stmt><expr><name>status</name> = <call><name>apr_uri_parse</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>parent_dir_url</name></expr></argument>, <argument><expr>&amp;<name>parent_dir_parsed_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Illegal parent directory URL '%s'."</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>parent_dir_url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Handle URLs relative to the current directory or to the
     repository root.  The backpaths may only remove path elements,
     not the hostname.  This allows an external to refer to another
     repository in the same server relative to the location of this
     repository, say using SVNParentPath. */</comment>
  <if>if <condition>(<expr>(0 == <call><name>strncmp</name><argument_list>(<argument><expr>"../"</expr></argument>, <argument><expr><name>uncanonicalized_url</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>) ||
      (0 == <call><name>strncmp</name><argument_list>(<argument><expr>"^/"</expr></argument>, <argument><expr><name>uncanonicalized_url</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>base_components</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>relative_components</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <comment type="block">/* Decompose either the parent directory's URL path or the
         repository root's URL path into components.  */</comment>
      <if>if <condition>(<expr>0 == <call><name>strncmp</name><argument_list>(<argument><expr>"../"</expr></argument>, <argument><expr><name>uncanonicalized_url</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>base_components</name> = <call><name>svn_path_decompose</name><argument_list>(<argument><expr><name><name>parent_dir_parsed_uri</name>.<name>path</name></name></expr></argument>,
                                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>relative_components</name> = <call><name>svn_path_decompose</name><argument_list>(<argument><expr><name>canonicalized_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>repos_root_parsed_uri</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>status</name> = <call><name>apr_uri_parse</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>repos_root_url</name></expr></argument>, <argument><expr>&amp;<name>repos_root_parsed_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Illegal repository root URL '%s'."</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>repos_root_url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <expr_stmt><expr><name>base_components</name> = <call><name>svn_path_decompose</name><argument_list>(<argument><expr><name><name>repos_root_parsed_uri</name>.<name>path</name></name></expr></argument>,
                                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>relative_components</name> = <call><name>svn_path_decompose</name><argument_list>(<argument><expr><name>canonicalized_url</name> + 2</expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>relative_components</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>relative_components</name></expr></argument>,
                                                <argument><expr><name>i</name></expr></argument>,
                                                <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>0 == <call><name>strcmp</name><argument_list>(<argument><expr>".."</expr></argument>, <argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <comment type="block">/* Constructing the final absolute URL together with
                 apr_uri_unparse() requires that the path be absolute,
                 so only pop a component if the component being popped
                 is not the component for the root directory. */</comment>
              <if>if <condition>(<expr><name><name>base_components</name>-&gt;<name>nelts</name></name> &gt; 1</expr>)</condition><then>
                <expr_stmt><expr><call><name>apr_array_pop</name><argument_list>(<argument><expr><name>base_components</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then>
          <else>else
            <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>base_components</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>component</name></expr>;</expr_stmt></else></if>
        }</block></for>

      <expr_stmt><expr><name><name>parent_dir_parsed_uri</name>.<name>path</name></name> = (<name>char</name> *)<call><name>svn_path_compose</name><argument_list>(<argument><expr><name>base_components</name></expr></argument>,
                                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent_dir_parsed_uri</name>.<name>query</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent_dir_parsed_uri</name>.<name>fragment</name></name> = <name>NULL</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>item</name>-&gt;<name>url</name></name> = <call><name>apr_uri_unparse</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>parent_dir_parsed_uri</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* The remaining URLs are relative to the either the scheme or
     server root and can only refer to locations inside that scope, so
     backpaths are not allowed. */</comment>
  <if>if <condition>(<expr><call><name>svn_path_is_backpath_present</name><argument_list>(<argument><expr><name>canonicalized_url</name> + 2</expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The external relative URL '%s' cannot have "
                               "backpaths, i.e. '..'."</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>uncanonicalized_url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Relative to the scheme. */</comment>
  <if>if <condition>(<expr>0 == <call><name>strncmp</name><argument_list>(<argument><expr>"//"</expr></argument>, <argument><expr><name>uncanonicalized_url</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>uri_scheme</name><argument_list>(<argument><expr>&amp;<name>scheme</name></expr></argument>, <argument><expr><name>repos_root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>url</name></name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                    <argument><expr><name>scheme</name></expr></argument>,
                                                    <argument><expr>":"</expr></argument>,
                                                    <argument><expr><name>uncanonicalized_url</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Relative to the server root. */</comment>
  <if>if <condition>(<expr><name><name>uncanonicalized_url</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>parent_dir_parsed_uri</name>.<name>path</name></name> = (<name>char</name> *)<name>canonicalized_url</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent_dir_parsed_uri</name>.<name>query</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent_dir_parsed_uri</name>.<name>fragment</name></name> = <name>NULL</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>item</name>-&gt;<name>url</name></name> = <call><name>apr_uri_unparse</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>parent_dir_parsed_uri</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unrecognized format for the relative external "
                             "URL '%s'."</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>uncanonicalized_url</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* This implements the 'svn_hash_diff_func_t' interface.
   BATON is of type 'struct handle_external_item_change_baton *'.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>handle_external_item_change</name><argument_list>(<argument><expr>const <name>void</name> *<name>key</name></expr></argument>, <argument><expr><name>apr_ssize_t</name> <name>klen</name></expr></argument>,
                            <argument>enum <expr><name>svn_hash_diff_key_status</name> <name>status</name></expr></argument>,
                            <argument><expr><name>void</name> *<name>baton</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type>struct <name>handle_external_item_change_baton</name> *</type><name>ib</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_external_item2_t</name> *</type><name>old_item</name></decl>, *<decl><type ref="prev"/><name>new_item</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>ib</name>-&gt;<name>parent_dir</name></name></expr></argument>,
                                   <argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Don't bother to check status, since we'll get that for free by
     attempting to retrieve the hash values anyway.  */</comment>

  <if>if <condition>(<expr>(<name><name>ib</name>-&gt;<name>old_desc</name></name>) &amp;&amp; (! <name><name>ib</name>-&gt;<name>is_export</name></name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>old_item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>ib</name>-&gt;<name>old_desc</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>old_item</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>resolve_relative_external_url</name><argument_list>(<argument><expr><name>old_item</name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>repos_root_url</name></name></expr></argument>,
                                              <argument><expr><name><name>ib</name>-&gt;<name>parent_dir_url</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>old_item</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name><name>ib</name>-&gt;<name>new_desc</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>new_item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>ib</name>-&gt;<name>new_desc</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>new_item</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>resolve_relative_external_url</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>repos_root_url</name></name></expr></argument>,
                                              <argument><expr><name><name>ib</name>-&gt;<name>parent_dir_url</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>new_item</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* We couldn't possibly be here if both values were null, right? */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>old_item</name> || <name>new_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* There's one potential ugliness.  If a target subdir changed, but
     its URL did not, then ideally we'd just rename the subdir, rather
     than remove the old subdir only to do a new checkout into the new
     subdir.

     We could solve this by "sneaking around the back" and looking in
     ib-&gt;new_desc, ib-&gt;old_desc to check if anything else in this
     parent_dir has the same URL.  Of course, if an external gets
     moved into some other directory, then we'd lose anyway.  The only
     way to fully handle this would be to harvest a global list based
     on urls/revs, and consult the list every time we're about to
     delete an external subdir: whenever a deletion is really part of
     a rename, then we'd do the rename on the spot.

     IMHO, renames aren't going to be frequent enough to make the
     extra bookkeeping worthwhile.
  */</comment>

  <comment type="block">/* Not protecting against recursive externals.  Detecting them in
     the global case is hard, and it should be pretty obvious to a
     user when it happens.  Worst case: your disk fills up :-). */</comment>

  <if>if <condition>(<expr>! <name>old_item</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* The target dir might have multiple components.  Guarantee
         the path leading down to the last component. */</comment>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we were handling renames the fancy way, then before
         checking out a new subdir here, we would somehow learn if
         it's really just a rename of an old one.  That would work in
         tandem with the next case -- this case would do nothing,
         knowing that the next case either already has, or soon will,
         rename the external subdirectory. */</comment>

      <comment type="block">/* First notify that we're about to handle an external. */</comment>
      <if>if <condition>(<expr><name><name>ib</name>-&gt;<name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
        <expr_stmt><expr><call>(*<name><name>ib</name>-&gt;<name>ctx</name>-&gt;<name>notify_func2</name></name>)
          <argument_list>(<argument><expr><name><name>ib</name>-&gt;<name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>,
           <argument><expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_update_external</name></expr></argument>,
                                <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name><name>ib</name>-&gt;<name>is_export</name></name></expr>)</condition><then>
        <comment type="block">/* ### It should be okay to "force" this export.  Externals
           only get created in subdirectories of versioned
           directories, so an external directory couldn't already
           exist before the parent export process unless a versioned
           directory above it did, which means the user would have
           already had to force these creations to occur. */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client_export4</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>new_item</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                   <argument><expr>&amp;(<name><name>new_item</name>-&gt;<name>peg_revision</name></name>)</expr></argument>,
                                   <argument><expr>&amp;(<name><name>new_item</name>-&gt;<name>revision</name></name>)</expr></argument>,
                                   <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>svn_depth_infinity</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name><name>ib</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__checkout_internal</name>
                <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>new_item</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                 <argument><expr>&amp;(<name><name>new_item</name>-&gt;<name>peg_revision</name></name>)</expr></argument>, <argument><expr>&amp;(<name><name>new_item</name>-&gt;<name>revision</name></name>)</expr></argument>,
                 <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>timestamp_sleep</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <name>new_item</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* See comment in above case about fancy rename handling.  Here,
         before removing an old subdir, we would see if it wants to
         just be renamed to a new one. */</comment>

      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>err2</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>-1</expr></argument>,
                               <argument><expr><name><name>ib</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                               <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* We don't use relegate_external() here, because we know that
         nothing else in this externals description (at least) is
         going to need this directory, and therefore it's better to
         leave stuff where the user expects it. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_wc_remove_from_revision_control</name>
        <argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
         <argument><expr><name><name>ib</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* ### Ugly. Unlock only if not going to return an error. Revisit */</comment>
      <if>if <condition>(<expr>!<name>err</name> || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_LEFT_LOCAL_MOD</name></expr>)</condition><then>
        <if>if <condition>(<expr>(<name>err2</name> = <call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
          <block>{
            <if>if <condition>(<expr>!<name>err</name></expr>)</condition><then>
              <expr_stmt><expr><name>err</name> = <name>err2</name></expr>;</expr_stmt></then>
            <else>else
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          }</block></then></if></then></if>

      <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> != <name>SVN_ERR_WC_LEFT_LOCAL_MOD</name>)</expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* ### If there were multiple path components leading down to
         that wc, we could try to remove them too. */</comment>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <call><name>compare_external_items</name><argument_list>(<argument><expr><name>new_item</name></expr></argument>, <argument><expr><name>old_item</name></expr></argument>)</argument_list></call>
           || <name><name>ib</name>-&gt;<name>update_unchanged</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Either the URL changed, or the exact same item is present in
         both hashes, and caller wants to update such unchanged items.
         In the latter case, the call below will try to make sure that
         the external really is a WC pointing to the correct
         URL/revision. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>switch_external</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>new_item</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr>&amp;(<name><name>new_item</name>-&gt;<name>revision</name></name>)</expr></argument>,
                              <argument><expr>&amp;(<name><name>new_item</name>-&gt;<name>peg_revision</name></name>)</expr></argument>,
                              <argument><expr><name><name>ib</name>-&gt;<name>timestamp_sleep</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if>

  <comment type="block">/* Clear IB-&gt;pool -- we only use it for scratchwork (and this will
     close any RA sessions still open in this pool). */</comment>
  <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>ib</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>


<comment type="block">/* Closure for handle_externals_change. */</comment>
<struct>struct <name>handle_externals_desc_change_baton</name>
<block>{
  <comment type="block">/* As returned by svn_wc_edited_externals(). */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>externals_new</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>externals_old</name></decl>;</decl_stmt>

  <comment type="block">/* The requested depth of the driving operation (e.g., update, switch). */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl>;</decl_stmt>

  <comment type="block">/* As returned by svn_wc_traversed_depths().  NULL means no ambient
     depths available (e.g., svn export). */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>ambient_depths</name></decl>;</decl_stmt>

  <comment type="block">/* These two map a URL to a path where the URL is either checked out
     to or exported to.  The to_path must be a substring of the
     external item parent directory path. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl>;</decl_stmt>

  <comment type="block">/* Passed through to handle_external_item_change_baton. */</comment>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_root_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>update_unchanged</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name> *</type><name>timestamp_sleep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_export</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* This implements the 'svn_hash_diff_func_t' interface.
   BATON is of type 'struct handle_externals_desc_change_baton *'.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>handle_externals_desc_change</name><argument_list>(<argument><expr>const <name>void</name> *<name>key</name></expr></argument>, <argument><expr><name>apr_ssize_t</name> <name>klen</name></expr></argument>,
                             <argument>enum <expr><name>svn_hash_diff_key_status</name> <name>status</name></expr></argument>,
                             <argument><expr><name>void</name> *<name>baton</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type>struct <name>handle_externals_desc_change_baton</name> *</type><name>cb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>handle_external_item_change_baton</name></type> <name>ib</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_desc_text</name></decl>, *<decl><type ref="prev"/><name>new_desc_text</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>old_desc</name></decl>, *<decl><type ref="prev"/><name>new_desc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>old_desc_hash</name></decl>, *<decl><type ref="prev"/><name>new_desc_hash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_external_item2_t</name> *</type><name>item</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ambient_depth_w</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>ambient_depth</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>cb</name>-&gt;<name>ambient_depths</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>ambient_depth_w</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>ambient_depths</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ambient_depth_w</name> == <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_WC_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Traversal of '%s' found no ambient depth"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>ambient_depth</name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>ambient_depth_w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>ambient_depth</name> = <name>svn_depth_infinity</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Bag out if the depth here is too shallow for externals action. */</comment>
  <if>if <condition>(<expr>(<name><name>cb</name>-&gt;<name>requested_depth</name></name> &lt; <name>svn_depth_infinity</name>
       &amp;&amp; <name><name>cb</name>-&gt;<name>requested_depth</name></name> != <name>svn_depth_unknown</name>)
      || (<name>ambient_depth</name> &lt; <name>svn_depth_infinity</name>
          &amp;&amp; <name><name>cb</name>-&gt;<name>requested_depth</name></name> &lt; <name>svn_depth_infinity</name>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr>(<name>old_desc_text</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>externals_old</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_parse_externals_description3</name><argument_list>(<argument><expr>&amp;<name>old_desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>old_desc_text</name></expr></argument>,
                                                <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>old_desc</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr>(<name>new_desc_text</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>externals_new</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_parse_externals_description3</name><argument_list>(<argument><expr>&amp;<name>new_desc</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>new_desc_text</name></expr></argument>,
                                                <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>new_desc</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>old_desc_hash</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>new_desc_hash</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create hashes of our two externals arrays so that we can
     efficiently generate a diff for them. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>old_desc</name> &amp;&amp; (<name>i</name> &lt; <name><name>old_desc</name>-&gt;<name>nelts</name></name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>old_desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_wc_external_item2_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>old_desc_hash</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>new_desc</name> &amp;&amp; (<name>i</name> &lt; <name><name>new_desc</name>-&gt;<name>nelts</name></name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>new_desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_wc_external_item2_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>new_desc_hash</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><name><name>ib</name>.<name>old_desc</name></name>          = <name>old_desc_hash</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ib</name>.<name>new_desc</name></name>          = <name>new_desc_hash</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ib</name>.<name>parent_dir</name></name>        = (const <name>char</name> *) <name>key</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ib</name>.<name>repos_root_url</name></name>    = <name><name>cb</name>-&gt;<name>repos_root_url</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ib</name>.<name>ctx</name></name>               = <name><name>cb</name>-&gt;<name>ctx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ib</name>.<name>update_unchanged</name></name>  = <name><name>cb</name>-&gt;<name>update_unchanged</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ib</name>.<name>is_export</name></name>         = <name><name>cb</name>-&gt;<name>is_export</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ib</name>.<name>timestamp_sleep</name></name>   = <name><name>cb</name>-&gt;<name>timestamp_sleep</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ib</name>.<name>pool</name></name>              = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the URL of the parent directory by appending a portion of
     parent_dir to from_url.  from_url is the URL for to_path and
     to_path is a substring of parent_dir, so append any characters in
     parent_dir past strlen(to_path) to from_url, making sure to move
     past a '/' in parent_dir, otherwise svn_path_join() will use the
     absolute path in parent_dir instead of joining from_url with the
     parent_dir substring. */</comment>
  <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>to_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>ib</name>.<name>parent_dir</name><index>[<expr><name>len</name></expr>]</index></name> == '/'</expr>)</condition><then>
    <expr_stmt><expr>++<name>len</name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>ib</name>.<name>parent_dir_url</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>from_url</name></name></expr></argument>,
                                    <argument><expr><name><name>ib</name>.<name>parent_dir</name></name> + <name>len</name></expr></argument>,
                                    <argument><expr><name><name>cb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We must use a custom version of svn_hash_diff so that the diff
     entries are processed in the order they were originally specified
     in the svn:externals properties. */</comment>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>old_desc</name> &amp;&amp; (<name>i</name> &lt; <name><name>old_desc</name>-&gt;<name>nelts</name></name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>old_desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_wc_external_item2_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>new_desc_hash</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>handle_external_item_change</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>,
                                            <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                                            <argument><expr><name>svn_hash_diff_key_both</name></expr></argument>, <argument><expr>&amp;<name>ib</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>handle_external_item_change</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>,
                                            <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                                            <argument><expr><name>svn_hash_diff_key_a</name></expr></argument>, <argument><expr>&amp;<name>ib</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></for>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>new_desc</name> &amp;&amp; (<name>i</name> &lt; <name><name>new_desc</name>-&gt;<name>nelts</name></name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>new_desc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_wc_external_item2_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>old_desc_hash</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>handle_external_item_change</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>,
                                            <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                                            <argument><expr><name>svn_hash_diff_key_b</name></expr></argument>, <argument><expr>&amp;<name>ib</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

  <comment type="block">/* Now destroy the subpool we pass to the hash differ.  This will
     close any remaining RA sessions used by the hash diff callback. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>ib</name>.<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>


<function><type><name>svn_error_t</name> *</type>
<name>svn_client__handle_externals</name><parameter_list>(<param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_url</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_root_url</name></decl></param>,
                             <param><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>update_unchanged</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name> *</type><name>timestamp_sleep</name></decl></param>,
                             <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>externals_old</name></decl>, *<decl><type ref="prev"/><name>externals_new</name></decl>, *<decl><type ref="prev"/><name>ambient_depths</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>handle_externals_desc_change_baton</name></type> <name>cb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_wc_edited_externals</name><argument_list>(<argument><expr>&amp;<name>externals_old</name></expr></argument>, <argument><expr>&amp;<name>externals_new</name></expr></argument>, <argument><expr><name>traversal_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_wc_traversed_depths</name><argument_list>(<argument><expr>&amp;<name>ambient_depths</name></expr></argument>, <argument><expr><name>traversal_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>cb</name>.<name>externals_new</name></name>     = <name>externals_new</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>externals_old</name></name>     = <name>externals_old</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>requested_depth</name></name>   = <name>requested_depth</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>ambient_depths</name></name>    = <name>ambient_depths</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>from_url</name></name>          = <name>from_url</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>to_path</name></name>           = <name>to_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>repos_root_url</name></name>    = <name>repos_root_url</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>ctx</name></name>               = <name>ctx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>update_unchanged</name></name>  = <name>update_unchanged</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>timestamp_sleep</name></name>   = <name>timestamp_sleep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>is_export</name></name>         = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>pool</name></name>              = <name>pool</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_diff</name><argument_list>(<argument><expr><name><name>cb</name>.<name>externals_old</name></name></expr></argument>, <argument><expr><name><name>cb</name>.<name>externals_new</name></name></expr></argument>,
                        <argument><expr><name>handle_externals_desc_change</name></expr></argument>, <argument><expr>&amp;<name>cb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_client__fetch_externals</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>externals</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_url</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_root_url</name></decl></param>,
                            <param><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>is_export</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name> *</type><name>timestamp_sleep</name></decl></param>,
                            <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>handle_externals_desc_change_baton</name></type> <name>cb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>cb</name>.<name>externals_new</name></name>     = <name>externals</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>externals_old</name></name>     = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>requested_depth</name></name>   = <name>requested_depth</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>ambient_depths</name></name>    = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>ctx</name></name>               = <name>ctx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>from_url</name></name>          = <name>from_url</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>to_path</name></name>           = <name>to_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>repos_root_url</name></name>    = <name>repos_root_url</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>update_unchanged</name></name>  = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>timestamp_sleep</name></name>   = <name>timestamp_sleep</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>is_export</name></name>         = <name>is_export</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>pool</name></name>              = <name>pool</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_diff</name><argument_list>(<argument><expr><name><name>cb</name>.<name>externals_old</name></name></expr></argument>, <argument><expr><name><name>cb</name>.<name>externals_new</name></name></expr></argument>,
                        <argument><expr><name>handle_externals_desc_change</name></expr></argument>, <argument><expr>&amp;<name>cb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_client__do_external_status</name><parameter_list>(<param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
                               <param><decl><type><name>svn_wc_status_func2_t</name></type> <name>status_func</name></decl></param>,
                               <param><decl><type><name>void</name> *</type><name>status_baton</name></decl></param>,
                               <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>get_all</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>update</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>no_ignore</name></decl></param>,
                               <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>externals_old</name></decl>, *<decl><type ref="prev"/><name>externals_new</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the values of the svn:externals properties. */</comment>
  <expr_stmt><expr><call><name>svn_wc_edited_externals</name><argument_list>(<argument><expr>&amp;<name>externals_old</name></expr></argument>, <argument><expr>&amp;<name>externals_new</name></expr></argument>, <argument><expr><name>traversal_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Loop over the hash of new values (we don't care about the old
     ones).  This is a mapping of versioned directories to property
     values. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>externals_new</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>exts</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propval</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <comment type="block">/* Clear the subpool. */</comment>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>propval</name> = <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* Parse the svn:externals property value.  This results in a
         hash mapping subdirectories to externals structures. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_parse_externals_description3</name><argument_list>(<argument><expr>&amp;<name>exts</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>propval</name></expr></argument>,
                                                  <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Make a sub-pool of SUBPOOL. */</comment>
      <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Loop over the subdir array. */</comment>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>exts</name> &amp;&amp; (<name>i</name> &lt; <name><name>exts</name>-&gt;<name>nelts</name></name>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fullpath</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_external_item2_t</name> *</type><name>external</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>external</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>exts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_wc_external_item2_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>external</name>-&gt;<name>target_dir</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If the external target directory doesn't exist on disk,
             just skip it. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>kind</name> != <name>svn_node_dir</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Tell the client we're staring an external status set. */</comment>
          <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
            <expr_stmt><expr><call>(<name><name>ctx</name>-&gt;<name>notify_func2</name></name>)
              <argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>,
               <argument><expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>svn_wc_notify_status_external</name></expr></argument>,
                                    <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* And then do the status. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client_status3</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>,
                                     <argument><expr>&amp;(<name><name>external</name>-&gt;<name>revision</name></name>)</expr></argument>,
                                     <argument><expr><name>status_func</name></expr></argument>, <argument><expr><name>status_baton</name></expr></argument>,
                                     <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>get_all</name></expr></argument>, <argument><expr><name>update</name></expr></argument>,
                                     <argument><expr><name>no_ignore</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></for>

  <comment type="block">/* Destroy SUBPOOL and (implicitly) ITERPOOL. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
