<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_client/merge.c"><comment type="block">/*
 * merge.c: merging
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<comment type="block">/* ==================================================================== */</comment>


<escape char="0xc"/>
<comment type="block">/*** Includes ***/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_wc_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/* MERGEINFO MERGE SOURCE NORMALIZATION
 *
 * Nearly any helper function herein that accepts two URL/revision
 * pairs expects one of two things to be true:
 *
 *    1.  that mergeinfo is not being recorded at all for this
 *        operation, or
 *
 *    2.  that the pairs represent two locations along a single line
 *        of version history such that there are no copies in the
 *        history of the object between the locations when treating
 *        the oldest of the two locations as non-inclusive.  In other
 *        words, if there is a copy at all between them, there is only
 *        one copy and its source was the oldest of the two locations.
 *
 * We use svn_ra_get_location_segments() to split a given range of
 * revisions across an object's history into several which obey these
 * rules.  For example, a merge between r19500 and r27567 of
 * Subversion's own /tags/1.4.5 directory gets split into sequential
 * merges of the following location pairs:
 *
 *    [/trunk:19549, /trunk:19523]
 *    (recorded in svn:mergeinfo as /trunk:19500-19523)
 *
 *    [/trunk:19523, /branches/1.4.x:25188]
 *    (recorded in svn:mergeinfo as /branches/1.4.x:19524-25188)
 *
 *    [/branches/1.4.x:25188, /tags/1.4.4@26345]
 *    (recorded in svn:mergeinfo as /tags/1.4.4:25189-26345)
 *
 *    [/tags/1.4.4@26345, /branches/1.4.5@26350]
 *    (recorded in svn:mergeinfo as /branches/1.4.5:26346-26350)
 *
 *    [/branches/1.4.5@26350, /tags/1.4.5@27567]
 *    (recorded in svn:mergeinfo as /tags/1.4.5:26351-27567)
 *
 * Our helper functions would then operate on one of these location
 * pairs at a time.
 */</comment>

<comment type="block">/* WHICH SVN_CLIENT_MERGE* API DO I WANT?
 *
 * libsvn_client has three public merge APIs; they are all wrappers
 * around the do_merge engine.  Which one to use depends on the number
 * of URLs passed as arguments and whether or not specific merge
 * ranges (-c/-r) are specified.
 *
 *                 1 URL                        2 URLs
 *     +--------------------------------+---------------------+
 *  -c |       mergeinfo-driven         |                     |
 *  or |        cherrypicking           |    unsupported      |
 *  -r |    (svn_client_merge_peg)      |                     |
 *     +--------------------------------+---------------------+
 *  no |      mergeinfo-driven          |  mergeinfo-oblivious|
 *  -c |        whole-branch            |    diff-and-apply   |
 *  or |       heuristic merge          |  (svn_client_merge) |
 *  -r | (svn_client_merge_reintegrate) |                     |
 *     +--------------------------------+---------------------+
 *
 *
 */</comment>

<comment type="block">/* THE CHILDREN_WITH_MERGEINFO ARRAY
 *
 * Many of the helper functions in this file pass around an
 * apr_array_header_t *CHILDREN_WITH_MERGEINFO.  This is a depth first
 * sorted array filled with svn_client__merge_path_t * describing the
 * merge target and any of its subtrees which have explicit mergeinfo
 * or otherwise need special attention during a merge.
 *
 * CHILDREN_WITH_MERGEINFO is intially created by get_mergeinfo_paths()
 * and outside of that function and its helpers should always meet the
 * seven criteria dictated in get_mergeinfo_paths()'s doc string.
 */</comment>

<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Utilities ***/</comment>

<comment type="block">/* Sanity check -- ensure that we have valid revisions to look at. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENSURE_VALID_REVISION_KINDS</name><parameter_list>(<param><type><name>rev1_kind</name></type></param>, <param><type><name>rev2_kind</name></type></param>)</parameter_list></cpp:macro></cpp:define> \


<comment type="block">/* Return SVN_ERR_UNSUPPORTED_FEATURE if URL's scheme does not
   match the scheme of the url for ADM_ACCESS's path; return
   SVN_ERR_BAD_URL if no scheme can be found for one or both urls;
   otherwise return SVN_NO_ERROR.  Use ADM_ACCESS's pool for
   temporary allocation. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_scheme_match</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>ent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>idx1</name></decl>, *<decl><type ref="prev"/><name>idx2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>ent</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>idx1</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>idx2</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>ent</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>(<name>idx1</name> == <name>NULL</name>) &amp;&amp; (<name>idx2</name> == <name>NULL</name>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"URLs have no scheme ('%s' and '%s')"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name><name>ent</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>idx1</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"URL has no scheme: '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>idx2</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"URL has no scheme: '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ent</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr>((<name>idx1</name> - <name>url</name>) != (<name>idx2</name> - <name><name>ent</name>-&gt;<name>url</name></name>))
           || (<call><name>strncmp</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name><name>ent</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>idx1</name> - <name>url</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Access scheme mixtures not yet supported ('%s' and '%s')"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name>url</name></expr></argument>, <argument><expr><name><name>ent</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if></else></if></else></if></else></if>

  <comment type="block">/* else */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Repos-Diff Editor Callbacks ***/</comment>


<comment type="block">/* Wrapper around svn_string_t, see merge_cmd_baton_t's
   working_mergeinfo member. */</comment>
<typedef>typedef <type><struct>struct <block>{
  <comment type="block">/* Working mergeinfo for a path prior to a merge.  May be NULL
     if the path has no working mergeinfo. */</comment>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>working_mergeinfo_propval</name></decl>;</decl_stmt>
}</block></struct></type> <name>working_mergeinfo_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>merge_cmd_baton_t</name> <block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>record_only</name></decl>;</decl_stmt>          <comment type="block">/* Whether to only record mergeinfo. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>sources_ancestral</name></decl>;</decl_stmt>    <comment type="block">/* Whether the left-side merge source is
                                         an ancestor of the right-side, or
                                         vice-versa (history-wise). */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same_repos</name></decl>;</decl_stmt>           <comment type="block">/* Whether the merge source repository
                                         is the same repository as the
                                         target.  Defaults to FALSE if DRY_RUN
                                         is TRUE.*/</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>mergeinfo_capable</name></decl>;</decl_stmt>    <comment type="block">/* Whether the merge source server
                                         is capable of Merge Tracking. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl>;</decl_stmt>      <comment type="block">/* Are we ignoring ancestry (and by
                                         extension, mergeinfo)?  FALSE if
                                         SOURCES_ANCESTRAL is FALSE. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>target_missing_child</name></decl>;</decl_stmt> <comment type="block">/* Whether working copy target of the
                                         merge is missing any immediate
                                         children. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>added_path</name></decl>;</decl_stmt>             <comment type="block">/* Set to the dir path whenever the
                                         dir is added as a child of a
                                         versioned dir (dry-run only) */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>;</decl_stmt>                 <comment type="block">/* Working copy target of merge */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl>;</decl_stmt>                    <comment type="block">/* The second URL in the merge */</comment>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>              <comment type="block">/* Client context for callbacks, etc. */</comment>

  <comment type="block">/* Whether invocation of the merge_file_added() callback required
     delegation to the merge_file_changed() function for the file
     currently being merged.  This info is used to detect whether a
     file on the left side of a 3-way merge actually exists (important
     because it's created as an empty temp file on disk regardless).*/</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>add_necessitated_merge</name></decl>;</decl_stmt>

  <comment type="block">/* The list of paths for entries we've deleted, used only when in
     dry_run mode. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>dry_run_deletions</name></decl>;</decl_stmt>

  <comment type="block">/* The list of any paths which remained in conflict after a
     resolution attempt was made.  We track this in-memory, rather
     than just using WC entry state, since the latter doesn't help us
     when in dry_run mode. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>conflicted_paths</name></decl>;</decl_stmt>

  <comment type="block">/* The diff3_cmd in ctx-&gt;config, if any, else null.  We could just
     extract this as needed, but since more than one caller uses it,
     we just set it up when this baton is created. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>merge_options</name></decl>;</decl_stmt>

  <comment type="block">/* RA sessions used throughout a merge operation.  Opened/re-parented
     as needed.  

     NOTE: During the actual merge editor drive, RA_SESSION1 is used
     for the primary editing and RA_SESSION2 for fetching additional
     information -- as necessary -- from the repository.  So during
     this phase of the merge, you *must not* reparent RA_SESSION1; use
     (temporarily reparenting if you must) RA_SESSION2 instead.  */</comment>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session2</name></decl>;</decl_stmt>

  <comment type="block">/* Flag indicating the fact target has everything merged already,
     for the sake of children's merge to work it sets itself a dummy
     merge range of requested_end_rev:requested_end_rev. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>target_has_dummy_merge_range</name></decl>;</decl_stmt>

  <comment type="block">/* Pool which has a lifetime limited to one iteration over a given
     merge source, i.e. it is cleared on every call to do_directory_merge()
     or do_file_merge() in do_merge(). */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block></struct></type> <name>merge_cmd_baton_t</name>;</typedef>

<function><type><name>apr_hash_t</name> *</type>
<name>svn_client__dry_run_deletions</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>merge_cmd_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name> <init>= <expr><name>merge_cmd_baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>merge_b</name>-&gt;<name>dry_run_deletions</name></name></expr>;</return>
}</block></function>

<comment type="block">/* Used to avoid spurious notifications (e.g. conflicts) from a merge
   attempt into an existing target which would have been deleted if we
   weren't in dry_run mode (issue #2584).  Assumes that WCPATH is
   still versioned (e.g. has an associated entry). */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>svn_boolean_t</name></type>
<name>dry_run_deleted_p</name><parameter_list>(<param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>wcpath</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<name><name>merge_b</name>-&gt;<name>dry_run</name></name> &amp;&amp;
          <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>dry_run_deletions</name></name></expr></argument>, <argument><expr><name>wcpath</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>;</return>
}</block></function>

<comment type="block">/* Return whether any WC path was put in conflict by the merge
   operation corresponding to MERGE_B. */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>svn_boolean_t</name></type>
<name>is_path_conflicted_by_merge</name><parameter_list>(<param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<name><name>merge_b</name>-&gt;<name>conflicted_paths</name></name> &amp;&amp;
          <call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>conflicted_paths</name></name></expr></argument>)</argument_list></call> &gt; 0)</expr>;</return>
}</block></function>

<comment type="block">/* Set *HONOR_MERGEINFO and *RECORD_MERGEINFO (if non-NULL)
   appropriately for MERGE_B.
   One rule is that we shan't record mergeinfo if we're not honoring it. */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type>
<name>mergeinfo_behavior</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>honor_mergeinfo</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name> *</type><name>record_mergeinfo</name></decl></param>,
                   <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>honor_mergeinfo</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>honor_mergeinfo</name> = (<name><name>merge_b</name>-&gt;<name>mergeinfo_capable</name></name>
                        &amp;&amp; <name><name>merge_b</name>-&gt;<name>sources_ancestral</name></name>
                        &amp;&amp; <name><name>merge_b</name>-&gt;<name>same_repos</name></name>
                        &amp;&amp; (! <name><name>merge_b</name>-&gt;<name>ignore_ancestry</name></name>))</expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>record_mergeinfo</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>record_mergeinfo</name> = (<name><name>merge_b</name>-&gt;<name>mergeinfo_capable</name></name>
                         &amp;&amp; <name><name>merge_b</name>-&gt;<name>sources_ancestral</name></name>
                         &amp;&amp; <name><name>merge_b</name>-&gt;<name>same_repos</name></name>
                         &amp;&amp; (! <name><name>merge_b</name>-&gt;<name>ignore_ancestry</name></name>)
                         &amp;&amp; (! <name><name>merge_b</name>-&gt;<name>dry_run</name></name>))</expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* Helper for merge_props_changed().  Filter out mergeinfo property additions
   to PATH when those additions refer to the same line of history.

   *PROPS is an array of svn_prop_t structures representing regular properties
   to be added to the working copy PATH.  ADM_ACCESS and MERGE_B are cascaded
   from merge_props_changed().
   
   If mergeinfo is not being honored, do nothing.  Otherwise examine the added
   mergeinfo, looking at each range (or single rev) of each source path.  If a
   source_path/range refers to the same line of history as PATH (pegged at its
   base revision), then filter out that range.  If the entire rangelist for a
   given path is filtered then filter out the path as well.  Set outgoing
   *PROPS to a shallow copy (allocated in POOL) of incoming *PROPS minus the
   filtered self-referential mergeinfo. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name>*</type>
<name>filter_self_referential_mergeinfo</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>props</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                   <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>,
                                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>honor_mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>adjusted_props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* If we aren't honoring mergeinfo, get outta here. */</comment>
  <expr_stmt><expr><call><name>mergeinfo_behavior</name><argument_list>(<argument><expr>&amp;<name>honor_mergeinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>honor_mergeinfo</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>adjusted_props</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>(*<name>props</name>)-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>(*<name>props</name>)-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr>(*<name>props</name>)</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If this property isn't mergeinfo or is NULL valued (i.e. prop removal)
         or empty mergeinfo it does not require any special handling.  There
         is nothing to filter out of empty mergeinfo and the concept of
         filtering doesn't apply if we are trying to remove mergeinfo
         entirely. */</comment>
      <if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> != 0)
          || (! <name><name>prop</name>-&gt;<name>value</name></name>)       <comment type="block">/* Removal of mergeinfo */</comment>
          || (! <name><name>prop</name>-&gt;<name>value</name>-&gt;<name>len</name></name>)</expr>)</condition><then> <comment type="block">/* Empty mergeinfo */</comment>
        <block>{
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>adjusted_props</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call> = *<name>prop</name></expr>;</expr_stmt>
        }</block></then>
      <else>else <comment type="block">/* Non-empty mergeinfo; filter self-referential mergeinfo out. */</comment>
        <block>{
          <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>mergeinfo</name></decl>, <decl><type ref="prev"/><name>filtered_mergeinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_url</name></decl>, *<decl><type ref="prev"/><name>merge_source_root_url</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>target_entry</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>,
                                         <argument><expr>&amp;<name>merge_source_root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <comment type="block">/* Get an entry for PATH so we can find it's base revision. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>target_entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, 
                                          <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <comment type="block">/* Temporarily reparent our RA session to the merge
             target's URL. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client_url_from_path</name><argument_list>(<argument><expr>&amp;<name>target_url</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__ensure_ra_session_url</name><argument_list>(<argument><expr>&amp;<name>old_url</name></expr></argument>, 
                                                    <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>,
                                                    <argument><expr><name>target_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <comment type="block">/* Parse the incoming mergeinfo to allow easier meddling. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mergeinfo</name></expr></argument>)</argument_list></call></expr>;</init>
               <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>void</name> *</type><name>value</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>merge_source_url</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>adjusted_rangelist</name> <init>=
                <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              
              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>source_path</name> = <name>key</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>rangelist</name> = <name>value</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>merge_source_url</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>merge_source_root_url</name></expr></argument>,
                                               <argument><expr><name>source_path</name> + 1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              
              <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
                <block>{
                  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>svn_opt_revision_t</name> *</type><name>start_revision</name></decl>, *<decl><type ref="prev"/><name>end_revision</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_url</name></decl>, *<decl><type ref="prev"/><name>end_url</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>peg_rev</name></decl>, <decl><type ref="prev"/><name>rev1_opt</name></decl>, <decl><type ref="prev"/><name>rev2_opt</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>=
                    <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  
                  <expr_stmt><expr><name><name>peg_rev</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>peg_rev</name>.<name>value</name>.<name>number</name></name> = <name><name>target_entry</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>rev1_opt</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
                  <comment type="block">/* SVN_PROP_MERGEINFO only stores forward merges, so
                     the start range of svn_merge_range_t RANGE is not
                     inclusive. */</comment>
                  <expr_stmt><expr><name><name>rev1_opt</name>.<name>value</name>.<name>number</name></name> = <name><name>range</name>-&gt;<name>start</name></name> + 1</expr>;</expr_stmt>
                  
                  <comment type="block">/* Because the merge source normalization code
                     ensures mergeinfo refers to real locations on
                     the same line of history, there's no need to
                     look at the whole range, just the start. */</comment>
                  <expr_stmt><expr><name><name>rev2_opt</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
                  
                  <comment type="block">/* Check if PATH@TARGET_ENTRY-&gt;REVISION exists at
                     RANGE-&gt;START on the same line of history. */</comment>
                  <expr_stmt><expr><name>err</name> = <call><name>svn_client__repos_locations</name><argument_list>(<argument><expr>&amp;<name>start_url</name></expr></argument>,
                                                    <argument><expr>&amp;<name>start_revision</name></expr></argument>,
                                                    <argument><expr>&amp;<name>end_url</name></expr></argument>,
                                                    <argument><expr>&amp;<name>end_revision</name></expr></argument>,
                                                    <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>,
                                                    <argument><expr><name>target_url</name></expr></argument>,
                                                    <argument><expr>&amp;<name>peg_rev</name></expr></argument>,
                                                    <argument><expr>&amp;<name>rev1_opt</name></expr></argument>,
                                                    <argument><expr>&amp;<name>rev2_opt</name></expr></argument>,
                                                    <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>,
                                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                    <block>{
                      <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CLIENT_UNRELATED_RESOURCES</name>
                          || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_RA_DAV_PATH_NOT_FOUND</name>
                          || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name></expr>)</condition><then>
                        <block>{
                          <comment type="block">/* PATH@TARGET_ENTRY-&gt;REVISION didn't exist at
                             RANGE-&gt;START or is unrelated to the resource
                             PATH@RANGE-&gt;START.  Either way we don't
                             filter. */</comment>
                          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                          <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt>
                          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>adjusted_rangelist</name></expr></argument>,
                                         <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
                        }</block></then>
                      <else>else
                        <block>{
                          <return>return <expr><name>err</name></expr>;</return>
                        }</block></else></if>
                    }</block></then>
                  <else>else
                    <block>{
                      <comment type="block">/* PATH@TARGET_ENTRY-&gt;REVISION exists on the same
                         line of history at RANGE-&gt;START.  But it might
                         have existed under a different name then, so
                         check if the URL it had then is the same as the
                         URL for the mergeinfo we are trying to add.  If
                         it is the same we can filter it out. */</comment>
                      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>start_url</name></expr></argument>, <argument><expr><name>merge_source_url</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
                        <block>{
                          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>adjusted_rangelist</name></expr></argument>,
                                         <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></else></if>
                }</block></for> <comment type="block">/* for (j = 0; j &lt; rangelist-&gt;nelts; j++) */</comment>
              
              <if>if <condition>(<expr><name><name>adjusted_rangelist</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
                <block>{
                  <if>if <condition>(<expr>!<name>filtered_mergeinfo</name></expr>)</condition><then>
                    <expr_stmt><expr><name>filtered_mergeinfo</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>filtered_mergeinfo</name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>,
                               <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>adjusted_rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for> <comment type="block">/* mergeinfo hash iteration */</comment>

          <comment type="block">/* If only some of the ranges mapped from SOURCE_PATH were
             filtered then create a new svn_prop_t to represent
             this.  Otherwise everything was filtered and we can
             ignore the svn:merginfo props entirely. */</comment>
          <if>if <condition>(<expr><name>filtered_mergeinfo</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Convert filtered_mergeinfo to a svn_prop_t and put it
                 back in the array. */</comment>
              <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>filtered_mergeinfo_str</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>adjusted_prop</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>adjusted_prop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr>&amp;<name>filtered_mergeinfo_str</name></expr></argument>,
                                              <argument><expr><name>filtered_mergeinfo</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>adjusted_prop</name>-&gt;<name>name</name></name> = <name>SVN_PROP_MERGEINFO</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>adjusted_prop</name>-&gt;<name>value</name></name> = <name>filtered_mergeinfo_str</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>adjusted_props</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call> = *<name>adjusted_prop</name></expr>;</expr_stmt>
            }</block></then></if>

          <comment type="block">/* If we reparented MERGE_B-&gt;RA_SESSION2 above, put it back
             to the original URL. */</comment>
          <if>if <condition>(<expr><name>old_url</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>, <argument><expr><name>old_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        }</block></else></if> <comment type="block">/* Property is non-empty mergeinfo. */</comment>
    }</block></for> <comment type="block">/* (i = 0; i &lt; (*props)-&gt;nelts; ++i) */</comment>

  <expr_stmt><expr>*<name>props</name> = <name>adjusted_props</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* A svn_wc_diff_callbacks2_t function.  Used for both file and directory
   property merges. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_props_changed</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>propchanges</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>original_props</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_categorize_props</name><argument_list>(<argument><expr><name>propchanges</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We only want to merge "regular" version properties:  by
     definition, 'svn merge' shouldn't touch any data within .svn/  */</comment>
  <if>if <condition>(<expr><name><name>props</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* svn_wc_merge_props() requires ADM_ACCESS to be the access for
         the parent of PATH. Since the advent of merge tracking,
         do_directory_merge() may call this (indirectly) with
         the access for the merge_b-&gt;target instead (issue #2781).
         So, if we have the wrong access, get the right one. */</comment>
      <if>if <condition>(<expr><call><name>svn_path_compare_paths</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_try3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                      <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                      <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Don't add mergeinfo from PATH's own history. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>filter_self_referential_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>,
                                                <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>err</name> = <call><name>svn_wc_merge_props2</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>original_props</name></expr></argument>, <argument><expr><name>props</name></expr></argument>,
                                <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>conflict_func</name></name></expr></argument>,
                                <argument><expr><name><name>ctx</name>-&gt;<name>conflict_baton</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_ENTRY_NOT_FOUND</name>
                  || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_UNVERSIONED_RESOURCE</name>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* if the entry doesn't exist in the wc, just 'skip' over
             this part of the tree-delta. */</comment>
          <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if></else></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Contains any state collected while resolving conflicts. */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* The wrapped callback and baton. */</comment>
  <decl_stmt><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>wrapped_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>wrapped_baton</name></decl>;</decl_stmt>

  <comment type="block">/* The list of any paths which remained in conflict after a
     resolution attempt was made. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> **</type><name>conflicted_paths</name></decl>;</decl_stmt>

  <comment type="block">/* Pool used in notification_receiver() to avoid the iteration
     sub-pool which is passed in, then subsequently destroyed. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block></struct></type> <name>conflict_resolver_baton_t</name>;</typedef>

<comment type="block">/* An implementation of the svn_wc_conflict_resolver_func_t interface.
   We keep a record of paths which remain in conflict after any
   resolution attempt from BATON-&gt;wrapped_func. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>conflict_resolver</name><parameter_list>(<param><decl><type><name>svn_wc_conflict_result_t</name> **</type><name>result</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>svn_wc_conflict_description_t</name> *</type><name>description</name></decl></param>,
                  <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>conflict_resolver_baton_t</name> *</type><name>conflict_b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>conflict_b</name>-&gt;<name>wrapped_func</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call>(*<name><name>conflict_b</name>-&gt;<name>wrapped_func</name></name>)<argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>description</name></expr></argument>,
                                      <argument><expr><name><name>conflict_b</name>-&gt;<name>wrapped_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <block>{
      <comment type="block">/* If we have no wrapped callback to invoke, then we still need
         to behave like a proper conflict-callback ourselves.  */</comment>
      <expr_stmt><expr>*<name>result</name> = <call><name>svn_wc_create_conflict_result</name><argument_list>(<argument><expr><name>svn_wc_conflict_choose_postpone</name></expr></argument>,
                                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Keep a record of paths still in conflict after the resolution attempt. */</comment>
  <if>if <condition>(<expr>(! <name><name>conflict_b</name>-&gt;<name>wrapped_func</name></name>)
      || (*<name>result</name> &amp;&amp; (<name>(*<name>result</name>)-&gt;<name>choice</name></name> == <name>svn_wc_conflict_choose_postpone</name>))</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>conflicted_path</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>conflict_b</name>-&gt;<name>pool</name></name></expr></argument>,
                                                <argument><expr><name><name>description</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>*<name><name>conflict_b</name>-&gt;<name>conflicted_paths</name></name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>*<name><name>conflict_b</name>-&gt;<name>conflicted_paths</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>conflict_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name><name>conflict_b</name>-&gt;<name>conflicted_paths</name></name></expr></argument>, <argument><expr><name>conflicted_path</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>conflicted_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* A svn_wc_diff_callbacks2_t function. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_file_changed</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>content_state</name></decl></param>,
                   <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>prop_state</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mine</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>older</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yours</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>older_rev</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>yours_rev</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype1</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype2</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>prop_changes</name></decl></param>,
                   <param><decl><type><name>apr_hash_t</name> *</type><name>original_props</name></decl></param>,
                   <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>merge_required</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
  <enum>enum <name>svn_wc_merge_outcome_t</name> <name>merge_outcome</name>;</enum>

  <comment type="block">/* Easy out:  no access baton means there ain't no merge target */</comment>
  <if>if <condition>(<expr><name>adm_access</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>prop_state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>prop_state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Other easy outs:  if the merge target isn't under version
     control, or is just missing from disk, fogettaboutit.  There's no
     way svn_wc_merge3() can do the merge. */</comment>
  <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ### a future thought:  if the file is under version control,
       but the working file is missing, maybe we can 'restore' the
       working file from the text-base, and then allow the merge to run?  */</comment>

    <if>if <condition>(<expr>(! <name>entry</name>) || (<name>kind</name> != <name>svn_node_file</name>)</expr>)</condition><then>
      <block>{
        <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
          <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>prop_state</name></expr>)</condition><then>
          <expr_stmt><expr>*<name>prop_state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
      }</block></then></if>
  }</block>

  <comment type="block">/* ### TODO: Thwart attempts to merge into a path that has
     ### unresolved conflicts.  This needs to be smart enough to deal
     ### with tree conflicts!
  if (is_path_conflicted_by_merge(merge_b, mine))
    {
      *content_state = svn_wc_notify_state_conflicted;
      return svn_error_createf(SVN_ERR_WC_FOUND_CONFLICT, NULL,
                               _("Path '%s' is in conflict, and must be "
                                 "resolved before the remainder of the "
                                 "requested merge can be applied"), mine);
    }
  */</comment>

  <comment type="block">/* This callback is essentially no more than a wrapper around
     svn_wc_merge3().  Thank goodness that all the
     diff-editor-mechanisms are doing the hard work of getting the
     fulltexts! */</comment>

  <comment type="block">/* Do property merge before text merge so that keyword expansion takes
     into account the new property values. */</comment>
  <if>if <condition>(<expr><name><name>prop_changes</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_props_changed</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>prop_state</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>prop_changes</name></expr></argument>,
                                <argument><expr><name>original_props</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <if>if <condition>(<expr><name>prop_state</name></expr>)</condition><then>
      <expr_stmt><expr>*<name>prop_state</name> = <name>svn_wc_notify_state_unchanged</name></expr>;</expr_stmt></then></if></else></if>

  <if>if <condition>(<expr><name>older</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_local_mods</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_text_modified_p</name><argument_list>(<argument><expr>&amp;<name>has_local_mods</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                     <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Special case:  if a binary file's working file is
         exactly identical to the 'left' side of the merge, then don't
         allow svn_wc_merge to produce a conflict.  Instead, just
         overwrite the working file with the 'right' side of the
         merge.  Why'd we check for local mods above?  Because we want
         to do a different notification depending on whether or not
         the file was locally modified.

         Alternately, if the 'left' side of the merge doesn't exist in
         the repository, and the 'right' side of the merge is
         identical to the WC, pretend we did the merge (a no-op). */</comment>
      <if>if <condition>(<expr>(<name>mimetype1</name> &amp;&amp; <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name>mimetype1</name></expr></argument>)</argument_list></call>)
          || (<name>mimetype2</name> &amp;&amp; <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name>mimetype2</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* For adds, the 'left' side of the merge doesn't exist. */</comment>
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>older_revision_exists</name> <init>=
              <expr>!<name><name>merge_b</name>-&gt;<name>add_necessitated_merge</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same_contents</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_files_contents_same_p</name><argument_list>(<argument><expr>&amp;<name>same_contents</name></expr></argument>,
                                               <argument><expr>(<name>older_revision_exists</name> ?
                                                <name>older</name> : <name>yours</name>)</expr></argument>,
                                               <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>same_contents</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name>older_revision_exists</name> &amp;&amp; !<name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>yours</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
              <expr_stmt><expr><name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>merge_required</name> = <name>FALSE</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

      <if>if <condition>(<expr><name>merge_required</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* xgettext: the '.working', '.merge-left.r%ld' and
             '.merge-right.r%ld' strings are used to tag onto a file
             name in case of a merge conflict */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_label</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr>".working"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>left_label</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>,
                                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>".merge-left.r%ld"</expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>older_rev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>right_label</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>,
                                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>".merge-right.r%ld"</expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name>yours_rev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>conflict_resolver_baton_t</name></type> <name>conflict_baton</name> <init>=
            <expr><block>{ <expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>conflict_func</name></name></expr>, <expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>conflict_baton</name></name></expr>,
              <expr>&amp;<name><name>merge_b</name>-&gt;<name>conflicted_paths</name></name></expr>, <expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_merge3</name><argument_list>(<argument><expr>&amp;<name>merge_outcome</name></expr></argument>,
                                <argument><expr><name>older</name></expr></argument>, <argument><expr><name>yours</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                <argument><expr><name>left_label</name></expr></argument>, <argument><expr><name>right_label</name></expr></argument>, <argument><expr><name>target_label</name></expr></argument>,
                                <argument><expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>diff3_cmd</name></name></expr></argument>,
                                <argument><expr><name><name>merge_b</name>-&gt;<name>merge_options</name></name></expr></argument>, <argument><expr><name>prop_changes</name></expr></argument>,
                                <argument><expr><name>conflict_resolver</name></expr></argument>, <argument><expr>&amp;<name>conflict_baton</name></expr></argument>,
                                <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>merge_outcome</name> == <name>svn_wc_merge_conflict</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_conflicted</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><name>has_local_mods</name>
                   &amp;&amp; <name>merge_outcome</name> != <name>svn_wc_merge_unchanged</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_merged</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><name>merge_outcome</name> == <name>svn_wc_merge_merged</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><name>merge_outcome</name> == <name>svn_wc_merge_no_merge</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then>
          <else>else <comment type="block">/* merge_outcome == svn_wc_merge_unchanged */</comment>
            <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_unchanged</name></expr>;</expr_stmt></else></if></else></if></else></if></else></if>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* A svn_wc_diff_callbacks2_t function. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_file_added</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                 <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>content_state</name></decl></param>,
                 <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>prop_state</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mine</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>older</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yours</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name></type> <name>rev1</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name></type> <name>rev2</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype1</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype2</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>prop_changes</name></decl></param>,
                 <param><decl><type><name>apr_hash_t</name> *</type><name>original_props</name></decl></param>,
                 <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>new_props</name></decl>;</decl_stmt>

  <comment type="block">/* In most cases, we just leave prop_state as unknown, and let the
     content_state what happened, so we set prop_state here to avoid that
     below. */</comment>
  <if>if <condition>(<expr><name>prop_state</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>prop_state</name> = <name>svn_wc_notify_state_unknown</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Apply the prop changes to a new hash table. */</comment>
  <expr_stmt><expr><name>new_props</name> = <call><name>apr_hash_copy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>original_props</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>prop_changes</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>prop_changes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* We don't want any DAV wcprops related to this file because
         they'll point to the wrong repository (in the
         merge-from-foreign-repository scenario) or wrong place in the
         right repository (in the same-repos scenario).  So we'll
         strip them.  (Is this a layering violation?)  */</comment>
      <if>if <condition>(<expr><call><name>svn_property_kind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call> == <name>svn_prop_wc_kind</name></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>new_props</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Easy out:  if we have no adm_access for the parent directory,
     then this portion of the tree-delta "patch" must be inapplicable.
     Send a 'missing' state back;  the repos-diff editor should then
     send a 'skip' notification. */</comment>
  <if>if <condition>(<expr>! <name>adm_access</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name> &amp;&amp; <name><name>merge_b</name>-&gt;<name>added_path</name></name>
          &amp;&amp; <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>added_path</name></name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>prop_state</name> &amp;&amp; <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>new_props</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*<name>prop_state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then></if>
        }</block></then>
      <else>else
        <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_node_none</name></expr>:
      <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>schedule</name></name> != <name>svn_wc_schedule_delete</name></expr>)</condition><then>
          <block>{
            <comment type="block">/* It's versioned but missing. */</comment>
            <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
              <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
          }</block></then></if>
        <if>if <condition>(<expr>! <name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr>)</condition><then>
          <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* If this is a merge from the same repository as our working copy,
               we handle adds as add-with-history.  Otherwise, we'll use a pure
               add. */</comment>
            <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>same_repos</name></name></expr>)</condition><then>
              <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child</name> <init>= <expr><call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>, 
                                                      <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>child</name> != <name>NULL</name></expr>)</condition><then>
                  <expr_stmt><expr><name>copyfrom_url</name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>url</name></name></expr></argument>, 
                                                            <argument><expr><name>child</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                <else>else
                  <expr_stmt><expr><name>copyfrom_url</name> = <name><name>merge_b</name>-&gt;<name>url</name></name></expr>;</expr_stmt></else></if>
                <expr_stmt><expr><name>copyfrom_rev</name> = <name>rev2</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_scheme_match</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then></if>

            <comment type="block">/* Since 'mine' doesn't exist, and this is
               'merge_file_added', I hope it's safe to assume that
               'older' is empty, and 'yours' is the full file.  Merely
               copying 'yours' to 'mine', isn't enough; we need to get
               the whole text-base and props installed too, just as if
               we had called 'svn cp wc wc'. */</comment>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_add_repos_file2</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>yours</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>new_props</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>,
                                           <argument><expr><name>copyfrom_rev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
          <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>prop_state</name> &amp;&amp; <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>new_props</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr>*<name>prop_state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then></if>
      }</block>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_dir</name></expr>:
      <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* directory already exists, is it under version control? */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>entry</name> &amp;&amp; <call><name>dry_run_deleted_p</name><argument_list>(<argument><expr><name>merge_b</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then>
          <else>else
            <comment type="block">/* this will make the repos_editor send a 'skipped' message */</comment>
            <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt></else></if>
        }</block></then></if>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_file</name></expr>:
      <block>{
        <comment type="block">/* file already exists, is it under version control? */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If it's an unversioned file, don't touch it.  If it's scheduled
           for deletion, then rm removed it from the working copy and the
           user must have recreated it, don't touch it */</comment>
        <if>if <condition>(<expr>!<name>entry</name> || <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name></expr>)</condition><then>
          <block>{
            <comment type="block">/* this will make the repos_editor send a 'skipped' message */</comment>
            <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
              <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt></then></if>
          }</block></then>
        <else>else
          <block>{
            <if>if <condition>(<expr><call><name>dry_run_deleted_p</name><argument_list>(<argument><expr><name>merge_b</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>)</argument_list></call></expr>)</condition><then>
              <block>{
                <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
                  <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then></if>
              }</block></then>
            <else>else
              <block>{
                <comment type="block">/* Indicate that we merge because of an add to handle a
                   special case for binary files with no local mods. */</comment>
                  <expr_stmt><expr><name><name>merge_b</name>-&gt;<name>add_necessitated_merge</name></name> = <name>TRUE</name></expr>;</expr_stmt>

                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_file_changed</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>content_state</name></expr></argument>,
                                             <argument><expr><name>prop_state</name></expr></argument>, <argument><expr><name>mine</name></expr></argument>, <argument><expr><name>older</name></expr></argument>, <argument><expr><name>yours</name></expr></argument>,
                                             <argument><expr><name>rev1</name></expr></argument>, <argument><expr><name>rev2</name></expr></argument>,
                                             <argument><expr><name>mimetype1</name></expr></argument>, <argument><expr><name>mimetype2</name></expr></argument>,
                                             <argument><expr><name>prop_changes</name></expr></argument>, <argument><expr><name>original_props</name></expr></argument>,
                                             <argument><expr><name>baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Reset the state so that the baton can safely be reused
                   in subsequent ops occurring during this merge. */</comment>
                  <expr_stmt><expr><name><name>merge_b</name>-&gt;<name>add_necessitated_merge</name></name> = <name>FALSE</name></expr>;</expr_stmt>
              }</block></else></if>
          }</block></else></if>
        <break>break;</break>
      }</block>
    </case><default>default:
      <if>if <condition>(<expr><name>content_state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_unknown</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </default>}</block></switch>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* A svn_wc_diff_callbacks2_t function. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_file_deleted</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mine</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>older</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yours</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype1</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype2</name></decl></param>,
                   <param><decl><type><name>apr_hash_t</name> *</type><name>original_props</name></decl></param>,
                   <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Easy out:  if we have no adm_access for the parent directory,
     then this portion of the tree-delta "patch" must be inapplicable.
     Send a 'missing' state back;  the repos-diff editor should then
     send a 'skip' notification. */</comment>
  <if>if <condition>(<expr>! <name>adm_access</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_node_file</name></expr>:
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>parent_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>,
                                  <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Passing NULL for the notify_func and notify_baton because
         repos_diff.c:delete_entry() will do it for us. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_client__wc_delete</name><argument_list>(<argument><expr><name>mine</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>force</name></name></expr></argument>,
                                  <argument><expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <name>state</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_dir</name></expr>:
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_none</name></expr>:
      <comment type="block">/* file is already non-existent, this is a no-op. */</comment>
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><default>default:
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_unknown</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </default>}</block></switch>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* A svn_wc_diff_callbacks2_t function. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_dir_added</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name> <init>= <expr><name>NULL</name></expr></init>, *<name>child</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Easy out:  if we have no adm_access for the parent directory,
     then this portion of the tree-delta "patch" must be inapplicable.
     Send a 'missing' state back;  the repos-diff editor should then
     send a 'skip' notification. */</comment>
  <if>if <condition>(<expr>! <name>adm_access</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name> &amp;&amp; <name><name>merge_b</name>-&gt;<name>added_path</name></name>
              &amp;&amp; <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>added_path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></else></if>
        }</block></then></if>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>child</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>child</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is a merge from the same repository as our working copy,
     we handle adds as add-with-history.  Otherwise, we'll use a pure
     add. */</comment>
  <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>same_repos</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>copyfrom_url</name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>copyfrom_rev</name> = <name>rev</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_scheme_match</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_node_none</name></expr>:
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>schedule</name></name> != <name>svn_wc_schedule_delete</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Versioned but missing */</comment>
          <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>merge_b</name>-&gt;<name>added_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_add2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                              <argument><expr><name>copyfrom_url</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>,
                              <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                              <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* don't pass notification func! */</comment>
                              <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></else></if>
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_dir</name></expr>:
      <comment type="block">/* Adding an unversioned directory doesn't destroy data */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>entry</name> || <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>!<name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_add2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                <argument><expr><name>copyfrom_url</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>,
                                <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* no notification func! */</comment>
                                <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>merge_b</name>-&gt;<name>added_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then></if>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>dry_run_deleted_p</name><argument_list>(<argument><expr><name>merge_b</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt></else></if>
        }</block></then></if></else></if>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_file</name></expr>:
      <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>merge_b</name>-&gt;<name>added_path</name></name> = <name>NULL</name></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>entry</name> &amp;&amp; <call><name>dry_run_deleted_p</name><argument_list>(<argument><expr><name>merge_b</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <comment type="block">/* ### TODO: Retain record of this dir being added to
               ### avoid problems from subsequent edits which try to
               ### add children. */</comment>
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt></else></if>
        }</block></then></if>
      <break>break;</break>
    </case><default>default:
      <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>merge_b</name>-&gt;<name>added_path</name></name> = <name>NULL</name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_unknown</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </default>}</block></switch>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* A svn_wc_diff_callbacks2_t function. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_dir_deleted</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                  <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Easy out:  if we have no adm_access for the parent directory,
     then this portion of the tree-delta "patch" must be inapplicable.
     Send a 'missing' state back;  the repos-diff editor should then
     send a 'skip' notification. */</comment>
  <if>if <condition>(<expr>! <name>adm_access</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_node_dir</name></expr>:
      <block>{
        <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>parent_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>,
                                    <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Passing NULL for the notify_func and notify_baton because
           repos_diff.c:delete_entry() will do it for us. */</comment>
        <expr_stmt><expr><name>err</name> = <call><name>svn_client__wc_delete</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>force</name></name></expr></argument>,
                                    <argument><expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name> &amp;&amp; <name>state</name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
        <else>else <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt>
          }</block></then></if></else></if>
      }</block>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_file</name></expr>:
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_obstructed</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_none</name></expr>:
      <comment type="block">/* dir is already non-existent, this is a no-op. */</comment>
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_missing</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><default>default:
      <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_unknown</name></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </default>}</block></switch>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* The main callback table for 'svn merge'.  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_wc_diff_callbacks2_t</name></type>
<name>merge_callbacks</name> <init>=
  <expr><block>{
    <expr><name>merge_file_changed</name></expr>,
    <expr><name>merge_file_added</name></expr>,
    <expr><name>merge_file_deleted</name></expr>,
    <expr><name>merge_dir_added</name></expr>,
    <expr><name>merge_dir_deleted</name></expr>,
    <expr><name>merge_props_changed</name></expr>
  }</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Merge Notification ***/</comment>


<comment type="block">/* Contains any state collected while receiving path notifications. */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* The wrapped callback and baton. */</comment>
  <decl_stmt><decl><type><name>svn_wc_notify_func2_t</name></type> <name>wrapped_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>wrapped_baton</name></decl>;</decl_stmt>

  <comment type="block">/* The number of notifications received. */</comment>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>nbr_notifications</name></decl>;</decl_stmt>

  <comment type="block">/* The number of operative notifications received. */</comment>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>nbr_operative_notifications</name></decl>;</decl_stmt>

  <comment type="block">/* The list of merged paths. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>merged_paths</name></decl>;</decl_stmt>

  <comment type="block">/* The list of any skipped paths, which should be examined and
     cleared after each invocation of the callback. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>skipped_paths</name></decl>;</decl_stmt>

  <comment type="block">/* A list of the root paths of any added subtrees which might require
     their own explicit mergeinfo. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>added_paths</name></decl>;</decl_stmt>

  <comment type="block">/* Flag indicating whether it is a single file merge or not. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_single_file_merge</name></decl>;</decl_stmt>

  <comment type="block">/* Depth first ordered list of paths that needs special care while merging.
     This defaults to NULL. For 'same_url' merge alone we set it to
     proper array. This is used by notification_receiver to put a
     merge notification begin lines. */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl>;</decl_stmt>

  <comment type="block">/* The index in CHILDREN_WITH_MERGEINFO where we found the nearest ancestor
     for merged path. Default value is '-1'.*/</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>cur_ancestor_index</name></decl>;</decl_stmt>

  <comment type="block">/* We use this to make a decision on merge begin line notifications. */</comment>
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl>;</decl_stmt>

  <comment type="block">/* Pool used in notification_receiver() to avoid the iteration
     sub-pool which is passed in, then subsequently destroyed. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

}</block></struct></type> <name>notification_receiver_baton_t</name>;</typedef>


<comment type="block">/* Finds a nearest ancestor in CHILDREN_WITH_MERGEINFO for PATH. If
   PATH_IS_OWN_ANCESTOR is TRUE then a child in CHILDREN_WITH_MERGEINFO
   where child-&gt;path == PATH is considered PATH's ancestor.  If FALSE,
   then child-&gt;path must be a proper ancestor of PATH.

   CHILDREN_WITH_MERGEINFO is expected to be sorted in Depth first
   order of path. Nearest ancestor's index from
   CHILDREN_WITH_MERGEINFO is returned. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_nearest_ancestor</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>path_is_own_ancestor</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ancestor_index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* This if condition is not needed as this function should be used
     from the context of same_url merge where CHILDREN_WITH_MERGEINFO
     will not be NULL and of size atleast 1. We have this if condition
     just to protect the wrong caller. */</comment>
  <if>if <condition>(<expr>!<name>children_with_mergeinfo</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call>
          &amp;&amp; (<call><name>svn_path_compare_paths</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> != 0
              || <name>path_is_own_ancestor</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>ancestor_index</name> = <name>i</name></expr>;</expr_stmt></then></if>      
    }</block></for>
  <return>return <expr><name>ancestor_index</name></expr>;</return>
}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_OPERATIVE_NOTIFICATION</name><parameter_list>(<param><type><name>notify</name></type></param>)</parameter_list></cpp:macro>  \
                    <cpp:value>(notify-&gt;content_state == svn_wc_notify_state_conflicted \
                     || notify-&gt;content_state == svn_wc_notify_state_merged  \
                     || notify-&gt;content_state == svn_wc_notify_state_changed \
                     || notify-&gt;prop_state == svn_wc_notify_state_conflicted \
                     || notify-&gt;prop_state == svn_wc_notify_state_merged     \
                     || notify-&gt;prop_state == svn_wc_notify_state_changed    \
                     || notify-&gt;action == svn_wc_notify_update_add)</cpp:value></cpp:define>

<comment type="block">/* Our svn_wc_notify_func2_t wrapper.*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>notification_receiver</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_wc_notify_t</name> *</type><name>notify</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>notification_receiver_baton_t</name> *</type><name>notify_b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_operative_notification</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Is the notification the result of a real operative merge? */</comment>
  <if>if <condition>(<expr><call><name>IS_OPERATIVE_NOTIFICATION</name><argument_list>(<argument><expr><name>notify</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>nbr_operative_notifications</name></name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>is_operative_notification</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If our merge sources are ancestors of one another... */</comment>
  <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>merge_b</name>-&gt;<name>sources_ancestral</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>nbr_notifications</name></name>++</expr>;</expr_stmt>

      <comment type="block">/* See if this is an operative directory merge. */</comment>
      <if>if <condition>(<expr>!(<name><name>notify_b</name>-&gt;<name>is_single_file_merge</name></name>) &amp;&amp; <name>is_operative_notification</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Find NOTIFY-&gt;PATH's nearest ancestor in
             NOTIFY-&gt;CHILDREN_WITH_MERGEINFO.  Normally we consider a child in
             NOTIFY-&gt;CHILDREN_WITH_MERGEINFO representing PATH to be an
             ancestor of PATH, but if this is a deletion of PATH then the
             notification must be for a proper ancestor of PATH.  This ensures
             we don't get notifications like:
             
               --- Merging rX into 'PARENT/CHILD'
               D    PARENT/CHILD

             But rather:

               --- Merging rX into 'PARENT'
               D    PARENT/CHILD
          */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>new_nearest_ancestor_index</name> <init>=
            <expr><call><name>find_nearest_ancestor</name><argument_list>(
              <argument><expr><name><name>notify_b</name>-&gt;<name>children_with_mergeinfo</name></name></expr></argument>,
              <argument><expr><name><name>notify</name>-&gt;<name>action</name></name> == <name>svn_wc_notify_update_delete</name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>,
              <argument><expr><name><name>notify</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>new_nearest_ancestor_index</name> != <name><name>notify_b</name>-&gt;<name>cur_ancestor_index</name></name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
                <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>children_with_mergeinfo</name></name></expr></argument>,
                              <argument><expr><name>new_nearest_ancestor_index</name></expr></argument>,
                              <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>cur_ancestor_index</name></name> = <name>new_nearest_ancestor_index</name></expr>;</expr_stmt>
              <if>if <condition>(<expr>!<name><name>child</name>-&gt;<name>absent</name></name> &amp;&amp; <name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> &gt; 0
                  &amp;&amp; !(<name>new_nearest_ancestor_index</name> == 0
                       &amp;&amp; <name><name>notify_b</name>-&gt;<name>merge_b</name>-&gt;<name>target_has_dummy_merge_range</name></name>)</expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify_merge_begin</name></decl>;</decl_stmt>
                  <expr_stmt><expr><name>notify_merge_begin</name> =
                    <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>,
                                         <argument><expr><name><name>notify_b</name>-&gt;<name>merge_b</name>-&gt;<name>same_repos</name></name> 
                                           ? <name>svn_wc_notify_merge_begin</name>
                                           : <name>svn_wc_notify_foreign_merge_begin</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>notify_merge_begin</name>-&gt;<name>merge_range</name></name> =
                    <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                  <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>wrapped_func</name></name></expr>)</condition><then>
                    <expr_stmt><expr><call>(*<name><name>notify_b</name>-&gt;<name>wrapped_func</name></name>)<argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>wrapped_baton</name></name></expr></argument>,
                                              <argument><expr><name>notify_merge_begin</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>

      <if>if <condition>(<expr><name><name>notify</name>-&gt;<name>content_state</name></name> == <name>svn_wc_notify_state_merged</name>
          || <name><name>notify</name>-&gt;<name>content_state</name></name> == <name>svn_wc_notify_state_changed</name>
          || <name><name>notify</name>-&gt;<name>prop_state</name></name> == <name>svn_wc_notify_state_merged</name>
          || <name><name>notify</name>-&gt;<name>prop_state</name></name> == <name>svn_wc_notify_state_changed</name>
          || <name><name>notify</name>-&gt;<name>action</name></name> == <name>svn_wc_notify_update_add</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>merged_path</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>notify</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>merged_paths</name></name> == <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>merged_paths</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>merged_paths</name></name></expr></argument>, <argument><expr><name>merged_path</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>merged_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr><name><name>notify</name>-&gt;<name>action</name></name> == <name>svn_wc_notify_skip</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>skipped_path</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>notify</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>skipped_paths</name></name> == <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>skipped_paths</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>skipped_paths</name></name></expr></argument>, <argument><expr><name>skipped_path</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>skipped_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <if>if <condition>(<expr><name><name>notify</name>-&gt;<name>action</name></name> == <name>svn_wc_notify_update_add</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_root_of_added_subtree</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>added_path</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>notify</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>added_path_parent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

          <comment type="block">/* Stash the root path of any added subtrees. */</comment>
          <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>added_paths</name></name> == <name>NULL</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>added_paths</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>is_root_of_added_subtree</name> = <name>TRUE</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><name>added_path_parent</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>added_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>!<call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>added_paths</name></name></expr></argument>, <argument><expr><name>added_path_parent</name></expr></argument>,
                                <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>is_root_of_added_subtree</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
            }</block></else></if>
          <if>if <condition>(<expr><name>is_root_of_added_subtree</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>added_paths</name></name></expr></argument>, <argument><expr><name>added_path</name></expr></argument>,
                         <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>added_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></then>
  <comment type="block">/* Otherwise, our merge sources aren't ancestors of one another. */</comment>
  <else>else <if>if <condition>(<expr>!(<name><name>notify_b</name>-&gt;<name>is_single_file_merge</name></name>)
           &amp;&amp; <name><name>notify_b</name>-&gt;<name>nbr_operative_notifications</name></name> == 1
           &amp;&amp; <name>is_operative_notification</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify_merge_begin</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>notify_merge_begin</name> = 
        <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>merge_b</name>-&gt;<name>target</name></name></expr></argument>,
                             <argument><expr><name><name>notify_b</name>-&gt;<name>merge_b</name>-&gt;<name>same_repos</name></name> 
                               ? <name>svn_wc_notify_merge_begin</name>
                               : <name>svn_wc_notify_foreign_merge_begin</name></expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>wrapped_func</name></name></expr>)</condition><then>
        <expr_stmt><expr><call>(*<name><name>notify_b</name>-&gt;<name>wrapped_func</name></name>)<argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>wrapped_baton</name></name></expr></argument>, <argument><expr><name>notify_merge_begin</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if></else></if>

  <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>wrapped_func</name></name></expr>)</condition><then>
    <expr_stmt><expr><call>(*<name><name>notify_b</name>-&gt;<name>wrapped_func</name></name>)<argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>wrapped_baton</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/* Helper for the numerous times we need to allocate and initialize
   a rangelist with one element.
   
   Return a rangelist allocated in POOL with one svn_merge_range_t
   element defined by START, END, and INHERITABLE. */</comment>
<function><type><specifier>static</specifier> <name>apr_array_header_t</name> *</type>
<name>init_rangelist</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name></type> <name>start</name></decl></param>,
               <param><decl><type><name>svn_revnum_t</name></type> <name>end</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>inheritable</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name></name> = <name>start</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name></name> = <name>end</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>inheritable</name></name> = <name>inheritable</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
  <return>return <expr><name>rangelist</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for the numerous times we need to allocate a svn_merge_range_t
   and push it onto a rangelist.

   Allocated a svn_merge_range_t element defined by START, END, and
   INHERITABLE and push it onto RANGELIST. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_range</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl></param>,
           <param><decl><type><name>svn_revnum_t</name></type> <name>start</name></decl></param>,
           <param><decl><type><name>svn_revnum_t</name></type> <name>end</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>inheritable</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name></name> = <name>start</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name></name> = <name>end</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>inheritable</name></name> = <name>inheritable</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Helper for filter_merged_revisions() when operating on a subtree.
   Like filter_merged_revisions(), this should only be called when
   honoring mergeinfo. 

   Filter the requested ranges being merged to a subtree so that we
   don't try to describe invalid subtrees to the merge report editor.
   Note in *CHILD_DELETED_OR_NONEXISTANT if the subtree doesn't exist,
   is deleted, or is renamed in the requested range.

   PARENT, MERGEINFO_PATH, REVISION1, REVISION2, PRIMARY_URL, RA_SESSION,
   and CTX are all cascaded from filter_merged_revisions().

   Since this function is only invoked for subtrees of the merge target,
   the guarantees afforded by normalize_merge_sources() don't apply.
   Therefore it is possible that PRIMARY_URL@REVISION1 and
   PRIMARY_URL@REVISION2 don't describe an unbroken line of history.

   Specifically we can end up with one of these eight cases:

     Note1: Unless noted otherwise, every case sets *REQUESTED_RANGELIST
            to a rangelist with one element defined by REVISION1 and
            REVISION2.

     Note2: The inheritability of all svn_merge_range_t in
            *REQUESTED_RANGELIST is always TRUE.

   Forward Merges, i.e. REVISION1 &lt; REVISION2 (PEG_REV)

     A) Requested range deletes subtree.

        PRIMARY_URL@REVISION1 exists, but PRIMARY_URL@REVISION2 doesn't
        exist because PRIMARY_URL was deleted prior to REVISION2.

        Set *CHILD_DELETED_OR_NONEXISTANT to TRUE.

     B) Part of requested range predates subtree's existance.

        PRIMARY_URL@REVISION2 exists, but PRIMARY_URL@REVISION1 doesn't
        exist because PRIMARY_URL didn't come into existence until some
        revision 'N' where N &gt; REVISION1.

        Set *CHILD_DELETED_OR_NONEXISTANT to FALSE.  Populate
        *REQUESTED_RANGELIST with the ranges between N and REVISION2
        (inclusive) at which PRIMARY_URL exists.  Then take the intersection
        of REVISION1:N (i.e. the range which predates the existance of
        PRIMARY_URL) and PARENT-&gt;REQUESTED_RANGELIST and add it to
        *REQUESTED_RANGELIST.  This prevents us from later trying to describe
        any non-existant path/revs for this subtree in
        drive_merge_report_editor().  A good thing as that would break the
        editor.

     C) Subtree doesn't exist in requested range or exists inside the
        requested range but is ultimately deleted.

        Neither PRIMARY_URL@REVISION1 or PRIMARY_URL@REVISION2 exist.

        Set *CHILD_DELETED_OR_NONEXISTANT to TRUE

     D) Subtree exists at start and end of requested range and was
        not replaced within that range.

        PRIMARY_URL@REVISION1 and PRIMARY_URL@REVISION2 both exist.

        Set *CHILD_DELETED_OR_NONEXISTANT to FALSE.

  Reverse Merges, i.e. REVISION1 (PEG_REV) &gt; REVISION2
                        
     E) Part of requested range postdates subtree's existance.

        PRIMARY_URL@REVISION2 exists, but PRIMARY_URL@REVISION1 doesn't
        exist because PRIMARY_URL was deleted prior to REVISION1.

        Set *CHILD_DELETED_OR_NONEXISTANT to FALSE.

        ### This is tricky, sort of the inverse of B; we want to reverse
        ### merge some range M:N, let's say 14:4, into the subtree, but the
        ### subtree was deleted at r10.  *BUT* we only allow reverse merges
        ### of ranges that exist in implicit or explicit mergeinfo.  Can't we
        ### simply set *REQUESTED_RANGELIST to REVISION1:REVISION2 and let the
        ### existing code in filter_merged_revisions() do its thing?  Because
        ### if the subtree has any explicit mergeinfo (via inheritance)
        ### describing ranges that postdate the subtree's existance, the
        ### subtree's nearest parent must also have that mergeinfo right?
        ### Put another way, how can all of the  following ever be true?
        ### 
        ###   i)   The subtree merge source doesn't exist anymore at
        ###        revsion X.
        ###   ii)  Mergeinfo for X is explicitly set on the subtree.
        ###   iii) The subtree's parent has no explicit mergeinfo for X.
        ### 
        ### This is where Kamesh utilized his recursive guess_live_ranges
        ### function...But do we ever need to do this in practice? 

     F) Requested range deletes (or replaces) a subtree.

        PRIMARY_URL@REVISION1 exists, but PRIMARY_URL@REVISION2 doesn't
        exist because PRIMARY_URL didn't come into existence until
        *after* REVISION2.  Or PRIMARY_URL@REVISION1 and PRIMARY_URL@REVISION2
        both exist, but they don't describe an unbroken line of history.

        Set *CHILD_DELETED_OR_NONEXISTANT to TRUE.

     G) Subtree doesn't exist in requested range or exists inside the
        requested range but is ultimately deleted.

        Neither PRIMARY_URL@REVISION1 or PRIMARY_URL@REVISION2 exist.

        Set *CHILD_DELETED_OR_NONEXISTANT to TRUE.

     H) Subtree exists at start and end of requested range and was
        not replaced within that range.

        PRIMARY_URL@REVISION1 and PRIMARY_URL@REVISION2 both exist and
        describe the start and end of an unbroken line of history.

        Set *CHILD_DELETED_OR_NONEXISTANT to FALSE.

   All the allocations are made from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prepare_subtree_ranges</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>requested_rangelist</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name> *</type><name>child_deleted_or_nonexistant</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo_path</name></decl></param>,
                       <param><decl><type><name>svn_client__merge_path_t</name> *</type><name>parent</name></decl></param>,
                       <param><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl></param>,
                       <param><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>primary_url</name></decl></param>,
                       <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                       <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_rollback</name> <init>= <expr><name>revision2</name> &lt; <name>revision1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>peg_rev</name> <init>= <expr><name>is_rollback</name> ? <name>revision1</name> : <name>revision2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name> <init>= <expr><name>is_rollback</name> ? <name>revision1</name> : <name>revision2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name> <init>= <expr><name>is_rollback</name> ? <name>revision2</name> : <name>revision1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>segments</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel_source_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>session_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>session_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__path_relative_to_root</name><argument_list>(<argument><expr>&amp;<name>rel_source_path</name></expr></argument>,
                                            <argument><expr><name>primary_url</name></expr></argument>,
                                            <argument><expr><name>session_url</name></expr></argument>,
                                            <argument><expr><name>FALSE</name></expr></argument>,
                                            <argument><expr><name>ra_session</name></expr></argument>,
                                            <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_client__repos_location_segments</name><argument_list>(<argument><expr>&amp;<name>segments</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>,
                                            <argument><expr><name>rel_source_path</name></expr></argument>, <argument><expr><name>peg_rev</name></expr></argument>,
                                            <argument><expr><name>start_rev</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If REL_SOURCE_PATH@PEG_REV doesn't exist then
     svn_client__repos_location_segments() typically returns an
     SVN_ERR_FS_NOT_FOUND error, but if it doesn't exist for a
     forward merge over ra_neon then we get SVN_ERR_RA_DAV_REQUEST_FAILED.
     http://subversion.tigris.org/issues/show_bug.cgi?id=3137 fixed some of
     the cases where different RA layers returned different error codes to
     signal the "path not found"...but it looks like there is more to do. */</comment>
 <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>
          || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_RA_DAV_REQUEST_FAILED</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>is_rollback</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_stat</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>rel_source_path</name></expr></argument>,
                                  <argument><expr><name>revision2</name></expr></argument>,  <argument><expr>&amp;<name>dirent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>dirent</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>child_deleted_or_nonexistant</name> = <name>FALSE</name></expr>;</expr_stmt></then> <comment type="block">/* Case E. */</comment>
              <else>else
                <expr_stmt><expr>*<name>child_deleted_or_nonexistant</name> = <name>TRUE</name></expr>;</expr_stmt></else></if>  <comment type="block">/* Case G. */</comment>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr>*<name>child_deleted_or_nonexistant</name> = <name>TRUE</name></expr>;</expr_stmt> <comment type="block">/* Case A &amp; C. */</comment>
            }</block></else></if>

          <expr_stmt><expr>*<name>requested_rangelist</name> = <call><name>init_rangelist</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                                <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <return>return <expr><name>err</name></expr>;</return></else></if>
    }</block></then>
  <else>else
    <block>{
      <if>if <condition>(<expr><name><name>segments</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name> <init>=
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr>(<name><name>segments</name>-&gt;<name>nelts</name></name> - 1)</expr></argument>,
                          <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>is_rollback</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name><name>segment</name>-&gt;<name>range_start</name></name> == <name>revision2</name>
                  &amp;&amp; <name><name>segment</name>-&gt;<name>range_end</name></name> == <name>revision1</name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* Case H. */</comment>
                  <expr_stmt><expr>*<name>requested_rangelist</name> = <call><name>init_rangelist</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                                        <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr>*<name>child_deleted_or_nonexistant</name> = <name>FALSE</name></expr>;</expr_stmt>
                }</block></then>
              <else>else <comment type="block">/* Multiple location segements found. */</comment>
                <block>{
                  <comment type="block">/* Case F. */</comment>
                  <expr_stmt><expr>*<name>requested_rangelist</name> = <call><name>init_rangelist</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                                        <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr>*<name>child_deleted_or_nonexistant</name> = <name>TRUE</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then>
          <else>else <comment type="block">/* Forward merge */</comment>
            <block>{
              <comment type="block">/* Again, because REVISION2 is the peg revision for the call
                 to svn_client__repos_location_segments, we know that the
                 range_end of the last segment in segments is equal to
                 REVISION2. */</comment>
              <if>if <condition>(<expr><name><name>segment</name>-&gt;<name>range_start</name></name> == <name>revision1</name>
                  &amp;&amp; <name><name>segment</name>-&gt;<name>range_end</name></name> == <name>revision2</name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* Case D. */</comment>
                  <expr_stmt><expr>*<name>requested_rangelist</name> = <call><name>init_rangelist</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                                        <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr>*<name>child_deleted_or_nonexistant</name> = <name>FALSE</name></expr>;</expr_stmt>
                }</block></then>
              <else>else <comment type="block">/* segment-&gt;range_start != revision1, since
                      segment-&gt;range_start can't be less than REVISION1,
                      this implies revision1 &lt; segment-&gt;range_start. */</comment>
                <block>{
                  <comment type="block">/* Case B. */</comment>
                  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>predate_intersection_rangelist</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>different_name_rangelist</name> <init>=
                    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                  <comment type="block">/* Make a ranglist that describes the range which predates
                     PRIMARY_URL's existance... */</comment>
                  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>predate_rangelist</name> <init>=
                    <expr><call><name>init_rangelist</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>,
                                   <argument><expr><name><name>segment</name>-&gt;<name>range_start</name></name></expr></argument>,
                                   <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <comment type="block">/* ...Find the intersection of that rangelist and the
                     subtree's parent's remaining ranges. */</comment>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_intersect</name><argument_list>(
                    <argument><expr>&amp;<name>predate_intersection_rangelist</name></expr></argument>,
                    <argument><expr><name>predate_rangelist</name></expr></argument>,
                    <argument><expr><name><name>parent</name>-&gt;<name>remaining_ranges</name></name></expr></argument>,
                    <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr>*<name>requested_rangelist</name> =
                    <call><name>init_rangelist</name><argument_list>(<argument><expr><name><name>segment</name>-&gt;<name>range_start</name></name></expr></argument>,
                                   <argument><expr><name>revision2</name></expr></argument>,
                                   <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <comment type="block">/* Merge *REQUESTED_RANGELIST with its parent's remaining
                     ranges the intersect with the subtree's prehistory. */</comment>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_merge</name><argument_list>(
                    <argument><expr><name>requested_rangelist</name></expr></argument>, <argument><expr><name>predate_intersection_rangelist</name></expr></argument>,
                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  
                  <comment type="block">/* Remove ranges that predate PRIMARY_URL's existance
                     because the source exists under a different URL due to a
                     rename between REVISION1:REVISION2 - see 'MERGE FAILS' in
                     http://subversion.tigris.org/issues/show_bug.cgi?id=3067#desc34.
                     */</comment>
                  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>segments</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                    <block>{
                      <expr_stmt><expr><name>segment</name> =
                        <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <if>if <condition>(<expr><name><name>segment</name>-&gt;<name>path</name></name>
                          &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>segment</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>mergeinfo_path</name> + 1</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
                        <expr_stmt><expr><call><name>push_range</name><argument_list>(<argument><expr><name>different_name_rangelist</name></expr></argument>,
                                   <argument><expr><name><name>segment</name>-&gt;<name>range_start</name></name></expr></argument>,
                                   <argument><expr><name><name>segment</name>-&gt;<name>range_end</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    }</block></for>
                  <if>if <condition>(<expr><name><name>different_name_rangelist</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_remove</name><argument_list>(<argument><expr><name>requested_rangelist</name></expr></argument>,
                                                 <argument><expr><name>different_name_rangelist</name></expr></argument>,
                                                 <argument><expr>*<name>requested_rangelist</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                  <expr_stmt><expr>*<name>child_deleted_or_nonexistant</name> = <name>FALSE</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if>
        }</block></then></if>
    }</block></else></if> <comment type="block">/* ! err */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Determining What Remains To Be Merged ***/</comment>

<comment type="block">/* Helper for calculate_remaining_ranges().

   Calculate the ranges that remain to be merged from the merge
   source MERGEINFO_PATH (relative to the repository root) to the working
   copy path represented by CHILD -- for use by drive_merge_report_editor()'s
   application of the editor to the WC.  Set CHILD-&gt;remaining_ranges to the
   set of revisions to merge.

   PARENT, PRIMARY_URL, IS_SUBTREE, RA_SESSION, CTX are cascaded from
   calculate_remaining_ranges().  If IS_SUBTREE is FALSE then PARENT is
   ignored.

   REVISION1 and REVISION2 describe the merge range requested from
   MERGEINFO_PATH.

   TARGET_MERGEINFO is the path's explicit or inherited mergeinfo.
   May be NULL if there is not mergeinfo or an empty hash for
   empty mergeinfo.
   
   IMPLICIT_MERGEINFO is the path's natural history described as
   mergeinfo - see svn_client__get_history_as_mergeinfo().

   NOTE: This should only be called when honoring mergeinfo.  
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>filter_merged_revisions</name><parameter_list>(<param><decl><type><name>svn_client__merge_path_t</name> *</type><name>parent</name></decl></param>,
                        <param><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo_path</name></decl></param>,
                        <param><decl><type><name>svn_mergeinfo_t</name></type> <name>target_mergeinfo</name></decl></param>,
                        <param><decl><type><name>svn_mergeinfo_t</name></type> <name>implicit_mergeinfo</name></decl></param>,
                        <param><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl></param>,
                        <param><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>primary_url</name></decl></param>,
                        <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                        <param><decl><type><name>svn_boolean_t</name></type> <name>is_subtree</name></decl></param>,
                        <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>target_rangelist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>mergeinfo</name> <init>= <expr><name>implicit_mergeinfo</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>requested_merge</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>is_subtree</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If CHILD is the merge target we then know that PRIMARY_URL,
         REVISION1, and REVISION2 are provided by normalize_merge_sources()
         -- see 'MERGEINFO MERGE SOURCE NORMALIZATION'.  Due to this
         normalization we know that PRIMARY_URL@REVISION1 and
         PRIMARY_URL@REVISION2 describe an unbroken line of history such
         that the entire range described by REVISION1:REVISION2 can
         potentially be merged to CHILD.  So we simply convert REVISION1 and
         REVISION2 to a rangelist and proceed to the filtering of merged
         revisions.

         But if CHILD is a subtree we don't have the same guarantees about
         PRIMARY_URL, REVISION1, and REVISION2 as we do for the merge target.
         PRIMARY_URL@REVSION1 and/or PRIMARY_URL@REVSION2 might not exist.

         If one or both doesn't exist, we need to know so we don't later try
         to describe these invalid subtrees in drive_merge_report_editor(),
         as that will break the merge. */</comment>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>child_deleted_or_nonexistant</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prepare_subtree_ranges</name><argument_list>(<argument><expr>&amp;<name>requested_merge</name></expr></argument>,
                                     <argument><expr>&amp;<name>child_deleted_or_nonexistant</name></expr></argument>,
                                     <argument><expr><name>mergeinfo_path</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
                                     <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                     <argument><expr><name>primary_url</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>child_deleted_or_nonexistant</name> &amp;&amp; <name>parent</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* A little trick: If CHILD is a subtree which will be deleted by
             the requested merge or simply doesn't exist along the line of
             history described by PRIMARY_URL@REVSION1 -&gt; PRIMARY_URL@REVSION2,
             then don't bother dealing with CHILD in a separate editor drive.
             Just make child's remaining ranges exactly the same as its
             nearest parent.
             
             For deletions this will cause the editor drive to be rooted at
             the subtree CHILD's nearest parent in CHILDREN_WITH_MERGEINFO
             This will simply delete the subtree.  For the case where neither
             PRIMARY_URL@REVSION1 or PRIMARY_URL@REVSION2 exist, there is
             nothing to merge to the subtree, so ignoring it completely is
             safe. See
             http://subversion.tigris.org/issues/show_bug.cgi?id=3067#desc5.
             */</comment>
          <expr_stmt><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name> =
            <call><name>svn_rangelist_dup</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Convert REVISION1 and REVISION2 to a rangelist.

         Note: Talking about a requested merge range's inheritability doesn't
         make much sense, but as we are using svn_merge_range_t to describe
         it we need to pick *something*.  Since all the rangelist
         manipulations in this function either don't consider inheritance
         by default or we are requesting that they don't (i.e.
         svn_rangelist_remove and svn_rangelist_intersect) then we could
         set the inheritability as FALSE, it won't matter either way. */</comment>
      <expr_stmt><expr><name>requested_merge</name> = <call><name>init_rangelist</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Now filter out revisions that have already been merged to CHILD. */</comment>
  <if>if <condition>(<expr><name>revision1</name> &gt; <name>revision2</name></expr>)</condition><then> <comment type="block">/* This is a reverse merge. */</comment>
    <block>{
      <if>if <condition>(<expr><name>target_mergeinfo</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>mergeinfo</name> = <call><name>svn_mergeinfo_dup</name><argument_list>(<argument><expr><name>implicit_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>, <argument><expr><name>target_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><name>target_rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>, 
                                      <argument><expr><name>mergeinfo_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>target_rangelist</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Return the intersection of the revs which are both
             already represented by the WC and are requested for
             revert.  The revert range and will need to be reversed
             for our APIs to work properly, as will the output for the
             revert to work properly. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_reverse</name><argument_list>(<argument><expr><name>requested_merge</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* We don't consider inheritance we determining intersecting
             ranges.  If we *did* consider inheritance, then our calculation
             would be wrong.  For example, if the REQUESTED_MERGE is 5:3 and
             TARGET_RANGELIST is r5* (non-inheritable) then the intersection
             would be r4.  And that would be wrong as we clearly want to
             reverse merge both r4 and r5 in this case.  Ignoring the ranges'
             inheritance results in an intersection of r4-5.
             
             You might be wondering about ENTRY's children, doesn't the above
             imply that we will reverse merge r4-5 from them?  Nope, this is
             safe to do because any path whose parent has non-inheritable
             ranges is always considered a subtree with differing mergeinfo
             even if that path has no explicit mergeinfo prior to the
             merge -- See condition 3 in the doc string for
             merge.c:get_mergeinfo_paths(). */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_intersect</name><argument_list>(<argument><expr>&amp;(<name><name>child</name>-&gt;<name>remaining_ranges</name></name>)</expr></argument>,
                                          <argument><expr><name>target_rangelist</name></expr></argument>,
                                          <argument><expr><name>requested_merge</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_reverse</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name> = 
            <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else <comment type="block">/* This is a forward merge */</comment>
    <block>{
      <expr_stmt><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name> = <name>requested_merge</name></expr>;</expr_stmt>

<comment type="block">/* ### TODO:  Which evil shall we choose?
   ###
   ### If we allow all forward-merges not already found in recorded
   ### mergeinfo, we destroy the ability to, say, merge the whole of a
   ### branch to the trunk while automatically ignoring the revisions
   ### common to both.  That's bad.
   ###
   ### If we allow only forward-merges not found in either recorded
   ### mergeinfo or implicit mergeinfo (natural history), then the
   ### previous scenario works great, but we can't reverse-merge a
   ### previous change made to our line of history and then remake it
   ### (because the reverse-merge will leave no mergeinfo trace, and
   ### the remake-it attempt will still find the original change in
   ### natural mergeinfo.  But you know, that we happen to use 'merge'
   ### for revision undoing is somewhat unnatural anyway, so I'm
   ### finding myself having little interest in caring too much about
   ### this.  That said, if we had a way of storing reverse merge
   ### ranges, we'd be in good shape either way.
*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_MERGE__ALLOW_ALL_FORWARD_MERGES_FROM_SELF</name></cpp:ifdef>
      <if>if <condition>(<expr><name>target_mergeinfo</name></expr>)</condition><then>
        <expr_stmt><expr><name>target_rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>target_mergeinfo</name></expr></argument>, 
                                        <argument><expr><name>mergeinfo_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <if>if <condition>(<expr><name>target_mergeinfo</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>mergeinfo</name> = <call><name>svn_mergeinfo_dup</name><argument_list>(<argument><expr><name>implicit_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>, <argument><expr><name>target_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><name>target_rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>, 
                                      <argument><expr><name>mergeinfo_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/* See earlier comment preceeding svn_rangelist_intersect() for
         why we don't consider inheritance here. */</comment>
      <if>if <condition>(<expr><name>target_rangelist</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_remove</name><argument_list>(<argument><expr>&amp;(<name><name>child</name>-&gt;<name>remaining_ranges</name></name>)</expr></argument>,
                                     <argument><expr><name>target_rangelist</name></expr></argument>,
                                     <argument><expr><name>requested_merge</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for do_file_merge and do_directory_merge (by way of
   populate_remaining_ranges() for the latter).

   Determine what portions of URL1@REVISION1 -&gt; URL2@REVISION2 have already
   been merged to CHILD-&gt;PATH and populate CHILD-&gt;REMAINING_RANGES with the
   ranges that still need merging.

   SOURCE_ROOT_URL, URL1, REVISION1, URL2, REVISION2, TARGET_MERGEINFO,
   IMPLICIT_MERGEINFO, RA_SESSION, and CTX are all cascaded from the
   caller's arguments of the same names.

   If IS_SUBTREE is FALSE then CHILD describes the merge target and the
   requirements around the values of URL1, REVISION1, URL2, and REVISION2
   described in 'MERGEINFO MERGE SOURCE NORMALIZATION' hold.  If IS_SUBTREE
   is TRUE then CHILD describes some subtree of a merge target and these
   normalization conditions do not necessarily hold.  IS_SUBTREE should
   always be FALSE when calling from do_file_merge().

   If IS_SUBTREE is FALSE then PARENT is ignored, otherwise PARENT must
   represent the nearest working copy ancestor of CHILD.

   NOTE: This should only be called when honoring mergeinfo.

   NOTE: When performing reverse merges, return
   SVN_ERR_CLIENT_NOT_READY_TO_MERGE if URL1@REVISION1, URL2@REVISION2, and
   ENTRY are all on the same line of history but ENTRY-REVISION is older than
   the REVISION1-REVISION2 range, see comment re issue #2973 below.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>calculate_remaining_ranges</name><parameter_list>(<param><decl><type><name>svn_client__merge_path_t</name> *</type><name>parent</name></decl></param>,
                           <param><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_root_url</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url2</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl></param>,
                           <param><decl><type><name>svn_mergeinfo_t</name></type> <name>target_mergeinfo</name></decl></param>,
                           <param><decl><type><name>svn_mergeinfo_t</name></type> <name>implicit_mergeinfo</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>is_subtree</name></decl></param>,
                           <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                           <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>primary_url</name> <init>= <expr>(<name>revision1</name> &lt; <name>revision2</name>) ? <name>url2</name> : <name>url1</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Determine which of the requested ranges to consider merging... */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__path_relative_to_root</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_path</name></expr></argument>, <argument><expr><name>primary_url</name></expr></argument>,
                                            <argument><expr><name>source_root_url</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                            <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>filter_merged_revisions</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>mergeinfo_path</name></expr></argument>,
                                  <argument><expr><name>target_mergeinfo</name></expr></argument>, <argument><expr><name>implicit_mergeinfo</name></expr></argument>,
                                  <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>, <argument><expr><name>primary_url</name></expr></argument>,
                                  <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>is_subtree</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Issue #2973 -- from the continuing series of "Why, since the advent of
     merge tracking, allowing merges into mixed rev and locally modified
     working copies isn't simple and could be considered downright evil".
     
     If reverse merging a range to the WC path represented by ENTRY, from
     that path's own history, where the path inherits no locally modified
     mergeinfo from its WC parents (i.e. there is no uncommitted merge to
     the WC), and the path's working revision is older than the range, then
     the merge will always be a no-op.  This is because we only allow reverse
     merges of ranges in the path's explicit or natural mergeinfo and a
     reverse merge from the path's future history obviously isn't going to be
     in either, hence the no-op.

     The problem is two-fold.  First, in a mixed rev WC, the change we
     want to revert might actually be to some child of the target path
     which is at a younger working revision.  Sure, we can merge directly
     to that child or update the WC or even use --ignore-ancestry and then
     successfully run the reverse merge, but that gets to the second
     problem: Those courses of action are not very obvious.  Before 1.5 if
     a user committed a change that didn't touch the commit target, then
     immediately decided to revert that change via a reverse merge it would
     just DTRT.  But with the advent of merge tracking the user gets a no-op.

     So in the name of user friendliness, return an error suggesting a helpful
     course of action.
  */</comment>
  <if>if <condition>(<expr>(<name>(<name><name>child</name>-&gt;<name>remaining_ranges</name></name>)-&gt;<name>nelts</name></name> == 0)
      &amp;&amp; (<name>revision2</name> &lt; <name>revision1</name>)
      &amp;&amp; (<name><name>entry</name>-&gt;<name>revision</name></name> &lt;= <name>revision2</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* Hmmm, an inoperative reverse merge from the "future".  If it is
         from our own future return a helpful error. */</comment>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_url</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>requested</name></decl>, <decl><type ref="prev"/><name>unspec</name></decl>, <decl><type ref="prev"/><name>pegrev</name></decl>, *<decl><type ref="prev"/><name>start_revision</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>unspec</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>requested</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>requested</name>.<name>value</name>.<name>number</name></name> = <name><name>entry</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pegrev</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pegrev</name>.<name>value</name>.<name>number</name></name> = <name>revision1</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>err</name> = <call><name>svn_client__repos_locations</name><argument_list>(<argument><expr>&amp;<name>start_url</name></expr></argument>, <argument><expr>&amp;<name>start_revision</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>url1</name></expr></argument>,
                                        <argument><expr>&amp;<name>pegrev</name></expr></argument>, <argument><expr>&amp;<name>requested</name></expr></argument>,
                                        <argument><expr>&amp;<name>unspec</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>
              || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_RA_DAV_PATH_NOT_FOUND</name>
              || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CLIENT_UNRELATED_RESOURCES</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <return>return <expr><name>err</name></expr>;</return></else></if>
        }</block></then>
      <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>start_url</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot reverse-merge a range from a "
                                    "path's own future history; try "
                                    "updating first"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></else></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_full_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_t</name> *</type><name>recorded_mergeinfo</name></decl></param>,
                   <param><decl><type><name>svn_mergeinfo_t</name> *</type><name>implicit_mergeinfo</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name> *</type><name>indirect</name></decl></param>,
                   <param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
                   <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>start</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>end</name></decl></param>,
                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>session_url</name> <init>= <expr><name>NULL</name></expr></init>, *<name>url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>target_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>peg_revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>sesspool</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Assert that we have sane input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call> 
         &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>end</name></expr></argument>)</argument_list></call> 
         &amp;&amp; (<name>start</name> &gt; <name>end</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* First, we get the real mergeinfo. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_wc_or_repos_mergeinfo</name><argument_list>(<argument><expr><name>recorded_mergeinfo</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
                                                <argument><expr><name>indirect</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>inherit</name></expr></argument>,
                                                <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                                <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
  <expr_stmt><expr><name><name>peg_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_working</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__derive_location</name><argument_list>(<argument><expr>&amp;<name>url</name></expr></argument>, <argument><expr>&amp;<name>target_rev</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                      <argument><expr>&amp;<name>peg_revision</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                      <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>target_rev</name> &lt;= <name>end</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We're asking about a range outside our natural history
         altogether.  That means our implicit mergeinfo is empty. */</comment>
      <expr_stmt><expr>*<name>implicit_mergeinfo</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Temporarily point our RA_SESSION at our target URL so we can
     fetch so-called "implicit mergeinfo" (that is, natural history). */</comment>
  <if>if <condition>(<expr><name>ra_session</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__ensure_ra_session_url</name><argument_list>(<argument><expr>&amp;<name>session_url</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, 
                                                <argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>sesspool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name><argument_list>(<argument><expr>&amp;<name>ra_session</name></expr></argument>, <argument><expr><name>url</name></expr></argument>,
                                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, 
                                                   <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Our underlying APIs can't yet handle the case where the peg
     revision isn't the youngest of the three revisions.  So we'll
     just verify that the source in the peg revision is related to the
     the source in the youngest requested revision (which is all the
     underlying APIs would do in this case right now anyway). */</comment>
  <if>if <condition>(<expr><name>target_rev</name> &lt; <name>start</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_url</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>requested</name></decl>, <decl><type ref="prev"/><name>unspec</name></decl>, <decl><type ref="prev"/><name>pegrev</name></decl>, *<decl><type ref="prev"/><name>start_revision</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>unspec</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>requested</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>requested</name>.<name>value</name>.<name>number</name></name> = <name>start</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pegrev</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pegrev</name>.<name>value</name>.<name>number</name></name> = <name>target_rev</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__repos_locations</name><argument_list>(<argument><expr>&amp;<name>start_url</name></expr></argument>, <argument><expr>&amp;<name>start_revision</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>url</name></expr></argument>,
                                          <argument><expr>&amp;<name>pegrev</name></expr></argument>, <argument><expr>&amp;<name>requested</name></expr></argument>,
                                          <argument><expr>&amp;<name>unspec</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* ### FIXME: Having a low-brain moment.  Shouldn't we check
         that START_URL matches our session URL at this point?  */</comment>
      <expr_stmt><expr><name>target_rev</name> = <name>start</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Fetch the implicit mergeinfo. */</comment>
  <expr_stmt><expr><name><name>peg_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>peg_revision</name>.<name>value</name>.<name>number</name></name> = <name>target_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_history_as_mergeinfo</name><argument_list>(<argument><expr><name>implicit_mergeinfo</name></expr></argument>, <argument><expr><name>url</name></expr></argument>,
                                               <argument><expr>&amp;<name>peg_revision</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, 
                                               <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we created an RA_SESSION above, destroy it.  Otherwise, if
     reparented an existing session, point it back where it was when
     we were called. */</comment>
  <if>if <condition>(<expr><name>sesspool</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>session_url</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>session_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper for do_directory_merge().

   For each child in CHILDREN_WITH_MERGEINFO, populates that
   child's remaining_ranges list.  CHILDREN_WITH_MERGEINFO is expected
   to be sorted in depth first order.  All persistent allocations are
   from CHILDREN_WITH_MERGEINFO-&gt;pool.

   If HONOR_MERGEINFO is set, this function will actually try to be
   intelligent about populating remaining_ranges list.  Otherwise, it
   will claim that each child has a single remaining range, from
   revision1, to revision2.

   See `MERGEINFO MERGE SOURCE NORMALIZATION' for more requirements
   around the values of URL1, REVISION1, URL2, and REVISION2.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>populate_remaining_ranges</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_root_url</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl></param>,
                          <param><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url2</name></decl></param>,
                          <param><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>inheritable</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>honor_mergeinfo</name></decl></param>,
                          <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_merge_src_canon_path</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                          <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>, *<decl><type ref="prev"/><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>merge_target_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pool</name> = <name><name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we aren't honoring mergeinfo or this is a --record-only merge,
     we'll make quick work of this by simply adding dummy REVISION1:REVISION2
     ranges for all children. */</comment>
  <if>if <condition>(<expr>! <name>honor_mergeinfo</name> || <name><name>merge_b</name>-&gt;<name>record_only</name></name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, 
                          <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name></name> = <name>revision1</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name></name> = <name>revision2</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>inheritable</name></name> = <name>inheritable</name></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name> = 
            <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
        }</block></for>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_repos_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>child_entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_url1</name></decl>, *<decl><type ref="prev"/><name>child_url2</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>parent</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If the path is absent don't do subtree merge either. */</comment>
      <if>if <condition>(<expr>!<name>child</name> || <name><name>child</name>-&gt;<name>absent</name></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call> == <name>merge_target_len</name></expr>)</condition><then>
        <expr_stmt><expr><name>child_repos_path</name> = ""</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>child_repos_path</name> = <name><name>child</name>-&gt;<name>path</name></name> +
          (<name>merge_target_len</name> ? <name>merge_target_len</name> + 1 : 0)</expr>;</expr_stmt></else></if>
      <expr_stmt><expr><name>child_url1</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>url1</name></expr></argument>, <argument><expr><name>child_repos_path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>child_url2</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>url2</name></expr></argument>, <argument><expr><name>child_repos_path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>child_entry</name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                      <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_full_mergeinfo</name><argument_list>(<argument><expr>&amp;(<name><name>child</name>-&gt;<name>pre_merge_mergeinfo</name></name>)</expr></argument>, 
                                 <argument><expr>&amp;(<name><name>child</name>-&gt;<name>implicit_mergeinfo</name></name>)</expr></argument>, <argument><expr><name>child_entry</name></expr></argument>,
                                 <argument><expr>&amp;(<name><name>child</name>-&gt;<name>indirect_mergeinfo</name></name>)</expr></argument>,
                                 <argument><expr><name>svn_mergeinfo_inherited</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>,
                                 <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If CHILD isn't the merge target find its parent. */</comment>
      <if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>parent_index</name> <init>= <expr><call><name>find_nearest_ancestor</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>parent</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>parent_index</name></expr></argument>,
                                 <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>!<name>parent</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* If CHILD is a subtree then its parent must be in
                 CHILDREN_WITH_MERGEINFO, see the global comment
                 'THE CHILDREN_WITH_MERGEINFO ARRAY'. */</comment>
              <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>calculate_remaining_ranges</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>child</name></expr></argument>,
                                         <argument><expr><name>source_root_url</name></expr></argument>,
                                         <argument><expr><name>child_url1</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>,
                                         <argument><expr><name>child_url2</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                         <argument><expr><name><name>child</name>-&gt;<name>pre_merge_mergeinfo</name></name></expr></argument>,
                                         <argument><expr><name><name>child</name>-&gt;<name>implicit_mergeinfo</name></name></expr></argument>,
                                         <argument><expr><name>i</name> &gt; 0 ? <name>TRUE</name> : <name>FALSE</name></expr></argument>, <comment type="block">/* is subtree */</comment>
                                         <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>child_entry</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Take advantage of the depth first ordering,
     i.e first(0th) item is target.*/</comment>
  <if>if <condition>(<expr><name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name> &gt; 1</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>dummy_range</name> <init>= 
            <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>dummy_range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>dummy_range</name>-&gt;<name>start</name></name> = <name>revision2</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>dummy_range</name>-&gt;<name>end</name></name> = <name>revision2</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>dummy_range</name>-&gt;<name>inheritable</name></name> = <name>inheritable</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, 
                                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dummy_range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> =
            <name>dummy_range</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>merge_b</name>-&gt;<name>target_has_dummy_merge_range</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Other Helper Functions ***/</comment>


<comment type="block">/* Create mergeinfo describing the merge of RANGELIST into TARGET_WCPATH,
   accounting for paths unaffected by the merge due to skips or conflicts from
   NOTIFY_B. For 'immediates' merge it sets an inheritable mergeinfo
   corresponding to current merge on merge target. For 'files' merge it sets
   an inheritable mergeinfo corrsponding to current merge on merged files.
   If TARGET_WCPATH is a directory and it is missing an immediate child then
   TARGET_MISSING_CHILD should be true, otherwise it is false.*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>determine_merges_performed</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>merges</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                           <param><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl></param>,
                           <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                           <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                           <param><decl><type><name>notification_receiver_baton_t</name> *</type><name>notify_b</name></decl></param>,
                           <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nbr_skips</name> <init>= <expr>(<name><name>notify_b</name>-&gt;<name>skipped_paths</name></name> != <name>NULL</name> ?
                          <call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>skipped_paths</name></name></expr></argument>)</argument_list></call> : 0)</expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr>*<name>merges</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>merges</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>nbr_skips</name> &gt; 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

      <comment type="block">/* Override the mergeinfo for child paths which weren't
         actually merged. */</comment>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>notify_b</name>-&gt;<name>skipped_paths</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
           <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>skipped_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_status2_t</name> *</type><name>status</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>skipped_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Before we override, make sure this is a versioned path, it
             might be an unversioned obstruction. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_status2</name><argument_list>(<argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr>(const <name>char</name> *) <name>skipped_path</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>status</name>-&gt;<name>text_status</name></name> == <name>svn_wc_status_none</name>
              || <name><name>status</name>-&gt;<name>text_status</name></name> == <name>svn_wc_status_unversioned</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Add an empty range list for this path.

             ### TODO: This works fine for a file path skipped because it is
             ### missing as long as the file's parent directory is present.
             ### But missing directory paths skipped are not handled yet,
             ### see issue #2915. */</comment>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>merges</name></expr></argument>, <argument><expr>(const <name>char</name> *) <name>skipped_path</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                       <argument><expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>nbr_skips</name> &lt; <name><name>notify_b</name>-&gt;<name>nbr_notifications</name></name></expr>)</condition><then>
            <comment type="block">/* ### Use RANGELIST as the mergeinfo for all children of
               ### this path which were not also explicitly
               ### skipped? */</comment>
            <empty_stmt>;</empty_stmt></then></if>
        }</block></for>
    }</block></then></if>
  <if>if <condition>(<expr>(<name>depth</name> != <name>svn_depth_infinity</name>) &amp;&amp; <name><name>notify_b</name>-&gt;<name>merged_paths</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>merged_path</name></decl>;</decl_stmt>

      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>notify_b</name>-&gt;<name>merged_paths</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
           <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>child_entry</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist_of_child</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>merged_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>child_entry</name></expr></argument>,
                                          <argument><expr><name>merged_path</name></expr></argument>,
                                          <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>((<name><name>child_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)
               &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>merged_path</name></expr></argument>)</argument_list></call> == 0)
               &amp;&amp; (<name>depth</name> == <name>svn_depth_immediates</name>))
              || ((<name><name>child_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>)
                  &amp;&amp; (<name>depth</name> == <name>svn_depth_files</name>))</expr>)</condition><then>
            <block>{
              <comment type="block">/* Set the explicit inheritable mergeinfo for,
                 1. Merge target directory if depth is immediates.
                 2. If merge is on a file and requested depth is 'files'.
               */</comment>
              <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
              <expr_stmt><expr><name>rangelist_of_child</name> = <call><name>svn_rangelist_dup</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rangelist_of_child</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                <block>{
                  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>rng</name> <init>=
                    <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rangelist_of_child</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <expr_stmt><expr><name><name>rng</name>-&gt;<name>inheritable</name></name> = <name>TRUE</name></expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
          <if>if <condition>(<expr><name>rangelist_of_child</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>merges</name></expr></argument>, <argument><expr>(const <name>char</name> *)<name>merged_path</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>rangelist_of_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Calculate the new mergeinfo for the target tree based on the merge
   info for TARGET_WCPATH and MERGES (a mapping of WC paths to range
   lists), and record it in the WC (at, and possibly below,
   TARGET_WCPATH). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>update_wc_mergeinfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_rel_path</name></decl></param>, <param><decl><type><name>apr_hash_t</name> *</type><name>merges</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>is_rollback</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <comment type="block">/* Combine the mergeinfo for the revision range just merged into
     the WC with its on-disk mergeinfo. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>merges</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>value</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ranges</name></decl>, *<decl><type ref="prev"/><name>rangelist</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ranges</name> = <name>value</name></expr>;</expr_stmt>

      <comment type="block">/* As some of the merges may've changed the WC's mergeinfo, get
         a fresh copy before using it to update the WC's mergeinfo. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_client__parse_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                        <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* If a directory PATH was skipped because it is missing or was
         obstructed by an unversioned item then there's nothing we can
         do with that, so skip it. */</comment>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_NOT_LOCKED</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then>
          <else>else
            <block>{
              <return>return <expr><name>err</name></expr>;</return>
            }</block></else></if>
        }</block></then></if>

      <comment type="block">/* If we are attempting to set empty revision range override mergeinfo
         on a path with no explicit mergeinfo, we first need the pristine
         mergeinfo that path inherits. */</comment>
      <if>if <condition>(<expr><name>mergeinfo</name> == <name>NULL</name> &amp;&amp; <name><name>ranges</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>inherited</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_wc_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>inherited</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                               <argument><expr><name>svn_mergeinfo_nearest_ancestor</name></expr></argument>,
                                               <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                               <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr><name>mergeinfo</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>mergeinfo</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* ASSUMPTION: "target_wcpath" is always both a parent and
         prefix of "path". */</comment>
      <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>len</name> &lt; <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_relative_to_target</name> <init>= <expr><name>len</name>?(<name>path</name> + <name>len</name> + 1):(<name>path</name>)</expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rel_path</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>repos_rel_path</name></expr></argument>, <argument><expr>"/"</expr></argument>,
                                 <argument><expr><name>path_relative_to_target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <expr_stmt><expr><name>rel_path</name> = <name>repos_rel_path</name></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><name>rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>, <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>rangelist</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>rangelist</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name>is_rollback</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>ranges</name> = <call><name>svn_rangelist_dup</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_reverse</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_remove</name><argument_list>(<argument><expr>&amp;<name>rangelist</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>rangelist</name></expr></argument>,
                                       <argument><expr><name>FALSE</name></expr></argument>,
                                       <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_merge</name><argument_list>(<argument><expr>&amp;<name>rangelist</name></expr></argument>, <argument><expr><name>ranges</name></expr></argument>,
                                      <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      <comment type="block">/* Update the mergeinfo by adjusting the path's rangelist. */</comment>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>, <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>is_rollback</name> &amp;&amp; <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>mergeinfo</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>svn_mergeinfo__remove_empty_rangelists</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>err</name> = <call><name>svn_client__record_wc_mergeinfo</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mergeinfo</name></expr></argument>,
                                            <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_ENTRY_NOT_FOUND</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* PATH isn't just missing, it's not even versioned as far
             as this working copy knows.  But it was included in
             MERGES, which means that the server knows about it.
             Likely we don't have access to the source due to authz
             restrictions.  For now just clear the error and
             continue...

             ### TODO:  Set non-inheritable mergeinfo on PATH's immediate
             ### parent and normal mergeinfo on PATH's siblings which we
             ### do have access to. */</comment>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Create and return an error structure appropriate for the unmerged
   revisions range(s). */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>svn_error_t</name> *</type>
<name>make_merge_conflict_error</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                          <param><decl><type><name>svn_merge_range_t</name> *</type><name>r</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_error_createf</name>
    <argument_list>(<argument><expr><name>SVN_ERR_WC_FOUND_CONFLICT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"One or more conflicts were produced while merging r%ld:%ld into\n"
       "'%s' --\n"
       "resolve all conflicts and rerun the merge to apply the remaining\n"
       "unmerged revisions"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>end</name></name></expr></argument>, <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Helper for do_directory_merge().

   TARGET_WCPATH is a directory and CHILDREN_WITH_MERGEINFO is filled
   with paths (svn_client__merge_path_t *) arranged in depth first order,
   which have mergeinfo set on them or meet one of the other criteria
   defined in get_mergeinfo_paths().  Remove any paths absent from disk
   or scheduled for deletion from CHILDREN_WITH_MERGEINFO which are equal to
   or are descendants of TARGET_WCPATH by setting those children to NULL.
   Also remove the path from the NOTIFY_B-&gt;SKIPPED_PATHS hash. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_absent_children</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                       <param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                       <param><decl><type><name>notification_receiver_baton_t</name> *</type><name>notify_b</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Before we try to override mergeinfo for skipped paths, make sure
     the path isn't absent due to authz restrictions, because there's
     nothing we can do about those. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                      <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>child</name>
          &amp;&amp; (<name><name>child</name>-&gt;<name>absent</name></name> || <name><name>child</name>-&gt;<name>scheduled_for_deletion</name></name>)
          &amp;&amp; <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>skipped_paths</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>notify_b</name>-&gt;<name>skipped_paths</name></name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>,
                         <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                        <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
}</block></function>

<comment type="block">/* Helper for do_directory_merge().

   Sets up the diff editor report and drives it by properly negating
   subtree that could have a conflicting merge history.

   MERGE_B-&gt;ra_session1 reflects URL1; MERGE_B-&gt;ra_session2 reflects URL2.

   If MERGE_B-&gt;sources_ancestral is set, then URL1@REVISION1 must be a
   historical ancestor of URL2@REVISION2, or vice-versa (see
   `MERGEINFO MERGE SOURCE NORMALIZATION' for more requirements around
   the values of URL1, REVISION1, URL2, and REVISION2 in this case).
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>drive_merge_report_editor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl></param>,
                          <param><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url2</name></decl></param>,
                          <param><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl></param>,
                          <param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>is_rollback</name></decl></param>,
                          <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                          <param><decl><type><name>notification_receiver_baton_t</name> *</type><name>notify_b</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_wc_diff_callbacks2_t</name> *</type><name>callbacks</name></decl></param>,
                          <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_ra_reporter3_t</name> *</type><name>reporter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>diff_editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>diff_edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>report_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>default_start</name></decl>, <decl><type ref="prev"/><name>target_start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>honor_mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_sess2_url</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>mergeinfo_behavior</name><argument_list>(<argument><expr>&amp;<name>honor_mergeinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Start with a safe default starting revision for the editor and the
     merge target. */</comment>
  <expr_stmt><expr><name>default_start</name> = <name>target_start</name> = <name>revision1</name></expr>;</expr_stmt>

  <comment type="block">/* If we are honoring mergeinfo the starting revision for the merge target
     might not be REVISION1, in fact the merge target might not need *any*
     part of REVISION1:REVISION2 merged -- Instead some subtree of the target
     needs REVISION1:REVISION2 -- So get the right starting revision for the
     target. */</comment>
  <if>if <condition>(<expr><name>honor_mergeinfo</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>target_has_dummy_merge_range</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* The merge target doesn't need anything merged. */</comment>
          <expr_stmt><expr><name>target_start</name> = <name>revision2</name></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>children_with_mergeinfo</name> &amp;&amp; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr>0</expr></argument>, 
                          <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
            <block>{
              <comment type="block">/* The merge target needs something merged, but it might
                 not be the entire REVISION1:REVISION2 range. */</comment>
              <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>=
                <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>, 
                              <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>target_start</name> = <name><name>range</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if>
    }</block></then></if>

  <comment type="block">/* Temporarily point our second RA session to URL1, too.  We use
     this to request individual file contents. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__ensure_ra_session_url</name><argument_list>(<argument><expr>&amp;<name>old_sess2_url</name></expr></argument>, 
                                            <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>, 
                                            <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Get the diff editor and a reporter with which to, ultimately,
     drive it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_diff_editor</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>callbacks</name></expr></argument>,
                                      <argument><expr><name>merge_b</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>dry_run</name></name></expr></argument>,
                                      <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>, <argument><expr><name>default_start</name></expr></argument>,
                                      <argument><expr><name>notification_receiver</name></expr></argument>, <argument><expr><name>notify_b</name></expr></argument>,
                                      <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                      <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                                      <argument><expr>&amp;<name>diff_editor</name></expr></argument>, <argument><expr>&amp;<name>diff_edit_baton</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_do_diff3</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>,
                          <argument><expr>&amp;<name>reporter</name></expr></argument>, <argument><expr>&amp;<name>report_baton</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                          <argument><expr>""</expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ignore_ancestry</name></name></expr></argument>, 
                          <argument><expr><name>TRUE</name></expr></argument>,  <comment type="block">/* text_deltas */</comment>
                          <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>diff_editor</name></expr></argument>, <argument><expr><name>diff_edit_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Drive the reporter. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>reporter</name>-&gt;<name>set_path</name></name><argument_list>(<argument><expr><name>report_baton</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>target_start</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>,
                             <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>honor_mergeinfo</name> &amp;&amp; <name>children_with_mergeinfo</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Describe children with mergeinfo overlapping this merge
         operation such that no repeated diff is retrieved for them from
         the repository. */</comment>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>target_wcpath_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <comment type="block">/* Start with CHILDREN_WITH_MERGEINFO[1], CHILDREN_WITH_MERGEINFO[0]
         is always the merge target (TARGET_WCPATH). */</comment>
      <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_repos_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>parent</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, 
                          <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>parent_index</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>nearest_parent_is_target</name></decl>;</decl_stmt>

          <if>if <condition>(<expr>!<name>child</name> || <name><name>child</name>-&gt;<name>absent</name></name></expr>)</condition><then>
            <continue>continue;</continue></then></if>
          
          <comment type="block">/* Find this child's nearest wc ancestor with mergeinfo. */</comment>
          <expr_stmt><expr><name>parent_index</name> = <call><name>find_nearest_ancestor</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>parent</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>parent_index</name></expr></argument>,
                                 <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <comment type="block">/* Note if the child's parent is the merge target. */</comment>
          <expr_stmt><expr><name>nearest_parent_is_target</name> =
            (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>)</argument_list></call> == 0) ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>

          <comment type="block">/* If a subtree needs the same range applied as it's nearest parent
             with mergeinfo, then we don't need to describe the subtree
             separately. */</comment>
          <if>if <condition>(<expr><name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>range</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                    <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>parent</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
                <block>{
                   <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>parent_range</name> <init>=
                    <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                  <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                   <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>child_range</name> <init>=
                    <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                  <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <if>if <condition>(<expr><name><name>parent_range</name>-&gt;<name>start</name></name> == <name><name>child_range</name>-&gt;<name>start</name></name></expr>)</condition><then>
                    <continue>continue;</continue></then></if> <comment type="block">/* Same as parent. */</comment>
                }</block></then></if>
            }</block></then>
          <else>else <comment type="block">/* child-&gt;remaining_ranges-&gt;nelts == 0*/</comment>
            <block>{
              <comment type="block">/* If both the subtree and its parent need no ranges applied
                 consider that as the "same ranges" and don't describe
                 the subtree.  If the subtree's parent is the merge target,
                 then the parent can have a dummy range; this is still
                 the same as no remaining ranges. */</comment>
              <if>if <condition>(<expr><name><name>parent</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> == 0
                  || (<name>nearest_parent_is_target</name>
                      &amp;&amp; <name><name>merge_b</name>-&gt;<name>target_has_dummy_merge_range</name></name>)</expr>)</condition><then>
                <continue>continue;</continue></then></if> <comment type="block">/* Same as parent. */</comment>
            }</block></else></if>

          <comment type="block">/* Ok, we really need to describe this subtree as it needs different
             ranges applied than its nearest working copy parent. */</comment>
          <expr_stmt><expr><name>child_repos_path</name> = <name><name>child</name>-&gt;<name>path</name></name> +
            (<name>target_wcpath_len</name> ? <name>target_wcpath_len</name> + 1 : 0)</expr>;</expr_stmt>

          <if>if <condition>(<expr>(<name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> == 0)
              || (<name>is_rollback</name> &amp;&amp; (<name><name>range</name>-&gt;<name>start</name></name> &lt; <name>revision2</name>))
              || (!<name>is_rollback</name> &amp;&amp; (<name><name>range</name>-&gt;<name>start</name></name> &gt; <name>revision2</name>))</expr>)</condition><then>
            <block>{
              <comment type="block">/* Nothing to merge to this child.  We'll claim we have
                 it up to date so the server doesn't send us
                 anything. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>reporter</name>-&gt;<name>set_path</name></name><argument_list>(<argument><expr><name>report_baton</name></expr></argument>, <argument><expr><name>child_repos_path</name></expr></argument>,
                                         <argument><expr><name>revision2</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, 
                                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>reporter</name>-&gt;<name>set_path</name></name><argument_list>(<argument><expr><name>report_baton</name></expr></argument>, <argument><expr><name>child_repos_path</name></expr></argument>,
                                         <argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, 
                                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>reporter</name>-&gt;<name>finish_report</name></name><argument_list>(<argument><expr><name>report_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Point the merge baton's second session back where it was. */</comment>
  <if>if <condition>(<expr><name>old_sess2_url</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>, <argument><expr><name>old_sess2_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Sleep to ensure timestamp integrity. */</comment>
  <expr_stmt><expr><call><name>svn_sleep_for_timestamps</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Return the most inclusive range start revision across all the
   remaining ranges in CHILDREN_WITH_MERGEINFO.  If there are no
   remaining ranges, return SVN_INVALID_REVNUM.  Skip no-op ranges
   on the target (they are probably dummies). */</comment>
<function><type><specifier>static</specifier> <name>svn_revnum_t</name></type>
<name>get_most_inclusive_start_rev</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>is_rollback</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name></decl>;</decl_stmt>

      <if>if <condition>(<expr>(! <name>child</name>) || <name><name>child</name>-&gt;<name>absent</name></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>
      <if>if <condition>(<expr>! <name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>
      <expr_stmt><expr><name>range</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name>i</name> == 0) &amp;&amp; (<name><name>range</name>-&gt;<name>start</name></name> == <name><name>range</name>-&gt;<name>end</name></name>)</expr>)</condition><then>
        <continue>continue;</continue></then></if>
      <if>if <condition>(<expr>(<name>start_rev</name> == <name>SVN_INVALID_REVNUM</name>)
          || (<name>is_rollback</name> &amp;&amp; (<name><name>range</name>-&gt;<name>start</name></name> &gt; <name>start_rev</name>))
          || ((! <name>is_rollback</name>) &amp;&amp; (<name><name>range</name>-&gt;<name>start</name></name> &lt; <name>start_rev</name>))</expr>)</condition><then>
        <expr_stmt><expr><name>start_rev</name> = <name><name>range</name>-&gt;<name>start</name></name></expr>;</expr_stmt></then></if>
    }</block></for>
  <return>return <expr><name>start_rev</name></expr>;</return>
}</block></function>

<comment type="block">/* Return the youngest qualifying end revision across the first of
   each child in CHILDREN_WITH_MERGEINFO's remaining ranges.  If
   nothing qualifies, return SVN_INVALID_REVNUM. */</comment>
<function><type><specifier>static</specifier> <name>svn_revnum_t</name></type>
<name>get_youngest_end_rev</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>is_rollback</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>child</name> || <name><name>child</name>-&gt;<name>absent</name></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>
      <if>if <condition>(<expr><name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                                   <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>(<name>end_rev</name> == <name>SVN_INVALID_REVNUM</name>)
              || (<name>is_rollback</name> &amp;&amp; (<name><name>range</name>-&gt;<name>end</name></name> &gt; <name>end_rev</name>))
              || ((! <name>is_rollback</name>) &amp;&amp; (<name><name>range</name>-&gt;<name>end</name></name> &lt; <name>end_rev</name>))</expr>)</condition><then>
            <expr_stmt><expr><name>end_rev</name> = <name><name>range</name>-&gt;<name>end</name></name></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></for>
  <return>return <expr><name>end_rev</name></expr>;</return>
}</block></function>

<comment type="block">/* If first item in each child of CHILDREN_WITH_MERGEINFO's
   remaining_ranges is inclusive of END_REV, Slice the first range in
   to two at END_REV. All the allocations are persistent and allocated
   from POOL. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slice_remaining_ranges</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>is_rollback</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
                                     <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                                   <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>child</name> || <name><name>child</name>-&gt;<name>absent</name></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>
      <if>if <condition>(<expr><name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                                   <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>(<name>is_rollback</name> &amp;&amp; (<name><name>range</name>-&gt;<name>start</name></name> &gt; <name>end_rev</name>)
               &amp;&amp; (<name><name>range</name>-&gt;<name>end</name></name> &lt; <name>end_rev</name>))
              || (!<name>is_rollback</name> &amp;&amp; (<name><name>range</name>-&gt;<name>start</name></name> &lt; <name>end_rev</name>)
                  &amp;&amp; (<name><name>range</name>-&gt;<name>end</name></name> &gt; <name>end_rev</name>))</expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>split_range1</name></decl>, *<decl><type ref="prev"/><name>split_range2</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>orig_remaining_ranges</name> <init>=
                                                     <expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name>split_range1</name> = <call><name>svn_merge_range_dup</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>split_range2</name> = <call><name>svn_merge_range_dup</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>split_range1</name>-&gt;<name>end</name></name> = <name>end_rev</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>split_range2</name>-&gt;<name>start</name></name> = <name>end_rev</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name> =
                     <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>(<name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> + 1)</expr></argument>,
                                    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>,
                             <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>split_range1</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>,
                             <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>split_range2</name></expr>;</expr_stmt>
              <for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>orig_remaining_ranges</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
                <block>{
                  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>orig_range</name> <init>=
                                     <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>orig_remaining_ranges</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                                                   <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>,
                                 <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>orig_range</name></expr>;</expr_stmt>
                }</block></for>
            }</block></then></if>
        }</block></then></if>
    }</block></for>
}</block></function>

<comment type="block">/* Helper for do_directory_merge().

   Remove the first remaining revision range for each child in
   CHILDREN_WITH_MERGEINFO *iff* that child was already merged.  END_REV is the
   ending revision of the most recently merged range, i.e. the same end_rev
   passed to drive_merge_report_editor() by do_directory_merge().  If a
   range is removed from a child's remaining_ranges array, allocate the new
   remaining_ranges array in POOL.

   ### TODO: We should have remaining_ranges in reverse order to avoid
   ### recreating and reallocationg the remaining_ranges every time we want
   ### to remove the first range.  If the ranges were reversed we could simply
   ### pop the last element in the array. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_first_range_from_remaining_ranges</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name></decl></param>,
                                         <param><decl><type><name>apr_array_header_t</name>
                                           *</type><name>children_with_mergeinfo</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
                                <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                              <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr>!<name>child</name> || <name><name>child</name>-&gt;<name>absent</name></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>
      <if>if <condition>(<expr><name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>first_range</name> <init>=
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name><name>first_range</name>-&gt;<name>end</name></name> == <name>end_rev</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>orig_remaining_ranges</name> <init>=
                <expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name> =
                <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>(<name><name>child</name>-&gt;<name>remaining_ranges</name>-&gt;<name>nelts</name></name> - 1)</expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <for>for (<init><expr><name>j</name> = 1</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>orig_remaining_ranges</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
                <block>{
                  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>=
                    <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>orig_remaining_ranges</name></expr></argument>,
                                  <argument><expr><name>j</name></expr></argument>,
                                  <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>remaining_ranges</name></name></expr></argument>,
                                 <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
                }</block></for>          
            }</block></then></if>
        }</block></then></if>
    }</block></for>
}</block></function>

<comment type="block">/* Marks 'inheritable' RANGE to TARGET_WCPATH by wiping off the
   corresponding 'non-inheritable' RANGE from TARGET_MERGEINFO for the
   merge source REL_PATH.  It does such marking only for same URLs
   from same Repository, not a dry run, target having existing
   mergeinfo(TARGET_MERGEINFO) and target being part of
   CHILDREN_WITH_MERGEINFO. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>mark_mergeinfo_as_inheritable_for_a_range</name><parameter_list>(
                                   <param><decl><type><name>svn_mergeinfo_t</name></type> <name>target_mergeinfo</name></decl></param>,
                                   <param><decl><type><name>svn_boolean_t</name></type> <name>same_urls</name></decl></param>,
                                   <param><decl><type><name>svn_merge_range_t</name> *</type><name>range</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel_path</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                   <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>,
                                   <param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                                   <param><decl><type><name>int</name></type> <name>target_index</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Check if we need to make non-inheritable ranges inheritable. */</comment>
  <if>if <condition>(<expr><name>target_mergeinfo</name> &amp;&amp; <name>same_urls</name>
      &amp;&amp; !<name><name>merge_b</name>-&gt;<name>dry_run</name></name>
      &amp;&amp; <name><name>merge_b</name>-&gt;<name>same_repos</name></name>
      &amp;&amp; <name>target_index</name> &gt;= 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>merge_path</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                      <argument><expr><name>target_index</name></expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If a path has no missing children, has non-inheritable ranges,
         *and* those non-inheritable ranges intersect with the merge being
         performed (i.e. this is a repeat merge where a previously missing
         child is now present) then those non-inheritable ranges are made
         inheritable. */</comment>
      <if>if <condition>(<expr><name>merge_path</name>
          &amp;&amp; <name><name>merge_path</name>-&gt;<name>has_noninheritable</name></name> &amp;&amp; !<name><name>merge_path</name>-&gt;<name>missing_child</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_equal</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>merges</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>inheritable_merges</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>inheritable_ranges</name> <init>=
            <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>inheritable_ranges</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>inheritable_merges</name></expr></argument>, <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                       <argument><expr><name>inheritable_ranges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Try to remove any non-inheritable ranges bound by the merge
             being performed. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_inheritable</name><argument_list>(<argument><expr>&amp;<name>merges</name></expr></argument>, <argument><expr><name>target_mergeinfo</name></expr></argument>,
                                            <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>,
                                            <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* If any non-inheritable ranges were removed put them back as
             inheritable ranges. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo__equals</name><argument_list>(<argument><expr>&amp;<name>is_equal</name></expr></argument>, <argument><expr><name>merges</name></expr></argument>, <argument><expr><name>target_mergeinfo</name></expr></argument>,
                                        <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>!<name>is_equal</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>merges</name></expr></argument>, <argument><expr><name>inheritable_merges</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__record_wc_mergeinfo</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>merges</name></expr></argument>,
                                                      <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* For shallow merges record the explicit *indirect* mergeinfo on the

     1. merged files *merged* with a depth 'files'.
     2. merged target directory *merged* with a depth 'immediates'.

   All subtrees which are going to get a 'inheritable merge range'
   because of this 'shallow' merge should have the explicit mergeinfo
   recorded on them. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>record_mergeinfo_on_merged_children</name><parameter_list>(<param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                    <param><decl><type><name>notification_receiver_baton_t</name> *</type><name>notify_b</name></decl></param>,
                                    <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>(<name>depth</name> != <name>svn_depth_infinity</name>) &amp;&amp; <name><name>notify_b</name>-&gt;<name>merged_paths</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>indirect_child_mergeinfo</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>child_target_mergeinfo</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>merged_path</name></decl>;</decl_stmt>

      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>notify_b</name>-&gt;<name>merged_paths</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
           <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>child_entry</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>merged_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>child_entry</name></expr></argument>, <argument><expr><name>merged_path</name></expr></argument>,
                                          <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>((<name><name>child_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)
                &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>merged_path</name></expr></argument>)</argument_list></call> == 0)
                &amp;&amp; (<name>depth</name> == <name>svn_depth_immediates</name>))
              || ((<name><name>child_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>)
                   &amp;&amp; (<name>depth</name> == <name>svn_depth_files</name>))</expr>)</condition><then>
            <block>{
              <comment type="block">/* Set the explicit inheritable mergeinfo for,
                    1. Merge target directory if depth is 'immediates'.
                    2. If merge is on a file and requested depth is 'files'.
               */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_wc_or_repos_mergeinfo</name>
                                      <argument_list>(<argument><expr>&amp;<name>child_target_mergeinfo</name></expr></argument>, <argument><expr><name>child_entry</name></expr></argument>,
                                       <argument><expr>&amp;<name>indirect_child_mergeinfo</name></expr></argument>,
                                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>svn_mergeinfo_inherited</name></expr></argument>,
                                       <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>, <argument><expr><name>merged_path</name></expr></argument>,
                                       <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>indirect_child_mergeinfo</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__record_wc_mergeinfo</name><argument_list>(<argument><expr><name>merged_path</name></expr></argument>,
                                                        <argument><expr><name>child_target_mergeinfo</name></expr></argument>,
                                                        <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></for>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Get REVISION of the file at URL.  SOURCE is a path that refers to that
   file's entry in the working copy, or NULL if we don't have one.  Return in
   *FILENAME the name of a file containing the file contents, in *PROPS a hash
   containing the properties and in *REV the revision.  All allocation occurs
   in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>single_file_merge_get_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>filename</name></decl></param>,
                           <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                           <param><decl><type><name>apr_hash_t</name> **</type><name>props</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>wc_target</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <comment type="block">/* ### Create this temporary file under .svn/tmp/ instead of next to
     ### the working file.*/</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
                                   <argument><expr><name>wc_target</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                   <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_file</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                          <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Send a notification specific to a single-file merge if the states
   indicate there's something worth reporting.

   If *HEADER_SENT is not set and HEADER_NOTIFICATION is not NULL, then
   send the header notification before sending the state notification,
   and set *HEADER_SENT to TRUE. */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type>
<name>single_file_merge_notify</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>, 
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                         <param><decl><type><name>svn_wc_notify_action_t</name></type> <name>action</name></decl></param>,
                         <param><decl><type><name>svn_wc_notify_state_t</name></type> <name>text_state</name></decl></param>,
                         <param><decl><type><name>svn_wc_notify_state_t</name></type> <name>prop_state</name></decl></param>, 
                         <param><decl><type><name>svn_wc_notify_t</name> *</type><name>header_notification</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name> *</type><name>header_sent</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name> <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name>text_state</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify</name>-&gt;<name>prop_state</name></name> = <name>prop_state</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>notify</name>-&gt;<name>content_state</name></name> == <name>svn_wc_notify_state_missing</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>notify</name>-&gt;<name>action</name></name> = <name>svn_wc_notify_skip</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><call><name>IS_OPERATIVE_NOTIFICATION</name><argument_list>(<argument><expr><name>notify</name></expr></argument>)</argument_list></call>
      &amp;&amp; <name>header_notification</name> 
      &amp;&amp; (! *<name>header_sent</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>notification_receiver</name><argument_list>(<argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>header_notification</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>header_sent</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
  <expr_stmt><expr><call><name>notification_receiver</name><argument_list>(<argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* A baton for get_mergeinfo_walk_cb. */</comment>
<struct>struct <name>get_mergeinfo_walk_baton</name>
<block>{
  <comment type="block">/* Access for the tree being walked. */</comment>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>base_access</name></decl>;</decl_stmt>
  <comment type="block">/* Array of paths that have explicit mergeinfo and/or are switched. */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl>;</decl_stmt>
  <comment type="block">/* Merge source canonical path. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>merge_src_canon_path</name></decl>;</decl_stmt>
  
  <comment type="block">/* Information on the merge cascaded from do_directory_merge() */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>merge_target_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_root_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>url1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>url2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl>;</decl_stmt>
  
  <comment type="block">/* merge depth requested. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl>;</decl_stmt>
  
  <comment type="block">/* RA session and client context cascaded from do_directory_merge() */</comment>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* svn_wc_entry_callbacks2_t found_entry() callback for get_mergeinfo_paths.

   Given PATH, its corresponding ENTRY, and WB, where WB is the WALK_BATON
   of type "struct get_mergeinfo_walk_baton *":  If PATH is switched,
   has explicit working svn:mergeinfo from a corresponding merge source, is
   missing a child due to a sparse checkout, is absent from disk, or is
   scheduled for deletion, then create a svn_client__merge_path_t *
   representing *PATH, allocated in WB-&gt;CHILDREN_WITH_MERGEINFO-&gt;POOL, and
   push it onto the WB-&gt;CHILDREN_WITH_MERGEINFO array. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_mergeinfo_walk_cb</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                      <param><decl><type><name>void</name> *</type><name>walk_baton</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_mergeinfo_walk_baton</name> *</type><name>wb</name> <init>= <expr><name>walk_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>propval</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>mergehash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>switched</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo_from_merge_src</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path_is_merge_target</name> <init>=
    <expr>!<call><name>svn_path_compare_paths</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>wb</name>-&gt;<name>merge_target_path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name> <init>= <expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* We're going to receive dirents twice;  we want to ignore the
     first one (where it's a child of a parent dir), and only use
     the second one (where we're looking at THIS_DIR).  The exception
     is absent dirs, these only come through once, so continue. */</comment>
  <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call> != 0)
      &amp;&amp; !<name><name>entry</name>-&gt;<name>absent</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Ignore the entry if it does not exist at the time of interest. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>deleted</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>absent</name></name> || <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>propval</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>switched</name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_prop_get</name><argument_list>(<argument><expr>&amp;<name>propval</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                              <argument><expr><name><name>wb</name>-&gt;<name>base_access</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* We always include the merge target regardless of its mergeinfo.
         So we don't need to check that PATH's mergeinfo corresponds to
         the merge source. */</comment>
      <if>if <condition>(<expr><name>propval</name> &amp;&amp; !<name>path_is_merge_target</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>merge_src_child_path</name> <init>=
            <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name><name>wb</name>-&gt;<name>merge_src_canon_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <comment type="block">/* When the merge target is '' or '.' WB-&gt;MERGE_TARGET_PATH is
             an empty string and PATH will always be relative.  In this case
             we can safely combine WB-&gt;MERGE_SRC_CANON_PATH and PATH with
             svn_path_add_compent() which will supply the missing '/' separator.

             Otherwise WB-&gt;MERGE_TARGET_PATH is relative or absolute and
             we remove the common root component between WB-&gt;MERGE_TARGET_PATH
             and PATH from PATH before combining it with
             WB-&gt;MERGE_SRC_CANON_PATH.  The +1 is required because if we are
             here that means WB-&gt;MERGE_TARGET_PATH is a proper ancestor of
             PATH and we must skip the path separator -- svn_path_add_compent()
             will add missing separators, but won't remove existing ones -- to
             avoid a merge_src_child_path with "//" in it. */</comment>
          <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>wb</name>-&gt;<name>merge_target_path</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_path_add_component</name><argument_list>(<argument><expr><name>merge_src_child_path</name></expr></argument>,
                                   <argument><expr><name>path</name> + <call><name>strlen</name><argument_list>(<argument><expr><name><name>wb</name>-&gt;<name>merge_target_path</name></name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_path_add_component</name><argument_list>(<argument><expr><name>merge_src_child_path</name></expr></argument>,
                                   <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergehash</name></expr></argument>, <argument><expr><name><name>propval</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>propval</name>-&gt;<name>len</name></name> == 0 <comment type="block">/* empty mergeinfo */</comment>
              || <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mergehash</name></expr></argument>, <argument><expr><name><name>merge_src_child_path</name>-&gt;<name>data</name></name></expr></argument>,
                              <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <comment type="block">/* The easy way: PATH already has mergeinfo
                 from this source or has empty mergeinfo... */</comment>
              <expr_stmt><expr><name>has_mergeinfo_from_merge_src</name> = <name>TRUE</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* ...the slightly harder way: See if PATH exists in the
                 merge source at the revisions being merged. If it doesn't
                 exist there is no way this subtree can be affected by the
                 merge so we can safely leave it, and its mergeinfo, alone. */</comment>
              <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>original_ra_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo_url</name> <init>=
                <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>wb</name>-&gt;<name>source_root_url</name></name></expr></argument>,
                              <comment type="block">/* Skip leading '/' or join won't work. */</comment>
                              <argument><expr>++(<name><name>merge_src_child_path</name>-&gt;<name>data</name></name>)</expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_opt_revision_t</name> *</type><name>start_revision</name></decl>, *<decl><type ref="prev"/><name>end_revision</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_url</name></decl>, *<decl><type ref="prev"/><name>end_url</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>peg_rev</name></decl>, <decl><type ref="prev"/><name>rev1_opt</name></decl>, <decl><type ref="prev"/><name>rev2_opt</name></decl>;</decl_stmt>
                      
              <expr_stmt><expr><name><name>peg_rev</name>.<name>value</name>.<name>number</name></name> = <name><name>wb</name>-&gt;<name>revision1</name></name> &lt; <name><name>wb</name>-&gt;<name>revision2</name></name>
                ? <name><name>wb</name>-&gt;<name>revision2</name></name> : <name><name>wb</name>-&gt;<name>revision1</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>peg_rev</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
              
              <expr_stmt><expr><name><name>rev1_opt</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>rev1_opt</name>.<name>value</name>.<name>number</name></name> = <name><name>wb</name>-&gt;<name>revision1</name></name></expr>;</expr_stmt>
                  
              <expr_stmt><expr><name><name>rev2_opt</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>rev2_opt</name>.<name>value</name>.<name>number</name></name> = <name><name>wb</name>-&gt;<name>revision2</name></name></expr>;</expr_stmt>
              
              <comment type="block">/* Instead of passing NULL to svn_client__repos_locations() and
                 causing another session to open, reparent WB-&gt;RA_SESSION
                 and use that. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__ensure_ra_session_url</name><argument_list>(<argument><expr>&amp;<name>original_ra_url</name></expr></argument>,
                                                        <argument><expr><name><name>wb</name>-&gt;<name>ra_session</name></name></expr></argument>,
                                                        <argument><expr><name>mergeinfo_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* Does PATH exist in the merge source? */</comment>
              <expr_stmt><expr><name>err</name> = <call><name>svn_client__repos_locations</name><argument_list>(<argument><expr>&amp;<name>start_url</name></expr></argument>, <argument><expr>&amp;<name>start_revision</name></expr></argument>,
                                                <argument><expr>&amp;<name>end_url</name></expr></argument>, <argument><expr>&amp;<name>end_revision</name></expr></argument>,
                                                <argument><expr><name><name>wb</name>-&gt;<name>ra_session</name></name></expr></argument>, <argument><expr><name>mergeinfo_url</name></expr></argument>,
                                                <argument><expr>&amp;<name>peg_rev</name></expr></argument>, <argument><expr>&amp;<name>rev1_opt</name></expr></argument>, <argument><expr>&amp;<name>rev2_opt</name></expr></argument>,
                                                <argument><expr><name><name>wb</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* We might see any of these errors depending on the RA
                     access method, but they all mean that PATH doesn't exist
                     in the merge source.
                     
                     ### TODO: Make svn_client__repos_locations() more
                     ###       consistent in the error it returns(?)
                     */</comment>
                  <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>
                      || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_RA_DAV_PATH_NOT_FOUND</name>
                      || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CLIENT_UNRELATED_RESOURCES</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                  <else>else
                    <return>return <expr><name>err</name></expr>;</return></else></if>
                 }</block></then>
              <else>else <comment type="block">/* PATH does exist in the merge source*/</comment>
                <block>{
                  <expr_stmt><expr><name>has_mergeinfo_from_merge_src</name> = <name>TRUE</name></expr>;</expr_stmt>
                }</block></else></if>

              <comment type="block">/* Reparent the session to its original URL if necessary. */</comment>
              <if>if <condition>(<expr><name>original_ra_url</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name><name>wb</name>-&gt;<name>ra_session</name></name></expr></argument>, 
                                          <argument><expr><name>original_ra_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if> <comment type="block">/* the slightly harder way */</comment>
        }</block></then></if>
      <comment type="block">/* Regardless of whether PATH has explicit mergeinfo or not, we must
         determine if PATH is switched.  This is so get_mergeinfo_paths()
         can later tweak PATH's parent to reflect a missing child (implying it
         needs non-inheritable mergeinfo ranges) and PATH's siblings so they
         get their own complete set of mergeinfo. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__path_switched</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>switched</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Store PATHs with explict mergeinfo, which are switched, are missing
     children due to a sparse checkout, are scheduled for deletion are absent
     from the WC, and/or are first level sub directories relative to merge
     target if depth is immediates. */</comment>
  <if>if <condition>(<expr><name>path_is_merge_target</name>
      || <name>has_mergeinfo_from_merge_src</name>
      || <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name>
      || <name>switched</name>
      || <name><name>entry</name>-&gt;<name>depth</name></name> == <name>svn_depth_empty</name>
      || <name><name>entry</name>-&gt;<name>depth</name></name> == <name>svn_depth_files</name>
      || <name><name>entry</name>-&gt;<name>absent</name></name>
      || ((<name><name>wb</name>-&gt;<name>depth</name></name> == <name>svn_depth_immediates</name>) &amp;&amp;
          (<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>) &amp;&amp;
          (<call><name>strcmp</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> != 0) &amp;&amp;
          (<call><name>strcmp</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name><name>wb</name>-&gt;<name>merge_target_path</name></name></expr></argument>)</argument_list></call> == 0))</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
        <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>wb</name>-&gt;<name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>child</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>child</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>wb</name>-&gt;<name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>child</name>-&gt;<name>missing_child</name></name> = (<name><name>entry</name>-&gt;<name>depth</name></name> == <name>svn_depth_empty</name>
                              || <name><name>entry</name>-&gt;<name>depth</name></name> == <name>svn_depth_files</name>
                              || ((<name><name>wb</name>-&gt;<name>depth</name></name> == <name>svn_depth_immediates</name>) &amp;&amp;
                                  (<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>) &amp;&amp;
                                  (<call><name>strcmp</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>,
                                          <argument><expr><name><name>wb</name>-&gt;<name>merge_target_path</name></name></expr></argument>)</argument_list></call> == 0)))
                              ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>child</name>-&gt;<name>switched</name></name> = <name>switched</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>child</name>-&gt;<name>absent</name></name> = <name><name>entry</name>-&gt;<name>absent</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>child</name>-&gt;<name>scheduled_for_deletion</name></name> =
        <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name> ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>propval</name>
          &amp;&amp; <call><name>strstr</name><argument_list>(<argument><expr><name><name>propval</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>SVN_MERGEINFO_NONINHERITABLE_STR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name><name>child</name>-&gt;<name>has_noninheritable</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

      <comment type="block">/* A little trickery: If PATH doesn't have any mergeinfo or has
         only inheritable mergeinfo, we still describe it as having
         non-inheritable mergeinfo if it is missing a child.  Why?  Because
         the mergeinfo we'll add to PATH as a result of the merge will need
         to be non-inheritable (since PATH is missing children) and doing
         this now allows get_mergeinfo_paths() to properly account for PATH's
         other children. */</comment>
      <if>if <condition>(<expr>!<name><name>child</name>-&gt;<name>has_noninheritable</name></name>
          &amp;&amp; (<name><name>entry</name>-&gt;<name>depth</name></name> == <name>svn_depth_empty</name>
              || <name><name>entry</name>-&gt;<name>depth</name></name> == <name>svn_depth_files</name>)</expr>)</condition><then>
      <expr_stmt><expr><name><name>child</name>-&gt;<name>has_noninheritable</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>wb</name>-&gt;<name>children_with_mergeinfo</name></name></expr></argument>,
                     <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call> = <name>child</name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* svn_wc_entry_callbacks2_t handle_error() callback for
   get_mergeinfo_paths().

   Squelch ERR by returning SVN_NO_ERROR if ERR is caused by a missing
   path (i.e. SVN_ERR_WC_PATH_NOT_FOUND) or an unversioned path
   (i.e. SVN_ERR_WC_NOT_LOCKED). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_mergeinfo_error_handler</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                            <param><decl><type><name>svn_error_t</name> *</type><name>err</name></decl></param>,
                            <param><decl><type><name>void</name> *</type><name>walk_baton</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>root_err</name> <init>= <expr><call><name>svn_error_root_cause</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>root_err</name> == <name>SVN_NO_ERROR</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <switch>switch <condition>(<expr><name><name>root_err</name>-&gt;<name>apr_err</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>SVN_ERR_WC_PATH_NOT_FOUND</name></expr>:
    </case><case>case <expr><name>SVN_ERR_WC_NOT_LOCKED</name></expr>:
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>

    </case><default>default:
      <return>return <expr><name>err</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<comment type="block">/* Helper for get_mergeinfo_paths()

   CHILDREN_WITH_MERGEINFO is a depth first sorted array filled with
   svn_client__merge_path_t *.  Starting at the element in
   CHILDREN_WITH_MERGEINFO located at START_INDEX look for that
   element's child/parent (as indicated by LOOKING_FOR_CHILD) named
   PATH. If the child/parent is found, set *CHILD_OR_PARENT to that
   element and return the index at which if was found.  If the
   child/parent is not found set *CHILD_OR_PARENT to NULL and return
   the index at which it should be inserted. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_child_or_parent</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                     <param><decl><type><name>svn_client__merge_path_t</name> **</type><name>child_or_parent</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>looking_for_child</name></decl></param>,
                     <param><decl><type><name>int</name></type> <name>start_index</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>child_or_parent</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* If possible, search forwards in the depth first sorted array
     to find a child PATH or backwards to find a parent PATH. */</comment>
  <if>if <condition>(<expr><name>start_index</name> &gt;= 0 &amp;&amp; <name>start_index</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>j</name> = <name>looking_for_child</name> ? <name>start_index</name> + 1 : <name>start_index</name></expr>;</init>
           <condition><expr><name>looking_for_child</name> ? <name>j</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name> : <name>j</name> &gt;= 0</expr>;</condition>
           <incr><expr><name>j</name> = <name>looking_for_child</name> ? <name>j</name> + 1 : <name>j</name> - 1</expr></incr>)
        <block>{
          <comment type="block">/* If this potential child is neither the child we are looking for
             or another one of PARENT's children then CHILD_PATH doesn't
             exist in CHILDREN_WITH_MERGEINFO. */</comment>
          <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>potential_child_or_parent</name> <init>=
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                          <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>cmp</name> <init>= <expr><call><name>svn_path_compare_paths</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                                           <argument><expr><name><name>potential_child_or_parent</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>cmp</name> == 0</expr>)</condition><then>
            <block>{
              <comment type="block">/* Found child or parent. */</comment>
              <expr_stmt><expr>*<name>child_or_parent</name> = <name>potential_child_or_parent</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then>
          <else>else <if>if <condition>(<expr>(<name>looking_for_child</name> &amp;&amp; <name>cmp</name> &lt; 0)
                   || (!<name>looking_for_child</name> &amp;&amp; <name>cmp</name> &gt; 0)</expr>)</condition><then>
            <block>{
              <comment type="block">/* PATH doesn't exist, but found where it should be inserted. */</comment>
              <if>if <condition>(<expr>!<name>looking_for_child</name></expr>)</condition><then>
                <expr_stmt><expr><name>j</name>++</expr>;</expr_stmt></then></if>
              <break>break;</break>
            }</block></then>
          <else>else <if>if <condition>(<expr>!<name>looking_for_child</name> &amp;&amp; <name>j</name> == 0</expr>)</condition><then>
            <block>{
              <comment type="block">/* Looking for a parent but are at start of the array so we know
                 where to insert the parent. */</comment>
              <break>break;</break>
            }</block></then></if></else></if></else></if>
          <comment type="block">/* else we are looking for a child but found one of its
             siblings...keep looking. */</comment>
        }</block></for>
    }</block></then></if>
  <return>return <expr><name>j</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for get_mergeinfo_paths()

   CHILDREN_WITH_MERGEINFO is a depth first sorted array filled with
   svn_client__merge_path_t *.  Insert INSERT_ELEMENT into the
   CHILDREN_WITH_MERGEINFO array at index INSERT_INDEX. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>insert_child_to_merge</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                      <param><decl><type><name>svn_client__merge_path_t</name> *</type><name>insert_element</name></decl></param>,
                      <param><decl><type><name>int</name></type> <name>insert_index</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>insert_index</name> == <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                     <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call> = <name>insert_element</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Copy the last element of CHILDREN_WITH_MERGEINFO and add it to the
         end of the array. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>curr</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                      <argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name> - 1</expr></argument>,
                      <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>curr_copy</name> <init>=
        <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>curr_copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr>*<name>curr_copy</name> = *<name>curr</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                     <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call> = <name>curr_copy</name></expr>;</expr_stmt>

      <comment type="block">/* Move all elements from INSERT_INDEX to the end of the array forward
         one spot then insert the new element. */</comment>
      <for>for (<init><expr><name>j</name> = <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name> - 2</expr>;</init> <condition><expr><name>j</name> &gt;= <name>insert_index</name></expr>;</condition> <incr><expr><name>j</name>--</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>prev</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>curr</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                               <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>j</name> == <name>insert_index</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>curr</name> = *<name>insert_element</name></expr>;</expr_stmt></then>
          <else>else
            <block>{
              <expr_stmt><expr><name>prev</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>j</name> - 1</expr></argument>,
                                   <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr>*<name>curr</name> = *<name>prev</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
    }</block></else></if>
}</block></function>

<comment type="block">/* Helper for get_mergeinfo_paths()'s qsort() call. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_merge_path_t_as_paths</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child1</name> <init>= <expr>*((<name>svn_client__merge_path_t</name> * const *) <name>a</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child2</name> <init>= <expr>*((<name>svn_client__merge_path_t</name> * const *) <name>b</name>)</expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_path_compare_paths</name><argument_list>(<argument><expr><name><name>child1</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>child2</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Helper for get_mergeinfo_paths().  If CHILD-&gt;PATH is switched or
   absent then make sure its parent is marked as missing a child.
   Start looking up for parent from *CURR_INDEX in
   CHILDREN_WITH_MERGEINFO.  Create the parent and insert it into
   CHILDREN_WITH_MERGEINFO if necessary (and increment *CURR_INDEX
   so that caller don't process the inserted element).  Also ensure
   that CHILD-&gt;PATH's siblings which are not already present in
   CHILDREN_WITH_MERGEINFO are also added to the array. Use POOL for
   all temporary allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>insert_parent_and_sibs_of_sw_absent_del_entry</name><parameter_list>(
                                   <param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                                   <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_cmd_baton</name></decl></param>,
                                   <param><decl><type><name>int</name> *</type><name>curr_index</name></decl></param>,
                                   <param><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name></decl></param>,
                                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>parent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name> <init>= <expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>insert_index</name></decl>, <decl><type ref="prev"/><name>parent_index</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!(<name><name>child</name>-&gt;<name>absent</name></name>
          || (<name><name>child</name>-&gt;<name>switched</name></name>
              &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call> != 0))</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>parent_index</name> = <call><name>find_child_or_parent</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>,
                                      <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>*<name>curr_index</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>parent</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>missing_child</name></name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Create a new element to insert into CHILDREN_WITH_MERGEINFO. */</comment>
      <expr_stmt><expr><name>parent</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>parent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>missing_child</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <comment type="block">/* Insert PARENT into CHILDREN_WITH_MERGEINFO. */</comment>
      <expr_stmt><expr><call><name>insert_child_to_merge</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>parent_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Increment for loop index so we don't process the inserted element. */</comment>
      <expr_stmt><expr>(*<name>curr_index</name>)++</expr>;</expr_stmt>
    }</block></else></if> <comment type="block">/*(parent == NULL) */</comment>

  <comment type="block">/* Add all of PARENT's non-missing children that are not already present.*/</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_try3</name><argument_list>(<argument><expr>&amp;<name>parent_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>parent</name>-&gt;<name>path</name></name></expr></argument>,
                                <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                <argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>sibling_of_missing</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_path</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* Does this child already exist in CHILDREN_WITH_MERGEINFO? */</comment>
      <expr_stmt><expr><name>child_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>insert_index</name> = <call><name>find_child_or_parent</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                          <argument><expr>&amp;<name>sibling_of_missing</name></expr></argument>, <argument><expr><name>child_path</name></expr></argument>,
                                          <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>parent_index</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Create the missing child and insert it into CHILDREN_WITH_MERGEINFO.*/</comment>
      <if>if <condition>(<expr>!<name>sibling_of_missing</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>sibling_of_missing</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>,
                                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>sibling_of_missing</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>sibling_of_missing</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>,
                                                 <argument><expr><name>child_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>insert_child_to_merge</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>sibling_of_missing</name></expr></argument>,
                                <argument><expr><name>insert_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for do_directory_merge()

   Perform a depth first walk of the working copy tree rooted at
   MERGE_CMD_BATON-&gt;TARGET (with the corresponding ENTRY).  Create an
   svn_client__merge_path_t * for any path which meets one or more of the
   following criteria:

     1) Path has working svn:mergeinfo from corresponding merge source or
        has empty mergeinfo.
     2) Path is switched.
     3) Path has no mergeinfo of it's own but it's parent has mergeinfo with
        non-inheritable ranges (in this case the function will actually set
        override mergeinfo on the path if this isn't a dry-run and the merge
        is between differences in the same repository).
     4) Path has an immediate child (or children) missing from the WC because
        the child is switched or absent from the WC, or due to a sparse
        checkout.
     5) Path has a sibling (or siblings) missing from the WC because the
        sibling is switched, absent, schduled for deletion, or missing due to
        a sparse checkout.
     6) Path is absent from disk due to an authz restriction.
     7) Path is equal to MERGE_CMD_BATON-&gt;TARGET.

   Store the svn_client__merge_path_t *'s in *CHILDREN_WITH_MERGEINFO in
   depth-first order based on the svn_client__merge_path_t *s path member as
   sorted by svn_path_compare_paths().

   Note: Since the walk is rooted at MERGE_CMD_BATON-&gt;TARGET, the latter is
   guaranteed to be in *CHILDREN_WITH_MERGEINFO and due to the depth-first
   ordering it is guaranteed to be the first element in
   *CHILDREN_WITH_MERGEINFO.

   Cascade MERGE_SRC_CANON_PATH. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_mergeinfo_paths</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl></param>,
                    <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_cmd_baton</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>merge_src_canon_path</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_root_url</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url2</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl></param>,
                    <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                    <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_wc_entry_callbacks2_t</name></type> <name>walk_callbacks</name> <init>=
    <expr><block>{ <expr><name>get_mergeinfo_walk_cb</name></expr>, <expr><name>get_mergeinfo_error_handler</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>get_mergeinfo_walk_baton</name></type> <name>wb</name> <init>=
    <expr><block>{ <expr><name>adm_access</name></expr>, <expr><name>children_with_mergeinfo</name></expr>,
      <expr><name>merge_src_canon_path</name></expr>, <expr><name><name>merge_cmd_baton</name>-&gt;<name>target</name></name></expr>, <expr><name>source_root_url</name></expr>,
      <expr><name>url1</name></expr>, <expr><name>url2</name></expr>, <expr><name>revision1</name></expr>, <expr><name>revision2</name></expr>,
      <expr><name>depth</name></expr>, <expr><name>ra_session</name></expr>, <expr><name>ctx</name></expr> }</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Cover cases 1), 2), 6), and 7) by walking the WC to get all paths which
     have mergeinfo and/or are switched or are absent from disk or is the
     target of the merge. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>walk_callbacks</name>.<name>found_entry</name></name><argument_list>(<argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr>&amp;<name>wb</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_walk_entries3</name><argument_list>(<argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                 <argument><expr>&amp;<name>walk_callbacks</name></expr></argument>, <argument><expr>&amp;<name>wb</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                 <argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                 <argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* CHILDREN_WITH_MERGEINFO must be in depth first order, but
     svn_wc_walk_entries3() relies on svn_wc_entries_read() which means the
     paths at a given directory level are not in any particular order.  Also,
     we may need to add elements to the array to cover case 3) through 5) from
     the docstring.  If so, it is more efficient to find and insert these
     paths if the sibling paths are in a guaranteed depth-first order.  For
     the first reason we sort the array, for the second reason we do it now
     rather than at the end of this function. */</comment>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>elts</name></name></expr></argument>,
        <argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr></argument>,
        <argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>elt_size</name></name></expr></argument>,
        <argument><expr><name>compare_merge_path_t_as_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>insert_index</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Case 3) Where merging to a path with a switched child the path gets
         non-inheritable mergeinfo for the merge range performed and the child
         gets it's own set of mergeinfo.  If the switched child later
         "returns", e.g. a switched path is unswitched, the child may not have
         any explicit mergeinfo.  If the initial merge is repeated we don't
         want to repeat the merge for the path, but we do want to repeat it
         for the previously switched child.  To ensure this we check if all
         of CHILD's non-missing children have explicit mergeinfo (they should
         already be present in CHILDREN_WITH_MERGEINFO if they do).  If not,
         add the children without mergeinfo to CHILDREN_WITH_MERGEINFO so
         do_directory_merge() will merge them independently.

         But that's not enough!  Since do_directory_merge() performs
         the merges on the paths in CHILDREN_WITH_MERGEINFO in a depth first
         manner it will merge the previously switched path's parent first.  As
         part of this merge it will update the parent's previously
         non-inheritable mergeinfo and make it inheritable (since it notices
         the path has no missing children), then when
         do_directory_merge() finally merges the previously missing
         child it needs to get mergeinfo from the child's nearest ancestor,
         but since do_directory_merge() already tweaked that
         mergeinfo, removing the non-inheritable flag, it appears that the
         child already has been merged to.  To prevent this we set override
         mergeinfo on the child now, before any merging is done, so it has
         explicit mergeinfo that reflects only CHILD's inheritable
         mergeinfo. */</comment>

      <if>if <condition>(<expr><name><name>child</name>-&gt;<name>has_noninheritable</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>child_access</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_try3</name><argument_list>(<argument><expr>&amp;<name>child_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                        <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>-1</expr></argument>,
                                        <argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                        <argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                                        <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>child_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                      <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
               <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child_of_noninheritable</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_path</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <continue>continue;</continue></then></if>

              <comment type="block">/* Does this child already exist in CHILDREN_WITH_MERGEINFO?  If
                 not, create it and insert it into CHILDREN_WITH_MERGEINFO and
                 set override mergeinfo on it. */</comment>
              <expr_stmt><expr><name>child_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>insert_index</name> = <call><name>find_child_or_parent</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                                  <argument><expr>&amp;<name>child_of_noninheritable</name></expr></argument>,
                                                  <argument><expr><name>child_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                                  <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>!<name>child_of_noninheritable</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>child_of_noninheritable</name> =
                    <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>child_of_noninheritable</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>child_of_noninheritable</name>-&gt;<name>path</name></name> =
                    <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>children_with_mergeinfo</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>child_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>insert_child_to_merge</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                        <argument><expr><name>child_of_noninheritable</name></expr></argument>,
                                        <argument><expr><name>insert_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr>!<name><name>merge_cmd_baton</name>-&gt;<name>dry_run</name></name>
                      &amp;&amp; <name><name>merge_cmd_baton</name>-&gt;<name>same_repos</name></name></expr>)</condition><then>
                    <block>{
                      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>inherited</name></decl>;</decl_stmt>
                      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>mergeinfo</name></decl>;</decl_stmt>
                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_wc_mergeinfo</name>
                              <argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>inherited</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                               <argument><expr><name>svn_mergeinfo_nearest_ancestor</name></expr></argument>,
                               <argument><expr><name>entry</name></expr></argument>, <argument><expr><name><name>child_of_noninheritable</name>-&gt;<name>path</name></name></expr></argument>,
                               <argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                               <argument><expr><name><name>merge_cmd_baton</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__record_wc_mergeinfo</name><argument_list>(
                        <argument><expr><name><name>child_of_noninheritable</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>mergeinfo</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                        <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
      <comment type="block">/* Case 4 and 5 are handled by the following function. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>insert_parent_and_sibs_of_sw_absent_del_entry</name><argument_list>(
        <argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>merge_cmd_baton</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr><name>child</name></expr></argument>,
        <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for> <comment type="block">/* i &lt; children_with_mergeinfo-&gt;nelts */</comment>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Implements the svn_log_entry_receiver_t interface. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>log_changed_revs</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                  <param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>revs</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>revision</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>revs</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>revision</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>revision</name> = <name><name>log_entry</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>revs</name></expr></argument>, <argument><expr><name>svn_revnum_t</name> *</expr></argument>)</argument_list></call> = <name>revision</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *OPERATIVE_RANGES_P to an array of svn_merge_range_t * merge
   range objects copied wholesale from RANGES which have the property
   that in some revision within that range the object identified by
   RA_SESSION was modified (if by "modified" we mean "'svn log' would
   return that revision).  *OPERATIVE_RANGES_P is allocated from the
   same pool as RANGES, and the ranges within it are shared with
   RANGES, too.  Use POOL for temporary allocations.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_noop_merge_ranges</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>operative_ranges_p</name></decl></param>,
                         <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                         <param><decl><type><name>apr_array_header_t</name> *</type><name>ranges</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>oldest_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>oldest_changed_rev</name></decl>, <decl><type ref="prev"/><name>youngest_changed_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>changed_revs</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>ranges</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>operative_ranges</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>ranges</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ranges</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><name><name>ranges</name>-&gt;<name>elt_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>log_targets</name> <init>= 
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>log_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = ""</expr>;</expr_stmt>

  <comment type="block">/* Find the revision extremes of the RANGES we have. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ranges</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>r</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>max_rev</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>min_rev</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>(! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>youngest_rev</name></expr></argument>)</argument_list></call>) || (<name>max_rev</name> &gt; <name>youngest_rev</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>youngest_rev</name> = <name>max_rev</name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr>(! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>oldest_rev</name></expr></argument>)</argument_list></call>) || (<name>min_rev</name> &lt; <name>oldest_rev</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>oldest_rev</name> = <name>min_rev</name></expr>;</expr_stmt></then></if>
    }</block></for>

  <comment type="block">/* Get logs across those ranges, recording which revisions hold
     changes to our object's history. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_log2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>log_targets</name></expr></argument>, <argument><expr><name>youngest_rev</name></expr></argument>, 
                          <argument><expr><name>oldest_rev</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, 
                          <argument><expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>log_changed_revs</name></expr></argument>, <argument><expr><name>changed_revs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Our list of changed revisions should be in youngest-to-oldest order. */</comment>
  <expr_stmt><expr><name>youngest_changed_rev</name> = *(<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>changed_revs</name></expr></argument>, 
                                         <argument><expr>0</expr></argument>, <argument><expr><name>svn_revnum_t</name> *</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>oldest_changed_rev</name> = *(<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>changed_revs</name></expr></argument>, 
                                       <argument><expr><name><name>changed_revs</name>-&gt;<name>nelts</name></name> - 1</expr></argument>, 
                                       <argument><expr><name>svn_revnum_t</name> *</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

  <comment type="block">/* Now, copy from RANGES to *OPERATIVE_RANGES, filtering out ranges
     that aren't operative (by virtue of not having any revisions
     represented in the CHANGED_REVS array). */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ranges</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>range_min</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>range_max</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

      <comment type="block">/* If the merge range is entirely outside the range of changed
         revisions, we've no use for it. */</comment>
      <if>if <condition>(<expr>(<name>range_min</name> &gt; <name>youngest_changed_rev</name>) 
          || (<name>range_max</name> &lt; <name>oldest_changed_rev</name>)</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* Walk through the changed_revs to see if any of them fall
         inside our current range. */</comment>
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>changed_revs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>changed_rev</name> <init>= 
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>changed_revs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>svn_revnum_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>(*<name>changed_rev</name> &gt;= <name>range_min</name>) &amp;&amp; (*<name>changed_rev</name> &lt;= <name>range_max</name>)</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>operative_ranges</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
        }</block></for>
    }</block></for>
  <expr_stmt><expr>*<name>operative_ranges_p</name> = <name>operative_ranges</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
  

<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Merge Source Normalization ***/</comment>

<typedef>typedef <type><struct>struct <name>merge_source_t</name>
<block>{
  <comment type="block">/* "left" side URL and revision (inclusive iff youngest) */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev1</name></decl>;</decl_stmt>

  <comment type="block">/* "right" side URL and revision (inclusive iff youngest) */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev2</name></decl>;</decl_stmt>

}</block></struct></type> <name>merge_source_t</name>;</typedef>

<comment type="block">/* qsort-compatible sort routine, rating merge_source_t * objects to
   be in descending (youngest-to-oldest) order based on their -&gt;rev1
   component. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_merge_source_ts</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>a_rev</name> <init>= <expr>((const <name>merge_source_t</name> *)<name>a</name>)-&gt;<name>rev1</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>b_rev</name> <init>= <expr>((const <name>merge_source_t</name> *)<name>b</name>)-&gt;<name>rev1</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>a_rev</name> == <name>b_rev</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>
  <return>return <expr><name>a_rev</name> &lt; <name>b_rev</name> ? 1 : -1</expr>;</return>
}</block></function>

<comment type="block">/* Set *MERGE_SOURCE_TS_P to a list of merge sources generated by
   slicing history location SEGMENTS with a given requested merge
   RANGE.  Use SOURCE_ROOT_URL for full source URL calculation.

   Order the merge sources in *MERGE_SOURCE_TS_P from oldest to
   youngest. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>combine_range_with_segments</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>merge_source_ts_p</name></decl></param>,
                            <param><decl><type><name>svn_merge_range_t</name> *</type><name>range</name></decl></param>,
                            <param><decl><type><name>apr_array_header_t</name> *</type><name>segments</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_root_url</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>merge_source_ts</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>minrev</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>maxrev</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>subtractive</name> <init>= <expr>(<name><name>range</name>-&gt;<name>start</name></name> &gt; <name><name>range</name>-&gt;<name>end</name></name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>segments</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>merge_source_t</name> *</type><name>merge_source</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev1</name></decl>;</decl_stmt>

      <comment type="block">/* If this segment doesn't overlap our range at all, or
         represents a gap, ignore it. */</comment>
      <if>if <condition>(<expr>(<name><name>segment</name>-&gt;<name>range_end</name></name> &lt; <name>minrev</name>)
          || (<name><name>segment</name>-&gt;<name>range_start</name></name> &gt; <name>maxrev</name>)
          || (! <name><name>segment</name>-&gt;<name>path</name></name>)</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* If our range spans a segment boundary, we have to point our
         merge_source_t's path1 to the path of the immediately older
         segment, else it points to the same location as its path2.  */</comment>
      <expr_stmt><expr><name>rev1</name> = <call><name>MAX</name><argument_list>(<argument><expr><name><name>segment</name>-&gt;<name>range_start</name></name></expr></argument>, <argument><expr><name>minrev</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
      <if>if <condition>(<expr><name>minrev</name> &lt;= <name><name>segment</name>-&gt;<name>range_start</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>path1</name> = (<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>i</name> - 1</expr></argument>,
                                     <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call>)-&gt;<name>path</name></expr>;</expr_stmt>
            }</block></then></if>
          <comment type="block">/* If we've backed PATH1 up into a segment gap, let's back
             it up further still to the segment before the gap.  We'll
             have to adjust rev1, too. */</comment>
          <if>if <condition>(<expr>(! <name>path1</name>) &amp;&amp; (<name>i</name> &gt; 1)</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>path1</name> = (<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>i</name> - 2</expr></argument>,
                                     <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call>)-&gt;<name>path</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>rev1</name> = (<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>i</name> - 2</expr></argument>,
                                    <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call>)-&gt;<name>range_end</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>path1</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>segment</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* If we don't have two valid paths, we won't know what to do
         when merging.  This could happen if someone requested a merge
         where the source didn't exist in a particular revision or
         something.  The merge code would probably bomb out anyway, so
         we'll just *not* create a merge source in this case. */</comment>
      <if>if <condition>(<expr>! (<name>path1</name> &amp;&amp; <name><name>segment</name>-&gt;<name>path</name></name>)</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* Build our merge source structure. */</comment>
      <expr_stmt><expr><name>merge_source</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>merge_source</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>url1</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>source_root_url</name></expr></argument>, 
                                         <argument><expr><call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, 
                                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>url2</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>source_root_url</name></expr></argument>, 
                                         <argument><expr><call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name><name>segment</name>-&gt;<name>path</name></name></expr></argument>, 
                                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>rev1</name></name> = <name>rev1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>rev2</name></name> = <call><name>MIN</name><argument_list>(<argument><expr><name><name>segment</name>-&gt;<name>range_end</name></name></expr></argument>, <argument><expr><name>maxrev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this is subtractive, reverse the whole calculation. */</comment>
      <if>if <condition>(<expr><name>subtractive</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>tmprev</name> <init>= <expr><name><name>merge_source</name>-&gt;<name>rev1</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmpurl</name> <init>= <expr><name><name>merge_source</name>-&gt;<name>url1</name></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>rev1</name></name> = <name><name>merge_source</name>-&gt;<name>rev2</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>url1</name></name> = <name><name>merge_source</name>-&gt;<name>url2</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>rev2</name></name> = <name>tmprev</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>url2</name></name> = <name>tmpurl</name></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>merge_source_ts</name></expr></argument>, <argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></call> = <name>merge_source</name></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* If this was a subtractive merge, and we created more than one
     merge source, we need to reverse the sort ordering of our sources. */</comment>
  <if>if <condition>(<expr><name>subtractive</name> &amp;&amp; (<name><name>merge_source_ts</name>-&gt;<name>nelts</name></name> &gt; 1)</expr>)</condition><then>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>merge_source_ts</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>merge_source_ts</name>-&gt;<name>nelts</name></name></expr></argument>,
          <argument><expr><name><name>merge_source_ts</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>compare_merge_source_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr>*<name>merge_source_ts_p</name> = <name>merge_source_ts</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Set *MERGE_SOURCES to an array of merge_source_t * objects, each
   holding the paths and revisions needed to fully describe a range of
   requested merges; order the objects from oldest to youngest.

   Determine the requested merges by examining SOURCE (and its
   associated URL, SOURCE_URL) and PEG_REVISION (which specifies the
   line of history from which merges will be pulled) and
   RANGES_TO_MERGE (a list of svn_opt_revision_range_t's which provide
   revision ranges).

   If PEG_REVISION is unspecified, treat that it as HEAD.

   SOURCE_ROOT_URL is the root URL of the source repository.

   Use RA_SESSION -- whose session URL matches SOURCE_URL -- to answer
   historical questions.

   CTX is a client context baton.

   Use POOL for all allocation.

   See `MERGEINFO MERGE SOURCE NORMALIZATION' for more on the
   background of this function.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>normalize_merge_sources</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>merge_sources_p</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_url</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_root_url</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>peg_revision</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>ranges_to_merge</name></decl></param>,
                        <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                        <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>peg_revnum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>oldest_requested</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_requested</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>trim_revision</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>youngest_opt_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>merge_range_ts</name></decl>, *<decl><type ref="prev"/><name>segments</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>youngest_opt_rev</name>.<name>kind</name></name> = <name>svn_opt_revision_head</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize our return variable. */</comment>
  <expr_stmt><expr>*<name>merge_sources_p</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Resolve our PEG_REVISION to a real number. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_revision_number</name><argument_list>(<argument><expr>&amp;<name>peg_revnum</name></expr></argument>, <argument><expr>&amp;<name>youngest_rev</name></expr></argument>,
                                          <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>,
                                          <argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>peg_revnum</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_BAD_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create a list to hold svn_merge_range_t's. */</comment>
  <expr_stmt><expr><name>merge_range_ts</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>ranges_to_merge</name>-&gt;<name>nelts</name></name></expr></argument>,
                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ranges_to_merge</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>range_start_rev</name></decl>, <decl><type ref="prev"/><name>range_end_rev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_opt_revision_t</name> *</type><name>range_start</name> <init>=
        <expr>&amp;((<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ranges_to_merge</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                         <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call>)-&gt;<name>start</name>)</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_opt_revision_t</name> *</type><name>range_end</name> <init>=
        <expr>&amp;((<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ranges_to_merge</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                         <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call>)-&gt;<name>end</name>)</expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Resolve revisions to real numbers, validating as we go. */</comment>
      <if>if <condition>(<expr>(<name><name>range_start</name>-&gt;<name>kind</name></name> == <name>svn_opt_revision_unspecified</name>)
          || (<name><name>range_end</name>-&gt;<name>kind</name></name> == <name>svn_opt_revision_unspecified</name>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_BAD_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Not all required revisions are specified"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_revision_number</name><argument_list>(<argument><expr>&amp;<name>range_start_rev</name></expr></argument>, <argument><expr>&amp;<name>youngest_rev</name></expr></argument>,
                                              <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>range_start</name></expr></argument>,
                                              <argument><expr><name>source</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_revision_number</name><argument_list>(<argument><expr>&amp;<name>range_end_rev</name></expr></argument>, <argument><expr>&amp;<name>youngest_rev</name></expr></argument>,
                                              <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>range_end</name></expr></argument>,
                                              <argument><expr><name>source</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this isn't a no-op range... */</comment>
      <if>if <condition>(<expr><name>range_start_rev</name> != <name>range_end_rev</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ...then create an svn_merge_range_t object for it. */</comment>
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name></name> = <name>range_start_rev</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name></name> = <name>range_end_rev</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>inheritable</name></name> = <name>TRUE</name></expr>;</expr_stmt>

          <comment type="block">/* Add our merge range to our list thereof. */</comment>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>merge_range_ts</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* No ranges to merge?  No problem. */</comment>
  <if>if <condition>(<expr><name><name>merge_range_ts</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Find the extremes of the revisions across our set of ranges. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>merge_range_ts</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>merge_range_ts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>minrev</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>maxrev</name> <init>= <expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Keep a running tally of the oldest and youngest requested
         revisions. */</comment>
      <if>if <condition>(<expr>(! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>oldest_requested</name></expr></argument>)</argument_list></call>)
          || (<name>minrev</name> &lt; <name>oldest_requested</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>oldest_requested</name> = <name>minrev</name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr>(! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>youngest_requested</name></expr></argument>)</argument_list></call>)
          || (<name>maxrev</name> &gt; <name>youngest_requested</name>)</expr>)</condition><then>
        <expr_stmt><expr><name>youngest_requested</name> = <name>maxrev</name></expr>;</expr_stmt></then></if>
    }</block></for>

  <comment type="block">/* ### FIXME:  Our underlying APIs can't yet handle the case where
     the peg revision isn't the youngest of the three revisions.  So
     we'll just verify that the source in the peg revision is related
     to the the source in the youngest requested revision (which is
     all the underlying APIs would do in this case right now anyway). */</comment>
  <if>if <condition>(<expr><name>peg_revnum</name> &lt; <name>youngest_requested</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_url</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>requested</name></decl>, <decl><type ref="prev"/><name>unspec</name></decl>, <decl><type ref="prev"/><name>pegrev</name></decl>, *<decl><type ref="prev"/><name>start_revision</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>unspec</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>requested</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>requested</name>.<name>value</name>.<name>number</name></name> = <name>youngest_requested</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pegrev</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>pegrev</name>.<name>value</name>.<name>number</name></name> = <name>peg_revnum</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__repos_locations</name><argument_list>(<argument><expr>&amp;<name>start_url</name></expr></argument>, <argument><expr>&amp;<name>start_revision</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>source_url</name></expr></argument>,
                                          <argument><expr>&amp;<name>pegrev</name></expr></argument>, <argument><expr>&amp;<name>requested</name></expr></argument>,
                                          <argument><expr>&amp;<name>unspec</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>peg_revnum</name> = <name>youngest_requested</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Fetch the locations for our merge range span. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__repos_location_segments</name><argument_list>(<argument><expr>&amp;<name>segments</name></expr></argument>,
                                              <argument><expr><name>ra_session</name></expr></argument>, <argument><expr>""</expr></argument>,
                                              <argument><expr><name>peg_revnum</name></expr></argument>,
                                              <argument><expr><name>youngest_requested</name></expr></argument>,
                                              <argument><expr><name>oldest_requested</name></expr></argument>,
                                              <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* See if we fetched enough history to do the job.  "Surely we did,"
     you say.  "After all, we covered the entire requested merge
     range."  Yes, that's true, but if our first segment doesn't
     extend back to the oldest request revision, we've got a special
     case to deal with.  Or if the first segment represents a gap,
     that's another special case.  */</comment>
  <expr_stmt><expr><name>trim_revision</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>segments</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name> <init>= 
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If the first segment doesn't start with the OLDEST_REQUESTED
         revision, we'll need to pass a trim revision to our range
         cruncher. */</comment>
      <if>if <condition>(<expr><name><name>segment</name>-&gt;<name>range_start</name></name> != <name>oldest_requested</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>trim_revision</name> = <name><name>segment</name>-&gt;<name>range_start</name></name></expr>;</expr_stmt>
        }</block></then>

      <comment type="block">/* Else, if the first segment has no path (and therefore is a
         gap), then we'll fetch the copy source revision from the
         second segment (provided there is one, of course) and use it
         to prepend an extra pathful segment to our list. 

         ### We could avoid this bit entirely if we'd passed
         ### SVN_INVALID_REVNUM instead of OLDEST_REQUESTED to
         ### svn_client__repos_location_segments(), but that would
         ### really penalize clients hitting pre-1.5 repositories with
         ### the typical small merge range request (because of the
         ### lack of a node-origins cache in the repository).  */</comment>
      <else>else <if>if <condition>(<expr>! <name><name>segment</name>-&gt;<name>path</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>segments</name>-&gt;<name>nelts</name></name> &gt; 1</expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_location_segment_t</name> *</type><name>segment2</name> <init>= 
                <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl>, *<decl><type ref="prev"/><name>segment_url</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>range_start_rev</name></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>range_start_rev</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>range_start_rev</name>.<name>value</name>.<name>number</name></name> = <name><name>segment2</name>-&gt;<name>range_start</name></name></expr>;</expr_stmt>

              <expr_stmt><expr><name>segment_url</name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name>source_root_url</name></expr></argument>,
                                                       <argument><expr><name><name>segment2</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_copy_source</name><argument_list>(<argument><expr><name>segment_url</name></expr></argument>, 
                                                  <argument><expr>&amp;<name>range_start_rev</name></expr></argument>,
                                                  <argument><expr>&amp;<name>copyfrom_path</name></expr></argument>, 
                                                  <argument><expr>&amp;<name>copyfrom_rev</name></expr></argument>,
                                                  <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="block">/* Got copyfrom data?  Fix up the first segment to cover
                 back to COPYFROM_REV + 1, and then prepend a new
                 segment covering just COPYFROM_REV. */</comment>
              <if>if <condition>(<expr><name>copyfrom_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>svn_location_segment_t</name> *</type><name>new_segment</name> <init>=
                    <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <comment type="block">/* Skip the leading '/'. */</comment>
                  <expr_stmt><expr><name><name>new_segment</name>-&gt;<name>path</name></name> = (*<name>copyfrom_path</name> == '/')
                    ? <name>copyfrom_path</name> + 1 : <name>copyfrom_path</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>new_segment</name>-&gt;<name>range_start</name></name> = <name>copyfrom_rev</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>new_segment</name>-&gt;<name>range_end</name></name> = <name>copyfrom_rev</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>segment</name>-&gt;<name>range_start</name></name> = <name>copyfrom_rev</name> + 1</expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>segments</name>-&gt;<name>elts</name></name> + <name><name>segments</name>-&gt;<name>elt_size</name></name></expr></argument>,
                          <argument><expr><name><name>segments</name>-&gt;<name>elts</name></name></expr></argument>, 
                          <argument><expr><name><name>segments</name>-&gt;<name>elt_size</name></name> * (<name><name>segments</name>-&gt;<name>nelts</name></name> - 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call> =
                    <name>new_segment</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if></else></if>
    }</block></then></if>

  <comment type="block">/* For each range in our requested range set, try to determine the
     path(s) associated with that range.  */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>merge_range_ts</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>merge_range_ts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>merge_sources</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>trim_revision</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* If the youngest of the range revisions predates the trim
             revision, discard the range. */</comment>
          <if>if <condition>(<expr><call><name>MAX</name><argument_list>(<argument><expr><name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call> &lt; <name>trim_revision</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Otherwise, if either of oldest of the range revisions predates
             the trim revision, update the range revision to be equal
             to the trim revision. */</comment>
          <if>if <condition>(<expr><name><name>range</name>-&gt;<name>start</name></name> &lt; <name>trim_revision</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name></name> = <name>trim_revision</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>range</name>-&gt;<name>end</name></name> &lt; <name>trim_revision</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name></name> = <name>trim_revision</name></expr>;</expr_stmt></then></if>
        }</block></then></if>

      <comment type="block">/* Copy the resulting merge sources into master list thereof. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>combine_range_with_segments</name><argument_list>(<argument><expr>&amp;<name>merge_sources</name></expr></argument>, <argument><expr><name>range</name></expr></argument>,
                                          <argument><expr><name>segments</name></expr></argument>, <argument><expr><name>source_root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>merge_sources</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>merge_sources_p</name></expr></argument>, <argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></call> =
            <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>merge_sources</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Merge Workhorse Functions ***/</comment>

<comment type="block">/* Helper for do_directory_merge() and do_file_merge() which filters out a
   path's own natural history from the mergeinfo describing a merge.

   Given the natural history IMPLICIT_MERGEINFO of some wc merge target path,
   the repository relative merge source path SOURCE_REL_PATH, and the
   requested merge range REQUESTED_RANGE from SOURCE_REL_PATH, remove any
   portion of REQUESTED_RANGE which is already described in
   IMPLICIT_MERGEINFO.  Store the result in *FILTERED_RANGELIST.
   
   This function only filters natural history for mergeinfo that will be
   *added* during a forward merge.  Removing natural history from explicit
   mergeinfo is harmless.  If REQUESTED_RANGE describes a reverse merge,
   then *FILTERED_RANGELIST is simply populated with one range described
   by REQUESTED_RANGE.

   *FILTERED_RANGELIST is allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>filter_natural_history_from_mergeinfo</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>filtered_rangelist</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_rel_path</name></decl></param>,
                                      <param><decl><type><name>svn_mergeinfo_t</name></type> <name>implicit_mergeinfo</name></decl></param>,
                                      <param><decl><type><name>svn_merge_range_t</name> *</type><name>requested_range</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Make the REQUESTED_RANGE into a rangelist. */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>requested_rangelist</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>requested_rangelist</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> =
    <call><name>svn_merge_range_dup</name><argument_list>(<argument><expr><name>requested_range</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>filtered_rangelist</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* For forward merges: If the IMPLICIT_MERGEINFO already describes ranges
     associated with SOURCE_REL_PATH then filter those ranges out. */</comment>
  <if>if <condition>(<expr><name>implicit_mergeinfo</name>
      &amp;&amp; (<name><name>requested_range</name>-&gt;<name>start</name></name> &lt; <name><name>requested_range</name>-&gt;<name>end</name></name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>implied_rangelist</name> <init>=
        <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>implicit_mergeinfo</name></expr></argument>, <argument><expr><name>source_rel_path</name></expr></argument>,
                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>implied_rangelist</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_remove</name><argument_list>(<argument><expr><name>filtered_rangelist</name></expr></argument>,
                                     <argument><expr><name>implied_rangelist</name></expr></argument>,
                                     <argument><expr><name>requested_rangelist</name></expr></argument>,
                                     <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* If no filtering was performed the filtered rangelist is
     simply the requested rangelist.*/</comment>
  <if>if <condition>(<expr>! (*<name>filtered_rangelist</name>)</expr>)</condition><then>
    <expr_stmt><expr>*<name>filtered_rangelist</name> = <name>requested_rangelist</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* The single-file, simplified version of do_directory_merge(), which see for
   parameter descriptions. 

   Additional parameters:

   If SOURCES_RELATED is set, the "left" and "right" sides of the
   merge source are historically related (ancestors, uncles, second
   cousins thrice removed, etc...).  (This is used to simulate the
   history checks that the repository logic does in the directory case.)  

   Note: MERGE_B-&gt;RA_SESSION1 must be associated with URL1 and
   MERGE_B-&gt;RA_SESSION2 with URL2.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_file_merge</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url2</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name></type> <name>sources_related</name></decl></param>,
              <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
              <param><decl><type><name>notification_receiver_baton_t</name> *</type><name>notify_b</name></decl></param>,
              <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props1</name></decl>, *<decl><type ref="prev"/><name>props2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmpfile1</name></decl>, *<decl><type ref="prev"/><name>tmpfile2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype1</name></decl>, *<decl><type ref="prev"/><name>mimetype2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>pval</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>propchanges</name></decl>, *<decl><type ref="prev"/><name>remaining_ranges</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_notify_state_t</name></type> <name>prop_state</name> <init>= <expr><name>svn_wc_notify_state_unknown</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_notify_state_t</name></type> <name>text_state</name> <init>= <expr><name>svn_wc_notify_state_unknown</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name>range</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>target_mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>conflicted_range</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>indirect</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_rollback</name> <init>= <expr>(<name>revision1</name> &gt; <name>revision2</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>primary_url</name> <init>= <expr><name>is_rollback</name> ? <name>url1</name> : <name>url2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>honor_mergeinfo</name></decl>, <decl><type ref="prev"/><name>record_mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>implicit_mergeinfo</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>mergeinfo_behavior</name><argument_list>(<argument><expr>&amp;<name>honor_mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>record_mergeinfo</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Note that this is a single-file merge. */</comment>
  <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>is_single_file_merge</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* Ensure that the adm_access we're playing with is our TARGET_WCPATH's
     parent, as required by some of underlying helper functions. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_try3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>range</name>.<name>start</name></name> = <name>revision1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>.<name>end</name></name> = <name>revision2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>.<name>inheritable</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>honor_mergeinfo</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_root_url</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>merge_target</name> <init>=
        <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>merge_target</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>,
                                     <argument><expr>&amp;<name>source_root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__path_relative_to_root</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_path</name></expr></argument>, <argument><expr><name>primary_url</name></expr></argument>,
                                                <argument><expr><name>source_root_url</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Fetch mergeinfo (temporarily reparenting ra_session1 to
         working copy target URL). */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_full_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>target_mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>implicit_mergeinfo</name></expr></argument>, 
                                 <argument><expr><name>entry</name></expr></argument>, <argument><expr>&amp;<name>indirect</name></expr></argument>, <argument><expr><name>svn_mergeinfo_inherited</name></expr></argument>,
                                 <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, 
                                 <argument><expr><call><name>MAX</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>MIN</name><argument_list>(<argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>, <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Calculate remaining merges unless this is a record only merge.
         In that case the remaining range is the whole range described
         by REVISION1:REVISION2. */</comment>
      <if>if <condition>(<expr>!<name><name>merge_b</name>-&gt;<name>record_only</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>calculate_remaining_ranges</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                             <argument><expr><name>source_root_url</name></expr></argument>,
                                             <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                             <argument><expr><name>target_mergeinfo</name></expr></argument>, 
                                             <argument><expr><name>implicit_mergeinfo</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                             <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>,
                                             <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>remaining_ranges</name> = <name><name>merge_target</name>-&gt;<name>remaining_ranges</name></name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* The simple cases where our remaining range is REVISION1:REVISION2. */</comment>
  <if>if <condition>(<expr>!<name>honor_mergeinfo</name> || <name><name>merge_b</name>-&gt;<name>record_only</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>remaining_ranges</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>&amp;<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>remaining_ranges</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = &amp;<name>range</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name><name>merge_b</name>-&gt;<name>record_only</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ranges_to_merge</name> <init>= <expr><name>remaining_ranges</name></expr></init></decl>;</decl_stmt>
      
      <comment type="block">/* If we have ancestrally related sources and more than one
         range to merge, eliminate no-op ranges before going through
         the effort of downloading the many copies of the file
         required to do these merges (two copies per range). */</comment>
      <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>sources_ancestral</name></name> &amp;&amp; (<name><name>remaining_ranges</name>-&gt;<name>nelts</name></name> &gt; 1)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_sess_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__ensure_ra_session_url</name><argument_list>(<argument><expr>&amp;<name>old_sess_url</name></expr></argument>, 
                                                    <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>,
                                                    <argument><expr><name>primary_url</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_noop_merge_ranges</name><argument_list>(<argument><expr>&amp;<name>ranges_to_merge</name></expr></argument>, 
                                           <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>, 
                                           <argument><expr><name>remaining_ranges</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>old_sess_url</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>, <argument><expr><name>old_sess_url</name></expr></argument>, 
                                    <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ranges_to_merge</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>n</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>header_sent</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session1</name></decl>, *<decl><type ref="prev"/><name>ra_session2</name></decl>;</decl_stmt>

          <comment type="block">/* When using this merge range, account for the exclusivity of
             its low value (which is indicated by this operation being a
             merge vs. revert). */</comment>
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>r</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ranges_to_merge</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                               <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>n</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>,
                                   <argument><expr><name><name>merge_b</name>-&gt;<name>same_repos</name></name> 
                                     ? <name>svn_wc_notify_merge_begin</name>
                                     : <name>svn_wc_notify_foreign_merge_begin</name></expr></argument>,
                                   <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>sources_ancestral</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>n</name>-&gt;<name>merge_range</name></name> = <name>r</name></expr>;</expr_stmt></then></if>

          <comment type="block">/* Issue #3174: If we are honoring mergeinfo, then URL1, URL2,
             REVISION1, and REVISION2 meet the conditions described in
             'MERGEINFO MERGE SOURCE NORMALIZATION'.  This means that
             URL1@REVISION1 may be the copy source of URL2@REVISION2.
             If this is the case, then URL1 != URL2.  Since
             MERGE_B-&gt;RA_SESSION1 is always opened with URL1, the only time
             we can safely call single_file_merge_get_file() with that RA
             session is for REVISION1 (or REVISION2 if this is a reverse
             merge). */</comment>
          <expr_stmt><expr><name>ra_session1</name> = <name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ra_session2</name> = <name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>honor_mergeinfo</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>url1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr>!<name>is_rollback</name> &amp;&amp; <name><name>r</name>-&gt;<name>start</name></name> != <name>revision1</name></expr>)</condition><then>
                <expr_stmt><expr><name>ra_session1</name> = <name>ra_session2</name></expr>;</expr_stmt></then> <comment type="block">/* Use URL2's RA session. */</comment>
              <else>else <if>if <condition>(<expr><name>is_rollback</name> &amp;&amp; <name><name>r</name>-&gt;<name>end</name></name> != <name>revision2</name></expr>)</condition><then>
                <expr_stmt><expr><name>ra_session2</name> = <name>ra_session1</name></expr>;</expr_stmt></then></if></else></if> <comment type="block">/* Use URL1's RA session. */</comment>
            }</block></then></if>
 
          <comment type="block">/* While we currently don't allow it, in theory we could be
             fetching two fulltexts from two different repositories here. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>single_file_merge_get_file</name><argument_list>(<argument><expr>&amp;<name>tmpfile1</name></expr></argument>, <argument><expr><name>ra_session1</name></expr></argument>,
                                             <argument><expr>&amp;<name>props1</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                             <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>single_file_merge_get_file</name><argument_list>(<argument><expr>&amp;<name>tmpfile2</name></expr></argument>, <argument><expr><name>ra_session2</name></expr></argument>,
                                             <argument><expr>&amp;<name>props2</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>end</name></name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                             <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Discover any svn:mime-type values in the proplists */</comment>
          <expr_stmt><expr><name>pval</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>props1</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>,
                              <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mimetype1</name> = <name>pval</name> ? <name><name>pval</name>-&gt;<name>data</name></name> : <name>NULL</name></expr>;</expr_stmt>

          <expr_stmt><expr><name>pval</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>props2</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>,
                              <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mimetype2</name> = <name>pval</name> ? <name><name>pval</name>-&gt;<name>data</name></name> : <name>NULL</name></expr>;</expr_stmt>

          <comment type="block">/* Deduce property diffs. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>propchanges</name></expr></argument>, <argument><expr><name>props2</name></expr></argument>, <argument><expr><name>props1</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If we aren't ignoring ancestry, then we've already done
             ancestry relatedness checks.  If we are ignoring ancestry, or
             our sources are known to be related, then we can do
             text-n-props merge; otherwise, we have to do a delete-n-add
             merge.  */</comment>
          <if>if <condition>(<expr>! (<name><name>merge_b</name>-&gt;<name>ignore_ancestry</name></name> || <name>sources_related</name>)</expr>)</condition><then>
            <block>{
              <comment type="block">/* Delete... */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_file_deleted</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>,
                                         <argument><expr>&amp;<name>text_state</name></expr></argument>,
                                         <argument><expr><name>target_wcpath</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>mimetype1</name></expr></argument>, <argument><expr><name>mimetype2</name></expr></argument>,
                                         <argument><expr><name>props1</name></expr></argument>,
                                         <argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>single_file_merge_notify</name><argument_list>(<argument><expr><name>notify_b</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                       <argument><expr><name>svn_wc_notify_update_delete</name></expr></argument>, <argument><expr><name>text_state</name></expr></argument>,
                                       <argument><expr><name>svn_wc_notify_state_unknown</name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
                                       <argument><expr>&amp;<name>header_sent</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* ...plus add... */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_file_added</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>,
                                       <argument><expr>&amp;<name>text_state</name></expr></argument>, <argument><expr>&amp;<name>prop_state</name></expr></argument>,
                                       <argument><expr><name>target_wcpath</name></expr></argument>,
                                       <argument><expr><name>tmpfile1</name></expr></argument>,
                                       <argument><expr><name>tmpfile2</name></expr></argument>,
                                       <argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>,
                                       <argument><expr><name><name>r</name>-&gt;<name>end</name></name></expr></argument>,
                                       <argument><expr><name>mimetype1</name></expr></argument>, <argument><expr><name>mimetype2</name></expr></argument>,
                                       <argument><expr><name>propchanges</name></expr></argument>, <argument><expr><name>props1</name></expr></argument>,
                                       <argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>single_file_merge_notify</name><argument_list>(<argument><expr><name>notify_b</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                       <argument><expr><name>svn_wc_notify_update_add</name></expr></argument>, <argument><expr><name>text_state</name></expr></argument>,
                                       <argument><expr><name>prop_state</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name>header_sent</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="block">/* ... equals replace. */</comment>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_file_changed</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>,
                                         <argument><expr>&amp;<name>text_state</name></expr></argument>, <argument><expr>&amp;<name>prop_state</name></expr></argument>,
                                         <argument><expr><name>target_wcpath</name></expr></argument>,
                                         <argument><expr><name>tmpfile1</name></expr></argument>,
                                         <argument><expr><name>tmpfile2</name></expr></argument>,
                                         <argument><expr><name><name>r</name>-&gt;<name>start</name></name></expr></argument>,
                                         <argument><expr><name><name>r</name>-&gt;<name>end</name></name></expr></argument>,
                                         <argument><expr><name>mimetype1</name></expr></argument>, <argument><expr><name>mimetype2</name></expr></argument>,
                                         <argument><expr><name>propchanges</name></expr></argument>, <argument><expr><name>props1</name></expr></argument>,
                                         <argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>single_file_merge_notify</name><argument_list>(<argument><expr><name>notify_b</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                       <argument><expr><name>svn_wc_notify_update_update</name></expr></argument>, <argument><expr><name>text_state</name></expr></argument>,
                                       <argument><expr><name>prop_state</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name>header_sent</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>

          <comment type="block">/* Ignore if temporary file not found. It may have been renamed. */</comment>
          <comment type="block">/* (This is where we complain about missing Lisp, or better yet,
             Python...) */</comment>
          <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>tmpfile1</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>err</name> &amp;&amp; ! <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then></if>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>tmpfile2</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>err</name> &amp;&amp; ! <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then></if>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr>(<name>i</name> &lt; (<name><name>ranges_to_merge</name>-&gt;<name>nelts</name></name> - 1))
              &amp;&amp; <call><name>is_path_conflicted_by_merge</name><argument_list>(<argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>conflicted_range</name> = <name>r</name></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
        }</block></for>
    }</block></then></if> <comment type="block">/* !merge_b-&gt;record_only */</comment>

  <comment type="block">/* Record updated WC mergeinfo to account for our new merges, minus
     any unresolved conflicts and skips.  We use the original
     REMAINING_RANGES here instead of the possibly-pared-down
     RANGES_TO_MERGE because we want to record all the requested
     merge ranges, include the noop ones.  */</comment>
  <if>if <condition>(<expr><name>record_mergeinfo</name> &amp;&amp; <name><name>remaining_ranges</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>merges</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>filtered_rangelist</name></decl>;</decl_stmt>

      <comment type="block">/* Filter any ranges from TARGET_WCPATH's own history, there is no
         need to record this explicitly in mergeinfo, it is already part
         of TARGET_WCPATH's natural history (implicit mergeinfo). */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>filter_natural_history_from_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>filtered_rangelist</name></expr></argument>,
                                                    <argument><expr><name>mergeinfo_path</name></expr></argument>,
                                                    <argument><expr><name>implicit_mergeinfo</name></expr></argument>,
                                                    <argument><expr>&amp;<name>range</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>filtered_rangelist</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>determine_merges_performed</name><argument_list>(<argument><expr>&amp;<name>merges</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                             <argument><expr><name>filtered_rangelist</name></expr></argument>,
                                             <argument><expr><name>svn_depth_infinity</name></expr></argument>,
                                             <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>notify_b</name></expr></argument>,
                                             <argument><expr><name>merge_b</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* If merge target has indirect mergeinfo set it before
             recording the first merge range. */</comment>
          <if>if <condition>(<expr><name>indirect</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__record_wc_mergeinfo</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>,
                                                    <argument><expr><name>target_mergeinfo</name></expr></argument>,
                                                    <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_wc_mergeinfo</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>mergeinfo_path</name></expr></argument>,
                                      <argument><expr><name>merges</name></expr></argument>, <argument><expr><name>is_rollback</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                      <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sleep to ensure timestamp integrity. */</comment>
  <expr_stmt><expr><call><name>svn_sleep_for_timestamps</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If our multi-pass merge terminated early due to conflicts, return
     that fact as an error. */</comment>
  <if>if <condition>(<expr><name>conflicted_range</name></expr>)</condition><then>
    <return>return <expr><call><name>make_merge_conflict_error</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>conflicted_range</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Perform a merge of changes between URL1@REVISION1 and
   URL2@REVISION2, applied to the children of PARENT_ENTRY.  URL1,
   URL2, and PARENT_ENTRY all represent directories -- for the single
   file case, the caller should use do_file_merge().

   If MERGE_B-&gt;sources_ancestral is set, then URL1@REVISION1 must be a
   historical ancestor of URL2@REVISION2, or vice-versa (see
   `MERGEINFO MERGE SOURCE NORMALIZATION' for more requirements around
   the values of URL1, REVISION1, URL2, and REVISION2 in this case).

   Handle DEPTH as documented for svn_client_merge3().

   CHILDREN_WITH_MERGEINFO may contain child paths (svn_client__merge_path_t *)
   which are switched or which have mergeinfo which differs from that of the
   merge target root (ignored if empty or NULL).  CHILDREN_WITH_MERGEINFO
   list should have entries sorted in depth first order as mandated by the
   reporter API. Because of this, we drive the diff editor in such a way that
   it avoids merging child paths when a merge is driven for their parent path.

   CHILDREN_WITH_MERGEINFO may contain TARGET_WCPATH (which may be
   MERGE_B-&gt;TARGET), in that case TARGET_INDEX is the array index for
   TARGET_WCPATH, otherwise it should be set to a negative value.

   NOTE: This is a wrapper around drive_merge_report_editor() which
   handles the complexities inherent to situations where a given
   directory's children may have intersecting merges (because they
   meet one or more of the criteria described in get_mergeinfo_paths()).
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_directory_merge</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>revision1</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url2</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>revision2</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>parent_entry</name></decl></param>,
                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                   <param><decl><type><name>notification_receiver_baton_t</name> *</type><name>notify_b</name></decl></param>,
                   <param><decl><type><name>merge_cmd_baton_t</name> *</type><name>merge_b</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>children_with_mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>merge_target_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name>range</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>inheritable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name> <init>= <expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>target_merge_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_rollback</name> <init>= <expr>(<name>revision1</name> &gt; <name>revision2</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>primary_url</name> <init>= <expr><name>is_rollback</name> ? <name>url1</name> : <name>url2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_root_url</name></decl>, *<decl><type ref="prev"/><name>mergeinfo_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>honor_mergeinfo</name></decl>, <decl><type ref="prev"/><name>record_mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same_urls</name> <init>= <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>url1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>)</argument_list></call> == 0)</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>mergeinfo_behavior</name><argument_list>(<argument><expr>&amp;<name>honor_mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>record_mergeinfo</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize CHILDREN_WITH_MERGEINFO. */</comment>
  <expr_stmt><expr><name>children_with_mergeinfo</name> =
    <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>children_with_mergeinfo</name></name> = <name>children_with_mergeinfo</name></expr>;</expr_stmt>

  <comment type="block">/* If our merge sources aren't related to each other, or don't come
     from the same repository as our target, mergeinfo is meaningless
     and we can skip right to the business of merging changes!  We'll
     just drop a dummy item into CHILDREN_WITH_MERGEINFO if the merge
     sources are related.  */</comment>
  <if>if <condition>(<expr>! (<name><name>merge_b</name>-&gt;<name>sources_ancestral</name></name> &amp;&amp; <name><name>merge_b</name>-&gt;<name>same_repos</name></name>)</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>merge_b</name>-&gt;<name>sources_ancestral</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>item</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>itemrange</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>itemrange</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>remaining_ranges</name> <init>=
            <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name><name>itemrange</name>-&gt;<name>start</name></name> = <name>revision1</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>itemrange</name>-&gt;<name>end</name></name> = <name>revision2</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>itemrange</name>-&gt;<name>inheritable</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>remaining_ranges</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>itemrange</name></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>item</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>item</name>-&gt;<name>remaining_ranges</name></name> = <name>remaining_ranges</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, 
                         <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call> = <name>item</name></expr>;</expr_stmt>
        }</block></then></if>
      <return>return <expr><call><name>drive_merge_report_editor</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>,
                                       <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>is_rollback</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>notify_b</name></expr></argument>, 
                                       <argument><expr><name>adm_access</name></expr></argument>, <argument><expr>&amp;<name>merge_callbacks</name></expr></argument>, 
                                       <argument><expr><name>merge_b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/*** If we get here, we're dealing with related sources from the
       same repository as the target -- merge tracking might be
       happenin'! ***/</comment>

  <comment type="block">/* Point our RA_SESSION to the URL of our youngest merge source side. */</comment>
  <expr_stmt><expr><name>ra_session</name> = <name>is_rollback</name> ? <name><name>merge_b</name>-&gt;<name>ra_session1</name></name> : <name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr>;</expr_stmt>

  <comment type="block">/* Fill CHILDREN_WITH_MERGEINFO with child paths (const
     svn_client__merge_path_t *) which might have intersecting merges
     because they meet one or more of the criteria described in
     get_mergeinfo_paths(). Here the paths are arranged in a depth
     first order. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>source_root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__path_relative_to_root</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_path</name></expr></argument>, <argument><expr><name>primary_url</name></expr></argument>,
                                            <argument><expr><name>source_root_url</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_mergeinfo_paths</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>,
                              <argument><expr><name>mergeinfo_path</name></expr></argument>, <argument><expr><name>parent_entry</name></expr></argument>, <argument><expr><name>source_root_url</name></expr></argument>,
                              <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                              <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                              <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The first item from the CHILDREN_WITH_MERGEINFO is the target
     thanks to depth-first ordering. */</comment>
  <expr_stmt><expr><name>target_merge_path</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr>0</expr></argument>,
                                    <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_b</name>-&gt;<name>target_missing_child</name></name> = <name><name>target_merge_path</name>-&gt;<name>missing_child</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>inheritable</name> = ((! <name><name>merge_b</name>-&gt;<name>target_missing_child</name></name>)
                 &amp;&amp; ((<name>depth</name> == <name>svn_depth_infinity</name>)
                     || (<name>depth</name> == <name>svn_depth_immediates</name>)))</expr>;</expr_stmt>

  <comment type="block">/* If we are honoring mergeinfo, then for each item in
     CHILDREN_WITH_MERGEINFO, we need to calculate what needs to be
     merged, and then merge it.  Otherwise, we just merge what we were
     asked to merge across the whole tree.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>populate_remaining_ranges</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, 
                                    <argument><expr><name>source_root_url</name></expr></argument>,
                                    <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                    <argument><expr><name>inheritable</name></expr></argument>, <argument><expr><name>honor_mergeinfo</name></expr></argument>,
                                    <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>mergeinfo_path</name></expr></argument>,
                                    <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Always start with a range which describes our most inclusive merge. */</comment>
  <expr_stmt><expr><name><name>range</name>.<name>start</name></name> = <name>revision1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>.<name>end</name></name> = <name>revision2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>.<name>inheritable</name></name> = <name>inheritable</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>honor_mergeinfo</name> &amp;&amp; !<name><name>merge_b</name>-&gt;<name>record_only</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl>, <decl><type ref="prev"/><name>end_rev</name></decl>;</decl_stmt>

      <comment type="block">/* From the remaining ranges of each item in
         CHILDREN_WITH_MERGEINFO, pick the most inclusive start and
         end revisions. */</comment>
      <expr_stmt><expr><name>start_rev</name> = <call><name>get_most_inclusive_start_rev</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                               <argument><expr><name>is_rollback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
      <comment type="block">/* Is there anything to merge? */</comment>
      <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>start_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>range</name>.<name>start</name></name> = <name>start_rev</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>end_rev</name> = <call><name>get_youngest_end_rev</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>is_rollback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Build a range which describes our most inclusive merge. */</comment>
          <expr_stmt><expr><name><name>range</name>.<name>start</name></name> = <name>start_rev</name></expr>;</expr_stmt>

          <comment type="block">/* While END_REV is valid, do the following:

             1. slice each remaining ranges around this 'end_rev'.
             2. starting with START_REV, call
                drive_merge_report_editor() on MERGE_B-&gt;target for 
                start_rev:end_rev.
             3. remove the first item from each remaining range.
             4. set START_REV=END_REV and pick the next END_REV.
             5. lather, rinse, repeat.
          */</comment>
          <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <while>while <condition>(<expr><name>end_rev</name> != <name>SVN_INVALID_REVNUM</name></expr>)</condition>
            <block>{
              <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>next_end_rev</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>real_url1</name> <init>= <expr><name>url1</name></expr></init>, *<name>real_url2</name> <init>= <expr><name>url2</name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_sess1_url</name> <init>= <expr><name>NULL</name></expr></init>, *<name>old_sess2_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* Use persistent pool while playing with remaining_ranges. */</comment>
              <expr_stmt><expr><call><name>slice_remaining_ranges</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>is_rollback</name></expr></argument>,
                                     <argument><expr><name>end_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>cur_ancestor_index</name></name> = -1</expr>;</expr_stmt>

              <comment type="block">/* URL1@REVISION1 is a real location; URL2@REVISION2 is a
                 real location -- that much we know (thanks to the merge
                 source normalization code).  But for revisions between
                 them, the URLs might differ.  Here are the rules:

                   * If URL1 == URL2, then all URLs between REVISION1 and
                     REVISION2 also match URL1/URL2.

                   * If URL1 != URL2, then:

                       * If REVISION1 &lt; REVISION2, only REVISION1 maps to
                         URL1.  The revisions between REVISION1+1 and
                         REVISION2 (inclusive) map to URL2.

                       * If REVISION1 &gt; REVISION2, Only REVISION2 maps to
                         URL2.  The revisions between REVISION1 and
                         REVISION2+1 (inclusive) map to URL1.
                   
                 We need to adjust our URLs accordingly, here.
              */</comment>
              <if>if <condition>(<expr>! <name>same_urls</name></expr>)</condition><then>
                <block>{
                  <if>if <condition>(<expr><name>is_rollback</name> &amp;&amp; (<name>end_rev</name> != <name>revision2</name>)</expr>)</condition><then>
                    <block>{
                      <expr_stmt><expr><name>real_url2</name> = <name>url1</name></expr>;</expr_stmt>
                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__ensure_ra_session_url</name>
                              <argument_list>(<argument><expr>&amp;<name>old_sess2_url</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>,
                               <argument><expr><name>real_url2</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                  <if>if <condition>(<expr>(! <name>is_rollback</name>) &amp;&amp; (<name>start_rev</name> != <name>revision1</name>)</expr>)</condition><then>
                    <block>{
                      <expr_stmt><expr><name>real_url1</name> = <name>url2</name></expr>;</expr_stmt>
                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__ensure_ra_session_url</name>
                              <argument_list>(<argument><expr>&amp;<name>old_sess1_url</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>,
                               <argument><expr><name>real_url1</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>drive_merge_report_editor</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>,
                                                <argument><expr><name>real_url1</name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>,
                                                <argument><expr><name>real_url2</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>,
                                                <argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                                <argument><expr><name>is_rollback</name></expr></argument>,
                                                <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>notify_b</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                                <argument><expr>&amp;<name>merge_callbacks</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>,
                                                <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>old_sess1_url</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session1</name></name></expr></argument>, 
                                        <argument><expr><name>old_sess1_url</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
              <if>if <condition>(<expr><name>old_sess2_url</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>ra_session2</name></name></expr></argument>, 
                                        <argument><expr><name>old_sess2_url</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

              <comment type="block">/* Prepare for the next iteration (if any). */</comment>
              <expr_stmt><expr><call><name>remove_first_range_from_remaining_ranges</name><argument_list>(
                <argument><expr><name>end_rev</name></expr></argument>, <argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>next_end_rev</name> = <call><name>get_youngest_end_rev</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                                  <argument><expr><name>is_rollback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>(<name>next_end_rev</name> != <name>SVN_INVALID_REVNUM</name>)
                  &amp;&amp; <call><name>is_path_conflicted_by_merge</name><argument_list>(<argument><expr><name>merge_b</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name>conflicted_range</name></decl>;</decl_stmt>
                  <expr_stmt><expr><name><name>conflicted_range</name>.<name>start</name></name> = <name>start_rev</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>conflicted_range</name>.<name>end</name></name> = <name>end_rev</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>err</name> = <call><name>make_merge_conflict_error</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>,
                                                  <argument><expr>&amp;<name>conflicted_range</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>range</name>.<name>end</name></name> = <name>end_rev</name></expr>;</expr_stmt>
                  <break>break;</break>
                }</block></then></if>
              <expr_stmt><expr><name>start_rev</name> = <name>end_rev</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>end_rev</name> = <name>next_end_rev</name></expr>;</expr_stmt>
            }</block></while>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
  <else>else
    <block>{
      <if>if <condition>(<expr>!<name><name>merge_b</name>-&gt;<name>record_only</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Reset cur_ancestor_index to -1 so that subsequent cherry
             picked revision ranges will be notified upon subsequent
             operative merge. */</comment>
          <expr_stmt><expr><name><name>notify_b</name>-&gt;<name>cur_ancestor_index</name></name> = -1</expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>drive_merge_report_editor</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>,
                                            <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>is_rollback</name></expr></argument>, 
                                            <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>notify_b</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, 
                                            <argument><expr>&amp;<name>merge_callbacks</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>, 
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

  <comment type="block">/* Record mergeinfo where appropriate.

     NOTE: any paths in CHILDREN_WITH_MERGEINFO which were switched
     but had no explicit working mergeinfo at the start of the call,
     will have some at the end of it if merge is not a no-op merge.
  */</comment>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>record_mergeinfo</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>filtered_rangelist</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>merge_target</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Update the WC mergeinfo here to account for our new
         merges, minus any unresolved conflicts and skips. */</comment>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>merges</name></decl>;</decl_stmt>

      <comment type="block">/* Remove absent children at or under TARGET_WCPATH from
         NOTIFY_B-&gt;SKIPPED_PATHS and CHILDREN_WITH_MERGEINFO before we
         calculate the merges performed. */</comment>
      <expr_stmt><expr><call><name>remove_absent_children</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>,
                             <argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>notify_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Filter any ranges from MERGE_B-&gt;TARGET's own history, there is no
         need to record this explicitly in mergeinfo, it is already part of
         MERGE_B-&gt;TARGET's natural history (implicit mergeinfo). */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>filter_natural_history_from_mergeinfo</name><argument_list>(
        <argument><expr>&amp;<name>filtered_rangelist</name></expr></argument>, <argument><expr><name>mergeinfo_path</name></expr></argument>, <argument><expr><name><name>merge_target</name>-&gt;<name>implicit_mergeinfo</name></name></expr></argument>,
        <argument><expr>&amp;<name>range</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>filtered_rangelist</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>determine_merges_performed</name><argument_list>(<argument><expr>&amp;<name>merges</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>,
                                             <argument><expr><name>filtered_rangelist</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>,
                                             <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>notify_b</name></expr></argument>,
                                             <argument><expr><name>merge_b</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>record_mergeinfo_on_merged_children</name><argument_list>(<argument><expr><name>depth</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                                      <argument><expr><name>notify_b</name></expr></argument>, <argument><expr><name>merge_b</name></expr></argument>,
                                                      <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_wc_mergeinfo</name><argument_list>(<argument><expr><name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>parent_entry</name></expr></argument>,
                                      <argument><expr><name>mergeinfo_path</name></expr></argument>, <argument><expr><name>merges</name></expr></argument>,
                                      <argument><expr><name>is_rollback</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>,
                                      <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>children_with_mergeinfo</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_repos_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_merge_src_canon_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>child_entry</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>child_merge_rangelist</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>child_merges</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>child</name> <init>=
                         <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                       <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>!<name>child</name> || <name><name>child</name>-&gt;<name>absent</name></name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call> == <name>merge_target_len</name></expr>)</condition><then>
            <expr_stmt><expr><name>child_repos_path</name> = ""</expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>child_repos_path</name> = <name><name>child</name>-&gt;<name>path</name></name> +
              (<name>merge_target_len</name> ? <name>merge_target_len</name> + 1 : 0)</expr>;</expr_stmt></else></if>
          <expr_stmt><expr><name>child_merge_src_canon_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>mergeinfo_path</name></expr></argument>,
                                                     <argument><expr><name>child_repos_path</name></expr></argument>,
                                                     <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>child_entry</name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>,
                                          <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>child_merges</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* As we did above for the merge target, filter any ranges from
             each child's natural history before setting mergeinfo. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>filter_natural_history_from_mergeinfo</name><argument_list>(
            <argument><expr>&amp;<name>child_merge_rangelist</name></expr></argument>, <argument><expr><name>child_merge_src_canon_path</name></expr></argument>,
            <argument><expr><name><name>child</name>-&gt;<name>implicit_mergeinfo</name></name></expr></argument>, <argument><expr>&amp;<name>range</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>child_merge_rangelist</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
            <continue>continue;</continue></then>
          <else>else
            <block>{
              <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
              <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>child_merge_rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
                <block>{
                  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>rng</name> <init>=
                    <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>child_merge_rangelist</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                                  <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <if>if <condition>(<expr><name><name>child_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>rng</name>-&gt;<name>inheritable</name></name> = <name>TRUE</name></expr>;</expr_stmt></then>
                  <else>else
                    <expr_stmt><expr><name><name>rng</name>-&gt;<name>inheritable</name></name> = (!(<name><name>child</name>-&gt;<name>missing_child</name></name>)
                                        &amp;&amp; (<name>depth</name> == <name>svn_depth_infinity</name>
                                     || <name>depth</name> == <name>svn_depth_immediates</name>))</expr>;</expr_stmt></else></if>
                }</block></for>
            }</block></else></if>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>child_merges</name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                       <argument><expr><name>child_merge_rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* If merge target has indirect mergeinfo set it before
             recording the first merge range. */</comment>
          <if>if <condition>(<expr><name><name>child</name>-&gt;<name>indirect_mergeinfo</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__record_wc_mergeinfo</name><argument_list>(
                                               <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>,
                                               <argument><expr><name><name>child</name>-&gt;<name>pre_merge_mergeinfo</name></name></expr></argument>,
                                               <argument><expr><name>adm_access</name></expr></argument>,
                                               <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_wc_mergeinfo</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>child_entry</name></expr></argument>,
                                      <argument><expr><name>child_merge_src_canon_path</name></expr></argument>,
                                      <argument><expr><name>child_merges</name></expr></argument>, <argument><expr><name>is_rollback</name></expr></argument>,
                                      <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>mark_mergeinfo_as_inheritable_for_a_range</name><argument_list>(
                                                   <argument><expr><name><name>child</name>-&gt;<name>pre_merge_mergeinfo</name></name></expr></argument>,
                                                   <argument><expr><name>TRUE</name></expr></argument>,
                                                   <argument><expr>&amp;<name>range</name></expr></argument>,
                                                   <argument><expr><name>child_merge_src_canon_path</name></expr></argument>,
                                                   <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>,
                                                   <argument><expr><name>adm_access</name></expr></argument>,
                                                   <argument><expr><name>merge_b</name></expr></argument>,
                                                   <argument><expr><name>children_with_mergeinfo</name></expr></argument>,
                                                   <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Elide explicit subtree mergeinfo. */</comment>
          <if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>in_switched_subtree</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
              
              <if>if <condition>(<expr><name><name>child</name>-&gt;<name>switched</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>in_switched_subtree</name> = <name>TRUE</name></expr>;</expr_stmt></then>
              <else>else <if>if <condition>(<expr><name>i</name> &gt; 1</expr>)</condition><then>
                <block>{
                  <comment type="block">/* Check if CHILD is part of a switched subtree */</comment>
                  <decl_stmt><decl><type><name>svn_client__merge_path_t</name> *</type><name>parent</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name>i</name> - 1</expr></init></decl>;</decl_stmt>
                  <for>for (<init>;</init> <condition><expr><name>j</name> &gt; 0</expr>;</condition> <incr><expr><name>j</name>--</expr></incr>)
                    <block>{
                      <expr_stmt><expr><name>parent</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>children_with_mergeinfo</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                                             <argument><expr><name>svn_client__merge_path_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <if>if <condition>(<expr><name>parent</name>
                          &amp;&amp; <name><name>parent</name>-&gt;<name>switched</name></name>
                          &amp;&amp; <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <block>{
                          <expr_stmt><expr><name>in_switched_subtree</name> = <name>TRUE</name></expr>;</expr_stmt>
                          <break>break;</break>
                        }</block></then></if>
                    }</block></for>
                }</block></then></if></else></if>

              <comment type="block">/* Allow mergeinfo on switched subtrees to elide to the
                 repository. Otherwise limit elision to the merge target
                 for now.  do_directory_merge() will eventually try to
                 elide that when the merge is complete. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__elide_mergeinfo</name><argument_list>(
                <argument><expr><name><name>child</name>-&gt;<name>path</name></name></expr></argument>,
                <argument><expr><name>in_switched_subtree</name> ? <name>NULL</name> : <name><name>merge_b</name>-&gt;<name>target</name></name></expr></argument>,
                <argument><expr><name>child_entry</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for> <comment type="block">/* (i = 0; i &lt; children_with_mergeinfo-&gt;nelts; i++) */</comment>
      
      <comment type="block">/* If a path has an immediate parent with non-inheritable mergeinfo at
         this point, then it meets criteria 3 or 5 described in
         get_mergeinfo_paths' doc string.  For paths which exist prior to a
         merge explicit mergeinfo has already been set.  But for paths added
         during the merge this is not the case.  The path might have explicit
         mergeinfo from the merge source, but no mergeinfo yet exists
         describing *this* merge.  So the added path has either incomplete
         explicit mergeinfo or inherits incomplete mergeinfo from its
         immediate parent (if any, the parent might have only non-inheritable
         ranges in which case the path simply inherits empty mergeinfo).

         So here we look at the root path of each subtree added during the
         merge and set explicit mergeinfo on it if it meets the aforementioned
         conditions. */</comment>
      <if>if <condition>(<expr><name><name>notify_b</name>-&gt;<name>added_paths</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>notify_b</name>-&gt;<name>added_paths</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
               <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>added_path</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>added_path_parent_propval</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>added_path</name> = <name>key</name></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              
              <comment type="block">/* Rather than using svn_client__get_wc_mergeinfo() and
                 analyzing the mergeinfo it returns to determine if
                 ADDED_PATH's parent has non-inheritable mergeinfo, it is
                 much simpler to just get the svn_string_t representation
                 of the svn:mergeinfo prop and look for the '*'
                 non-inheritable marker. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_prop_get</name><argument_list>(<argument><expr>&amp;<name>added_path_parent_propval</name></expr></argument>,
                                      <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>,
                                      <argument><expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>added_path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>added_path_parent_propval</name>
                  &amp;&amp; <call><name>strstr</name><argument_list>(<argument><expr><name><name>added_path_parent_propval</name>-&gt;<name>data</name></name></expr></argument>,
                            <argument><expr><name>SVN_MERGEINFO_NONINHERITABLE_STR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <comment type="block">/* ADDED_PATH's immediate parent has non-inheritable
                     mergeinfo. */</comment>
                  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>inherited</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>rng</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>merge_mergeinfo</name></decl>, <decl><type ref="prev"/><name>added_path_mergeinfo</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>common_ancestor_path</name> <init>=
                    <expr><call><name>svn_path_get_longest_ancestor</name><argument_list>(<argument><expr><name>added_path</name></expr></argument>,
                                                  <argument><expr><name><name>target_merge_path</name>-&gt;<name>path</name></name></expr></argument>,
                                                  <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative_added_path</name> <init>=
                    <expr><name>added_path</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>common_ancestor_path</name></expr></argument>)</argument_list></call> + 1</expr></init></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>added_path</name></expr></argument>,
                                                  <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                  <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <comment type="block">/* Calculate the mergeinfo resulting from this merge. */</comment>
                  <expr_stmt><expr><name>merge_mergeinfo</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name>rangelist</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr>1</expr></argument>,
                                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>                            
                  <expr_stmt><expr><name>rng</name> = <call><name>svn_merge_range_dup</name><argument_list>(<argument><expr>&amp;<name>range</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
                    <expr_stmt><expr><name><name>rng</name>-&gt;<name>inheritable</name></name> = <name>TRUE</name></expr>;</expr_stmt></then>
                  <else>else
                    <expr_stmt><expr><name><name>rng</name>-&gt;<name>inheritable</name></name> =
                      (!(<name>depth</name> == <name>svn_depth_infinity</name>
                         || <name>depth</name> == <name>svn_depth_immediates</name>))</expr>;</expr_stmt></else></if>
                  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call> = <name>rng</name></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>merge_mergeinfo</name></expr></argument>,
                               <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>mergeinfo_path</name></expr></argument>,
                                             <argument><expr><name>relative_added_path</name></expr></argument>,
                                             <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <comment type="block">/* Get any explicit mergeinfo the added path has. */</comment>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_wc_mergeinfo</name><argument_list>(
                    <argument><expr>&amp;<name>added_path_mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>inherited</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                    <argument><expr><name>svn_mergeinfo_explicit</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>added_path</name></expr></argument>,
                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>merge_b</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <comment type="block">/* Combine the explict mergeinfo on the added path (if any)
                     with the mergeinfo for this merge. */</comment>
                  <if>if <condition>(<expr><name>added_path_mergeinfo</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>merge_mergeinfo</name></expr></argument>,
                                                <argument><expr><name>added_path_mergeinfo</name></expr></argument>,
                                                <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__record_wc_mergeinfo</name><argument_list>(<argument><expr><name>added_path</name></expr></argument>,
                                                          <argument><expr><name>merge_mergeinfo</name></expr></argument>,
                                                          <argument><expr><name>adm_access</name></expr></argument>,
                                                          <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
    }</block></then></if> <comment type="block">/* (!merge_b-&gt;dry_run &amp;&amp; merge_b-&gt;same_repos) */</comment>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<comment type="block">/* Drive a merge of MERGE_SOURCES into working copy path TARGET (with
   associated TARGET_ENTRY and ADM_ACCESS baton).  

   If SOURCES_ANCESTRAL is set, then for every merge source in
   MERGE_SOURCES, the "left" and "right" side of the merge source are
   ancestrally related.  (See 'MERGEINFO MERGE SOURCE NORMALIZATION'
   for more on what that means and how it matters.)  

   If SOURCES_RELATED is set, the "left" and "right" sides of the
   merge source are historically related (ancestors, uncles, second
   cousins thrice removed, etc...).  (This is passed through to
   do_file_merge() to simulate the history checks that the repository
   logic does in the directory case.)

   SAME_REPOS is TRUE iff the merge sources live in the same
   repository as the one from which the target working copy has been
   checked out.

   FORCE, DRY_RUN, RECORD_ONLY, IGNORE_ANCESTRY, DEPTH, MERGE_OPTIONS,
   and CTX are as described in the docstring for svn_client_merge_peg3().
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_merge</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>merge_sources</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>target_entry</name></decl></param>,
         <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>sources_ancestral</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>sources_related</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>same_repos</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
         <param><decl><type><name>svn_boolean_t</name></type> <name>record_only</name></decl></param>,
         <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>merge_options</name></decl></param>,
         <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>merge_cmd_baton_t</name></type> <name>merge_cmd_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>notification_receiver_baton_t</name></type> <name>notify_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>checked_mergeinfo_capability</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check from some special conditions when in record-only mode
     (which is a merge-tracking thing). */</comment>
  <if>if <condition>(<expr><name>record_only</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We can't do a record-only merge if the sources aren't related. */</comment>
      <if>if <condition>(<expr>! <name>sources_ancestral</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Use of two URLs is not compatible with "
                                  "mergeinfo modification"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* We can't do a record-only merge if the sources aren't from
         the same repository as the target. */</comment>
      <if>if <condition>(<expr>! <name>same_repos</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Merge from foreign repository is not "
                                  "compatible with mergeinfo modification"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* If this is a dry-run record-only merge, there's nothing to do. */</comment>
      <if>if <condition>(<expr><name>dry_run</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Ensure a known depth. */</comment>
  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_unknown</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth</name> = <name><name>target_entry</name>-&gt;<name>depth</name></name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Set up the diff3 command, so various callers don't have to. */</comment>
  <expr_stmt><expr><name>cfg</name> = <name><name>ctx</name>-&gt;<name>config</name></name> ? <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>SVN_CONFIG_CATEGORY_CONFIG</name></expr></argument>,
                                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>diff3_cmd</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_HELPERS</name></expr></argument>,
                 <argument><expr><name>SVN_CONFIG_OPTION_DIFF3_CMD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Build the merge context baton (or at least the parts of it that
     don't need to be reset for each merge source).  */</comment>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>force</name></name> = <name>force</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>dry_run</name></name> = <name>dry_run</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>record_only</name></name> = <name>record_only</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>ignore_ancestry</name></name> = <name>ignore_ancestry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>same_repos</name></name> = <name>same_repos</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>mergeinfo_capable</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>sources_ancestral</name></name> = <name>sources_ancestral</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>target_missing_child</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>target</name></name> = <name>target</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>merge_options</name></name> = <name>merge_options</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>diff3_cmd</name></name> = <name>diff3_cmd</name></expr>;</expr_stmt>

  <comment type="block">/* Build the notification receiver baton. */</comment>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>wrapped_func</name></name> = <name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>wrapped_baton</name></name> = <name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>nbr_notifications</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>nbr_operative_notifications</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>merged_paths</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>skipped_paths</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>added_paths</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>is_single_file_merge</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>children_with_mergeinfo</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>cur_ancestor_index</name></name> = -1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>merge_b</name></name> = &amp;<name>merge_cmd_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>notify_baton</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>merge_sources</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>merge_source_t</name> *</type><name>merge_source</name> <init>= 
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>merge_sources</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl>, *<decl><type ref="prev"/><name>url2</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev1</name></decl>, <decl><type ref="prev"/><name>rev2</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session1</name></decl>, *<decl><type ref="prev"/><name>ra_session2</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Convenience variables. */</comment>
      <expr_stmt><expr><name>url1</name> = <name><name>merge_source</name>-&gt;<name>url1</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>url2</name> = <name><name>merge_source</name>-&gt;<name>url2</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rev1</name> = <name><name>merge_source</name>-&gt;<name>rev1</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rev2</name> = <name><name>merge_source</name>-&gt;<name>rev2</name></name></expr>;</expr_stmt>

      <comment type="block">/* Sanity check:  if our left- and right-side merge sources are
         the same, there's nothing to here. */</comment>
      <if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>url1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>)</argument_list></call> == 0) &amp;&amp; (<name>rev1</name> == <name>rev2</name>)</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* Establish RA sessions to our URLs. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name><argument_list>(<argument><expr>&amp;<name>ra_session1</name></expr></argument>, <argument><expr><name>url1</name></expr></argument>,
                                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, 
                                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name><argument_list>(<argument><expr>&amp;<name>ra_session2</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>,
                                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, 
                                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Populate the portions of the merge context baton that need to
         be reset for each merge source iteration. */</comment>
      <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>url</name></name> = <name>url2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>added_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>add_necessitated_merge</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>dry_run_deletions</name></name> = 
        <name>dry_run</name> ? <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>conflicted_paths</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>target_has_dummy_merge_range</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>ra_session1</name></name> = <name>ra_session1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_cmd_baton</name>.<name>ra_session2</name></name> = <name>ra_session2</name></expr>;</expr_stmt>

      <comment type="block">/* Populate the portions of the merge context baton that require
         an RA session to set, but shouldn't be reset for each iteration. */</comment>
      <if>if <condition>(<expr>! <name>checked_mergeinfo_capability</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_has_capability</name><argument_list>(<argument><expr><name>ra_session1</name></expr></argument>,
                                        <argument><expr>&amp;<name><name>merge_cmd_baton</name>.<name>mergeinfo_capable</name></name></expr></argument>,
                                        <argument><expr><name>SVN_RA_CAPABILITY_MERGEINFO</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>checked_mergeinfo_capability</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Call our merge helpers based on entry kind. */</comment>
      <if>if <condition>(<expr><name><name>target_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_file_merge</name><argument_list>(<argument><expr><name>url1</name></expr></argument>, <argument><expr><name>rev1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>rev2</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, 
                                <argument><expr><name>sources_related</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, 
                                <argument><expr>&amp;<name>notify_baton</name></expr></argument>, <argument><expr>&amp;<name>merge_cmd_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>target_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_directory_merge</name><argument_list>(<argument><expr><name>url1</name></expr></argument>, <argument><expr><name>rev1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>rev2</name></expr></argument>, <argument><expr><name>target_entry</name></expr></argument>, 
                                     <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr>&amp;<name>notify_baton</name></expr></argument>,
                                     <argument><expr>&amp;<name>merge_cmd_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>

      <comment type="block">/* The final mergeinfo on TARGET_WCPATH may itself elide. */</comment>
      <if>if <condition>(<expr>! <name>dry_run</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__elide_mergeinfo</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>target_entry</name></expr></argument>,
                                            <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Perform a two-URL merge between URLs which are related, but neither
   is a direct ancestor of the other.  This first does a real two-URL
   merge (unless this is record-only), followed by record-only merges
   to represent the changed mergeinfo.

   The merge is between URL1@REV1 (in RA_SESSION1) and URL2@REV2 (in
   RA_SESSION2); YC_REV is their youngest common ancestor.
   SOURCE_REPOS_ROOT and WC_REPOS_ROOT are the repository roots of the
   source URL and the target working copy.  ENTRY is the wc entry for
   TARGET_WCPATH.  Other arguments are as in all of the public merge
   APIs.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_cousins_and_supplement_mergeinfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                                       <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                       <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>URL1</name></decl></param>,
                                       <param><decl><type><name>svn_revnum_t</name></type> <name>rev1</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>URL2</name></decl></param>,
                                       <param><decl><type><name>svn_revnum_t</name></type> <name>rev2</name></decl></param>,
                                       <param><decl><type><name>svn_revnum_t</name></type> <name>yc_rev</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_repos_root</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>wc_repos_root</name></decl></param>,
                                       <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                                       <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                                       <param><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl></param>,
                                       <param><decl><type><name>svn_boolean_t</name></type> <name>record_only</name></decl></param>,
                                       <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>merge_options</name></decl></param>,
                                       <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_opt_revision_range_t</name> *</type><name>range</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>remove_sources</name></decl>, *<decl><type ref="prev"/><name>add_sources</name></decl>, *<decl><type ref="prev"/><name>ranges</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>peg_revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same_repos</name> <init>=
    <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>wc_repos_root</name></expr></argument>, <argument><expr><name>source_repos_root</name></expr></argument>)</argument_list></call> == 0) ? <name>TRUE</name> : <name>FALSE</name></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><name><name>peg_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>old_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>range</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>value</name>.<name>number</name></name> = <name>rev1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>value</name>.<name>number</name></name> = <name>yc_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ranges</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>peg_revision</name>.<name>value</name>.<name>number</name></name> = <name>rev1</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>URL1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>normalize_merge_sources</name><argument_list>(<argument><expr>&amp;<name>remove_sources</name></expr></argument>, <argument><expr><name>URL1</name></expr></argument>, <argument><expr><name>URL1</name></expr></argument>,
                                  <argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr>&amp;<name>peg_revision</name></expr></argument>, 
                                  <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>range</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>value</name>.<name>number</name></name> = <name>yc_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>value</name>.<name>number</name></name> = <name>rev2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ranges</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>peg_revision</name>.<name>value</name>.<name>number</name></name> = <name>rev2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>URL2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>normalize_merge_sources</name><argument_list>(<argument><expr>&amp;<name>add_sources</name></expr></argument>, <argument><expr><name>URL2</name></expr></argument>, <argument><expr><name>URL2</name></expr></argument>,
                                  <argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr>&amp;<name>peg_revision</name></expr></argument>, 
                                  <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>old_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this isn't a record-only merge, we'll first do a stupid
     point-to-point merge... */</comment>
  <if>if <condition>(<expr>! <name>record_only</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>merge_source_t</name> *</type><name>faux_source</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>faux_sources</name> <init>= 
        <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>faux_source</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>faux_source</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>faux_source</name>-&gt;<name>url1</name></name> = <name>URL1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>faux_source</name>-&gt;<name>url2</name></name> = <name>URL2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>faux_source</name>-&gt;<name>rev1</name></name> = <name>rev1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>faux_source</name>-&gt;<name>rev2</name></name> = <name>rev2</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>faux_sources</name></expr></argument>, <argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></call> = <name>faux_source</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_merge</name><argument_list>(<argument><expr><name>faux_sources</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, 
                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>same_repos</name></expr></argument>,
                       <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>, 
                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <name>same_repos</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Merge from foreign repository is not "
                                "compatible with mergeinfo modification"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if></else></if>

  <comment type="block">/* ... and now, if we're doing the mergeinfo thang, we execute a
     pair of record-only merges using the real sources we've
     calculated.  (We know that each tong in our fork of our merge
     source history tree has an ancestral relationship with the common
     ancestral, so we force ancestral=TRUE here.) */</comment>
  <if>if <condition>(<expr><name>same_repos</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_merge</name><argument_list>(<argument><expr><name>add_sources</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, 
                       <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>same_repos</name></expr></argument>,
                       <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>, 
                       <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_merge</name><argument_list>(<argument><expr><name>remove_sources</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, 
                       <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>same_repos</name></expr></argument>,
                       <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>, 
                       <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/*-----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Public APIs ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_merge3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source1</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision1</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source2</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision2</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                  <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>record_only</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>merge_options</name></decl></param>,
                  <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>URL1</name></decl>, *<decl><type ref="prev"/><name>URL2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev1</name></decl>, <decl><type ref="prev"/><name>rev2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>related</name> <init>= <expr><name>FALSE</name></expr></init>, <name>ancestral</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>wc_repos_root</name></decl>, *<decl><type ref="prev"/><name>source_repos_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session1</name></decl>, *<decl><type ref="prev"/><name>ra_session2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>merge_sources</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>merge_source_t</name> *</type><name>merge_source</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>working_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yc_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>yc_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>sesspool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same_repos</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity check our input -- we require specified revisions. */</comment>
  <if>if <condition>(<expr>(<name><name>revision1</name>-&gt;<name>kind</name></name> == <name>svn_opt_revision_unspecified</name>)
      || (<name><name>revision2</name>-&gt;<name>kind</name></name> == <name>svn_opt_revision_unspecified</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_BAD_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Not all required revisions are specified"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* ### FIXME: This function really ought to do a history check on
     the left and right sides of the merge source, and -- if one is an
     ancestor of the other -- just call svn_client_merge_peg3() with
     the appropriate args. */</comment>

  <comment type="block">/* If source1 or source2 are paths, we need to get the underlying
     URL from the wc and save the initial path we were passed so we
     can use it as a path parameter (either in the baton or not).
     otherwise, the path will just be NULL, which means we won't be
     able to figure out some kind of revision specifications, but in
     that case it won't matter, because those ways of specifying a
     revision are meaningless for a url. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client_url_from_path</name><argument_list>(<argument><expr>&amp;<name>URL1</name></expr></argument>, <argument><expr><name>source1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>URL1</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ENTRY_MISSING_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' has no URL"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>source1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client_url_from_path</name><argument_list>(<argument><expr>&amp;<name>URL2</name></expr></argument>, <argument><expr><name>source2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>URL2</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ENTRY_MISSING_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' has no URL"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>source2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Open an admistrative session with the working copy. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                 <argument><expr>! <name>dry_run</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                 <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fetch the target's entry. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, 
                                  <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Determine the working copy target's repository root URL. */</comment>
  <expr_stmt><expr><name><name>working_rev</name>.<name>kind</name></name> = <name>svn_opt_revision_working</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_repos_root</name><argument_list>(<argument><expr>&amp;<name>wc_repos_root</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                     <argument><expr>&amp;<name>working_rev</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open some RA sessions to our merge source sides. */</comment>
  <expr_stmt><expr><name>sesspool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name><argument_list>(<argument><expr>&amp;<name>ra_session1</name></expr></argument>,
                                               <argument><expr><name>URL1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name><argument_list>(<argument><expr>&amp;<name>ra_session2</name></expr></argument>,
                                               <argument><expr><name>URL2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Resolve revisions to real numbers. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_revision_number</name><argument_list>(<argument><expr>&amp;<name>rev1</name></expr></argument>, <argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name>ra_session1</name></expr></argument>, 
                                          <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_revision_number</name><argument_list>(<argument><expr>&amp;<name>rev2</name></expr></argument>, <argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name>ra_session2</name></expr></argument>, 
                                          <argument><expr><name>revision2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the repository root URL from one of our sessions (the other
     doesn't matter -- if it ain't the same, other stuff would fall
     over later).  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>ra_session1</name></expr></argument>, <argument><expr>&amp;<name>source_repos_root</name></expr></argument>, <argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do our working copy and sources come from the same repository? */</comment>
  <expr_stmt><expr><name>same_repos</name> = (<call><name>strcmp</name><argument_list>(<argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr><name>wc_repos_root</name></expr></argument>)</argument_list></call> == 0) ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Unless we're ignoring ancestry, see if the two sources are related.  */</comment>
  <if>if <condition>(<expr>! <name>ignore_ancestry</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_youngest_common_ancestor</name><argument_list>(<argument><expr>&amp;<name>yc_path</name></expr></argument>, <argument><expr>&amp;<name>yc_rev</name></expr></argument>,
                                                     <argument><expr><name>URL1</name></expr></argument>, <argument><expr><name>rev1</name></expr></argument>,
                                                     <argument><expr><name>URL2</name></expr></argument>, <argument><expr><name>rev2</name></expr></argument>,
                                                     <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Check for a youngest common ancestor.  If we have one, we'll be
     doing merge tracking.

     So, given a requested merge of the differences between A and
     B, and a common ancestor of C, we will find ourselves in one of
     four positions, and four different approaches:
 
        A == B == C   there's nothing to merge

        A == C != B   we merge the changes between A (or C) and B

        B == C != A   we merge the changes between B (or C) and A

        A != B != C   we merge the changes between A and B without
                      merge recording, then record-only two merges:
                      from A to C, and from C to B
  */</comment>
  <if>if <condition>(<expr><name>yc_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>yc_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ranges</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_opt_revision_range_t</name> *</type><name>range</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>peg_revision</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>peg_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>

      <comment type="block">/* Note that our merge sources are related. */</comment>
      <expr_stmt><expr><name>related</name> = <name>TRUE</name></expr>;</expr_stmt>
      
      <comment type="block">/* Make YC_PATH into a full URL. */</comment>
      <expr_stmt><expr><name>yc_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>source_repos_root</name></expr></argument>, 
                              <argument><expr><call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name>yc_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If the common ancestor matches the right side of our merge,
         then we only need to reverse-merge the left side. */</comment>
      <if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>yc_path</name></expr></argument>, <argument><expr><name>URL2</name></expr></argument>)</argument_list></call> == 0) &amp;&amp; (<name>yc_rev</name> == <name>rev2</name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>ancestral</name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>range</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>value</name>.<name>number</name></name> = <name>rev1</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>value</name>.<name>number</name></name> = <name>yc_rev</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ranges</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>peg_revision</name>.<name>value</name>.<name>number</name></name> = <name>rev1</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>normalize_merge_sources</name><argument_list>(<argument><expr>&amp;<name>merge_sources</name></expr></argument>, <argument><expr><name>URL1</name></expr></argument>, <argument><expr><name>URL1</name></expr></argument>,
                                          <argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr>&amp;<name>peg_revision</name></expr></argument>, 
                                          <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>ra_session1</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <comment type="block">/* If the common ancestor matches the left side of our merge,
         then we only need to merge the right side. */</comment>
      <else>else <if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>yc_path</name></expr></argument>, <argument><expr><name>URL1</name></expr></argument>)</argument_list></call> == 0) &amp;&amp; (<name>yc_rev</name> == <name>rev1</name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>ancestral</name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>range</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>range</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name>.<name>value</name>.<name>number</name></name> = <name>yc_rev</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name>.<name>value</name>.<name>number</name></name> = <name>rev2</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>ranges</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call> = <name>range</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>peg_revision</name>.<name>value</name>.<name>number</name></name> = <name>rev2</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>normalize_merge_sources</name><argument_list>(<argument><expr>&amp;<name>merge_sources</name></expr></argument>, <argument><expr><name>URL2</name></expr></argument>, <argument><expr><name>URL2</name></expr></argument>,
                                          <argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr>&amp;<name>peg_revision</name></expr></argument>, 
                                          <argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>ra_session2</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <comment type="block">/* And otherwise, we need to do both: reverse merge the left
         side, and merge the right. */</comment>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_cousins_and_supplement_mergeinfo</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
                                                         <argument><expr><name>adm_access</name></expr></argument>,
                                                         <argument><expr><name>ra_session1</name></expr></argument>, 
                                                         <argument><expr><name>URL1</name></expr></argument>, <argument><expr><name>rev1</name></expr></argument>,
                                                         <argument><expr><name>URL2</name></expr></argument>, <argument><expr><name>rev2</name></expr></argument>,
                                                         <argument><expr><name>yc_rev</name></expr></argument>,
                                                         <argument><expr><name>source_repos_root</name></expr></argument>,
                                                         <argument><expr><name>wc_repos_root</name></expr></argument>,
                                                         <argument><expr><name>depth</name></expr></argument>,
                                                         <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>,
                                                         <argument><expr><name>record_only</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>,
                                                         <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>,
                                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Close our temporary RA sessions (this could've happened
             after the second call to normalize_merge_sources() inside
             the merge_cousins_and_supplement_mergeinfo() routine). */</comment>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></else></if></else></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Build a single-item merge_source_t array. */</comment>
      <expr_stmt><expr><name>merge_sources</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>merge_source</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>merge_source</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>url1</name></name> = <name>URL1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>url2</name></name> = <name>URL2</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>rev1</name></name> = <name>rev1</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_source</name>-&gt;<name>rev2</name></name> = <name>rev2</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>merge_sources</name></expr></argument>, <argument><expr><name>merge_source_t</name> *</expr></argument>)</argument_list></call> = <name>merge_source</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Close our temporary RA sessions. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_merge</name><argument_list>(<argument><expr><name>merge_sources</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, 
                   <argument><expr><name>ancestral</name></expr></argument>, <argument><expr><name>related</name></expr></argument>, <argument><expr><name>same_repos</name></expr></argument>,
                   <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>, 
                   <argument><expr><name>record_only</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_merge2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source1</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision1</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source2</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision2</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>merge_options</name></decl></param>,
                  <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_client_merge3</name><argument_list>(<argument><expr><name>source1</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>source2</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                           <argument><expr><name>target_wcpath</name></expr></argument>,
                           <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>,
                           <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_merge</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source1</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision1</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source2</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision2</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                 <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_client_merge2</name><argument_list>(<argument><expr><name>source1</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>source2</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>,
                           <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>,
                           <argument><expr><name>dry_run</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* If TARGET_WCPATH does not reflect a single-revision,
   svn_depth_infinity, pristine, unswitched working copy -- in other
   words, a subtree found in a single revision -- raise
   SVN_ERR_CLIENT_NOT_READY_TO_MERGE. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>ensure_wc_reflects_repository_subtree</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                                      <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_revision_status_t</name> *</type><name>wc_stat</name></decl>;</decl_stmt>

  <comment type="block">/* Get a WC summary with min/max revisions set to the BASE revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_revision_status</name><argument_list>(<argument><expr>&amp;<name>wc_stat</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, 
                                 <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>wc_stat</name>-&gt;<name>switched</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot reintegrate into a working copy "
                              "with a switched subtree"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>wc_stat</name>-&gt;<name>sparse_checkout</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot reintegrate into a working copy "
                              "not entirely at infinite depth"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>wc_stat</name>-&gt;<name>modified</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot reintegrate into a working copy "
                              "that has local modifications"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr>! (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>wc_stat</name>-&gt;<name>min_rev</name></name></expr></argument>)</argument_list></call>
         &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>wc_stat</name>-&gt;<name>max_rev</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot determine revision of working copy"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>wc_stat</name>-&gt;<name>min_rev</name></name> != <name><name>wc_stat</name>-&gt;<name>max_rev</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot reintegrate into mixed-revision "
                              "working copy; try updating first"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Given a "mergeinfo" hash HISTORY_AS_MERGEINFO representing revision
   ranges from a merge target that are not represented in the merge
   source, check (using RA_SESSION, which is pointed at the repository
   root) that all of the ranges in the hash are "phantoms": that is,
   their corresponding path did not change in any of their revisions.
   Raises SVN_ERR_CLIENT_NOT_READY_TO_MERGE if any are not phantoms.
   Temporary allocations in POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>ensure_all_missing_ranges_are_phantoms</name><parameter_list>(<param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                                       <param><decl><type><name>svn_mergeinfo_t</name></type> <name>history_as_mergeinfo</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>history_as_mergeinfo</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>value</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rangelist</name> = <name>value</name></expr>;</expr_stmt>

      <comment type="block">/* mergeinfo hashes contain paths that start with slashes;
         ra APIs take paths without slashes. */</comment>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path</name>++</expr>;</expr_stmt>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, 
                                                   <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>

          <comment type="block">/* This function should not receive any "rollback"
             ranges. */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>range</name>-&gt;<name>start</name></name> &lt; <name><name>range</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_stat</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>,
                              <argument><expr><name>path</name></expr></argument>,
                              <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>,
                              <argument><expr>&amp;<name>dirent</name></expr></argument>,
                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><call><name>svn_merge_range_contains_rev</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>created_rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_url</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>full_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>full_url</name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name>full_url</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"At least one revision (r%ld) "
                                         "not yet merged from '%s'"</expr></argument>)</argument_list></call></expr></argument>, 
                                       <argument><expr><name><name>dirent</name>-&gt;<name>created_rev</name></name></expr></argument>, <argument><expr><name>full_url</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></for>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Return a new catalog in *CATALOG_P equal to CATALOG, but containing
   only source ranges from the segments in SEGMENTS (whose elements
   are of type svn_location_segment_t *).  The returned values are
   (deeply) allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_irrelevant_ranges</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_catalog_t</name> *</type><name>catalog_p</name></decl></param>,
                         <param><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>catalog</name></decl></param>,
                         <param><decl><type><name>apr_array_header_t</name> *</type><name>segments</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_repos_rel_path</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>new_catalog</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>history_as_mergeinfo</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__mergeinfo_from_segments</name><argument_list>(<argument><expr>&amp;<name>history_as_mergeinfo</name></expr></argument>,
                                              <argument><expr><name>segments</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>catalog</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>mergeinfo</name></decl>, <decl><type ref="prev"/><name>filtered_mergeinfo</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>mergeinfo</name> = <name>val</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_intersect</name><argument_list>(<argument><expr>&amp;<name>filtered_mergeinfo</name></expr></argument>,
                                      <argument><expr><name>mergeinfo</name></expr></argument>,
                                      <argument><expr><name>history_as_mergeinfo</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Don't put an empty hash in the catalog for the root of the source.
         An empty hash represents empty mergeinfo as opposed to *no*
         mergeinfo.  We need to do this for the root of the source because
         if calculate_left_hand_side() sees *any* mergeinfo left on the source
         it will interpret this as coming from the target, when in fact
         nothing has been merged from the target to the source.  This
         ultimately causes calculate_left_hand_side() to follow the wrong code
         path and abort.  We only do this for the root of the source however,
         subtrees with mergeinfo cannot lose all mergeinfo as that would mean
         they are inheriting from the root, which isn't the case.  See here
         for more details:
         http://subversion.tigris.org/servlets/ReadMsg?list=dev&amp;msgNo=136908
         */</comment>
      <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>filtered_mergeinfo</name></expr></argument>)</argument_list></call>
          || <call><name>strcmp</name><argument_list>(<argument><expr><name>source_repos_rel_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>new_catalog</name></expr></argument>,
                     <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                     <argument><expr><name>filtered_mergeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

  <expr_stmt><expr>*<name>catalog_p</name> = <name>new_catalog</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* TODO(reint): Document.

   RA_SESSION must be opened at the repository root. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>calculate_left_hand_side</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>url_left</name></decl></param>,
                         <param><decl><type><name>svn_revnum_t</name> *</type><name>rev_left</name></decl></param>,
                         <param><decl><type><name>svn_mergeinfo_t</name> *</type><name>source_mergeinfo_p</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_repos_rel_path</name></decl></param>,
                         <param><decl><type><name>svn_revnum_t</name></type> <name>target_rev</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_repos_rel_path</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_repos_root</name></decl></param>,
                         <param><decl><type><name>svn_revnum_t</name></type> <name>source_rev</name></decl></param>,
                         <param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                         <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>segments</name></decl>;</decl_stmt> <comment type="block">/* array of (svn_location_segment_t *) */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>have_mergeinfo_for_source</name> <init>= <expr><name>FALSE</name></expr></init>,
    <name>have_mergeinfo_for_descendants</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>mergeinfo_catalog</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>source_repos_rel_path_as_array</name>
    <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the history (segments) for the target */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__repos_location_segments</name><argument_list>(<argument><expr>&amp;<name>segments</name></expr></argument>,
                                              <argument><expr><name>ra_session</name></expr></argument>,
                                              <argument><expr><name>target_repos_rel_path</name></expr></argument>,
                                              <argument><expr><name>target_rev</name></expr></argument>, <argument><expr><name>target_rev</name></expr></argument>,
                                              <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                              <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the mergeinfo from the source, including its descendants. */</comment>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>source_repos_rel_path_as_array</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>
    = <name>source_repos_rel_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_mergeinfo</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>mergeinfo_catalog</name></expr></argument>,
                               <argument><expr><name>source_repos_rel_path_as_array</name></expr></argument>, <argument><expr><name>source_rev</name></expr></argument>,
                               <argument><expr><name>svn_mergeinfo_inherited</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>mergeinfo_catalog</name></expr>)</condition><then>
    <expr_stmt><expr><name>mergeinfo_catalog</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Filter mergeinfo_catalog so that all of the ranges come from
     the target's history */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_irrelevant_ranges</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_catalog</name></expr></argument>,
                                   <argument><expr><name>mergeinfo_catalog</name></expr></argument>,
                                   <argument><expr><name>segments</name></expr></argument>,
                                   <argument><expr><name>source_repos_rel_path</name></expr></argument>,
                                   <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Elide! */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__elide_mergeinfo_catalog</name><argument_list>(<argument><expr><name>mergeinfo_catalog</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* See which case we fall into: */</comment>
  <comment type="block">/* TODO(reint): make sure we look things up with keys that start
     with slash.  This may not be as simple as it sounds, since
     source_repos_rel_path is also used as the component argument to
     (e.g.) svn_path_join(), which expects the component to *not*
     start with a slash (or at least, it will behave in a way we
     probably don't want if the component *does* start with slash).
  */</comment>
  <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mergeinfo_catalog</name></expr></argument>, <argument><expr><name>source_repos_rel_path</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>have_mergeinfo_for_source</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>mergeinfo_catalog</name></expr></argument>)</argument_list></call> &gt; 1 ||
      (! <name>have_mergeinfo_for_source</name> &amp;&amp; <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>mergeinfo_catalog</name></expr></argument>)</argument_list></call> == 1)</expr>)</condition><then>
    <expr_stmt><expr><name>have_mergeinfo_for_descendants</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>! <name>have_mergeinfo_for_source</name> &amp;&amp; ! <name>have_mergeinfo_for_descendants</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* TODO(reint): Make sure we're not fetching location segments
         over and over. */</comment>
      <comment type="block">/* We never merged to the source.  Just return the branch point. */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yc_ancestor_path</name></decl>,
        *<decl><type ref="prev"/><name>source_url</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr><name>source_repos_rel_path</name></expr></argument>,
                                    <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init>,
        *<name>target_url</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr><name>target_repos_rel_path</name></expr></argument>,
                                    <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_youngest_common_ancestor</name><argument_list>(<argument><expr>&amp;<name>yc_ancestor_path</name></expr></argument>,
                                                       <argument><expr><name>rev_left</name></expr></argument>,
                                                       <argument><expr><name>source_url</name></expr></argument>, <argument><expr><name>source_rev</name></expr></argument>,
                                                       <argument><expr><name>target_url</name></expr></argument>, <argument><expr><name>target_rev</name></expr></argument>,
                                                       <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!(<name>yc_ancestor_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr>*<name>rev_left</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s@%ld' must be ancestrally related to "
                                   "'%s@%ld'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>source_url</name></expr></argument>, <argument><expr><name>source_rev</name></expr></argument>,
                                 <argument><expr><name>target_url</name></expr></argument>, <argument><expr><name>target_rev</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr>*<name>url_left</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr><name>yc_ancestor_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>source_mergeinfo_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <name>have_mergeinfo_for_descendants</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Easy case: return the last path/rev in the mergeinfo. */</comment>
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>source_mergeinfo</name> <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mergeinfo_catalog</name></expr></argument>,
                                                      <argument><expr><name>source_repos_rel_path</name></expr></argument>,
                                                      <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>i</name> = <name><name>segments</name>-&gt;<name>nelts</name></name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name>
            <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_location_segment_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Ignore gaps in history. */</comment>
          <if>if <condition>(<expr>!<name><name>segment</name>-&gt;<name>path</name></name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <expr_stmt><expr><name>rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>source_mergeinfo</name></expr></argument>,
                                   <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>segment</name>-&gt;<name>path</name></name></expr></argument>,
                                               <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>rangelist</name> != <name>NULL</name> &amp;&amp; <name><name>rangelist</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>last_range</name>
                <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name><name>rangelist</name>-&gt;<name>nelts</name></name> - 1</expr></argument>,
                                <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr>*<name>rev_left</name> = <name><name>last_range</name>-&gt;<name>end</name></name></expr>;</expr_stmt>
              <expr_stmt><expr>*<name>url_left</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr><name><name>segment</name>-&gt;<name>path</name></name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr>*<name>source_mergeinfo_p</name> = <call><name>svn_mergeinfo_dup</name><argument_list>(<argument><expr><name>source_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
            }</block></then></if>
        }</block></for>
      <comment type="block">/* We only got here because we had mergeinfo for the source; if
         there were no segments, then our logic was wrong. */</comment>
      <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_url</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>full_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>full_url</name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name>full_url</name></expr></argument>, <argument><expr><name>source_repos_rel_path</name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr>"Cannot reintegrate from '%s' yet:\n"
                               "Some revisions have been merged under it "
                               "that have not been merged\n"
                               "into the reintegration target; "
                               "merge them first, then retry."</expr></argument>, <argument><expr><name>full_url</name></expr></argument>)</argument_list></call></expr>;</return>
      <comment type="block">/* TODO(reint): It would be even better to print out mergeinfo_catalog
         here.  Is there a helper function for that? */</comment> 
    }</block></else></if></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_client_merge_reintegrate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>peg_revision</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>merge_options</name></decl></param>,
                             <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>wc_repos_root</name></decl>, *<decl><type ref="prev"/><name>source_repos_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>working_revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_repos_rel_path</name></decl>, *<decl><type ref="prev"/><name>target_repos_rel_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>yc_ancestor_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>yc_ancestor_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url1</name></decl>, *<decl><type ref="prev"/><name>url2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev1</name></decl>, <decl><type ref="prev"/><name>rev2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>source_mergeinfo</name></decl>;</decl_stmt>


  <comment type="block">/* Open an admistrative session with the working copy. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                 <argument><expr>(! <name>dry_run</name>)</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                 <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fetch the target's entry. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                  <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure we're dealing with a real URL. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client_url_from_path</name><argument_list>(<argument><expr>&amp;<name>url2</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>url2</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ENTRY_MISSING_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' has no URL"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Determine the working copy target's repository root URL. */</comment>
  <expr_stmt><expr><name><name>working_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_working</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_repos_root</name><argument_list>(<argument><expr>&amp;<name>wc_repos_root</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                     <argument><expr>&amp;<name>working_revision</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open an RA session to our source URL, and determine its root URL. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name><argument_list>(<argument><expr>&amp;<name>ra_session</name></expr></argument>, <argument><expr><name>wc_repos_root</name></expr></argument>,
                                               <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>source_repos_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* source_repos_root and wc_repos_root are required to be the same,
     as mergeinfo doesn't come into play for cross-repository merging. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr><name>wc_repos_root</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_UNRELATED_RESOURCES</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' must be from the same repository as "
                               "'%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>ensure_wc_reflects_repository_subtree</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* As the WC tree is "pure", use its last-updated-to revision as
     the default revision for the left side of our merge, since that's
     what the repository sub-tree is required to be up to date with
     (with regard to the WC). */</comment>
  <expr_stmt><expr><name>rev1</name> = <name><name>entry</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__path_relative_to_root</name><argument_list>(<argument><expr>&amp;<name>source_repos_rel_path</name></expr></argument>,
                                            <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                            <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__path_relative_to_root</name><argument_list>(<argument><expr>&amp;<name>target_repos_rel_path</name></expr></argument>, 
                                            <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>wc_repos_root</name></expr></argument>,
                                            <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_revision_number</name><argument_list>(<argument><expr>&amp;<name>rev2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>,
                                          <argument><expr><name>source_repos_rel_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>calculate_left_hand_side</name><argument_list>(<argument><expr>&amp;<name>url1</name></expr></argument>, <argument><expr>&amp;<name>rev1</name></expr></argument>, <argument><expr>&amp;<name>source_mergeinfo</name></expr></argument>,
                                   <argument><expr><name>target_repos_rel_path</name></expr></argument>,
                                   <argument><expr><name>rev1</name></expr></argument>,
                                   <argument><expr><name>source_repos_rel_path</name></expr></argument>,
                                   <argument><expr><name>source_repos_root</name></expr></argument>,
                                   <argument><expr><name>rev2</name></expr></argument>,
                                   <argument><expr><name>ra_session</name></expr></argument>,
                                   <argument><expr><name>ctx</name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_youngest_common_ancestor</name><argument_list>(<argument><expr>&amp;<name>yc_ancestor_path</name></expr></argument>,
                                                   <argument><expr>&amp;<name>yc_ancestor_rev</name></expr></argument>,
                                                   <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>rev2</name></expr></argument>,
                                                   <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>rev1</name></expr></argument>,
                                                   <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!(<name>yc_ancestor_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>yc_ancestor_rev</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_NOT_READY_TO_MERGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s@%ld' must be ancestrally related to "
                               "'%s@%ld'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>rev1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>rev2</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>rev1</name> &gt; <name>yc_ancestor_rev</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Have we actually merged anything to the source from the
         target?  If so, make sure we've merged a contiguous
         prefix. */</comment>
      <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>opt_rev1</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>target_mergeinfo</name></decl>, <decl><type ref="prev"/><name>deleted_mergeinfo</name></decl>, <decl><type ref="prev"/><name>added_mergeinfo</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>opt_rev1</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>opt_rev1</name>.<name>value</name>.<name>number</name></name> = <name>rev1</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_history_as_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>target_mergeinfo</name></expr></argument>,
                                                   <argument><expr><name><name>entry</name>-&gt;<name>url</name></name></expr></argument>,
                                                   <argument><expr>&amp;<name>opt_rev1</name></expr></argument>,
                                                   <argument><expr><name>rev1</name></expr></argument>,
                                                   <argument><expr><name>yc_ancestor_rev</name> + 1</expr></argument>,
                                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* ### TODO(reint): Consider CONSIDER_INHERITANCE parameter... */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_diff</name><argument_list>(<argument><expr>&amp;<name>deleted_mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>added_mergeinfo</name></expr></argument>,
                                 <argument><expr><name>target_mergeinfo</name></expr></argument>, <argument><expr><name>source_mergeinfo</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>ensure_all_missing_ranges_are_phantoms</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>,
                                                     <argument><expr><name>deleted_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Left side: trunk@youngest-trunk-rev-merged-to-branch-at-specified-peg-rev
   * Right side: branch@specified-peg-revision */</comment>

  <comment type="block">/* Do the real merge! */</comment>
  <comment type="block">/* ### TODO(reint): Make sure that one isn't the same line ancestor
     ### of the other (what's erroneously referred to as "ancestrally
     ### related" in this source file).  We can merge to trunk without
     ### implementing this. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_cousins_and_supplement_mergeinfo</name><argument_list>(<argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, 
                                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>,
                                                 <argument><expr><name>url1</name></expr></argument>, <argument><expr><name>rev1</name></expr></argument>, <argument><expr><name>url2</name></expr></argument>, <argument><expr><name>rev2</name></expr></argument>,
                                                 <argument><expr><name>yc_ancestor_rev</name></expr></argument>,
                                                 <argument><expr><name>source_repos_root</name></expr></argument>,
                                                 <argument><expr><name>wc_repos_root</name></expr></argument>,
                                                 <argument><expr><name>svn_depth_infinity</name></expr></argument>, 
                                                 <argument><expr><name>FALSE</name></expr></argument>,
                                                 <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>,
                                                 <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Shutdown the administrative session. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_client_merge_peg3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>ranges_to_merge</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>peg_revision</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                      <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>record_only</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>merge_options</name></decl></param>,
                      <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>URL</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>merge_sources</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>wc_repos_root</name></decl>, *<decl><type ref="prev"/><name>source_repos_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>working_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>sesspool</name></decl>;</decl_stmt>

  <comment type="block">/* No ranges to merge?  No problem. */</comment>
  <if>if <condition>(<expr><name><name>ranges_to_merge</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Open an admistrative session with the working copy. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                 <argument><expr>(! <name>dry_run</name>)</expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                 <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fetch the target's entry. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                  <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure we're dealing with a real URL. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client_url_from_path</name><argument_list>(<argument><expr>&amp;<name>URL</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>URL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ENTRY_MISSING_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' has no URL"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Determine the working copy target's repository root URL. */</comment>
  <expr_stmt><expr><name><name>working_rev</name>.<name>kind</name></name> = <name>svn_opt_revision_working</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_repos_root</name><argument_list>(<argument><expr>&amp;<name>wc_repos_root</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>,
                                     <argument><expr>&amp;<name>working_rev</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open an RA session to our source URL, and determine its root URL. */</comment>
  <expr_stmt><expr><name>sesspool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name><argument_list>(<argument><expr>&amp;<name>ra_session</name></expr></argument>,
                                               <argument><expr><name>URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>source_repos_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Normalize our merge sources. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>normalize_merge_sources</name><argument_list>(<argument><expr>&amp;<name>merge_sources</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>URL</name></expr></argument>,
                                  <argument><expr><name>source_repos_root</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>,
                                  <argument><expr><name>ranges_to_merge</name></expr></argument>, <argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We're done with our little RA session. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>sesspool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Do the real merge!  (We say with confidence that our merge
     sources are both ancestral and related.) */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_merge</name><argument_list>(<argument><expr><name>merge_sources</name></expr></argument>, <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                   <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                   <argument><expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>wc_repos_root</name></expr></argument>, <argument><expr><name>source_repos_root</name></expr></argument>)</argument_list></call> == 0)</expr></argument>,
                   <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>, <argument><expr><name>record_only</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>,
                   <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Shutdown the administrative session. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_client_merge_peg2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision1</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision2</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>peg_revision</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>merge_options</name></decl></param>,
                      <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_opt_revision_range_t</name></type> <name>range</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ranges_to_merge</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>range</name>.<name>start</name></name> = *<name>revision1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>range</name>.<name>end</name></name> = *<name>revision2</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>ranges_to_merge</name></expr></argument>, <argument><expr><name>svn_opt_revision_range_t</name> *</expr></argument>)</argument_list></call> = &amp;<name>range</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_client_merge_peg3</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>ranges_to_merge</name></expr></argument>,
                               <argument><expr><name>peg_revision</name></expr></argument>,
                               <argument><expr><name>target_wcpath</name></expr></argument>,
                               <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>,
                               <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_merge_peg</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision1</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>revision2</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_opt_revision_t</name> *</type><name>peg_revision</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_wcpath</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>force</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                     <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_client_merge_peg2</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>revision1</name></expr></argument>, <argument><expr><name>revision2</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>,
                               <argument><expr><name>target_wcpath</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>ignore_ancestry</name></expr></argument>, <argument><expr><name>force</name></expr></argument>,
                               <argument><expr><name>dry_run</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
