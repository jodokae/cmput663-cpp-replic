<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_client/commit_util.c"><comment type="block">/*
 * commit_util.c:  Driver for the WC commit process.
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<comment type="block">/* ==================================================================== */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_iter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>  <comment type="block">/* for qsort() */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_wc_private.h"</cpp:file></cpp:include>

<comment type="block">/*** Uncomment this to turn on commit driver debugging. ***/</comment>
<comment type="block">/*
#define SVN_CLIENT_COMMIT_DEBUG
*/</comment>


<escape char="0xc"/>
<comment type="block">/*** Harvesting Commit Candidates ***/</comment>


<comment type="block">/* Add a new commit candidate (described by all parameters except
   `COMMITTABLES') to the COMMITTABLES hash.  All of the commit item's
   members are allocated out of the COMMITTABLES hash pool. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_committable</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>committables</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
                <param><decl><type><name>apr_byte_t</name></type> <name>state_flags</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>committables</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_name</name> <init>= <expr><name>SVN_CLIENT__SINGLE_REPOS_NAME</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>array</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>new_item</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity checks. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>path</name> &amp;&amp; <name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### todo: Get the canonical repository for this item, which will
     be the real key for the COMMITTABLES hash, instead of the above
     bogosity. */</comment>
  <expr_stmt><expr><name>array</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>committables</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* E-gads!  There is no array for this repository yet!  Oh, no
     problem, we'll just create (and add to the hash) one. */</comment>
  <if>if <condition>(<expr><name>array</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>array</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>committables</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Now update pointer values, ensuring that their allocations live
     in POOL. */</comment>
  <expr_stmt><expr><call><name>svn_client_commit_item_create</name><argument_list>(<argument><expr>(const <name>svn_client_commit_item3_t</name> **) &amp;<name>new_item</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_item</name>-&gt;<name>path</name></name>           = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_item</name>-&gt;<name>kind</name></name>           = <name>kind</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_item</name>-&gt;<name>url</name></name>            = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_item</name>-&gt;<name>revision</name></name>       = <name>revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_item</name>-&gt;<name>copyfrom_url</name></name>   = <name>copyfrom_url</name>
    ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_item</name>-&gt;<name>copyfrom_rev</name></name>   = <name>copyfrom_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_item</name>-&gt;<name>state_flags</name></name>    = <name>state_flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_item</name>-&gt;<name>incoming_prop_changes</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>,
                                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_prop_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, add the commit item to the array. */</comment>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>svn_client_commit_item3_t</name> *</expr></argument>)</argument_list></call> = <name>new_item</name></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_prop_mods</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>props_changed</name></decl></param>,
                <param><decl><type><name>svn_boolean_t</name> *</type><name>eol_prop_changed</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prop_mods</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>eol_prop_changed</name> = *<name>props_changed</name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_props_modified_p</name><argument_list>(<argument><expr><name>props_changed</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! *<name>props_changed</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_get_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>prop_mods</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>prop_mods</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>prop_mod</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>prop_mods</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>prop_mod</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_EOL_STYLE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr>*<name>eol_prop_changed</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
    }</block></for>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* If there is a commit item for PATH in COMMITTABLES, return it, else
   return NULL.  Use POOL for temporary allocation only. */</comment>
<function><type><specifier>static</specifier> <name>svn_client_commit_item3_t</name> *</type>
<name>look_up_committable</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>committables</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>committables</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>these_committables</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>these_committables</name> = <name>val</name></expr>;</expr_stmt>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>these_committables</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>this_committable</name>
            <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>these_committables</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                            <argument><expr><name>svn_client_commit_item3_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>this_committable</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><name>this_committable</name></expr>;</return></then></if>
        }</block></for>
    }</block></for>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements the svn_wc_entry_callbacks_t-&gt;found_entry interface. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_lock_token</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>walk_baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>lock_tokens</name> <init>= <expr><name>walk_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>token_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>lock_tokens</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* I want every lock-token I can get my dirty hands on!
     If this entry is switched, so what.  We will send an irrelevant lock
     token. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>url</name></name> &amp;&amp; <name><name>entry</name>-&gt;<name>lock_token</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>token_pool</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                 <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>token_pool</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>lock_token</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Entry walker callback table to add lock tokens in an hierarchy. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_wc_entry_callbacks2_t</name></type> <name>add_tokens_callbacks</name> <init>= <expr><block>{
  <expr><name>add_lock_token</name></expr>,
  <expr><name>svn_client__default_walker_error_handler</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Recursively search for commit candidates in (and under) PATH (with
   entry ENTRY and ancestry URL), and add those candidates to
   COMMITTABLES.  If in ADDS_ONLY modes, only new additions are
   recognized.  COPYFROM_URL is the default copyfrom-url for children
   of copied directories.

   DEPTH indicates how to treat files and subdirectories of PATH when
   PATH is itself a directory; see svn_client__harvest_committables()
   for its behavior.

   Lock tokens of candidates will be added to LOCK_TOKENS, if
   non-NULL.  JUST_LOCKED indicates whether to treat non-modified items with
   lock tokens as commit candidates.

   If in COPY_MODE, treat the entry as if it is destined to be added
   with history as URL, and add 'deleted' entries to COMMITTABLES as
   items to delete in the copy destination.

   If CHANGELISTS is non-NULL, it is a hash whose keys are const char *
   changelist names used as a restrictive filter
   when harvesting committables; that is, don't add a path to
   COMMITTABLES unless it's a member of one of those changelists.

   If CTX-&gt;CANCEL_FUNC is non-null, call it with CTX-&gt;CANCEL_BATON to see
   if the user has cancelled the operation.

   Any items added to COMMITTABLES are allocated from the COMITTABLES
   hash pool, not POOL.  POOL is used for temporary allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>harvest_committables</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>committables</name></decl></param>,
                     <param><decl><type><name>apr_hash_t</name> *</type><name>lock_tokens</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>parent_entry</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>adds_only</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>copy_mode</name></decl></param>,
                     <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>just_locked</name></decl></param>,
                     <param><decl><type><name>apr_hash_t</name> *</type><name>changelists</name></decl></param>,
                     <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_mod</name> <init>= <expr><name>FALSE</name></expr></init>, <name>prop_mod</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_byte_t</name></type> <name>state_flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>tc</name></decl>, <decl><type ref="prev"/><name>pc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cf_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>cf_rev</name> <init>= <expr><name><name>entry</name>-&gt;<name>copyfrom_rev</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>propval</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_special</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>token_pool</name> <init>= <expr>(<name>lock_tokens</name> ? <call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>lock_tokens</name></expr></argument>)</argument_list></call>
                            : <name>NULL</name>)</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Early out if the item is already marked as committable. */</comment>
  <if>if <condition>(<expr><call><name>look_up_committable</name><argument_list>(<argument><expr><name>committables</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>ctx</name>-&gt;<name>cancel_func</name></name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Make P_PATH the parent dir. */</comment>
  <expr_stmt><expr><name>p_path</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return error on unknown path kinds.  We check both the entry and
     the node itself, since a path might have changed kind since its
     entry was written. */</comment>
  <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name>) &amp;&amp; (<name><name>entry</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_NODE_UNKNOWN_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unknown entry kind for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_special_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr>&amp;<name>is_special</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>(<name>kind</name> != <name>svn_node_file</name>)
      &amp;&amp; (<name>kind</name> != <name>svn_node_dir</name>)
      &amp;&amp; (<name>kind</name> != <name>svn_node_none</name>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_NODE_UNKNOWN_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unknown entry kind for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Verify that the node's type has not changed before attempting to
     commit. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_prop_get</name><argument_list>(<argument><expr>&amp;<name>propval</name></expr></argument>, <argument><expr><name>SVN_PROP_SPECIAL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>(((! <name>propval</name>) &amp;&amp; (<name>is_special</name>))
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYMLINK</name></cpp:ifdef>
       || ((<name>propval</name>) &amp;&amp; (! <name>is_special</name>))
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SYMLINK */</comment>
       ) &amp;&amp; (<name>kind</name> != <name>svn_node_none</name>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_NODE_UNEXPECTED_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Entry '%s' has unexpectedly changed special status"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Get a fully populated entry for PATH if we can, and check for
     conflicts. If this is a directory ... */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ... then try to read its own entries file so we have a full
         entry for it (we were going to have to do this eventually to
         recurse anyway, so... ) */</comment>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>e</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>copy_mode</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we failed to get an entries hash for the directory, no
         sweat.  Cleanup and move along.  */</comment>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>entries</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* If we got an entries hash, and the "this dir" entry is
         present, override our current ENTRY with it, and check for
         conflicts. */</comment>
      <if>if <condition>(<expr>(<name>entries</name>) &amp;&amp; ((<name>e</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>,
                                          <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>))</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>entry</name> = <name>e</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_conflicted_p</name><argument_list>(<argument><expr>&amp;<name>tc</name></expr></argument>, <argument><expr>&amp;<name>pc</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>

      <comment type="block">/* No new entry?  Just check the parent's pointer for
         conflicts. */</comment>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_conflicted_p</name><argument_list>(<argument><expr>&amp;<name>tc</name></expr></argument>, <argument><expr>&amp;<name>pc</name></expr></argument>, <argument><expr><name>p_path</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>

  <comment type="block">/* If this is not a directory, check for conflicts using the
     parent's path. */</comment>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_conflicted_p</name><argument_list>(<argument><expr>&amp;<name>tc</name></expr></argument>, <argument><expr>&amp;<name>pc</name></expr></argument>, <argument><expr><name>p_path</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Bail now if any conflicts exist for the ENTRY. */</comment>
  <if>if <condition>(<expr><name>tc</name> || <name>pc</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Paths in conflict which are not part of our changelist should
         be ignored. */</comment>
      <if>if <condition>(<expr><call><name>SVN_WC__CL_MATCH</name><argument_list>(<argument><expr><name>changelists</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_WC_FOUND_CONFLICT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Aborting commit: '%s' remains in conflict"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* If we have our own URL, and we're NOT in COPY_MODE, it wins over
     the telescoping one(s).  In COPY_MODE, URL will always be the
     URL-to-be of the copied item.  */</comment>
  <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>url</name></name>) &amp;&amp; (! <name>copy_mode</name>)</expr>)</condition><then>
    <expr_stmt><expr><name>url</name> = <name><name>entry</name>-&gt;<name>url</name></name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Check for the deletion case.  Deletes occur only when not in
     "adds-only mode".  We use the SVN_CLIENT_COMMIT_ITEM_DELETE flag
     to represent two slightly different conditions:

     - The entry is marked as 'deleted'.  When copying a mixed-rev wc,
       we still need to send a delete for that entry, otherwise the
       object will wrongly exist in the repository copy.

     - The entry is scheduled for deletion or replacement, which case
       we need to send a delete either way.
  */</comment>
  <if>if <condition>(<expr>(! <name>adds_only</name>)
      &amp;&amp; ((<name><name>entry</name>-&gt;<name>deleted</name></name> &amp;&amp; <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_normal</name>)
          || (<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name>)
          || (<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name>))</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>state_flags</name> |= <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Check for the trivial addition case.  Adds can be explicit
     (schedule == add) or implicit (schedule == replace ::= delete+add).
     We also note whether or not this is an add with history here.  */</comment>
  <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_add</name>)
      || (<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>state_flags</name> |= <name>SVN_CLIENT_COMMIT_ITEM_ADD</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>copyfrom_url</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>state_flags</name> |= <name>SVN_CLIENT_COMMIT_ITEM_IS_COPY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cf_url</name> = <name><name>entry</name>-&gt;<name>copyfrom_url</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>adds_only</name> = <name>FALSE</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>adds_only</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* Check for the copied-subtree addition case.  */</comment>
  <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>copied</name></name> || <name>copy_mode</name>)
      &amp;&amp; (! <name><name>entry</name>-&gt;<name>deleted</name></name>)
      &amp;&amp; (<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_normal</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>p_rev</name> <init>= <expr><name><name>entry</name>-&gt;<name>revision</name></name> - 1</expr></init></decl>;</decl_stmt> <comment type="block">/* arbitrary non-equal value */</comment>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>wc_root</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If this is not a WC root then its parent's revision is
         admissible for comparative purposes. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_is_wc_root</name><argument_list>(<argument><expr>&amp;<name>wc_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>wc_root</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>parent_entry</name></expr>)</condition><then>
            <expr_stmt><expr><name>p_rev</name> = <name><name>parent_entry</name>-&gt;<name>revision</name></name></expr>;</expr_stmt></then></if>
        }</block></then>
      <else>else <if>if <condition>(<expr>! <name>copy_mode</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_WC_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Did not expect '%s' to be a working copy root"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

      <comment type="block">/* If the ENTRY's revision differs from that of its parent, we
         have to explicitly commit ENTRY as a copy. */</comment>
      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>revision</name></name> != <name>p_rev</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>state_flags</name> |= <name>SVN_CLIENT_COMMIT_ITEM_ADD</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>state_flags</name> |= <name>SVN_CLIENT_COMMIT_ITEM_IS_COPY</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>adds_only</name> = <name>FALSE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cf_rev</name> = <name><name>entry</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>copy_mode</name></expr>)</condition><then>
            <expr_stmt><expr><name>cf_url</name> = <name><name>entry</name>-&gt;<name>url</name></name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><name>copyfrom_url</name></expr>)</condition><then>
            <expr_stmt><expr><name>cf_url</name> = <name>copyfrom_url</name></expr>;</expr_stmt></then>
          <else>else <comment type="block">/* ### See issue #830 */</comment>
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Commit item '%s' has copy flag but no copyfrom URL"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* If an add is scheduled to occur, dig around for some more
     information about it. */</comment>
  <if>if <condition>(<expr><name>state_flags</name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_ADD</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>working_kind</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eol_prop_changed</name></decl>;</decl_stmt>

      <comment type="block">/* First of all, the working file or directory must exist.
         See issue #3198. */</comment>  
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>working_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>working_kind</name> == <name>svn_node_none</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_WC_PATH_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is scheduled for addition, but is missing"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <comment type="block">/* See if there are property modifications to send. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_prop_mods</name><argument_list>(<argument><expr>&amp;<name>prop_mod</name></expr></argument>, <argument><expr>&amp;<name>eol_prop_changed</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                              <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Regular adds of files have text mods, but for copies we have
         to test for textual mods.  Directories simply don't have text! */</comment>
      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Check for text mods.  If EOL_PROP_CHANGED is TRUE, then
             we need to force a translated byte-for-byte comparison
             against the text-base so that a timestamp comparison
             won't bail out early.  Depending on how the svn:eol-style
             prop was changed, we might have to send new text to the
             server to match the new newline style.  */</comment>
          <if>if <condition>(<expr><name>state_flags</name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_IS_COPY</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_text_modified_p</name><argument_list>(<argument><expr>&amp;<name>text_mod</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                           <argument><expr><name>eol_prop_changed</name></expr></argument>,
                                           <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>text_mod</name> = <name>TRUE</name></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></then>

  <comment type="block">/* Else, if we aren't deleting this item, we'll have to look for
     local text or property mods to determine if the path might be
     committable. */</comment>
  <else>else <if>if <condition>(<expr>! (<name>state_flags</name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eol_prop_changed</name></decl>;</decl_stmt>

      <comment type="block">/* See if there are property modifications to send. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_prop_mods</name><argument_list>(<argument><expr>&amp;<name>prop_mod</name></expr></argument>, <argument><expr>&amp;<name>eol_prop_changed</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                              <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check for text mods on files.  If EOL_PROP_CHANGED is TRUE,
         then we need to force a translated byte-for-byte comparison
         against the text-base so that a timestamp comparison won't
         bail out early.  Depending on how the svn:eol-style prop was
         changed, we might have to send new text to the server to
         match the new newline style.  */</comment>
      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_text_modified_p</name><argument_list>(<argument><expr>&amp;<name>text_mod</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>eol_prop_changed</name></expr></argument>,
                                       <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if></else></if>

  <comment type="block">/* Set text/prop modification flags accordingly. */</comment>
  <if>if <condition>(<expr><name>text_mod</name></expr>)</condition><then>
    <expr_stmt><expr><name>state_flags</name> |= <name>SVN_CLIENT_COMMIT_ITEM_TEXT_MODS</name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>prop_mod</name></expr>)</condition><then>
    <expr_stmt><expr><name>state_flags</name> |= <name>SVN_CLIENT_COMMIT_ITEM_PROP_MODS</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* If the entry has a lock token and it is already a commit candidate,
     or the caller wants unmodified locked items to be treated as
     such, note this fact. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>lock_token</name></name>
      &amp;&amp; (<name>state_flags</name> || <name>just_locked</name>)</expr>)</condition><then>
    <expr_stmt><expr><name>state_flags</name> |= <name>SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now, if this is something to commit, add it to our list. */</comment>
  <if>if <condition>(<expr><name>state_flags</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>SVN_WC__CL_MATCH</name><argument_list>(<argument><expr><name>changelists</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* Finally, add the committable item. */</comment>
          <expr_stmt><expr><call><name>add_committable</name><argument_list>(<argument><expr><name>committables</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>url</name></expr></argument>,
                          <argument><expr><name><name>entry</name>-&gt;<name>revision</name></name></expr></argument>,
                          <argument><expr><name>cf_url</name></expr></argument>,
                          <argument><expr><name>cf_rev</name></expr></argument>,
                          <argument><expr><name>state_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>lock_tokens</name> &amp;&amp; <name><name>entry</name>-&gt;<name>lock_token</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>token_pool</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                         <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>token_pool</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>lock_token</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* For directories, recursively handle each entry according to depth
     (except when the directory is being deleted, unless the deletion
     is part of a replacement ... how confusing).  */</comment>
  <if>if <condition>(<expr><name>entries</name> &amp;&amp; (<name>depth</name> &gt; <name>svn_depth_empty</name>)
      &amp;&amp; ((! (<name>state_flags</name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name>))
          || (<name>state_flags</name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_ADD</name>))</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>this_entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>loop_pool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Loop over all other entries in this directory, skipping the
         "this dir" entry. */</comment>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init>
           <condition><expr><name>hi</name></expr>;</condition>
           <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>used_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name_uri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>this_cf_url</name> <init>= <expr><name>cf_url</name> ? <name>cf_url</name> : <name>copyfrom_url</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name> <init>= <expr><name>adm_access</name></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Get the next entry.  Name is an entry name; value is an
             entry structure. */</comment>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>

          <comment type="block">/* Skip "this dir" */</comment>
          <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <expr_stmt><expr><name>this_entry</name> = <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>name_uri</name> = <call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>this_cf_url</name></expr>)</condition><then>
            <expr_stmt><expr><name>this_cf_url</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>this_cf_url</name></expr></argument>, <argument><expr><name>name_uri</name></expr></argument>, <argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* We'll use the entry's URL if it has one and if we aren't
             in copy_mode, else, we'll just extend the parent's URL
             with the entry's basename.  */</comment>
          <if>if <condition>(<expr>(! <name><name>this_entry</name>-&gt;<name>url</name></name>) || (<name>copy_mode</name>)</expr>)</condition><then>
            <expr_stmt><expr><name>used_url</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>name_uri</name></expr></argument>, <argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* Recurse. */</comment>
          <if>if <condition>(<expr><name><name>this_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name>depth</name> &lt;= <name>svn_depth_files</name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* Don't bother with any of this if it's a directory
                     and depth says not to go there. */</comment>
                  <continue>continue;</continue>
                }</block></then>
              <else>else
                <block>{
                  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>lockerr</name></decl>;</decl_stmt>
                  <expr_stmt><expr><name>lockerr</name> = <call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                                <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <if>if <condition>(<expr><name>lockerr</name></expr>)</condition><then>
                    <block>{
                      <if>if <condition>(<expr><name><name>lockerr</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_NOT_LOCKED</name></expr>)</condition><then>
                        <block>{
                          <comment type="block">/* A missing, schedule-delete child dir is
                             allowable.  Just don't try to recurse. */</comment>
                          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>childkind</name></decl>;</decl_stmt>
                          <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>,
                                                               <argument><expr>&amp;<name>childkind</name></expr></argument>,
                                                               <argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                          <if>if <condition>(<expr>! <name>err</name>
                              &amp;&amp; (<name>childkind</name> == <name>svn_node_none</name>)
                              &amp;&amp; (<name><name>this_entry</name>-&gt;<name>schedule</name></name>
                                  == <name>svn_wc_schedule_delete</name>)</expr>)</condition><then>
                            <block>{
                              <if>if <condition>(<expr><call><name>SVN_WC__CL_MATCH</name><argument_list>(<argument><expr><name>changelists</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                                <block>{
                                  <expr_stmt><expr><call><name>add_committable</name><argument_list>(
                                    <argument><expr><name>committables</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>,
                                    <argument><expr><name><name>this_entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>used_url</name></expr></argument>,
                                    <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                    <argument><expr><name>SVN_CLIENT_COMMIT_ITEM_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>lockerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                  <continue>continue;</continue> <comment type="block">/* don't recurse! */</comment>
                                }</block></then></if>
                            }</block></then>
                          <else>else
                            <block>{
                              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                              <return>return <expr><name>lockerr</name></expr>;</return>
                            }</block></else></if>
                        }</block></then>
                      <else>else
                        <return>return <expr><name>lockerr</name></expr>;</return></else></if>
                    }</block></then></if>
                }</block></else></if>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><name>dir_access</name> = <name>adm_access</name></expr>;</expr_stmt>
            }</block></else></if>

          <block>{
            <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth_below_here</name> <init>= <expr><name>depth</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* If depth is svn_depth_files, then we must be recursing
               into a file, or else we wouldn't be here -- either way,
               svn_depth_empty is the right depth to use.  On the
               other hand, if depth is svn_depth_immediates, then we
               could be recursing into a directory or a file -- in
               which case svn_depth_empty is *still* the right depth
               to use.  I know that sounds bizarre (one normally
               expects to just do depth - 1) but it's correct. */</comment>
            <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_immediates</name>
                || <name>depth</name> == <name>svn_depth_files</name></expr>)</condition><then>
              <expr_stmt><expr><name>depth_below_here</name> = <name>svn_depth_empty</name></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>harvest_committables</name>
                    <argument_list>(<argument><expr><name>committables</name></expr></argument>, <argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>,
                     <argument><expr><name>used_url</name> ? <name>used_url</name> : <name><name>this_entry</name>-&gt;<name>url</name></name></expr></argument>,
                     <argument><expr><name>this_cf_url</name></expr></argument>,
                     <argument><expr><name>this_entry</name></expr></argument>,
                     <argument><expr><name>entry</name></expr></argument>,
                     <argument><expr><name>adds_only</name></expr></argument>,
                     <argument><expr><name>copy_mode</name></expr></argument>,
                     <argument><expr><name>depth_below_here</name></expr></argument>,
                     <argument><expr><name>just_locked</name></expr></argument>,
                     <argument><expr><name>changelists</name></expr></argument>,
                     <argument><expr><name>ctx</name></expr></argument>,
                     <argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block>
        }</block></for>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>loop_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Fetch lock tokens for descendants of deleted directories. */</comment>
  <if>if <condition>(<expr><name>lock_tokens</name> &amp;&amp; <name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>
      &amp;&amp; (<name>state_flags</name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_walk_entries3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr>&amp;<name>add_tokens_callbacks</name></expr></argument>,
                                   <argument><expr><name>lock_tokens</name></expr></argument>,
                                   <comment type="block">/* If a directory was deleted, everything
                                      under it would better be deleted too,
                                      so pass svn_depth_infinity not depth. */</comment>
                                   <argument><expr><name>svn_depth_infinity</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                   <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* BATON is an apr_hash_t * of harvested committables. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>validate_dangler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dangling_parent</name> <init>= <expr><name>key</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dangling_child</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The baton points to the committables hash */</comment>
  <if>if <condition>(<expr>! <call><name>look_up_committable</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>dangling_parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_ILLEGAL_TARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not under version control "
           "and is not part of the commit, "
           "yet its child '%s' is part of the commit"</expr></argument>)</argument_list></call></expr></argument>,
         <comment type="block">/* Probably one or both of these is an entry, but
            safest to local_stylize just in case. */</comment>
         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dangling_parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>dangling_child</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_client__harvest_committables</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>committables</name></decl></param>,
                                 <param><decl><type><name>apr_hash_t</name> **</type><name>lock_tokens</name></decl></param>,
                                 <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_dir</name></decl></param>,
                                 <param><decl><type><name>apr_array_header_t</name> *</type><name>targets</name></decl></param>,
                                 <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                                 <param><decl><type><name>svn_boolean_t</name></type> <name>just_locked</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>changelists</name></decl></param>,
                                 <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changelist_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* It's possible that one of the named targets has a parent that is
   * itself scheduled for addition or replacement -- that is, the
   * parent is not yet versioned in the repository.  This is okay, as
   * long as the parent itself is part of this same commit, either
   * directly, or by virtue of a grandparent, great-grandparent, etc,
   * being part of the commit.
   *
   * Since we don't know what's included in the commit until we've
   * harvested all the targets, we can't reliably check this as we
   * go.  So in `danglers', we record named targets whose parents
   * are unversioned, then after harvesting the total commit group, we
   * check to make sure those parents are included.
   *
   * Each key of danglers is an unversioned parent.  The (const char *)
   * value is one of that parent's children which is named as part of
   * the commit; the child is included only to make a better error
   * message.
   *
   * (The reason we don't bother to check unnamed -- i.e, implicit --
   * targets is that they can only join the commit if their parents
   * did too, so this situation can't arise for them.)
   */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>danglers</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Create the COMMITTABLES hash. */</comment>
  <expr_stmt><expr>*<name>committables</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* And the LOCK_TOKENS dito. */</comment>
  <expr_stmt><expr>*<name>lock_tokens</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we have a list of changelists, convert that into a hash with
     changelist keys. */</comment>
  <if>if <condition>(<expr><name>changelists</name> &amp;&amp; <name><name>changelists</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_from_cstring_keys</name><argument_list>(<argument><expr>&amp;<name>changelist_hash</name></expr></argument>, <argument><expr><name>changelists</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <do>do
    <block>{
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Add the relative portion of our full path (if there are no
         relative paths, TARGET will just be PARENT_DIR for a single
         iteration. */</comment>
      <expr_stmt><expr><name>target</name> = <call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>,
                                  <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>parent_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name><name>targets</name>-&gt;<name>nelts</name></name>
                                  ? <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>
                                  : <name>NULL</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* No entry?  This TARGET isn't even under version control! */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>,
                                        <argument><expr><name>target</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                     <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name><name>entry</name>-&gt;<name>url</name></name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_WC_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Entry for '%s' has no URL"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* We have to be especially careful around entries scheduled for
         addition or replacement. */</comment>
      <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_add</name>)
          || (<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>p_entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>parent_access</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>,
                                    <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_NOT_LOCKED</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>parent_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
                                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                                       <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
            <block>{
              <return>return <expr><name>err</name></expr>;</return>
            }</block></then></if></else></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>p_entry</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>,
                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name>p_entry</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_WC_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is scheduled for addition within unversioned parent"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <if>if <condition>(<expr>(<name><name>p_entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_add</name>)
              || (<name><name>p_entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name>)</expr>)</condition><then>
            <block>{
              <comment type="block">/* Copy the parent and target into pool; subpool
                 lasts only for this loop iteration, and we check
                 danglers after the loop is over. */</comment>
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>danglers</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                           <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

      <comment type="block">/* If this entry is marked as 'copied' but scheduled normally, then
         it should be the child of something else marked for addition with
         history. */</comment>
      <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>copied</name></name>) &amp;&amp; (<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_normal</name>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_ILLEGAL_TARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Entry for '%s' is marked as 'copied' but is not itself scheduled"
             "\nfor addition.  Perhaps you're committing a target that is\n"
             "inside an unversioned (or not-yet-versioned) directory?"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Handle our TARGET. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>,
                                  <argument><expr>(<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>
                                   ? <name>target</name>
                                   : <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call>)</expr></argument>,
                                  <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>harvest_committables</name><argument_list>(<argument><expr>*<name>committables</name></expr></argument>, <argument><expr>*<name>lock_tokens</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                   <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>,
                                   <argument><expr><name>just_locked</name></expr></argument>, <argument><expr><name>changelist_hash</name></expr></argument>,
                                   <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block>
  while <condition>(<expr><name>i</name> &lt; <name><name>targets</name>-&gt;<name>nelts</name></name></expr>)</condition>;</do>

  <comment type="block">/* Make sure that every path in danglers is part of the commit. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_iter_apr_hash</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><name>danglers</name></expr></argument>, <argument><expr><name>validate_dangler</name></expr></argument>, <argument><expr>*<name>committables</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<struct>struct <name>copy_committables_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>committables</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>harvest_copy_committables</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>void</name> *</type><name>item</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>copy_committables_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client__copy_pair_t</name> *</type><name>pair</name> <init>=
    <expr>*(<name>svn_client__copy_pair_t</name> **)<name>item</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>

  <comment type="block">/* Read the entry for this SRC. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name><name>pair</name>-&gt;<name>src</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the right access baton for this SRC. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name><name>pair</name>-&gt;<name>src</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                <argument><expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name><name>pair</name>-&gt;<name>src</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* Handle this SRC.  Because add_committable() uses the hash pool to
     allocate the new commit_item, we can safely use the iterpool here. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>harvest_committables</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>committables</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>pair</name>-&gt;<name>src</name></name></expr></argument>,
                               <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name><name>pair</name>-&gt;<name>dst</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>svn_depth_infinity</name></expr></argument>,
                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_client__get_copy_committables</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>committables</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>copy_pairs</name></decl></param>,
                                  <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                  <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>copy_committables_baton</name></type> <name>btn</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>committables</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>btn</name>.<name>adm_access</name></name> = <name>adm_access</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>btn</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>btn</name>.<name>committables</name></name> = *<name>committables</name></expr>;</expr_stmt>

  <comment type="block">/* For each copy pair, harvest the committables for that pair into the
     committables hash. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_iter_apr_array</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>copy_pairs</name></expr></argument>,
                             <argument><expr><name>harvest_copy_committables</name></expr></argument>, <argument><expr>&amp;<name>btn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>int</name></type> <name>svn_client__sort_commit_item_urls</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_client_commit_item3_t</name> *</type><name>item1</name>
    <init>= <expr>*((const <name>svn_client_commit_item3_t</name> * const *) <name>a</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_client_commit_item3_t</name> *</type><name>item2</name>
    <init>= <expr>*((const <name>svn_client_commit_item3_t</name> * const *) <name>b</name>)</expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>svn_path_compare_paths</name><argument_list>(<argument><expr><name><name>item1</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name><name>item2</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_client__condense_commit_items</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>base_url</name></decl></param>,
                                  <param><decl><type><name>apr_array_header_t</name> *</type><name>commit_items</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ci</name> <init>= <expr><name>commit_items</name></expr></init></decl>;</decl_stmt> <comment type="block">/* convenience */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>last_item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ci</name> &amp;&amp; <name><name>ci</name>-&gt;<name>nelts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sort our commit items by their URLs. */</comment>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>ci</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>ci</name>-&gt;<name>nelts</name></name></expr></argument>,
        <argument><expr><name><name>ci</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>svn_client__sort_commit_item_urls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Loop through the URLs, finding the longest usable ancestor common
     to all of them, and making sure there are no duplicate URLs.  */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ci</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client_commit_item3_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>url</name> = <name><name>item</name>-&gt;<name>url</name></name></expr>;</expr_stmt>

      <if>if <condition>(<expr>(<name>last_item</name>) &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>last_item</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_CLIENT_DUPLICATE_COMMIT_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot commit both '%s' and '%s' as they refer to the same URL"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>last_item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* In the first iteration, our BASE_URL is just our only
         encountered commit URL to date.  After that, we find the
         longest ancestor between the current BASE_URL and the current
         commit URL.  */</comment>
      <if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then>
        <expr_stmt><expr>*<name>base_url</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr>*<name>base_url</name> = <call><name>svn_path_get_longest_ancestor</name><argument_list>(<argument><expr>*<name>base_url</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <comment type="block">/* If our BASE_URL is itself a to-be-committed item, and it is
         anything other than an already-versioned directory with
         property mods, we'll call its parent directory URL the
         BASE_URL.  Why?  Because we can't have a file URL as our base
         -- period -- and all other directory operations (removal,
         addition, etc.) require that we open that directory's parent
         dir first.  */</comment>
      <comment type="block">/* ### I don't understand the strlen()s here, hmmm.  -kff */</comment>
      <if>if <condition>(<expr>(<call><name>strlen</name><argument_list>(<argument><expr>*<name>base_url</name></expr></argument>)</argument_list></call> == <call><name>strlen</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call>)
          &amp;&amp; (! ((<name><name>item</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)
                 &amp;&amp; <name><name>item</name>-&gt;<name>state_flags</name></name> == <name>SVN_CLIENT_COMMIT_ITEM_PROP_MODS</name>))</expr>)</condition><then>
        <expr_stmt><expr>*<name>base_url</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr>*<name>base_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Stash our item here for the next iteration. */</comment>
      <expr_stmt><expr><name>last_item</name> = <name>item</name></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Now that we've settled on a *BASE_URL, go hack that base off
     of all of our URLs. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ci</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>this_item</name>
        <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client_commit_item3_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>url_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>this_item</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>base_url_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr>*<name>base_url</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>url_len</name> &gt; <name>base_url_len</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>this_item</name>-&gt;<name>url</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>this_item</name>-&gt;<name>url</name></name> + <name>base_url_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name><name>this_item</name>-&gt;<name>url</name></name> = ""</expr>;</expr_stmt></else></if>
    }</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_CLIENT_COMMIT_DEBUG</name></cpp:ifdef>
  <comment type="block">/* ### TEMPORARY CODE ### */</comment>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"COMMITTABLES: (base URL=%s)\n"</expr></argument>, <argument><expr>*<name>base_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   FLAGS     REV  REL-URL (COPY-URL)\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ci</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>this_item</name>
        <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client_commit_item3_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>flags</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>flags</name><index>[<expr>0</expr>]</index></name> = (<name><name>this_item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_ADD</name>)
                   ? 'a' : '-'</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>flags</name><index>[<expr>1</expr>]</index></name> = (<name><name>this_item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name>)
                   ? 'd' : '-'</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>flags</name><index>[<expr>2</expr>]</index></name> = (<name><name>this_item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_TEXT_MODS</name>)
                   ? 't' : '-'</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>flags</name><index>[<expr>3</expr>]</index></name> = (<name><name>this_item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_PROP_MODS</name>)
                   ? 'p' : '-'</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>flags</name><index>[<expr>4</expr>]</index></name> = (<name><name>this_item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_IS_COPY</name>)
                   ? 'c' : '-'</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>flags</name><index>[<expr>5</expr>]</index></name> = '\0'</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   %s  %6ld  '%s' (%s)\n"</expr></argument>,
              <argument><expr><name>flags</name></expr></argument>,
              <argument><expr><name><name>this_item</name>-&gt;<name>revision</name></name></expr></argument>,
              <argument><expr><name><name>this_item</name>-&gt;<name>url</name></name> ? <name><name>this_item</name>-&gt;<name>url</name></name> : ""</expr></argument>,
              <argument><expr><name><name>this_item</name>-&gt;<name>copyfrom_url</name></name> ? <name><name>this_item</name>-&gt;<name>copyfrom_url</name></name> : "none"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_CLIENT_COMMIT_DEBUG */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>file_mod_t</name>
<block>{
  <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>item</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>file_baton</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* A baton for use with the path-based editor driver */</comment>
<struct>struct <name>path_driver_cb_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>     <comment type="block">/* top-level access baton */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>    <comment type="block">/* commit editor */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>edit_baton</name></decl>;</decl_stmt>                    <comment type="block">/* commit editor's baton */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>file_mods</name></decl>;</decl_stmt>               <comment type="block">/* hash: path-&gt;file_mod_t */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>tempfiles</name></decl>;</decl_stmt>               <comment type="block">/* hash of tempfiles created */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>notify_path_prefix</name></decl>;</decl_stmt>      <comment type="block">/* notification path prefix */</comment>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>               <comment type="block">/* client context baton */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>commit_items</name></decl>;</decl_stmt>            <comment type="block">/* the committables */</comment>
}</block>;</struct>


<comment type="block">/* This implements svn_delta_path_driver_cb_func_t */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_item_commit</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>dir_baton</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>callback_baton</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>path_driver_cb_baton</name> *</type><name>cb_baton</name> <init>= <expr><name>callback_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>item</name> <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>cb_baton</name>-&gt;<name>commit_items</name></name></expr></argument>,
                                                 <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name> <init>= <expr><name><name>item</name>-&gt;<name>kind</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>file_baton</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>file_pool</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name> <init>= <expr><name><name>cb_baton</name>-&gt;<name>adm_access</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name> <init>= <expr><name><name>cb_baton</name>-&gt;<name>editor</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>file_mods</name> <init>= <expr><name><name>cb_baton</name>-&gt;<name>file_mods</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>notify_path_prefix</name> <init>= <expr><name><name>cb_baton</name>-&gt;<name>notify_path_prefix</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>cb_baton</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Do some initializations. */</comment>
  <expr_stmt><expr>*<name>dir_baton</name> = <name>NULL</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>item</name>-&gt;<name>copyfrom_url</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>copyfrom_url</name> = <name><name>item</name>-&gt;<name>copyfrom_url</name></name></expr>;</expr_stmt></then></if>

  <comment type="block">/* If this is a file with textual mods, we'll be keeping its baton
     around until the end of the commit.  So just lump its memory into
     a single, big, all-the-file-batons-in-here pool.  Otherwise, we
     can just use POOL, and trust our caller to clean that mess up. */</comment>
  <if>if <condition>(<expr>(<name>kind</name> == <name>svn_node_file</name>)
      &amp;&amp; (<name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_TEXT_MODS</name>)</expr>)</condition><then>
    <expr_stmt><expr><name>file_pool</name> = <call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>file_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>file_pool</name> = <name>pool</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* Call the cancellation function. */</comment>
  <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>ctx</name>-&gt;<name>cancel_func</name></name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Validation. */</comment>
  <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_IS_COPY</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name>copyfrom_url</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Commit item '%s' has copy flag but no copyfrom URL"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_CLIENT_BAD_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Commit item '%s' has copy flag but an invalid revision"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* If a feedback table was supplied by the application layer,
     describe what we're about to do to this item.  */</comment>
  <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Convert an absolute path into a relative one (if possible.) */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>npath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>notify_path_prefix</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>notify_path_prefix</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>npath</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>notify_path_prefix</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>npath</name> = "."</expr>;</expr_stmt></else></if>
        }</block></then></if>
      <if>if <condition>(<expr>! <name>npath</name></expr>)</condition><then>
        <expr_stmt><expr><name>npath</name> = <name><name>item</name>-&gt;<name>path</name></name></expr>;</expr_stmt></then></if> <comment type="block">/* Otherwise just use full path */</comment>

      <if>if <condition>(<expr>(<name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name>)
          &amp;&amp; (<name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_ADD</name>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* We don't print the "(bin)" notice for binary files when
             replacing, only when adding.  So we don't bother to get
             the mime-type here. */</comment>
          <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>npath</name></expr></argument>, <argument><expr><name>svn_wc_notify_commit_replaced</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>npath</name></expr></argument>, <argument><expr><name>svn_wc_notify_commit_deleted</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_ADD</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>npath</name></expr></argument>, <argument><expr><name>svn_wc_notify_commit_added</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>item</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>propval</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_prop_get</name>
                      <argument_list>(<argument><expr>&amp;<name>propval</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>propval</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>notify</name>-&gt;<name>mime_type</name></name> = <name><name>propval</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></then>
      <else>else <if>if <condition>(<expr>(<name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_TEXT_MODS</name>)
               || (<name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_PROP_MODS</name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>npath</name></expr></argument>, <argument><expr><name>svn_wc_notify_commit_modified</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_TEXT_MODS</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name>svn_wc_notify_state_unchanged</name></expr>;</expr_stmt></else></if>
          <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_PROP_MODS</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>notify</name>-&gt;<name>prop_state</name></name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>notify</name>-&gt;<name>prop_state</name></name> = <name>svn_wc_notify_state_unchanged</name></expr>;</expr_stmt></else></if>
        }</block></then>
      <else>else
        <expr_stmt><expr><name>notify</name> = <name>NULL</name></expr>;</expr_stmt></else></if></else></if></else></if></else></if>

      <if>if <condition>(<expr><name>notify</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name><name>item</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call>(*<name><name>ctx</name>-&gt;<name>notify_func2</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* If this item is supposed to be deleted, do so. */</comment>
  <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>parent_baton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>delete_entry</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>revision</name></name></expr></argument>,
                                   <argument><expr><name>parent_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If this item is supposed to be added, do so. */</comment>
  <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_ADD</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>parent_baton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>add_file</name></name>
                  <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>,
                   <argument><expr><name>copyfrom_url</name> ? <name><name>item</name>-&gt;<name>copyfrom_rev</name></name> : <name>SVN_INVALID_REVNUM</name></expr></argument>,
                   <argument><expr><name>file_pool</name></expr></argument>, <argument><expr>&amp;<name>file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>parent_baton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>add_directory</name></name>
                  <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>,
                   <argument><expr><name>copyfrom_url</name> ? <name><name>item</name>-&gt;<name>copyfrom_rev</name></name> : <name>SVN_INVALID_REVNUM</name></expr></argument>,
                   <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* Set other prop-changes, if available in the baton */</comment>
      <if>if <condition>(<expr><name><name>item</name>-&gt;<name>outgoing_prop_changes</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>prop</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prop_changes</name> <init>= <expr><name><name>item</name>-&gt;<name>outgoing_prop_changes</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>ctr</name></decl>;</decl_stmt>
          <for>for (<init><expr><name>ctr</name> = 0</expr>;</init> <condition><expr><name>ctr</name> &lt; <name><name>prop_changes</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>ctr</name>++</expr></incr>)
            <block>{
              <expr_stmt><expr><name>prop</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>prop_changes</name></expr></argument>, <argument><expr><name>ctr</name></expr></argument>, <argument><expr><name>svn_prop_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name><name>editor</name>-&gt;<name>change_file_prop</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>,
                                           <argument><expr><name><name>prop</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><call><name><name>editor</name>-&gt;<name>change_dir_prop</name></name><argument_list>(<argument><expr>*<name>dir_baton</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>,
                                          <argument><expr><name><name>prop</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Now handle property mods. */</comment>
  <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_PROP_MODS</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>tmp_entry</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>! <name>file_baton</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>parent_baton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_file</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>,
                                        <argument><expr><name><name>item</name>-&gt;<name>revision</name></name></expr></argument>,
                                        <argument><expr><name>file_pool</name></expr></argument>, <argument><expr>&amp;<name>file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr>! *<name>dir_baton</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr>! <name>parent_baton</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_root</name></name>
                          <argument_list>(<argument><expr><name><name>cb_baton</name>-&gt;<name>edit_baton</name></name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>revision</name></name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_directory</name></name>
                          <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>revision</name></name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>
        }</block></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_transmit_prop_deltas</name>
              <argument_list>(<argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>tmp_entry</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>,
               <argument><expr>(<name>kind</name> == <name>svn_node_dir</name>) ? *<name>dir_baton</name> : <name>file_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Make any additional client -&gt; repository prop changes. */</comment>
      <if>if <condition>(<expr><name><name>item</name>-&gt;<name>outgoing_prop_changes</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>prop</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

          <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>item</name>-&gt;<name>outgoing_prop_changes</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
              <expr_stmt><expr><name>prop</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>outgoing_prop_changes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                   <argument><expr><name>svn_prop_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name><name>editor</name>-&gt;<name>change_file_prop</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>,
                                           <argument><expr><name><name>prop</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><call><name><name>editor</name>-&gt;<name>change_dir_prop</name></name><argument_list>(<argument><expr>*<name>dir_baton</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>,
                                          <argument><expr><name><name>prop</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></for>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Finally, handle text mods (in that we need to open a file if it
     hasn't already been opened, and we need to put the file baton in
     our FILES hash). */</comment>
  <if>if <condition>(<expr>(<name>kind</name> == <name>svn_node_file</name>)
      &amp;&amp; (<name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_TEXT_MODS</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type>struct <name>file_mod_t</name> *</type><name>mod</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>file_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>mod</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>! <name>file_baton</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>parent_baton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_file</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>,
                                    <argument><expr><name><name>item</name>-&gt;<name>revision</name></name></expr></argument>,
                                    <argument><expr><name>file_pool</name></expr></argument>, <argument><expr>&amp;<name>file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Add this file mod to the FILE_MODS hash. */</comment>
      <expr_stmt><expr><name><name>mod</name>-&gt;<name>item</name></name> = <name>item</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>mod</name>-&gt;<name>file_baton</name></name> = <name>file_baton</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>file_mods</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>file_baton</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Close any outstanding file batons that didn't get caught by
         the "has local mods" conditional above. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_file</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>file_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_CLIENT_COMMIT_DEBUG</name></cpp:ifdef>
<comment type="block">/* Prototype for function below */</comment>
<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_test_editor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                                    <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>real_editor</name></decl></param>,
                                    <param><decl><type><name>void</name> *</type><name>real_eb</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_CLIENT_COMMIT_DEBUG */</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client__do_commit</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl></param>,
                      <param><decl><type><name>apr_array_header_t</name> *</type><name>commit_items</name></decl></param>,
                      <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                      <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>notify_path_prefix</name></decl></param>,
                      <param><decl><type><name>apr_hash_t</name> **</type><name>tempfiles</name></decl></param>,
                      <param><decl><type><name>apr_hash_t</name> **</type><name>digests</name></decl></param>,
                      <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>file_mods</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>items_hash</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>path_driver_cb_baton</name></type> <name>cb_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>paths</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>commit_items</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_CLIENT_COMMIT_DEBUG</name></cpp:ifdef>
  <block>{
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_test_editor</name><argument_list>(<argument><expr>&amp;<name>editor</name></expr></argument>, <argument><expr>&amp;<name>edit_baton</name></expr></argument>,
                            <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                            <argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_CLIENT_COMMIT_DEBUG */</comment>

  <comment type="block">/* If the caller wants us to track temporary file creation, create a
     hash to store those paths in. */</comment>
  <if>if <condition>(<expr><name>tempfiles</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>tempfiles</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Ditto for the md5 digests. */</comment>
  <if>if <condition>(<expr><name>digests</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>digests</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Build a hash from our COMMIT_ITEMS array, keyed on the
     URI-decoded relative paths (which come from the item URLs).  And
     keep an array of those decoded paths, too.  */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>commit_items</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>item</name> <init>=
        <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>commit_items</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client_commit_item3_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>items_hash</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>path</name></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Setup the callback baton. */</comment>
  <expr_stmt><expr><name><name>cb_baton</name>.<name>adm_access</name></name> = <name>adm_access</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb_baton</name>.<name>editor</name></name> = <name>editor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb_baton</name>.<name>edit_baton</name></name> = <name>edit_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb_baton</name>.<name>file_mods</name></name> = <name>file_mods</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb_baton</name>.<name>tempfiles</name></name> = <name>tempfiles</name> ? *<name>tempfiles</name> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb_baton</name>.<name>notify_path_prefix</name></name> = <name>notify_path_prefix</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb_baton</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb_baton</name>.<name>commit_items</name></name> = <name>items_hash</name></expr>;</expr_stmt>

  <comment type="block">/* Drive the commit editor! */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_delta_path_driver</name><argument_list>(<argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                <argument><expr><name>paths</name></expr></argument>, <argument><expr><name>do_item_commit</name></expr></argument>, <argument><expr>&amp;<name>cb_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Transmit outstanding text deltas. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>file_mods</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type>struct <name>file_mod_t</name> *</type><name>mod</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>item</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>file_baton</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tempfile</name></decl>, *<decl><type ref="prev"/><name>dir_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>fulltext</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>item_access</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Get the next entry. */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mod</name> = <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* Transmit the entry. */</comment>
      <expr_stmt><expr><name>item</name> = <name><name>mod</name>-&gt;<name>item</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>file_baton</name> = <name><name>mod</name>-&gt;<name>file_baton</name></name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>ctx</name>-&gt;<name>cancel_func</name></name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>npath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>notify_path_prefix</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>notify_path_prefix</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
                <expr_stmt><expr><name>npath</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>notify_path_prefix</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>,
                                          <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><name>npath</name> = "."</expr>;</expr_stmt></else></if>
            }</block></then></if>
          <if>if <condition>(<expr>! <name>npath</name></expr>)</condition><then>
            <expr_stmt><expr><name>npath</name> = <name><name>item</name>-&gt;<name>path</name></name></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>npath</name></expr></argument>,
                                        <argument><expr><name>svn_wc_notify_commit_postfix_txdelta</name></expr></argument>,
                                        <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
          <expr_stmt><expr><call>(*<name><name>ctx</name>-&gt;<name>notify_func2</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr><name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_ADD</name></expr>)</condition><then>
        <expr_stmt><expr><name>fulltext</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><name>dir_path</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>item_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dir_path</name></expr></argument>,
                                  <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_transmit_text_deltas2</name><argument_list>(<argument><expr><name>tempfiles</name> ? &amp;<name>tempfile</name> : <name>NULL</name></expr></argument>,
                                           <argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>,
                                           <argument><expr><name>item_access</name></expr></argument>, <argument><expr><name>fulltext</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>,
                                           <argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>tempfiles</name> &amp;&amp; <name>tempfile</name> &amp;&amp; *<name>tempfiles</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>tempfile</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr>*<name>tempfiles</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tempfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>tempfiles</name></expr></argument>, <argument><expr><name>tempfile</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>(<name>void</name> *)1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <if>if <condition>(<expr><name>digests</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>new_digest</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr>*<name>digests</name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>digests</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close the edit. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_edit</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Commit callback baton */</comment>

<struct>struct <name>commit_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_commit_info_t</name> **</type><name>info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><name>svn_error_t</name> *</type><name>svn_client__commit_get_baton</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>baton</name></decl></param>,
                                          <param><decl><type><name>svn_commit_info_t</name> **</type><name>info</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>commit_baton</name> *</type><name>cb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>cb</name>-&gt;<name>info</name></name> = <name>info</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>baton</name> = <name>cb</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type><name>svn_client__commit_callback</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_commit_info_t</name> *</type><name>commit_info</name></decl></param>,
                                         <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>commit_baton</name> *</type><name>cb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*(<name><name>cb</name>-&gt;<name>info</name></name>) = <call><name>svn_commit_info_dup</name><argument_list>(<argument><expr><name>commit_info</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_CLIENT_COMMIT_DEBUG</name></cpp:ifdef>
<escape char="0xc"/>
<comment type="block">/*** Temporary test editor ***/</comment>

<struct>struct <name>edit_baton</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>real_editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>real_eb</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>item_baton</name>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>real_baton</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> struct <name>item_baton</name> *</type>
<name>make_baton</name><parameter_list>(<param><decl><type>struct <name>edit_baton</name> *</type><name>eb</name></decl></param>,
           <param><decl><type><name>void</name> *</type><name>real_baton</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>new_baton</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>new_baton</name>-&gt;<name>eb</name></name> = <name>eb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_baton</name>-&gt;<name>real_baton</name></name> = <name>real_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_baton</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>new_baton</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_target_revision</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>target_revision</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call>(*<name><name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>set_target_revision</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>real_eb</name></name></expr></argument>,
                                                 <argument><expr><name>target_revision</name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_root</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
          <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>dir_pool</name></decl></param>,
          <param><decl><type><name>void</name> **</type><name>root_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>new_baton</name> <init>= <expr><call><name>make_baton</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>dir_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"TEST EDIT STARTED (base URL=%s)\n"</expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>root_baton</name> = <name>new_baton</name></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>open_root</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>real_eb</name></name></expr></argument>,
                                       <argument><expr><name>base_revision</name></expr></argument>,
                                       <argument><expr><name>dir_pool</name></expr></argument>,
                                       <argument><expr>&amp;<name><name>new_baton</name>-&gt;<name>real_baton</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
         <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
         <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_revision</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
         <param><decl><type><name>void</name> **</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>db</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>new_baton</name> <init>= <expr><call><name>make_baton</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>eb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copystuffs</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>copyfrom_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_revision</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>copystuffs</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                              <argument><expr>" (copied from %s:%ld)"</expr></argument>,
                              <argument><expr><name>copyfrom_path</name></expr></argument>,
                              <argument><expr><name>copyfrom_revision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   Adding  : %s%s\n"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>copystuffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>baton</name> = <name>new_baton</name></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>db</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>add_file</name></name>)<argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>real_baton</name></name></expr></argument>,
                                          <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>copyfrom_revision</name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name><name>new_baton</name>-&gt;<name>real_baton</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delete_entry</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
             <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>db</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   Deleting: %s\n"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>db</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>delete_entry</name></name>)<argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>,
                                              <argument><expr><name><name>db</name>-&gt;<name>real_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
          <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
          <param><decl><type><name>void</name> **</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>db</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>new_baton</name> <init>= <expr><call><name>make_baton</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>eb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   Opening : %s\n"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>baton</name> = <name>new_baton</name></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>db</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>open_file</name></name>)<argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>real_baton</name></name></expr></argument>,
                                           <argument><expr><name>base_revision</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                           <argument><expr>&amp;<name><name>new_baton</name>-&gt;<name>real_baton</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_file</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text_checksum</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>fb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   Closing : %s\n"</expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>fb</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>close_file</name></name>)<argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>real_baton</name></name></expr></argument>,
                                            <argument><expr><name>text_checksum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_file_prop</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>fb</name> <init>= <expr><name>file_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"      PropSet (%s=%s)\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name> ? <name><name>value</name>-&gt;<name>data</name></name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>fb</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>change_file_prop</name></name>)<argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>real_baton</name></name></expr></argument>,
                                                  <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_textdelta</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                <param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>handler</name></decl></param>,
                <param><decl><type><name>void</name> **</type><name>handler_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>fb</name> <init>= <expr><name>file_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"      Transmitting text...\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>fb</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>apply_textdelta</name></name>)<argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>real_baton</name></name></expr></argument>,
                                                 <argument><expr><name>base_checksum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                                 <argument><expr><name>handler</name></expr></argument>, <argument><expr><name>handler_baton</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_edit</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"TEST EDIT COMPLETED\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>close_edit</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>real_eb</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_revision</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
              <param><decl><type><name>void</name> **</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>db</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>new_baton</name> <init>= <expr><call><name>make_baton</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>eb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copystuffs</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>copyfrom_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_revision</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>copystuffs</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                              <argument><expr>" (copied from %s:%ld)"</expr></argument>,
                              <argument><expr><name>copyfrom_path</name></expr></argument>,
                              <argument><expr><name>copyfrom_revision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   Adding  : %s%s\n"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>copystuffs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>baton</name> = <name>new_baton</name></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>db</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>add_directory</name></name>)<argument_list>(<argument><expr><name>path</name></expr></argument>,
                                               <argument><expr><name><name>db</name>-&gt;<name>real_baton</name></name></expr></argument>,
                                               <argument><expr><name>copyfrom_path</name></expr></argument>,
                                               <argument><expr><name>copyfrom_revision</name></expr></argument>,
                                               <argument><expr><name>pool</name></expr></argument>,
                                               <argument><expr>&amp;<name><name>new_baton</name>-&gt;<name>real_baton</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
               <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
               <param><decl><type><name>void</name> **</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>db</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>new_baton</name> <init>= <expr><call><name>make_baton</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>eb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   Opening : %s\n"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>baton</name> = <name>new_baton</name></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>db</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>open_directory</name></name>)<argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>real_baton</name></name></expr></argument>,
                                                <argument><expr><name>base_revision</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                                <argument><expr>&amp;<name><name>new_baton</name>-&gt;<name>real_baton</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_dir_prop</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>db</name> <init>= <expr><name>dir_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"      PropSet (%s=%s)\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name> ? <name><name>value</name>-&gt;<name>data</name></name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>db</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>change_dir_prop</name></name>)<argument_list>(<argument><expr><name><name>db</name>-&gt;<name>real_baton</name></name></expr></argument>,
                                                 <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_directory</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>item_baton</name> *</type><name>db</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"   Closing : %s\n"</expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>db</name>-&gt;<name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>close_directory</name></name>)<argument_list>(<argument><expr><name><name>db</name>-&gt;<name>real_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>abort_edit</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"TEST EDIT ABORTED\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call>(*<name><name>eb</name>-&gt;<name>real_editor</name>-&gt;<name>abort_edit</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>real_eb</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_test_editor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>real_editor</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>real_eb</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_delta_editor_t</name> *</type><name>ed</name> <init>= <expr><call><name>svn_delta_default_editor</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>eb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>eb</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>real_editor</name></name> = <name>real_editor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>real_eb</name></name> = <name>real_eb</name></expr>;</expr_stmt>

  <comment type="block">/* We don't implement absent_file() or absent_directory() in this
     editor, because presumably commit would never send that. */</comment>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>set_target_revision</name></name> = <name>set_target_revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>open_root</name></name> = <name>open_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>add_directory</name></name> = <name>add_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>open_directory</name></name> = <name>open_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>close_directory</name></name> = <name>close_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>add_file</name></name> = <name>add_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>open_file</name></name> = <name>open_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>close_file</name></name> = <name>close_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>delete_entry</name></name> = <name>delete_entry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>apply_textdelta</name></name> = <name>apply_textdelta</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>change_dir_prop</name></name> = <name>change_dir_prop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>change_file_prop</name></name> = <name>change_file_prop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>close_edit</name></name> = <name>close_edit</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ed</name>-&gt;<name>abort_edit</name></name> = <name>abort_edit</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>editor</name> = <name>ed</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>edit_baton</name> = <name>eb</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_CLIENT_COMMIT_DEBUG */</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client__get_log_msg</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>log_msg</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>tmp_file</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>commit_items</name></decl></param>,
                        <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>log_msg_func3</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* The client provided a callback function for the current API.
         Forward the call to it directly. */</comment>
      <return>return <expr><call>(*<name><name>ctx</name>-&gt;<name>log_msg_func3</name></name>)<argument_list>(<argument><expr><name>log_msg</name></expr></argument>, <argument><expr><name>tmp_file</name></expr></argument>, <argument><expr><name>commit_items</name></expr></argument>,
                                   <argument><expr><name><name>ctx</name>-&gt;<name>log_msg_baton3</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>log_msg_func2</name></name> || <name><name>ctx</name>-&gt;<name>log_msg_func</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* The client provided a pre-1.5 (or pre-1.3) API callback
         function.  Convert the commit_items list to the appropriate
         type, and forward call to it. */</comment>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>old_commit_items</name> <init>=
        <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name><name>commit_items</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>commit_items</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>item</name> <init>=
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>commit_items</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_client_commit_item3_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>log_msg_func2</name></name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_client_commit_item2_t</name> *</type><name>old_item</name> <init>=
                <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>old_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>path</name></name> = <name><name>item</name>-&gt;<name>path</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>kind</name></name> = <name><name>item</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>url</name></name> = <name><name>item</name>-&gt;<name>url</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>revision</name></name> = <name><name>item</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>copyfrom_url</name></name> = <name><name>item</name>-&gt;<name>copyfrom_url</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>copyfrom_rev</name></name> = <name><name>item</name>-&gt;<name>copyfrom_rev</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>state_flags</name></name> = <name><name>item</name>-&gt;<name>state_flags</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>wcprop_changes</name></name> = <name><name>item</name>-&gt;<name>incoming_prop_changes</name></name></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>old_commit_items</name></expr></argument>, <argument><expr><name>svn_client_commit_item2_t</name> *</expr></argument>)</argument_list></call> =
                <name>old_item</name></expr>;</expr_stmt>
            }</block></then>
          <else>else <comment type="block">/* ctx-&gt;log_msg_func */</comment>
            <block>{
              <decl_stmt><decl><type><name>svn_client_commit_item_t</name> *</type><name>old_item</name> <init>=
                <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>old_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>path</name></name> = <name><name>item</name>-&gt;<name>path</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>kind</name></name> = <name><name>item</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>url</name></name> = <name><name>item</name>-&gt;<name>url</name></name></expr>;</expr_stmt>
              <comment type="block">/* The pre-1.3 API used the revision field for copyfrom_rev
                 and revision depeding of copyfrom_url. */</comment>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>revision</name></name> = <name><name>item</name>-&gt;<name>copyfrom_url</name></name> ?
                <name><name>item</name>-&gt;<name>copyfrom_rev</name></name> : <name><name>item</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>copyfrom_url</name></name> = <name><name>item</name>-&gt;<name>copyfrom_url</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>state_flags</name></name> = <name><name>item</name>-&gt;<name>state_flags</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_item</name>-&gt;<name>wcprop_changes</name></name> = <name><name>item</name>-&gt;<name>incoming_prop_changes</name></name></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>old_commit_items</name></expr></argument>, <argument><expr><name>svn_client_commit_item_t</name> *</expr></argument>)</argument_list></call> =
                <name>old_item</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

      <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>log_msg_func2</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <call>(*<name><name>ctx</name>-&gt;<name>log_msg_func2</name></name>)<argument_list>(<argument><expr><name>log_msg</name></expr></argument>, <argument><expr><name>tmp_file</name></expr></argument>, <argument><expr><name>old_commit_items</name></expr></argument>,
                                    <argument><expr><name><name>ctx</name>-&gt;<name>log_msg_baton2</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>err</name> = <call>(*<name><name>ctx</name>-&gt;<name>log_msg_func</name></name>)<argument_list>(<argument><expr><name>log_msg</name></expr></argument>, <argument><expr><name>tmp_file</name></expr></argument>, <argument><expr><name>old_commit_items</name></expr></argument>,
                                   <argument><expr><name><name>ctx</name>-&gt;<name>log_msg_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* No log message callback was provided by the client. */</comment>
      <expr_stmt><expr>*<name>log_msg</name> = ""</expr>;</expr_stmt>
      <expr_stmt><expr>*<name>tmp_file</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></else></if></else></if>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client__ensure_revprop_table</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>revprop_table_out</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>apr_hash_t</name> *</type><name>revprop_table_in</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>log_msg</name></decl></param>,
                                 <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>new_revprop_table</name></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>revprop_table_in</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>svn_prop_has_svn_prop</name><argument_list>(<argument><expr><name>revprop_table_in</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_PROPERTY_NAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Standard properties can't be set "
                                  "explicitly as revision properties"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name>new_revprop_table</name> = <call><name>apr_hash_copy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>revprop_table_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>new_revprop_table</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>new_revprop_table</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_LOG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
               <argument><expr><call><name>svn_string_create</name><argument_list>(<argument><expr><name>log_msg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>revprop_table_out</name> = <name>new_revprop_table</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
