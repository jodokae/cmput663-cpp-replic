<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_client/commit.c"><comment type="block">/*
 * commit.c:  wrappers around wc commit functionality.
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<comment type="block">/* ==================================================================== */</comment>


<escape char="0xc"/>
<comment type="block">/*** Includes. ***/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_subst.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_client.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error_codes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_iter.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"client.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<comment type="block">/* Import context baton.

   ### TODO:  Add the following items to this baton:
      /` import editor/baton. `/
      const svn_delta_editor_t *editor;
      void *edit_baton;

      /` Client context baton `/
      svn_client_ctx_t `ctx;

      /` Paths (keys) excluded from the import (values ignored) `/
      apr_hash_t *excludes;
*/</comment>
<typedef>typedef <type><struct>struct <name>import_ctx_t</name>
<block>{
  <comment type="block">/* Whether any changes were made to the repository */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>repos_changed</name></decl>;</decl_stmt>

}</block></struct></type> <name>import_ctx_t</name>;</typedef>


<comment type="block">/* Apply PATH's contents (as a delta against the empty string) to
   FILE_BATON in EDITOR.  Use POOL for any temporary allocation.
   PROPERTIES is the set of node properties set on this file.

   Fill DIGEST with the md5 checksum of the sent file; DIGEST must be
   at least APR_MD5_DIGESTSIZE bytes long. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>send_file_contents</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                   <param><decl><type><name>apr_hash_t</name> *</type><name>properties</name></decl></param>,
                   <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>digest</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmpfile_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>contents</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>handler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>handler_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>f</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>eol_style_val</name> <init>= <expr><name>NULL</name></expr></init>, *<name>keywords_val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>special</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_subst_eol_style_t</name></type> <name>eol_style</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl>;</decl_stmt>

  <comment type="block">/* If there are properties, look for EOL-style and keywords ones. */</comment>
  <if>if <condition>(<expr><name>properties</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>eol_style_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>properties</name></expr></argument>, <argument><expr><name>SVN_PROP_EOL_STYLE</name></expr></argument>,
                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_PROP_EOL_STYLE</name></expr></argument>)</argument_list></sizeof> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>keywords_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>properties</name></expr></argument>, <argument><expr><name>SVN_PROP_KEYWORDS</name></expr></argument>,
                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_PROP_KEYWORDS</name></expr></argument>)</argument_list></sizeof> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>properties</name></expr></argument>, <argument><expr><name>SVN_PROP_SPECIAL</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>special</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* Get an editor func that wants to consume the delta stream. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>apply_textdelta</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                  <argument><expr>&amp;<name>handler</name></expr></argument>, <argument><expr>&amp;<name>handler_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>eol_style_val</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_subst_eol_style_from_value</name><argument_list>(<argument><expr>&amp;<name>eol_style</name></expr></argument>, <argument><expr>&amp;<name>eol</name></expr></argument>, <argument><expr><name><name>eol_style_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>eol</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>eol_style</name> = <name>svn_subst_eol_style_none</name></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr><name>keywords_val</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_build_keywords2</name><argument_list>(<argument><expr>&amp;<name>keywords</name></expr></argument>, <argument><expr><name><name>keywords_val</name>-&gt;<name>data</name></name></expr></argument>,
                                      <argument><expr><call><name>APR_STRINGIFY</name><argument_list>(<argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>keywords</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* If we have EOL styles or keywords to de-translate, do it.  */</comment>
  <if>if <condition>(<expr><call><name>svn_subst_translation_required</name><argument_list>(<argument><expr><name>eol_style</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>special</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>temp_dir</name></decl>;</decl_stmt>

      <comment type="block">/* Now create a new tempfile, and open a stream to it. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_temp_dir</name><argument_list>(<argument><expr>&amp;<name>temp_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name>
              <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmpfile_path</name></expr></argument>,
               <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>temp_dir</name></expr></argument>, <argument><expr>"svn-import"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_translate_to_normal_form</name>
              <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>tmpfile_path</name></expr></argument>, <argument><expr><name>eol_style</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
               <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>special</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Open our contents file, either the original path or the temporary
     copy we might have made above. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr><name>tmpfile_path</name> ? <name>tmpfile_path</name> : <name>path</name></expr></argument>,
                           <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>contents</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Send the file's contents to the delta-window handler. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_txdelta_send_stream</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>, <argument><expr><name>handler_baton</name></expr></argument>,
                                  <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close our contents file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The temp file is removed by the pool cleanup run by the caller */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Import file PATH as EDIT_PATH in the repository directory indicated
 * by DIR_BATON in EDITOR.
 *
 * Accumulate file paths and their batons in FILES, which must be
 * non-null.  (These are used to send postfix textdeltas later).
 *
 * If CTX-&gt;NOTIFY_FUNC is non-null, invoke it with CTX-&gt;NOTIFY_BATON
 * for each file.
 *
 * Use POOL for any temporary allocation.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>import_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
            <param><decl><type><name>import_ctx_t</name> *</type><name>import_ctx</name></decl></param>,
            <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>file_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text_checksum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name>*</type> <name>properties</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_special</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_check_valid</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_special_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr>&amp;<name>is_special</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add the file, using the pool from the FILES hash. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>add_file</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remember that the repository was modified */</comment>
  <expr_stmt><expr><name><name>import_ctx</name>-&gt;<name>repos_changed</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>is_special</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* add automatic properties */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_auto_props</name><argument_list>(<argument><expr>&amp;<name>properties</name></expr></argument>, <argument><expr>&amp;<name>mimetype</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>properties</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>properties</name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>properties</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>pname</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>pval</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>pname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>pval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>change_file_prop</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>, <argument><expr><name>pval</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name>
        <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_commit_added</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>mime_type</name></name> = <name>mimetype</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name><name>notify</name>-&gt;<name>prop_state</name></name>
        = <name>svn_wc_notify_state_inapplicable</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>lock_state</name></name> = <name>svn_wc_notify_lock_state_inapplicable</name></expr>;</expr_stmt>
      <expr_stmt><expr><call>(*<name><name>ctx</name>-&gt;<name>notify_func2</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If this is a special file, we need to set the svn:special
     property and create a temporary detranslated version in order to
     send to the server. */</comment>
  <if>if <condition>(<expr><name>is_special</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>properties</name></expr></argument>, <argument><expr><name>SVN_PROP_SPECIAL</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                   <argument><expr><call><name>svn_string_create</name><argument_list>(<argument><expr><name>SVN_PROP_BOOLEAN_TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>change_file_prop</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>SVN_PROP_SPECIAL</name></expr></argument>,
                                       <argument><expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>properties</name></expr></argument>,
                                                    <argument><expr><name>SVN_PROP_SPECIAL</name></expr></argument>,
                                                    <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Now, transmit the file contents. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>send_file_contents</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>,
                             <argument><expr><name>properties</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Finally, close the file. */</comment>
  <expr_stmt><expr><name>text_checksum</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_file</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>text_checksum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Import directory PATH into the repository directory indicated by
 * DIR_BATON in EDITOR.  EDIT_PATH is the path imported as the root
 * directory, so all edits are relative to that.
 *
 * DEPTH is the depth at this point in the descent (it may be changed
 * for recursive calls).
 *
 * Accumulate file paths and their batons in FILES, which must be
 * non-null.  (These are used to send postfix textdeltas later).
 *
 * EXCLUDES is a hash whose keys are absolute paths to exclude from
 * the import (values are unused).
 *
 * If NO_IGNORE is FALSE, don't import files or directories that match
 * ignore patterns.
 *
 * If CTX-&gt;NOTIFY_FUNC is non-null, invoke it with CTX-&gt;NOTIFY_BATON for each
 * directory.
 *
 * Use POOL for any temporary allocation.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>import_dir</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
           <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
           <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
           <param><decl><type><name>apr_hash_t</name> *</type><name>excludes</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>no_ignore</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_unknown_node_types</name></decl></param>,
           <param><decl><type><name>import_ctx_t</name> *</type><name>import_ctx</name></decl></param>,
           <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* iteration pool */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>dirents</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ignores</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_check_valid</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>no_ignore</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_get_default_ignores</name><argument_list>(<argument><expr>&amp;<name>ignores</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_get_dirents2</name><argument_list>(<argument><expr>&amp;<name>dirents</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dirents</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>this_path</name></decl>, *<decl><type ref="prev"/><name>this_edit_path</name></decl>, *<decl><type ref="prev"/><name>abs_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_io_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>filename</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>ctx</name>-&gt;<name>cancel_func</name></name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><call><name>svn_wc_is_adm_dir</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* If someone's trying to import a directory named the same
             as our administrative directories, that's probably not
             what they wanted to do.  If they are importing a file
             with that name, something is bound to blow up when they
             checkout what they've imported.  So, just skip items with
             that name.  */</comment>
          <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name>
                <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
                                                     <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>svn_wc_notify_skip</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name><name>notify</name>-&gt;<name>prop_state</name></name>
                = <name>svn_wc_notify_state_inapplicable</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>notify</name>-&gt;<name>lock_state</name></name> = <name>svn_wc_notify_lock_state_inapplicable</name></expr>;</expr_stmt>
              <expr_stmt><expr><call>(*<name><name>ctx</name>-&gt;<name>notify_func2</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <continue>continue;</continue>
        }</block></then></if>

      <comment type="block">/* Typically, we started importing from ".", in which case
         edit_path is "".  So below, this_path might become "./blah",
         and this_edit_path might become "blah", for example. */</comment>
      <expr_stmt><expr><name>this_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>this_edit_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this is an excluded path, exclude it. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>abs_path</name></expr></argument>, <argument><expr><name>this_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>excludes</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr>(!<name>no_ignore</name>) &amp;&amp; <call><name>svn_wc_match_ignore_list</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>ignores</name></expr></argument>,
                                                   <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr><name><name>dirent</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name> &amp;&amp; <name>depth</name> &gt;= <name>svn_depth_immediates</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>void</name> *</type><name>this_dir_baton</name></decl>;</decl_stmt>

          <comment type="block">/* Add the new subdirectory, getting a descent baton from
             the editor. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>add_directory</name></name><argument_list>(<argument><expr><name>this_edit_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>,
                                        <argument><expr>&amp;<name>this_dir_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Remember that the repository was modified */</comment>
          <expr_stmt><expr><name><name>import_ctx</name>-&gt;<name>repos_changed</name></name> = <name>TRUE</name></expr>;</expr_stmt>

          <comment type="block">/* By notifying before the recursive call below, we display
             a directory add before displaying adds underneath the
             directory.  To do it the other way around, just move this
             after the recursive call. */</comment>
          <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name>
                <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>this_path</name></expr></argument>, <argument><expr><name>svn_wc_notify_commit_added</name></expr></argument>,
                                       <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name><name>notify</name>-&gt;<name>prop_state</name></name>
                = <name>svn_wc_notify_state_inapplicable</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>notify</name>-&gt;<name>lock_state</name></name> = <name>svn_wc_notify_lock_state_inapplicable</name></expr>;</expr_stmt>
              <expr_stmt><expr><call>(*<name><name>ctx</name>-&gt;<name>notify_func2</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

          <comment type="block">/* Recurse. */</comment>
          <block>{
            <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth_below_here</name> <init>= <expr><name>depth</name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_immediates</name></expr>)</condition><then>
              <expr_stmt><expr><name>depth_below_here</name> = <name>svn_depth_empty</name></expr>;</expr_stmt></then></if>

            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>import_dir</name><argument_list>(<argument><expr><name>editor</name></expr></argument>, <argument><expr><name>this_dir_baton</name></expr></argument>, <argument><expr><name>this_path</name></expr></argument>,
                               <argument><expr><name>this_edit_path</name></expr></argument>, <argument><expr><name>depth_below_here</name></expr></argument>, <argument><expr><name>excludes</name></expr></argument>,
                               <argument><expr><name>no_ignore</name></expr></argument>, <argument><expr><name>ignore_unknown_node_types</name></expr></argument>,
                               <argument><expr><name>import_ctx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>,
                               <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block>

          <comment type="block">/* Finally, close the sub-directory. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr><name>this_dir_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>dirent</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name> &amp;&amp; <name>depth</name> &gt;= <name>svn_depth_files</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>import_file</name><argument_list>(<argument><expr><name>editor</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>this_path</name></expr></argument>,
                              <argument><expr><name>this_edit_path</name></expr></argument>, <argument><expr><name>import_ctx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>dirent</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name> &amp;&amp; <name><name>dirent</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>ignore_unknown_node_types</name></expr>)</condition><then>
            <block>{
              <comment type="block">/*## warn about it*/</comment>
              <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>notify_func2</name></name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name>
                    <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>this_path</name></expr></argument>,
                                           <argument><expr><name>svn_wc_notify_skip</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name><name>notify</name>-&gt;<name>prop_state</name></name>
                    = <name>svn_wc_notify_state_inapplicable</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>notify</name>-&gt;<name>lock_state</name></name> = <name>svn_wc_notify_lock_state_inapplicable</name></expr>;</expr_stmt>
                  <expr_stmt><expr><call>(*<name><name>ctx</name>-&gt;<name>notify_func2</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>notify_baton2</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then>
          <else>else
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_NODE_UNKNOWN_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unknown or unversionable type for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>this_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
        }</block></then></if></else></if></else></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Recursively import PATH to a repository using EDITOR and
 * EDIT_BATON.  PATH can be a file or directory.
 *
 * DEPTH is the depth at which to import PATH; it behaves as for
 * svn_client_import3().
 *
 * NEW_ENTRIES is an ordered array of path components that must be
 * created in the repository (where the ordering direction is
 * parent-to-child).  If PATH is a directory, NEW_ENTRIES may be empty
 * -- the result is an import which creates as many new entries in the
 * top repository target directory as there are importable entries in
 * the top of PATH; but if NEW_ENTRIES is not empty, its last item is
 * the name of a new subdirectory in the repository to hold the
 * import.  If PATH is a file, NEW_ENTRIES may not be empty, and its
 * last item is the name used for the file in the repository.  If
 * NEW_ENTRIES contains more than one item, all but the last item are
 * the names of intermediate directories that are created before the
 * real import begins.  NEW_ENTRIES may NOT be NULL.
 *
 * EXCLUDES is a hash whose keys are absolute paths to exclude from
 * the import (values are unused).
 *
 * If NO_IGNORE is FALSE, don't import files or directories that match
 * ignore patterns.
 *
 * If CTX-&gt;NOTIFY_FUNC is non-null, invoke it with CTX-&gt;NOTIFY_BATON for
 * each imported path, passing actions svn_wc_notify_commit_added.
 *
 * Use POOL for any temporary allocation.
 *
 * Note: the repository directory receiving the import was specified
 * when the editor was fetched.  (I.e, when EDITOR-&gt;open_root() is
 * called, it returns a directory baton for that directory, which is
 * not necessarily the root.)
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>import</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
       <param><decl><type><name>apr_array_header_t</name> *</type><name>new_entries</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
       <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
       <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
       <param><decl><type><name>apr_hash_t</name> *</type><name>excludes</name></decl></param>,
       <param><decl><type><name>svn_boolean_t</name></type> <name>no_ignore</name></decl></param>,
       <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_unknown_node_types</name></decl></param>,
       <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>root_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ignores</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>batons</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>import_ctx_t</name> *</type><name>import_ctx</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>import_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get a root dir baton.  We pass an invalid revnum to open_root
     to mean "base this on the youngest revision".  Should we have an
     SVN_YOUNGEST_REVNUM defined for these purposes? */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_root</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                            <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>root_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Import a file or a directory tree. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make the intermediate directory components necessary for properly
     rooting our import source tree.  */</comment>
  <if>if <condition>(<expr><name><name>new_entries</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>batons</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>new_entries</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>new_entries</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>new_entries</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>edit_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If this is the last path component, and we're importing a
             file, then this component is the name of the file, not an
             intermediate directory. */</comment>
          <if>if <condition>(<expr>(<name>i</name> == <name><name>new_entries</name>-&gt;<name>nelts</name></name> - 1) &amp;&amp; (<name>kind</name> == <name>svn_node_file</name>)</expr>)</condition><then>
            <break>break;</break></then></if>

          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>batons</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call> = <name>root_baton</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>add_directory</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>,
                                        <argument><expr><name>root_baton</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>root_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Remember that the repository was modified */</comment>
          <expr_stmt><expr><name><name>import_ctx</name>-&gt;<name>repos_changed</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name>
        <argument_list>(<argument><expr><name>SVN_ERR_NODE_UNKNOWN_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"New entry name required when importing a file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if></else></if>

  <comment type="block">/* Note that there is no need to check whether PATH's basename is
     the same name that we reserve for our administrative
     subdirectories.  It would be strange -- though not illegal -- to
     import the contents of a directory of that name, because the
     directory's own name is not part of those contents.  Of course,
     if something underneath it also has our reserved name, then we'll
     error. */</comment>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>ignores_match</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>!<name>no_ignore</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_get_default_ignores</name><argument_list>(<argument><expr>&amp;<name>ignores</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>ignores_match</name> = <call><name>svn_wc_match_ignore_list</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ignores</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <if>if <condition>(<expr>!<name>ignores_match</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>import_file</name><argument_list>(<argument><expr><name>editor</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>edit_path</name></expr></argument>,
                            <argument><expr><name>import_ctx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>import_dir</name><argument_list>(<argument><expr><name>editor</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>edit_path</name></expr></argument>,
                         <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>excludes</name></expr></argument>, <argument><expr><name>no_ignore</name></expr></argument>,
                         <argument><expr><name>ignore_unknown_node_types</name></expr></argument>, <argument><expr><name>import_ctx</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></then>
  <else>else <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name>
           || <name>kind</name> == <name>svn_node_unknown</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_NODE_UNKNOWN_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' does not exist"</expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if></else></if></else></if>

  <comment type="block">/* Close up shop; it's time to go home. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>batons</name> &amp;&amp; <name><name>batons</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>void</name> **</type><name>baton</name></decl>;</decl_stmt>
      <while>while <condition>(<expr>(<name>baton</name> = (<name>void</name> **) <call><name>apr_array_pop</name><argument_list>(<argument><expr><name>batons</name></expr></argument>)</argument_list></call>)</expr>)</condition>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr>*<name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>import_ctx</name>-&gt;<name>repos_changed</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_edit</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>abort_edit</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_ra_editor</name><parameter_list>(<param><decl><type><name>svn_ra_session_t</name> **</type><name>ra_session</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name> *</type><name>latest_rev</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
              <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
              <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_dir</name></decl></param>,
              <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>base_access</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>log_msg</name></decl></param>,
              <param><decl><type><name>apr_array_header_t</name> *</type><name>commit_items</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>apr_hash_t</name> *</type><name>revprop_table</name></decl></param>,
              <param><decl><type><name>svn_commit_info_t</name> **</type><name>commit_info_p</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name></type> <name>is_commit</name></decl></param>,
              <param><decl><type><name>apr_hash_t</name> *</type><name>lock_tokens</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name></type> <name>keep_locks</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>commit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>commit_revprops</name></decl>;</decl_stmt>

  <comment type="block">/* Open an RA session to URL. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__open_ra_session_internal</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>,
                                               <argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>,
                                               <argument><expr><name>base_access</name></expr></argument>, <argument><expr><name>commit_items</name></expr></argument>,
                                               <argument><expr><name>is_commit</name></expr></argument>, <argument><expr>!<name>is_commit</name></expr></argument>,
                                               <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this is an import (aka, not a commit), we need to verify that
     our repository URL exists. */</comment>
  <if>if <condition>(<expr>! <name>is_commit</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_check_path</name><argument_list>(<argument><expr>*<name>ra_session</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_ENTRY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' does not exist"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>base_url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Fetch the latest revision if requested. */</comment>
  <if>if <condition>(<expr><name>latest_rev</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_latest_revnum</name><argument_list>(<argument><expr>*<name>ra_session</name></expr></argument>, <argument><expr><name>latest_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__ensure_revprop_table</name><argument_list>(<argument><expr>&amp;<name>commit_revprops</name></expr></argument>, <argument><expr><name>revprop_table</name></expr></argument>,
                                           <argument><expr><name>log_msg</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fetch RA commit editor. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__commit_get_baton</name><argument_list>(<argument><expr>&amp;<name>commit_baton</name></expr></argument>, <argument><expr><name>commit_info_p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_ra_get_commit_editor3</name><argument_list>(<argument><expr>*<name>ra_session</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                                   <argument><expr><name>commit_revprops</name></expr></argument>,
                                   <argument><expr><name>svn_client__commit_callback</name></expr></argument>,
                                   <argument><expr><name>commit_baton</name></expr></argument>, <argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>keep_locks</name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** Public Interfaces. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_import3</name><parameter_list>(<param><decl><type><name>svn_commit_info_t</name> **</type><name>commit_info_p</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                   <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>no_ignore</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_unknown_node_types</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_hash_t</name> *</type><name>revprop_table</name></decl></param>,
                   <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>log_msg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>excludes</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_dir</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>new_entries</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>4</expr></argument>,
                                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>temp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <comment type="block">/* Create a new commit item and add it to the array. */</comment>
  <if>if <condition>(<expr><call><name>SVN_CLIENT__HAS_LOG_MSG_FUNC</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* If there's a log message gatherer, create a temporary commit
         item array solely to help generate the log message.  The
         array is not used for the import itself. */</comment>
      <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>item</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>commit_items</name>
        <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client_commit_item_create</name>
              <argument_list>(<argument><expr>(const <name>svn_client_commit_item3_t</name> **) &amp;<name>item</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>state_flags</name></name> = <name>SVN_CLIENT_COMMIT_ITEM_ADD</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>commit_items</name></expr></argument>, <argument><expr><name>svn_client_commit_item3_t</name> *</expr></argument>)</argument_list></call> = <name>item</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_client__get_log_msg</name><argument_list>(<argument><expr>&amp;<name>log_msg</name></expr></argument>, <argument><expr>&amp;<name>tmp_file</name></expr></argument>, <argument><expr><name>commit_items</name></expr></argument>,
                                      <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>log_msg</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
      <if>if <condition>(<expr><name>tmp_file</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>abs_path</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>abs_path</name></expr></argument>, <argument><expr><name>tmp_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>excludes</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>(<name>void</name> *)1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>base_dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Figure out all the path components we need to create just to have
     a place to stick our imported tree. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* See if the user is interested in cancelling this operation. */</comment>
      <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>ctx</name>-&gt;<name>cancel_func</name></name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If get_ra_editor below failed we either tried to open
             an invalid url, or else some other kind of error.  In case
             the url was bad we back up a directory and try again. */</comment>

          <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> != <name>SVN_ERR_FS_NO_SUCH_ENTRY</name></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then>
          <else>else
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

          <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>, <argument><expr>&amp;<name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>new_entries</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> =
            <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>url</name> = <name>temp</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block>
  while <condition>(<expr>(<name>err</name> = <call><name>get_ra_editor</name><argument_list>(<argument><expr>&amp;<name>ra_session</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr>&amp;<name>editor</name></expr></argument>, <argument><expr>&amp;<name>edit_baton</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>log_msg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>revprop_table</name></expr></argument>, 
                              <argument><expr><name>commit_info_p</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call>)</expr>)</condition>;</do>

  <comment type="block">/* Reverse the order of the components we added to our NEW_ENTRIES array. */</comment>
  <if>if <condition>(<expr><name><name>new_entries</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name><name>new_entries</name>-&gt;<name>nelts</name></name> / 2)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <expr_stmt><expr><name>j</name> = <name><name>new_entries</name>-&gt;<name>nelts</name></name> - <name>i</name> - 1</expr>;</expr_stmt>
          <expr_stmt><expr><name>component</name> =
            <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>new_entries</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>new_entries</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> =
            <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>new_entries</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>new_entries</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> =
            <name>component</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* An empty NEW_ENTRIES list the first call to get_ra_editor() above
     succeeded.  That means that URL corresponds to an already
     existing filesystem entity. */</comment>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name> &amp;&amp; (! <name><name>new_entries</name>-&gt;<name>nelts</name></name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_ENTRY_EXISTS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' already exists"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* The repository doesn't know about the reserved administrative
     directory. */</comment>
  <if>if <condition>(<expr><name><name>new_entries</name>-&gt;<name>nelts</name></name>
      <comment type="block">/* What's this, what's this?  This assignment is here because we
         use the value to construct the error message just below.  It
         may not be aesthetically pleasing, but it's less ugly than
         calling APR_ARRAY_IDX twice. */</comment>
      &amp;&amp; <call><name>svn_wc_is_adm_dir</name><argument_list>(<argument><expr><name>temp</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>new_entries</name></expr></argument>,
                                                <argument><expr><name><name>new_entries</name>-&gt;<name>nelts</name></name> - 1</expr></argument>,
                                                <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_CL_ADM_DIR_RESERVED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is a reserved name and cannot be imported"</expr></argument>)</argument_list></call></expr></argument>,
       <comment type="block">/* ### Is svn_path_local_style() really necessary for this? */</comment>
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>


  <comment type="block">/* If an error occurred during the commit, abort the edit and return
     the error.  We don't even care if the abort itself fails.  */</comment>
  <if>if <condition>(<expr>(<name>err</name> = <call><name>import</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>new_entries</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                    <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>excludes</name></expr></argument>, <argument><expr><name>no_ignore</name></expr></argument>,
                    <argument><expr><name>ignore_unknown_node_types</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>abort_edit</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Transfer *COMMIT_INFO from the subpool to the callers pool */</comment>
  <if>if <condition>(<expr>*<name>commit_info_p</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_commit_info_t</name> *</type><name>tmp_commit_info</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>tmp_commit_info</name> = <call><name>svn_create_commit_info</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>tmp_commit_info</name> = **<name>commit_info_p</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>tmp_commit_info</name>-&gt;<name>date</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tmp_commit_info</name>-&gt;<name>date</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>tmp_commit_info</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name><name>tmp_commit_info</name>-&gt;<name>author</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tmp_commit_info</name>-&gt;<name>author</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>tmp_commit_info</name>-&gt;<name>author</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name><name>tmp_commit_info</name>-&gt;<name>post_commit_err</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>tmp_commit_info</name>-&gt;<name>post_commit_err</name></name>
          = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>tmp_commit_info</name>-&gt;<name>post_commit_err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr>*<name>commit_info_p</name> = <name>tmp_commit_info</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_client_import2</name><parameter_list>(<param><decl><type><name>svn_commit_info_t</name> **</type><name>commit_info_p</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>nonrecursive</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>no_ignore</name></decl></param>,
                   <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_client_import3</name><argument_list>(<argument><expr><name>commit_info_p</name></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>, <argument><expr><name>url</name></expr></argument>,
                            <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr>! <name>nonrecursive</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>no_ignore</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_import</name><parameter_list>(<param><decl><type><name>svn_client_commit_info_t</name> **</type><name>commit_info_p</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>nonrecursive</name></decl></param>,
                  <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_commit_info_t</name> *</type><name>commit_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_client_import2</name><argument_list>(<argument><expr>&amp;<name>commit_info</name></expr></argument>,
                           <argument><expr><name>path</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>nonrecursive</name></expr></argument>,
                           <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* These structs have the same layout for the common fields. */</comment>
  <expr_stmt><expr>*<name>commit_info_p</name> = (<name>svn_client_commit_info_t</name> *) <name>commit_info</name></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_tmpfiles</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>tempfiles</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <comment type="block">/* Split if there's nothing to be done. */</comment>
  <if>if <condition>(<expr>! <name>tempfiles</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Make a subpool. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clean up any tempfiles. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>tempfiles</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>key</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>! <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then>
          <else>else
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Remove the subpool. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>reconcile_errors</name><parameter_list>(<param><decl><type><name>svn_error_t</name> *</type><name>commit_err</name></decl></param>,
                 <param><decl><type><name>svn_error_t</name> *</type><name>unlock_err</name></decl></param>,
                 <param><decl><type><name>svn_error_t</name> *</type><name>bump_err</name></decl></param>,
                 <param><decl><type><name>svn_error_t</name> *</type><name>cleanup_err</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Early release (for good behavior). */</comment>
  <if>if <condition>(<expr>! (<name>commit_err</name> || <name>unlock_err</name> || <name>bump_err</name> || <name>cleanup_err</name>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If there was a commit error, start off our error chain with
     that. */</comment>
  <if>if <condition>(<expr><name>commit_err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>commit_err</name> = <call><name>svn_error_quick_wrap</name>
        <argument_list>(<argument><expr><name>commit_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Commit failed (details follow):"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>commit_err</name></expr>;</expr_stmt>
    }</block></then>

  <comment type="block">/* Else, create a new "general" error that will lead off the errors
     that follow. */</comment>
  <else>else
    <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_BASE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Commit succeeded, but other errors follow:"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* If there was an unlock error... */</comment>
  <if>if <condition>(<expr><name>unlock_err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Wrap the error with some headers. */</comment>
      <expr_stmt><expr><name>unlock_err</name> = <call><name>svn_error_quick_wrap</name>
        <argument_list>(<argument><expr><name>unlock_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error unlocking locked dirs (details follow):"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Append this error to the chain. */</comment>
      <expr_stmt><expr><call><name>svn_error_compose</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>unlock_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If there was a bumping error... */</comment>
  <if>if <condition>(<expr><name>bump_err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Wrap the error with some headers. */</comment>
      <expr_stmt><expr><name>bump_err</name> = <call><name>svn_error_quick_wrap</name>
        <argument_list>(<argument><expr><name>bump_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error bumping revisions post-commit (details follow):"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Append this error to the chain. */</comment>
      <expr_stmt><expr><call><name>svn_error_compose</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>bump_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If there was a cleanup error... */</comment>
  <if>if <condition>(<expr><name>cleanup_err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Wrap the error with some headers. */</comment>
      <expr_stmt><expr><name>cleanup_err</name> = <call><name>svn_error_quick_wrap</name>
        <argument_list>(<argument><expr><name>cleanup_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error in post-commit clean-up (details follow):"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Append this error to the chain. */</comment>
      <expr_stmt><expr><call><name>svn_error_compose</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>cleanup_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Remove redundancies by removing duplicates from NONRECURSIVE_TARGETS,
 * and removing any target that either is, or is a descendant of, a path in
 * RECURSIVE_TARGETS.  Return the result in *PUNIQUE_TARGETS.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_redundancies</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>punique_targets</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>nonrecursive_targets</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>recursive_targets</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>temp_pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>abs_recursive_targets</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>abs_targets</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rel_targets</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<name><name>nonrecursive_targets</name>-&gt;<name>nelts</name></name> &lt;= 0) || (! <name>punique_targets</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* No targets or no place to store our work means this function
         really has nothing to do. */</comment>
      <if>if <condition>(<expr><name>punique_targets</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>punique_targets</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Initialize our temporary pool. */</comment>
  <expr_stmt><expr><name>temp_pool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create our list of absolute paths for our "keepers" */</comment>
  <expr_stmt><expr><name>abs_targets</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>temp_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create our list of absolute paths for our recursive targets */</comment>
  <if>if <condition>(<expr><name>recursive_targets</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>abs_recursive_targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>temp_pool</name></expr></argument>,
                                             <argument><expr><name><name>recursive_targets</name>-&gt;<name>nelts</name></name></expr></argument>,
                                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>recursive_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel_path</name> <init>=
            <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>recursive_targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>abs_path</name></decl>;</decl_stmt>

          <comment type="block">/* Get the absolute path for this target. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>abs_path</name></expr></argument>, <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>temp_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>abs_recursive_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>abs_path</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Create our list of untainted paths for our "keepers" */</comment>
  <expr_stmt><expr><name>rel_targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>nonrecursive_targets</name>-&gt;<name>nelts</name></name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For each target in our list we do the following:

     1. Calculate its absolute path (ABS_PATH).
     2. See if any of the keepers in RECURSIVE_TARGETS is a parent of, or
        is the same path as, ABS_PATH.  If so, we ignore this
        target.  If not, however, add this target's original path to
        REL_TARGETS. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>nonrecursive_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel_path</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>nonrecursive_targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                           <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>abs_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>keep_me</name></decl>;</decl_stmt>

      <comment type="block">/* Get the absolute path for this target. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>abs_path</name></expr></argument>, <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>temp_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* For each keeper in ABS_TARGETS, see if this target is the
         same as or a child of that keeper. */</comment>
      <expr_stmt><expr><name>keep_me</name> = <name>TRUE</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>abs_recursive_targets</name></expr>)</condition><then>
        <block>{
          <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>abs_recursive_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keeper</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>abs_recursive_targets</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                                                 <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <comment type="block">/* Quit here if we find this path already in the keepers. */</comment>
              <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>keeper</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>keep_me</name> = <name>FALSE</name></expr>;</expr_stmt>
                  <break>break;</break>
                }</block></then></if>

              <comment type="block">/* Quit here if this path is a child of one of the keepers. */</comment>
              <if>if <condition>(<expr><call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>keeper</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>temp_pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>keep_me</name> = <name>FALSE</name></expr>;</expr_stmt>
                  <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block></then></if>

      <comment type="block">/* If this is a new keeper, add its absolute path to ABS_TARGETS
         and its original path to REL_TARGETS. */</comment>
      <if>if <condition>(<expr><name>keep_me</name>
          &amp;&amp; <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>abs_targets</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>rel_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>rel_path</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>abs_targets</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Destroy our temporary pool. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>temp_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure we return the list of untainted keeper paths. */</comment>
  <expr_stmt><expr>*<name>punique_targets</name> = <name>rel_targets</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Adjust relative targets.  If there is an empty string in REL_TARGETS
 * get the actual target anchor point.  It is likely that this is one dir up
 * from BASE_DIR, therefor we need to prepend the name part of the actual
 * target to all paths in REL_TARGETS.  Return the new anchor in *PBASE_DIR,
 * and the adjusted relative paths in *PREL_TARGETS.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>adjust_rel_targets</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pbase_dir</name></decl></param>,
                   <param><decl><type><name>apr_array_header_t</name> **</type><name>prel_targets</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_dir</name></decl></param>,
                   <param><decl><type><name>apr_array_header_t</name> *</type><name>rel_targets</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>anchor_one_up</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>new_rel_targets</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rel_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>target</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rel_targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>target</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>anchor_one_up</name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Default to not doing anything */</comment>
  <expr_stmt><expr><name>new_rel_targets</name> = <name>rel_targets</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>anchor_one_up</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_get_actual_target</name><argument_list>(<argument><expr><name>base_dir</name></expr></argument>, <argument><expr>&amp;<name>parent_dir</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>*<name>name</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Our new "grandfather directory" is the parent directory
             of the former one. */</comment>
          <expr_stmt><expr><name>base_dir</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>new_rel_targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>rel_targets</name>-&gt;<name>nelts</name></name></expr></argument>,
                                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rel_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
              <expr_stmt><expr><name>target</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rel_targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>target</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>new_rel_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>target</name></expr>;</expr_stmt>
            }</block></for>
         }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr>*<name>pbase_dir</name> = <name>base_dir</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>prel_targets</name> = <name>new_rel_targets</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* For all lock tokens in ALL_TOKENS for URLs under BASE_URL, add them
   to a new hashtable allocated in POOL.  *RESULT is set to point to this
   new hash table.  *RESULT will be keyed on const char * URI-decoded paths
   relative to BASE_URL.  The lock tokens will not be duplicated. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>collect_lock_tokens</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>result</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>all_tokens</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>base_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>base_url</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>result</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>all_tokens</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>url</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>token</name> = <name>val</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>base_len</name></expr></argument>)</argument_list></call> == 0
          &amp;&amp; (<name><name>url</name><index>[<expr><name>base_len</name></expr>]</index></name> == '\0' || <name><name>url</name><index>[<expr><name>base_len</name></expr>]</index></name> == '/')</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>url</name><index>[<expr><name>base_len</name></expr>]</index></name> == '\0'</expr>)</condition><then>
            <expr_stmt><expr><name>url</name> = ""</expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>url</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>url</name> + <name>base_len</name> + 1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>result</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<struct>struct <name>post_commit_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_wc_committed_queue_t</name> *</type><name>queue</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>qpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>base_dir_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>keep_changelists</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>keep_locks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>digests</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>post_process_commit_item</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>void</name> *</type><name>this_item</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>post_commit_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><name><name>btn</name>-&gt;<name>qpool</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> *</type><name>item</name> <init>=
    <expr>*(<name>svn_client_commit_item3_t</name> **)<name>this_item</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>loop_recurse</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>adm_access_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>remove_lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>bump_err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>item</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><name>adm_access_path</name> = <name><name>item</name>-&gt;<name>path</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name>adm_access_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>bump_err</name> = <call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>base_dir_access</name></name></expr></argument>,
                                 <argument><expr><name>adm_access_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>bump_err</name>
      &amp;&amp; <name><name>bump_err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_NOT_LOCKED</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Is it a directory that was deleted in the commit?
         Then we probably committed a missing directory. */</comment>
      <if>if <condition>(<expr><name><name>item</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>
          &amp;&amp; <name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_DELETE</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Mark it as deleted in the parent. */</comment>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>bump_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>svn_wc_mark_missing_deleted</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>,
                                             <argument><expr><name><name>btn</name>-&gt;<name>base_dir_access</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>
  <if>if <condition>(<expr><name>bump_err</name></expr>)</condition><then>
    <return>return <expr><name>bump_err</name></expr>;</return></then></if>


  <if>if <condition>(<expr>(<name><name>item</name>-&gt;<name>state_flags</name></name> &amp; <name>SVN_CLIENT_COMMIT_ITEM_ADD</name>)
      &amp;&amp; (<name><name>item</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)
      &amp;&amp; (<name><name>item</name>-&gt;<name>copyfrom_url</name></name>)</expr>)</condition><then>
    <expr_stmt><expr><name>loop_recurse</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>remove_lock</name> = (! <name><name>btn</name>-&gt;<name>keep_locks</name></name> &amp;&amp; (<name><name>item</name>-&gt;<name>state_flags</name></name>
                                       &amp; <name>SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN</name>))</expr>;</expr_stmt>

  <comment type="block">/* Allocate the queue in a longer-lived pool than (iter)pool:
     we want it to survive the next iteration. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_queue_committed</name>
          <argument_list>(<argument><expr>&amp;(<name><name>btn</name>-&gt;<name>queue</name></name>)</expr></argument>,
           <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>loop_recurse</name></expr></argument>,
           <argument><expr><name><name>item</name>-&gt;<name>incoming_prop_changes</name></name></expr></argument>,
           <argument><expr><name>remove_lock</name></expr></argument>, <argument><expr>(! <name><name>btn</name>-&gt;<name>keep_changelists</name></name>)</expr></argument>,
           <argument><expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>digests</name></name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>commit_item_is_changed</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>void</name> *</type><name>this_item</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_client_commit_item3_t</name> **</type><name>item</name> <init>= <expr><name>this_item</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>(*<name>item</name>)-&gt;<name>state_flags</name></name> != <name>SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_iter_break</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<struct>struct <name>lock_dirs_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>base_dir_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>levels_to_lock</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>lock_dirs_for_commit</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>void</name> *</type><name>this_item</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>lock_dirs_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>base_dir_access</name></name></expr></argument>,
                          <argument><expr>*(const <name>char</name> **)<name>this_item</name></expr></argument>,
                          <argument><expr><name>TRUE</name></expr></argument>, <comment type="block">/* Write lock */</comment>
                          <argument><expr><name><name>btn</name>-&gt;<name>levels_to_lock</name></name></expr></argument>,
                          <argument><expr><name><name>btn</name>-&gt;<name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                          <argument><expr><name><name>btn</name>-&gt;<name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<struct>struct <name>check_dir_delete_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>base_dir_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_nonrecursive_dir_delete</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>void</name> *</type><name>this_item</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>check_dir_delete_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>target</name></expr></argument>, <argument><expr>*(const <name>char</name> **)<name>this_item</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>base_dir_access</name></name></expr></argument>,
                                      <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Are all the targets part of the same working copy?"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### TODO(sd): This check is slightly too strict.  It should be
     ### possible to:
     ###
     ###   * delete an empty directory when depth==svn_depth_empty;
     ###
     ###   * delete a directory containing only files when
     ###     depth==svn_depth_files;
     ###
     ###   * delete a directory containing only files and empty
     ###     subdirs when depth==svn_depth_immediates.
     ###
     ### But for now, we insist on svn_depth_infinity if you're
     ### going to delete a directory, because we're lazy and
     ### trying to get depthy commits working in the first place.
     ###
     ### This would be fairly easy to fix, though: just, well,
     ### check the above conditions!
  */</comment>
  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>depth</name></name> != <name>svn_depth_infinity</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_status2_t</name> *</type><name>status</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_status2</name><argument_list>(<argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>status</name>-&gt;<name>text_status</name></name> == <name>svn_wc_status_deleted</name> ||
              <name><name>status</name>-&gt;<name>text_status</name></name> == <name>svn_wc_status_replaced</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot non-recursively commit a "
                                      "directory deletion"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></then></if>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_commit4</name><parameter_list>(<param><decl><type><name>svn_commit_info_t</name> **</type><name>commit_info_p</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>targets</name></decl></param>,
                   <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>keep_locks</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>keep_changelists</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>changelists</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_hash_t</name> *</type><name>revprop_table</name></decl></param>,
                   <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>log_msg</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rel_targets</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>dirs_to_lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>dirs_to_lock_recursive</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>lock_base_dir_recursive</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>committables</name></decl>, *<decl><type ref="prev"/><name>lock_tokens</name></decl>, *<decl><type ref="prev"/><name>tempfiles</name> <init>= <expr><name>NULL</name></expr></init>, *<name>digests</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>base_dir_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>commit_items</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>cmt_err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init>, *<name>unlock_err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>bump_err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init>, *<name>cleanup_err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>commit_in_progress</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>display_dir</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Committing URLs doesn't make sense, so error if it's tried. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>target</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_ILLEGAL_TARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is a URL, but URLs cannot be commit targets"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>

  <comment type="block">/* Condense the target list. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_condense_targets</name><argument_list>(<argument><expr>&amp;<name>base_dir</name></expr></argument>, <argument><expr>&amp;<name>rel_targets</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>,
                                    <argument><expr><name>depth</name> == <name>svn_depth_infinity</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* When svn_path_condense_targets() was written, we didn't have real
   * depths, we just had recursive / nonrecursive.
   *
   * Nowadays things are more complex.  If depth == svn_depth_files,
   * for example, and two targets are "foo" and "foo/bar", then
   * ideally we should condense out "foo/bar" if it's a file and not
   * if it's a directory.  And, of course, later when we get adm
   * access batons for the commit, we'd ideally lock directories to
   * precisely the depth required and no deeper.
   *
   * But for now we don't do that.  Instead, we lock recursively from
   * base_dir, if depth indicates that we might need anything below
   * there (but note that above, we don't condense away targets that
   * need to be named explicitly when depth != svn_depth_infinity).
   *
   * Here's a case where this all matters:
   *
   *    $ svn st -q
   *    M      A/D/G/rho
   *    M      iota
   *    $ svn ci -m "log msg" --depth=immediates . A/D/G
   *
   * If we don't lock base_dir recursively, then it will get an error...
   *
   *    subversion/libsvn_wc/lock.c:570: (apr_err=155004)
   *    svn: Working copy '/blah/blah/blah/wc' locked
   *    svn: run 'svn cleanup' to remove locks \
   *         (type 'svn help cleanup' for details)
   *
   * ...because later (see dirs_to_lock_recursively and dirs_to_lock)
   * we'd call svn_wc_adm_open3() to get access objects for "" and
   * "A/D/G", but the request for "" would fail because base_dir_access
   * would already be open for that directory.  (In that circumstance,
   * you're supposed to use svn_wc_adm_retrieve() instead; but it
   * would be clumsy to have a conditional path just to decide between
   * open3() and retrieve().)
   *
   * (Note that the results would be the same if even the working copy
   * were an explicit argument, e.g.:
   * 'svn ci -m "log msg" --depth=immediates wc wc/A/D/G'.)
   *
   * So we set lock_base_dir_recursive=TRUE now, and end up locking
   * more than we need to, but this keeps the code simple and correct.
   *
   * In an inspired bit of foresight, the adm locking code anticipated
   * the eventual addition of svn_depth_immediates, and allows us to
   * set the exact number of lock levels.  So optimizing the code here
   * at least shouldn't require any changes to the adm locking system.
   */</comment>
  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_files</name> || <name>depth</name> == <name>svn_depth_immediates</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel_target</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rel_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <block>{
          <expr_stmt><expr><name>rel_target</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rel_targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>rel_target</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
            <expr_stmt><expr><name>lock_base_dir_recursive</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* No targets means nothing to commit, so just return. */</comment>
  <if>if <condition>(<expr>! <name>base_dir</name></expr>)</condition><then>
    <goto>goto <name>cleanup</name>;</goto></then></if>

  <comment type="block">/* Prepare an array to accumulate dirs to lock */</comment>
  <expr_stmt><expr><name>dirs_to_lock</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dirs_to_lock_recursive</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we calculated only a base_dir and no relative targets, this
     must mean that we are being asked to commit (effectively) a
     single path. */</comment>
  <if>if <condition>(<expr>(! <name>rel_targets</name>) || (! <name><name>rel_targets</name>-&gt;<name>nelts</name></name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_get_actual_target</name><argument_list>(<argument><expr><name>base_dir</name></expr></argument>, <argument><expr>&amp;<name>parent_dir</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>*<name>name</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

          <comment type="block">/* Our new "grandfather directory" is the parent directory
             of the former one. */</comment>
          <expr_stmt><expr><name>base_dir</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Make the array if it wasn't already created. */</comment>
          <if>if <condition>(<expr>! <name>rel_targets</name></expr>)</condition><then>
            <expr_stmt><expr><name>rel_targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>targets</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* Now, push this name as a relative path to our new
             base directory. */</comment>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>rel_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>name</name></expr>;</expr_stmt>

          <expr_stmt><expr><name>target</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>base_dir</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If the final target is a dir, we want to recursively lock it */</comment>
          <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_infinity</name> || <name>depth</name> == <name>svn_depth_immediates</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>dirs_to_lock_recursive</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>target</name></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>dirs_to_lock</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>target</name></expr>;</expr_stmt></else></if>
            }</block></then></if>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* Unconditionally lock recursively down from base_dir. */</comment>
          <expr_stmt><expr><name>lock_base_dir_recursive</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else <if>if <condition>(<expr>! <name>lock_base_dir_recursive</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>adjust_rel_targets</name><argument_list>(<argument><expr>&amp;<name>base_dir</name></expr></argument>, <argument><expr>&amp;<name>rel_targets</name></expr></argument>,
                                 <argument><expr><name>base_dir</name></expr></argument>, <argument><expr><name>rel_targets</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rel_targets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>target</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>base_dir</name></expr></argument>,
                                 <argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rel_targets</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If the final target is a dir, we want to lock it */</comment>
          <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Notice how here we test infinity||immediates, but up
                 in the call to svn_path_condense_targets(), we only
                 tested depth==infinity.  That's because condensation
                 and adm lock acquisition serve different purposes. */</comment>
              <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_infinity</name> || <name>depth</name> == <name>svn_depth_immediates</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>dirs_to_lock_recursive</name></expr></argument>,
                               <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <comment type="block">/* Don't lock if target is the base_dir, base_dir will be
                   locked anyway and we can't lock it twice */</comment>
                <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
                  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>dirs_to_lock</name></expr></argument>,
                                 <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
            }</block></then></if>

          <comment type="block">/* Now we need to iterate over the parent paths of this path
             adding them to the set of directories we want to lock.
             Do nothing if target is already the base_dir. */</comment>
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr>&amp;<name>parent_dir</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><name>target</name> = <name>parent_dir</name></expr>;</expr_stmt>

              <while>while <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>)</argument_list></call> != 0</expr>)</condition>
                <block>{
                  <if>if <condition>(<expr>(<name><name>target</name><index>[<expr>0</expr>]</index></name> == '\0') ||
                      <call><name>svn_dirent_is_root</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>
                     )</condition><then>
                    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

                  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>dirs_to_lock</name></expr></argument>,
                                 <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name>target</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></while>
            }</block></then></if>
        }</block></for>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>base_dir_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>,
                           <argument><expr><name>TRUE</name></expr></argument>,  <comment type="block">/* Write lock */</comment>
                           <argument><expr><name>lock_base_dir_recursive</name> ? -1 : 0</expr></argument>, <comment type="block">/* lock levels */</comment>
                           <argument><expr><name><name>ctx</name>-&gt;<name>cancel_func</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>lock_base_dir_recursive</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>unique_dirs_to_lock</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>lock_dirs_baton</name></type> <name>btn</name></decl>;</decl_stmt>

      <comment type="block">/* Sort the paths in a depth-last directory-ish order. */</comment>
      <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>dirs_to_lock</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>dirs_to_lock</name>-&gt;<name>nelts</name></name></expr></argument>,
            <argument><expr><name><name>dirs_to_lock</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>svn_sort_compare_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>dirs_to_lock_recursive</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>dirs_to_lock_recursive</name>-&gt;<name>nelts</name></name></expr></argument>,
            <argument><expr><name><name>dirs_to_lock_recursive</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>svn_sort_compare_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Remove any duplicates */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_remove_redundancies</name><argument_list>(<argument><expr>&amp;<name>unique_dirs_to_lock</name></expr></argument>,
                                           <argument><expr><name>dirs_to_lock_recursive</name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirs_to_lock_recursive</name> = <name>unique_dirs_to_lock</name></expr>;</expr_stmt>

      <comment type="block">/* Remove dirs and descendants from dirs_to_lock if there is
         any ancestor in dirs_to_lock_recursive */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_redundancies</name><argument_list>(<argument><expr>&amp;<name>unique_dirs_to_lock</name></expr></argument>,
                                  <argument><expr><name>dirs_to_lock</name></expr></argument>,
                                  <argument><expr><name>dirs_to_lock_recursive</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirs_to_lock</name> = <name>unique_dirs_to_lock</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>btn</name>.<name>base_dir_access</name></name> = <name>base_dir_access</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>.<name>levels_to_lock</name></name> = 0</expr>;</expr_stmt>
      <comment type="block">/* First lock all the dirs to be locked non-recursively */</comment>
      <if>if <condition>(<expr><name>dirs_to_lock</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_iter_apr_array</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dirs_to_lock</name></expr></argument>,
                                   <argument><expr><name>lock_dirs_for_commit</name></expr></argument>, <argument><expr>&amp;<name>btn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Lock the rest of the targets (recursively) */</comment>
      <expr_stmt><expr><name><name>btn</name>.<name>levels_to_lock</name></name> = -1</expr>;</expr_stmt>
      <if>if <condition>(<expr><name>dirs_to_lock_recursive</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_iter_apr_array</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dirs_to_lock_recursive</name></expr></argument>,
                                   <argument><expr><name>lock_dirs_for_commit</name></expr></argument>, <argument><expr>&amp;<name>btn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* One day we might support committing from multiple working copies, but
     we don't yet.  This check ensures that we don't silently commit a
     subset of the targets.

     At the same time, if a non-recursive commit is desired, do not
     allow a deleted directory as one of the targets. */</comment>
  <block>{
    <decl_stmt><decl><type>struct <name>check_dir_delete_baton</name></type> <name>btn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>btn</name>.<name>base_dir_access</name></name> = <name>base_dir_access</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>btn</name>.<name>depth</name></name> = <name>depth</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_iter_apr_array</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>,
                               <argument><expr><name>check_nonrecursive_dir_delete</name></expr></argument>, <argument><expr>&amp;<name>btn</name></expr></argument>,
                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <comment type="block">/* Crawl the working copy for commit items. */</comment>
  <if>if <condition>(<expr>(<name>cmt_err</name> = <call><name>svn_client__harvest_committables</name><argument_list>(<argument><expr>&amp;<name>committables</name></expr></argument>,
                                                  <argument><expr>&amp;<name>lock_tokens</name></expr></argument>,
                                                  <argument><expr><name>base_dir_access</name></expr></argument>,
                                                  <argument><expr><name>rel_targets</name></expr></argument>,
                                                  <argument><expr><name>depth</name></expr></argument>,
                                                  <argument><expr>! <name>keep_locks</name></expr></argument>,
                                                  <argument><expr><name>changelists</name></expr></argument>,
                                                  <argument><expr><name>ctx</name></expr></argument>,
                                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <goto>goto <name>cleanup</name>;</goto></then></if>

  <comment type="block">/* ### todo: Currently there should be only one hash entry, which
     has a hacked name until we have the entries files storing
     canonical repository URLs.  Then, the hacked name can go away
     and be replaced with a canonical repos URL, and from there we
     are poised to started handling nested working copies.  See
     http://subversion.tigris.org/issues/show_bug.cgi?id=960. */</comment>
  <if>if <condition>(<expr>! ((<name>commit_items</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>committables</name></expr></argument>,
                                      <argument><expr><name>SVN_CLIENT__SINGLE_REPOS_NAME</name></expr></argument>,
                                      <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>))</expr>)</condition><then>
    <goto>goto <name>cleanup</name>;</goto></then></if>

  <comment type="block">/* If our array of targets contains only locks (and no actual file
     or prop modifications), then we return here to avoid committing a
     revision with no changes. */</comment>
  <block>{
    <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>not_found_changed_path</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>


    <expr_stmt><expr><name>cmt_err</name> = <call><name>svn_iter_apr_array</name><argument_list>(<argument><expr>&amp;<name>not_found_changed_path</name></expr></argument>,
                                 <argument><expr><name>commit_items</name></expr></argument>,
                                 <argument><expr><name>commit_item_is_changed</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>not_found_changed_path</name> || <name>cmt_err</name></expr>)</condition><then>
      <goto>goto <name>cleanup</name>;</goto></then></if>
  }</block>

  <comment type="block">/* Go get a log message.  If an error occurs, or no log message is
     specified, abort the operation. */</comment>
  <if>if <condition>(<expr><call><name>SVN_CLIENT__HAS_LOG_MSG_FUNC</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_file</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>cmt_err</name> = <call><name>svn_client__get_log_msg</name><argument_list>(<argument><expr>&amp;<name>log_msg</name></expr></argument>, <argument><expr>&amp;<name>tmp_file</name></expr></argument>, <argument><expr><name>commit_items</name></expr></argument>,
                                        <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>cmt_err</name> || (! <name>log_msg</name>)</expr>)</condition><then>
        <goto>goto <name>cleanup</name>;</goto></then></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>log_msg</name> = ""</expr>;</expr_stmt></else></if>

  <comment type="block">/* Sort and condense our COMMIT_ITEMS. */</comment>
  <if>if <condition>(<expr>(<name>cmt_err</name> = <call><name>svn_client__condense_commit_items</name><argument_list>(<argument><expr>&amp;<name>base_url</name></expr></argument>,
                                                   <argument><expr><name>commit_items</name></expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <goto>goto <name>cleanup</name>;</goto></then></if>

  <comment type="block">/* Collect our lock tokens with paths relative to base_url. */</comment>
  <if>if <condition>(<expr>(<name>cmt_err</name> = <call><name>collect_lock_tokens</name><argument_list>(<argument><expr>&amp;<name>lock_tokens</name></expr></argument>, <argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>base_url</name></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <goto>goto <name>cleanup</name>;</goto></then></if>

  <if>if <condition>(<expr>(<name>cmt_err</name> = <call><name>get_ra_editor</name><argument_list>(<argument><expr>&amp;<name>ra_session</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr>&amp;<name>editor</name></expr></argument>, <argument><expr>&amp;<name>edit_baton</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>,
                               <argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>, <argument><expr><name>base_dir_access</name></expr></argument>, <argument><expr><name>log_msg</name></expr></argument>, 
                               <argument><expr><name>commit_items</name></expr></argument>, <argument><expr><name>revprop_table</name></expr></argument>, <argument><expr><name>commit_info_p</name></expr></argument>,
                               <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>keep_locks</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <goto>goto <name>cleanup</name>;</goto></then></if>

  <comment type="block">/* Make a note that we have a commit-in-progress. */</comment>
  <expr_stmt><expr><name>commit_in_progress</name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* Determine prefix to strip from the commit notify messages */</comment>
  <if>if <condition>(<expr>(<name>cmt_err</name> = <call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>display_dir</name></expr></argument>,
                                       <argument><expr><name>display_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <goto>goto <name>cleanup</name>;</goto></then></if>
  <expr_stmt><expr><name>display_dir</name> = <call><name>svn_path_get_longest_ancestor</name><argument_list>(<argument><expr><name>display_dir</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Perform the commit. */</comment>
  <expr_stmt><expr><name>cmt_err</name> = <call><name>svn_client__do_commit</name><argument_list>(<argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>commit_items</name></expr></argument>, <argument><expr><name>base_dir_access</name></expr></argument>,
                                  <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                                  <argument><expr><name>display_dir</name></expr></argument>,
                                  <argument><expr>&amp;<name>tempfiles</name></expr></argument>, <argument><expr>&amp;<name>digests</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Handle a successful commit. */</comment>
  <if>if <condition>(<expr>(! <name>cmt_err</name>)
      || (<name><name>cmt_err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_committed_queue_t</name> *</type><name>queue</name> <init>= <expr><call><name>svn_wc_committed_queue_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>post_commit_baton</name></type> <name>btn</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>btn</name>.<name>queue</name></name> = <name>queue</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>.<name>qpool</name></name> = <name>pool</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>.<name>base_dir_access</name></name> = <name>base_dir_access</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>.<name>keep_changelists</name></name> = <name>keep_changelists</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>.<name>keep_locks</name></name> = <name>keep_locks</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>.<name>digests</name></name> = <name>digests</name></expr>;</expr_stmt>

      <comment type="block">/* Make a note that our commit is finished. */</comment>
      <expr_stmt><expr><name>commit_in_progress</name> = <name>FALSE</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>bump_err</name> = <call><name>svn_iter_apr_array</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>commit_items</name></expr></argument>,
                                    <argument><expr><name>post_process_commit_item</name></expr></argument>, <argument><expr>&amp;<name>btn</name></expr></argument>,
                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>bump_err</name></expr>)</condition><then>
        <goto>goto <name>cleanup</name>;</goto></then></if>

      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>commit_info_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bump_err</name>
        = <call><name>svn_wc_process_committed_queue</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>base_dir_access</name></expr></argument>,
                                         <argument><expr><name>(*<name>commit_info_p</name>)-&gt;<name>revision</name></name></expr></argument>,
                                         <argument><expr><name>(*<name>commit_info_p</name>)-&gt;<name>date</name></name></expr></argument>,
                                         <argument><expr><name>(*<name>commit_info_p</name>)-&gt;<name>author</name></name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Sleep to ensure timestamp integrity. */</comment>
  <expr_stmt><expr><call><name>svn_sleep_for_timestamps</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

 <label><name>cleanup</name>:</label>
  <comment type="block">/* Abort the commit if it is still in progress. */</comment>
  <if>if <condition>(<expr><name>commit_in_progress</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>abort_edit</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* A bump error is likely to occur while running a working copy log file,
     explicitly unlocking and removing temporary files would be wrong in
     that case.  A commit error (cmt_err) should only occur before any
     attempt to modify the working copy, so it doesn't prevent explicit
     clean-up. */</comment>
  <if>if <condition>(<expr>! <name>bump_err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>unlock_err</name> = <call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>base_dir_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <name>unlock_err</name></expr>)</condition><then>
        <expr_stmt><expr><name>cleanup_err</name> = <call><name>remove_tmpfiles</name><argument_list>(<argument><expr><name>tempfiles</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* As per our promise, if *commit_info_p isn't set, provide a default where 
     rev = SVN_INVALID_REVNUM. */</comment>
  <if>if <condition>(<expr>! *<name>commit_info_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>commit_info_p</name> = <call><name>svn_create_commit_info</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><call><name>reconcile_errors</name><argument_list>(<argument><expr><name>cmt_err</name></expr></argument>, <argument><expr><name>unlock_err</name></expr></argument>, <argument><expr><name>bump_err</name></expr></argument>, <argument><expr><name>cleanup_err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_commit3</name><parameter_list>(<param><decl><type><name>svn_commit_info_t</name> **</type><name>commit_info_p</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>targets</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>keep_locks</name></decl></param>,
                   <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name> <init>= <expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_client_commit4</name><argument_list>(<argument><expr><name>commit_info_p</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>keep_locks</name></expr></argument>,
                            <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_commit2</name><parameter_list>(<param><decl><type><name>svn_client_commit_info_t</name> **</type><name>commit_info_p</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>targets</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>keep_locks</name></decl></param>,
                   <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_commit_info_t</name> *</type><name>commit_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_client_commit3</name><argument_list>(<argument><expr>&amp;<name>commit_info</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>keep_locks</name></expr></argument>,
                           <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* These structs have the same layout for the common fields. */</comment>
  <expr_stmt><expr>*<name>commit_info_p</name> = (<name>svn_client_commit_info_t</name> *) <name>commit_info</name></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_client_commit</name><parameter_list>(<param><decl><type><name>svn_client_commit_info_t</name> **</type><name>commit_info_p</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>targets</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>nonrecursive</name></decl></param>,
                  <param><decl><type><name>svn_client_ctx_t</name> *</type><name>ctx</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_client_commit2</name><argument_list>(<argument><expr><name>commit_info_p</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>,
                            <argument><expr><name>nonrecursive</name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>,
                            <argument><expr><name>TRUE</name></expr></argument>,
                            <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
