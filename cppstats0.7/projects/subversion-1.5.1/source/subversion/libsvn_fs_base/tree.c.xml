<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_base/tree.c"><comment type="block">/* tree.c : tree-like filesystem, built on DAG filesystem
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<comment type="block">/* The job of this layer is to take a filesystem with lots of node
   sharing going on --- the real DAG filesystem as it appears in the
   database --- and make it look and act like an ordinary tree
   filesystem, with no sharing.

   We do just-in-time cloning: you can walk from some unfinished
   transaction's root down into directories and files shared with
   committed revisions; as soon as you try to change something, the
   appropriate nodes get cloned (and parent directory entries updated)
   invisibly, behind your back.  Any other references you have to
   nodes that have been cloned by other changes, even made by other
   processes, are automatically updated to point to the right clones.  */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trail.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node-rev.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"key-gen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revs-txns.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/txn-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/rev-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/nodes-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/changes-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/copies-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/node-origins-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../libsvn_fs/fs-loader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_fs_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>


<comment type="block">/* ### I believe this constant will become internal to reps-strings.c.
   ### see the comment in window_consumer() for more information. */</comment>

<comment type="block">/* ### the comment also seems to need tweaking: the log file stuff
   ### is no longer an issue... */</comment>
<comment type="block">/* Data written to the filesystem through the svn_fs_apply_textdelta()
   interface is cached in memory until the end of the data stream, or
   until a size trigger is hit.  Define that trigger here (in bytes).
   Setting the value to 0 will result in no filesystem buffering at
   all.  The value only really matters when dealing with file contents
   bigger than the value itself.  Above that point, large values here
   allow the filesystem to buffer more data in memory before flushing
   to the database, which increases memory usage but greatly decreases
   the amount of disk access (and log-file generation) in database.
   Smaller values will limit your overall memory consumption, but can
   drastically hurt throughput by necessitating more write operations
   to the database (which also generates more log-files).  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BUFFER_SIZE</name></cpp:macro>          <cpp:value>512000</cpp:value></cpp:define>

<comment type="block">/* The maximum number of cache items to maintain in the node cache. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_CACHE_MAX_KEYS</name></cpp:macro>        <cpp:value>32</cpp:value></cpp:define>


<escape char="0xc"/>
<comment type="block">/* The root structure.  */</comment>

<comment type="block">/* Structure for svn_fs_root_t's node_cache hash values. */</comment>
<struct>struct <name>dag_node_cache_t</name>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt> <comment type="block">/* NODE to be cached. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>          <comment type="block">/* Index into the keys array for this cache item's key. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt> <comment type="block">/* Pool in which NODE is allocated. */</comment>
}</block>;</struct>


<typedef>typedef <type><struct>struct
<block>{

  <comment type="block">/* For revision roots, this is a dag node for the revision's root
     directory.  For transaction roots, we open the root directory
     afresh every time, since the root may have been cloned, or
     the transaction may have disappeared altogether.  */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl>;</decl_stmt>

  <comment type="block">/* Cache structures, for mapping const char * PATH to const
     struct dag_node_cache_t * structures.

     ### Currently this is only used for revision roots.  To be safe
     for transaction roots, you must have the guarantee that there is
     never more than a single transaction root per Subversion
     transaction ever open at a given time -- having two roots open to
     the same Subversion transaction would be a request for pain.
     Also, you have to ensure that if a 'make_path_mutable()' fails for
     any reason, you don't leave cached nodes for the portion of that
     function that succeeded.  In other words, this cache must never,
     ever, lie. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>node_cache</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>node_cache_keys</name><index>[<expr><name>NODE_CACHE_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>node_cache_idx</name></decl>;</decl_stmt>
}</block></struct></type> <name>base_root_data_t</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type><name>make_revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                                         <param><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type><name>make_txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn</name></decl></param>,
                                    <param><decl><type><name>svn_revnum_t</name></type> <name>base_rev</name></decl></param>, <param><decl><type><name>apr_uint32_t</name></type> <name>flags</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<escape char="0xc"/>
<comment type="block">/*** Node Caching in the Roots. ***/</comment>

<comment type="block">/* Return NODE for PATH from ROOT's node cache, or NULL if the node
   isn't cached. */</comment>
<function><type><specifier>static</specifier> <name>dag_node_t</name> *</type>
<name>dag_node_cache_get</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>base_root_data_t</name> *</type><name>brd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dag_node_cache_t</name> *</type><name>cache_item</name></decl>;</decl_stmt>

  <comment type="block">/* Assert valid input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>path</name> == '/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Only allow revision roots. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <comment type="block">/* Look in the cache for our desired item. */</comment>
  <expr_stmt><expr><name>cache_item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>node_cache</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>cache_item</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_fs_base__dag_dup</name><argument_list>(<argument><expr><name><name>cache_item</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/* Add the NODE for PATH to ROOT's node cache.  Callers should *NOT*
   call this unless they are adding a currently un-cached item to the
   cache, or are replacing the NODE for PATH with a new (different)
   one. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dag_node_cache_set</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>base_root_data_t</name> *</type><name>brd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cache_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>cache_pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dag_node_cache_t</name> *</type><name>cache_item</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>num_keys</name> <init>= <expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>node_cache</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* What?  No POOL passed to this function?

     To ensure that our cache values live as long as the svn_fs_root_t
     in which they are ultimately stored, and to allow us to free()
     them individually without harming the rest, they are each
     allocated from a subpool of ROOT's pool.  We'll keep one subpool
     around for each cache slot -- as we start expiring stuff
     to make room for more entries, we'll re-use the expired thing's
     pool. */</comment>

  <comment type="block">/* Assert valid input and state. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>path</name> == '/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>brd</name>-&gt;<name>node_cache_idx</name></name> &lt;= <name>num_keys</name>)
         &amp;&amp; (<name>num_keys</name> &lt;= <name>NODE_CACHE_MAX_KEYS</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Only allow revision roots. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="block">/* Special case: the caller wants us to replace an existing cached
     node with a new one.  If the callers aren't mindless, this should
     only happen when a node is made mutable under a transaction
     root, and that only happens once under that root.  So, we'll be a
     little bit sloppy here, and count on callers doing the right
     thing. */</comment>
  <expr_stmt><expr><name>cache_item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>node_cache</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>cache_item</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### This section is somehow broken.  I don't know how, but it
         ### is.  And I don't want to spend any more time on it.  So,
         ### callers, use only revision root and don't try to update
         ### an already-cached thing.  -- cmpilato */</comment>
      <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
      int cache_index = cache_item-&gt;idx;
      cache_path = brd-&gt;node_cache_keys[cache_index];
      cache_pool = cache_item-&gt;pool;
      cache_item-&gt;node = svn_fs_base__dag_dup(node, cache_pool);

      <comment type="block">/* Now, move the cache key reference to the end of the keys in
         the keys array (unless it's already at the end).  ### Yes,
         it's a memmove(), but we're not talking about pages of memory
         here. */</comment>
      if (cache_index != (num_keys - 1))
        {
          int move_num = NODE_CACHE_MAX_KEYS - cache_index - 1;
          memmove(brd-&gt;node_cache_keys + cache_index,
                  brd-&gt;node_cache_keys + cache_index + 1,
                  move_num * sizeof(const char *));
          cache_index = num_keys - 1;
          brd-&gt;node_cache_keys[cache_index] = cache_path;
        }

      <comment type="block">/* Advance the cache pointers. */</comment>
      cache_item-&gt;idx = cache_index;
      brd-&gt;node_cache_idx = (cache_index + 1) % NODE_CACHE_MAX_KEYS;
      return;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

  <comment type="block">/* We're adding a new cache item.  First, see if we have room for it
     (otherwise, make some room). */</comment>
  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>node_cache</name></name></expr></argument>)</argument_list></call> == <name>NODE_CACHE_MAX_KEYS</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* No room.  Expire the oldest thing. */</comment>
      <expr_stmt><expr><name>cache_path</name> = <name><name>brd</name>-&gt;<name>node_cache_keys</name><index>[<expr><name><name>brd</name>-&gt;<name>node_cache_idx</name></name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>cache_item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>node_cache</name></name></expr></argument>, <argument><expr><name>cache_path</name></expr></argument>,
                                <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>node_cache</name></name></expr></argument>, <argument><expr><name>cache_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cache_pool</name> = <name><name>cache_item</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>cache_pool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Make the cache item, allocated in its own pool. */</comment>
  <expr_stmt><expr><name>cache_item</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cache_item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cache_item</name>-&gt;<name>node</name></name> = <call><name>svn_fs_base__dag_dup</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cache_item</name>-&gt;<name>idx</name></name> = <name><name>brd</name>-&gt;<name>node_cache_idx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cache_item</name>-&gt;<name>pool</name></name> = <name>cache_pool</name></expr>;</expr_stmt>

  <comment type="block">/* Now add it to the cache. */</comment>
  <expr_stmt><expr><name>cache_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>node_cache</name></name></expr></argument>, <argument><expr><name>cache_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>cache_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>brd</name>-&gt;<name>node_cache_keys</name><index>[<expr><name><name>brd</name>-&gt;<name>node_cache_idx</name></name></expr>]</index></name> = <name>cache_path</name></expr>;</expr_stmt>

  <comment type="block">/* Advance the cache pointer. */</comment>
  <expr_stmt><expr><name><name>brd</name>-&gt;<name>node_cache_idx</name></name> = (<name><name>brd</name>-&gt;<name>node_cache_idx</name></name> + 1) % <name>NODE_CACHE_MAX_KEYS</name></expr>;</expr_stmt>
}</block></function>



<escape char="0xc"/>
<comment type="block">/* Creating transaction and revision root nodes.  */</comment>

<struct>struct <name>txn_root_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_txn_root</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                  <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>txn_root_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name> <init>= <expr><name><name>args</name>-&gt;<name>root_p</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name> <init>= <expr><name><name>args</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>svn_txn_id</name> <init>= <expr><name><name>txn</name>-&gt;<name>id</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>root_id</name></decl>, *<decl><type ref="prev"/><name>base_root_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>txnprops</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Verify that the transaction actually exists.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__get_txn_ids</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr>&amp;<name>base_root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                   <argument><expr><name>svn_txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Look for special txn props that represent the 'flags' behavior of
     the transaction. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__txn_proplist_in_trail</name><argument_list>(<argument><expr>&amp;<name>txnprops</name></expr></argument>, <argument><expr><name>svn_txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_OOD</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>flags</name> |= <name>SVN_FS_TXN_CHECK_OOD</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_LOCKS</name></expr></argument>, 
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>flags</name> |= <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>root</name> = <call><name>make_txn_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>svn_txn_id</name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>base_rev</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>root_p</name> = <name>root</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
                      <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>txn_root_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>root_p</name></name> = &amp;<name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>txn</name></name> = <name>txn</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_txn_root</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>root_p</name> = <name>root</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>revision_root_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_revision_root</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                       <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>revision_root_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_revision_root</name><argument_list>(<argument><expr>&amp;<name>root_dir</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>rev</name></name></expr></argument>,
                                         <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>root</name> = <call><name>make_revision_root</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>root_dir</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name><name>args</name>-&gt;<name>root_p</name></name> = <name>root</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
                           <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>revision_root_args</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>root_p</name></name> = &amp;<name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>rev</name></name> = <name>rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_revision_root</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>root_p</name> = <name>root</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Getting dag nodes for roots.  */</comment>


<comment type="block">/* Set *NODE_P to a freshly opened dag node referring to the root
   directory of ROOT, as part of TRAIL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>root_node</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
          <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
          <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>base_root_data_t</name> *</type><name>brd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* It's a revision root, so we already have its root directory
         opened.  */</comment>
      <expr_stmt><expr>*<name>node_p</name> = <call><name>svn_fs_base__dag_dup</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>root_dir</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* It's a transaction root.  Open a fresh copy.  */</comment>
      <return>return <expr><call><name>svn_fs_base__dag_txn_root</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>txn</name></name></expr></argument>,
                                       <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if>
}</block></function>


<comment type="block">/* Set *NODE_P to a mutable root directory for ROOT, cloning if
   necessary, as part of TRAIL.  ROOT must be a transaction root.  Use
   ERROR_PATH in error messages.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>mutable_root_node</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
                  <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error_path</name></decl></param>,
                  <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_fs_base__dag_clone_root</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>txn</name></name></expr></argument>,
                                       <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <comment type="block">/* If it's not a transaction root, we can't change its contents.  */</comment>
    <return>return <expr><call><name>SVN_FS__ERR_NOT_MUTABLE</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>error_path</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Traversing directory paths.  */</comment>

<typedef>typedef <type><enum>enum <name>copy_id_inherit_t</name>
<block>{
  <decl><name>copy_id_inherit_unknown</name> <init>= <expr>0</expr></init></decl>,
  <decl><name>copy_id_inherit_self</name></decl>,
  <decl><name>copy_id_inherit_parent</name></decl>,
  <decl><name>copy_id_inherit_new</name></decl>

}</block></enum></type> <name>copy_id_inherit_t</name>;</typedef>

<comment type="block">/* A linked list representing the path from a node up to a root
   directory.  We use this for cloning, and for operations that need
   to deal with both a node and its parent directory.  For example, a
   `delete' operation needs to know that the node actually exists, but
   also needs to change the parent directory.  */</comment>
<typedef>typedef <type><struct>struct <name>parent_path_t</name>
<block>{

  <comment type="block">/* A node along the path.  This could be the final node, one of its
     parents, or the root.  Every parent path ends with an element for
     the root directory.  */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* The name NODE has in its parent directory.  This is zero for the
     root directory, which (obviously) has no name in its parent.  */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>entry</name></decl>;</decl_stmt>

  <comment type="block">/* The parent of NODE, or zero if NODE is the root directory.  */</comment>
  <decl_stmt><decl><type>struct <name>parent_path_t</name> *</type><name>parent</name></decl>;</decl_stmt>

  <comment type="block">/* The copy ID inheritence style. */</comment>
  <decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>copy_inherit</name></decl>;</decl_stmt>

  <comment type="block">/* If copy ID inheritence style is copy_id_inherit_new, this is the
     path which should be implicitly copied; otherwise, this is NULL. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_src_path</name></decl>;</decl_stmt>

}</block></struct></type> <name>parent_path_t</name>;</typedef>


<comment type="block">/* Return the FS path for the parent path chain object PARENT_PATH,
   allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>parent_path_path</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>"/"</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>path_so_far</name> = <call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name><name>parent_path</name>-&gt;<name>entry</name></name>
    ? <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>
         : <name>path_so_far</name></expr>;</return>
}</block></function>


<comment type="block">/* Return the FS path for the parent path chain object CHILD relative
   to its ANCESTOR in the same chain, allocated in POOL.  */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>parent_path_relpath</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>child</name></decl></param>,
                    <param><decl><type><name>parent_path_t</name> *</type><name>ancestor</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>this_node</name> <init>= <expr><name>child</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>this_node</name> != <name>ancestor</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>this_node</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path_so_far</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>this_node</name>-&gt;<name>entry</name></name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>this_node</name> = <name><name>this_node</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
    }</block></while>
  <return>return <expr><name>path_so_far</name></expr>;</return>
}</block></function>


<comment type="block">/* Choose a copy ID inheritance method *INHERIT_P to be used in the
   event that immutable node CHILD in FS needs to be made mutable.  If
   the inheritance method is copy_id_inherit_new, also return a
   *COPY_SRC_PATH on which to base the new copy ID (else return NULL
   for that path).  CHILD must have a parent (it cannot be the root
   node).  TXN_ID is the transaction in which these items might be
   mutable.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_copy_inheritance</name><parameter_list>(<param><decl><type><name>copy_id_inherit_t</name> *</type><name>inherit_p</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>copy_src_path</name></decl></param>,
                     <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                     <param><decl><type><name>parent_path_t</name> *</type><name>child</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                     <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>child_id</name></decl>, *<decl><type ref="prev"/><name>parent_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_copy_id</name></decl>, *<decl><type ref="prev"/><name>parent_copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>id_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make some assertions about the function input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>child</name> &amp;&amp; <name><name>child</name>-&gt;<name>parent</name></name> &amp;&amp; <name>txn_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize our return variables (default: self-inheritance). */</comment>
  <expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_self</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>copy_src_path</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Initialize some convenience variables. */</comment>
  <expr_stmt><expr><name>child_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>parent_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>child_copy_id</name> = <call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>parent_copy_id</name> = <call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Easy out: if this child is already mutable, we have nothing to do. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__key_compare</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_txn_id</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If the child and its parent are on the same branch, then the
     child will inherit the copy ID of its parent when made mutable.
     This is trivially detectable when the child and its parent have
     the same copy ID.  But that's not the sole indicator of
     same-branchness.  It might be the case that the parent was the
     result of a copy, but the child has not yet been cloned for
     mutability since that copy.  Detection of this latter case
     basically means making sure the copy IDs don't differ for some
     other reason, such as that the child was the direct target of the
     copy whose ID it has.  There is a special case here, too -- if
     the child's copy ID is the special ID "0", it can't have been the
     target of any copy, and therefore must be on the same branch as
     its parent.  */</comment>
  <if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>child_copy_id</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call> == 0)
      || (<call><name>svn_fs_base__key_compare</name><argument_list>(<argument><expr><name>child_copy_id</name></expr></argument>, <argument><expr><name>parent_copy_id</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_parent</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>copy_t</name> *</type><name>copy</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_copy</name><argument_list>(<argument><expr>&amp;<name>copy</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>child_copy_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>svn_fs_base__id_compare</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name></expr></argument>, <argument><expr><name>child_id</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_parent</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></else></if>

  <comment type="block">/* If we get here, the child and its parent are not on speaking
     terms -- there will be no parental inheritence handed down in
     *this* generation. */</comment>

  <comment type="block">/* If the child was created at a different path than the one we are
     expecting its clone to live, one of its parents must have been
     created via a copy since the child was created.  The child isn't
     on the same branch as its parent (we caught those cases early);
     it can't keep its current copy ID because there's been an
     affecting copy (its clone won't be on the same branch as the
     child is).  That leaves only one course of action -- to assign
     the child a brand new "soft" copy ID. */</comment>
  <expr_stmt><expr><name>id_path</name> = <call><name>svn_fs_base__dag_get_created_path</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>id_path</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_new</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>copy_src_path</name> = <name>id_path</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* The node gets to keep its own ID. */</comment>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Allocate a new parent_path_t node from POOL, referring to NODE,
   ENTRY, PARENT, and COPY_ID.  */</comment>
<function><type><specifier>static</specifier> <name>parent_path_t</name> *</type>
<name>make_parent_path</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                 <param><decl><type><name>char</name> *</type><name>entry</name></decl></param>,
                 <param><decl><type><name>parent_path_t</name> *</type><name>parent</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>parent_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>node</name></name> = <name>node</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>entry</name></name> = <name>entry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>parent</name></name> = <name>parent</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>copy_id_inherit_unknown</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_src_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>parent_path</name></expr>;</return>
}</block></function>


<comment type="block">/* Flags for open_path.  */</comment>
<typedef>typedef <type><enum>enum <name>open_path_flags_t</name> <block>{

  <comment type="block">/* The last component of the PATH need not exist.  (All parent
     directories must exist, as usual.)  If the last component doesn't
     exist, simply leave the `node' member of the bottom parent_path
     component zero.  */</comment>
  <decl><name>open_path_last_optional</name> <init>= <expr>1</expr></init></decl>

}</block></enum></type> <name>open_path_flags_t</name>;</typedef>


<comment type="block">/* Open the node identified by PATH in ROOT, as part of TRAIL.  Set
   *PARENT_PATH_P to a path from the node up to ROOT, allocated in
   TRAIL-&gt;pool.  The resulting *PARENT_PATH_P value is guaranteed to
   contain at least one element, for the root directory.

   If resulting *PARENT_PATH_P will eventually be made mutable and
   modified, or if copy ID inheritance information is otherwise
   needed, TXN_ID should be the ID of the mutability transaction.  If
   TXN_ID is NULL, no copy ID in heritance information will be
   calculated for the *PARENT_PATH_P chain.

   If FLAGS &amp; open_path_last_optional is zero, return the error
   SVN_ERR_FS_NOT_FOUND if the node PATH refers to does not exist.  If
   non-zero, require all the parent directories to exist as normal,
   but if the final path component doesn't exist, simply return a path
   whose bottom `node' member is zero.  This option is useful for
   callers that create new nodes --- we find the parent directory for
   them, and tell them whether the entry exists already.

   NOTE: Public interfaces which only *read* from the filesystem
   should not call this function directly, but should instead use
   get_dag().
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_path</name><parameter_list>(<param><decl><type><name>parent_path_t</name> **</type><name>parent_path_p</name></decl></param>,
          <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
          <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>here</name></decl>;</decl_stmt> <comment type="block">/* The directory we're currently looking at.  */</comment>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt> <comment type="block">/* The path from HERE up to the root.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rest</name></decl>;</decl_stmt> <comment type="block">/* The portion of PATH we haven't traversed yet.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>canon_path</name> <init>= <expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>"/"</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make a parent_path item for the root node, using its own current
     copy id.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>root_node</name><argument_list>(<argument><expr>&amp;<name>here</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>here</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>here</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>copy_id_inherit_self</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rest</name> = <name>canon_path</name> + 1</expr>;</expr_stmt> <comment type="block">/* skip the leading '/', it saves in iteration */</comment>

  <comment type="block">/* Whenever we are at the top of this loop:
     - HERE is our current directory,
     - ID is the node revision ID of HERE,
     - REST is the path we're going to find in HERE, and
     - PARENT_PATH includes HERE and all its parents.  */</comment>
  <for>for (<init>;</init><condition>;</condition><incr/>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>child</name></decl>;</decl_stmt>

      <comment type="block">/* Parse out the next entry from the path.  */</comment>
      <expr_stmt><expr><name>entry</name> = <call><name>svn_fs__next_entry_name</name><argument_list>(<argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Calculate the path traversed thus far. */</comment>
      <expr_stmt><expr><name>path_so_far</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>*<name>entry</name> == '\0'</expr>)</condition><then>
        <block>{
          <comment type="block">/* Given the behavior of svn_fs__next_entry_name(), this
             happens when the path either starts or ends with a slash.
             In either case, we stay put: the current directory stays
             the same, and we add nothing to the parent path. */</comment>
          <expr_stmt><expr><name>child</name> = <name>here</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>inherit</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>cached_node</name></decl>;</decl_stmt>

          <comment type="block">/* If we found a directory entry, follow it.  First, we
             check our node cache, and, failing that, we hit the DAG
             layer. */</comment>
          <expr_stmt><expr><name>cached_node</name> = <call><name>dag_node_cache_get</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>cached_node</name></expr>)</condition><then>
            <expr_stmt><expr><name>child</name> = <name>cached_node</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>err</name> = <call><name>svn_fs_base__dag_open</name><argument_list>(<argument><expr>&amp;<name>child</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

          <comment type="block">/* "file not found" requires special handling.  */</comment>
          <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* If this was the last path component, and the caller
                 said it was optional, then don't return an error;
                 just put a NULL node pointer in the path.  */</comment>

              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr>(<name>flags</name> &amp; <name>open_path_last_optional</name>)
                  &amp;&amp; (! <name>next</name> || *<name>next</name> == '\0')</expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
                }</block></then>
              <else>else
                <block>{
                  <comment type="block">/* Build a better error message than svn_fs_base__dag_open
                     can provide, giving the root and full path name.  */</comment>
                  <return>return <expr><call><name>SVN_FS__NOT_FOUND</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></else></if>
            }</block></then></if>

          <comment type="block">/* Other errors we return normally.  */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Now, make a parent_path item for CHILD. */</comment>
          <expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>txn_id</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_copy_inheritance</name><argument_list>(<argument><expr>&amp;<name>inherit</name></expr></argument>, <argument><expr>&amp;<name>copy_path</name></expr></argument>,
                                           <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                           <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>inherit</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_src_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>copy_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

          <comment type="block">/* Cache the node we found (if it wasn't already cached). */</comment>
          <if>if <condition>(<expr>! <name>cached_node</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>

      <comment type="block">/* Are we finished traversing the path?  */</comment>
      <if>if <condition>(<expr>! <name>next</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="block">/* The path isn't finished yet; we'd better be in a directory.  */</comment>
      <if>if <condition>(<expr><call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>SVN_FS__ERR_NOT_DIRECTORY</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failure opening '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><name>rest</name> = <name>next</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>here</name> = <name>child</name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr>*<name>parent_path_p</name> = <name>parent_path</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Make the node referred to by PARENT_PATH mutable, if it isn't
   already, as part of TRAIL.  ROOT must be the root from which
   PARENT_PATH descends.  Clone any parent directories as needed.
   Adjust the dag nodes in PARENT_PATH to refer to the clones.  Use
   ERROR_PATH in error messages.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>make_path_mutable</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                  <param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error_path</name></decl></param>,
                  <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>cloned_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Is the node mutable already?  */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Are we trying to clone the root, or somebody's child node?  */</comment>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>parent_id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name> <init>= <expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_src_path</name> <init>= <expr><name><name>parent_path</name>-&gt;<name>copy_src_path</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>inherit</name> <init>= <expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>clone_path</name></decl>;</decl_stmt>

      <comment type="block">/* We're trying to clone somebody's child.  Make sure our parent
         is mutable.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                <argument><expr><name>error_path</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <switch>switch <condition>(<expr><name>inherit</name></expr>)</condition>
        <block>{
        <case>case <expr><name>copy_id_inherit_parent</name></expr>:
          <expr_stmt><expr><name>parent_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>copy_id</name> = <call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>copy_id_inherit_new</name></expr>:
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__reserve_copy_id</name><argument_list>(<argument><expr>&amp;<name>copy_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>copy_id_inherit_self</name></expr>:
          <expr_stmt><expr><name>copy_id</name> = <name>NULL</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>copy_id_inherit_unknown</name></expr>:
        </case><default>default:
          <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* uh-oh -- somebody didn't calculate copy-ID
                      inheritance data. */</comment>
        </default>}</block></switch>

      <comment type="block">/* Now make this node mutable.  */</comment>
      <expr_stmt><expr><name>clone_path</name> = <call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_clone_child</name><argument_list>(<argument><expr>&amp;<name>cloned_node</name></expr></argument>,
                                           <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                           <argument><expr><name>clone_path</name></expr></argument>,
                                           <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                           <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                           <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we just created a brand new copy ID, we need to store a
         `copies' table entry for it, as well as a notation in the
         transaction that should this transaction be terminated, our
         new copy needs to be removed. */</comment>
      <if>if <condition>(<expr><name>inherit</name> == <name>copy_id_inherit_new</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>new_node_id</name> <init>=
            <expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>cloned_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__create_copy</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>copy_src_path</name></expr></argument>,
                                          <argument><expr><call><name>svn_fs_base__id_txn_id</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>new_node_id</name></expr></argument>,
                                          <argument><expr><name>copy_kind_soft</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__add_txn_copy</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* We're trying to clone the root directory.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>mutable_root_node</name><argument_list>(<argument><expr>&amp;<name>cloned_node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>error_path</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Update the PARENT_PATH link to refer to the clone.  */</comment>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>node</name></name> = <name>cloned_node</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Walk up PARENT_PATH to the root of the tree, adjusting each node's
   mergeinfo count by COUNT_DELTA as part of Subversion transaction
   TXN_ID and TRAIL.  Use POOL for allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>adjust_parent_mergeinfo_counts</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
                               <param><decl><type><name>apr_int64_t</name></type> <name>count_delta</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, 
                               <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>pp</name> <init>= <expr><name>parent_path</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>count_delta</name> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>pp</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_adjust_mergeinfo_count</name><argument_list>(<argument><expr><name><name>pp</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>count_delta</name></expr></argument>,
                                                      <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                                      <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pp</name> = <name><name>pp</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
    }</block></while>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Open the node identified by PATH in ROOT, as part of TRAIL.  Set
   *DAG_NODE_P to the node we find, allocated in TRAIL-&gt;pool.  Return
   the error SVN_ERR_FS_NOT_FOUND if this node doesn't exist. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_dag</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>dag_node_p</name></decl></param>,
        <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
        <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Canonicalize the input PATH. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If ROOT is a revision root, we'll look for the DAG in our cache. */</comment>
  <expr_stmt><expr><name>node</name> = <call><name>dag_node_cache_get</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>node</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Call open_path with no flags, as we want this to return an error
         if the node for which we are searching doesn't exist. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>node</name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>

      <comment type="block">/* No need to cache our find -- open_path() will do that for us. */</comment>
    }</block></then></if>

  <expr_stmt><expr>*<name>dag_node_p</name> = <name>node</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Populating the `changes' table. */</comment>

<comment type="block">/* Add a change to the changes table in FS, keyed on transaction id
   TXN_ID, and indicated that a change of kind CHANGE_KIND occurred on
   PATH (whose node revision id is--or was, in the case of a
   deletion--NODEREV_ID), and optionally that TEXT_MODs or PROP_MODs
   occurred.  Do all this as part of TRAIL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_change</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>noderev_id</name></decl></param>,
           <param><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>change_kind</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>text_mod</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>prop_mod</name></decl></param>,
           <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>change_t</name></type> <name>change</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>change</name>.<name>path</name></name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>change</name>.<name>noderev_id</name></name> = <name>noderev_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>change</name>.<name>kind</name></name> = <name>change_kind</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>change</name>.<name>text_mod</name></name> = <name>text_mod</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>change</name>.<name>prop_mod</name></name> = <name>prop_mod</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_bdb__changes_add</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr>&amp;<name>change</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Generic node operations.  */</comment>


<struct>struct <name>node_id_args</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_node_id</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_id_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name><name>args</name>-&gt;<name>id_p</name></name> = <call><name>svn_fs_base__id_copy</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_node_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
             <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>base_root_data_t</name> *</type><name>brd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name>
      &amp;&amp; (<name><name>path</name><index>[<expr>0</expr>]</index></name> == '\0' || ((<name><name>path</name><index>[<expr>0</expr>]</index></name> == '/') &amp;&amp; (<name><name>path</name><index>[<expr>1</expr>]</index></name> == '\0')))</expr>)</condition><then>
    <block>{
      <comment type="block">/* Optimize the case where we don't need any db access at all.
         The root directory ("" or "/") node is stored in the
         svn_fs_root_t object, and never changes when it's a revision
         root, so we can just reach in and grab it directly. */</comment>
      <expr_stmt><expr>*<name>id_p</name> = <call><name>svn_fs_base__id_copy</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>brd</name>-&gt;<name>root_dir</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>node_id_args</name></type> <name>args</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>args</name>.<name>id_p</name></name> = &amp;<name>id</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_node_id</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>id_p</name> = <name>id</name></expr>;</expr_stmt>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>node_created_rev_args</name> <block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_node_created_rev</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_created_rev_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_revision</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>revision</name></name>)</expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_node_created_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
                      <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_created_rev_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>revision</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name>
          <argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_node_created_rev</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>revision</name> = <name><name>args</name>.<name>revision</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>node_created_path_args</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>created_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_node_created_path</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_created_path_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name><name>args</name>-&gt;<name>created_path</name></name> = <call><name>svn_fs_base__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_node_created_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>created_path</name></decl></param>,
                       <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_created_path_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>created_path</name></name> = <name>created_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name>
          <argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_node_created_path</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>node_kind_args</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt> <comment type="block">/* OUT parameter */</comment>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_node_kind</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_kind_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>id</name></name></expr></argument>,
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>-&gt;<name>kind</name></name> = <call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>node_kind</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind_p</name></decl></param>,
          <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_kind_args</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>

  <comment type="block">/* Get the node id. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_node_id</name><argument_list>(<argument><expr>&amp;<name>node_id</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Use the node id to get the real kind. */</comment>
  <expr_stmt><expr><name><name>args</name>.<name>id</name></name> = <name>node_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_node_kind</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>kind_p</name> = <name><name>args</name>.<name>kind</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_check_path</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind_p</name></decl></param>,
                <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>node_kind</name><argument_list>(<argument><expr><name>kind_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; 
      ((<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>)
       || (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_DIRECTORY</name>))</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>kind_p</name> = <name>svn_node_none</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>node_prop_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> **</type><name>value_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_node_prop</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                   <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_prop_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*(<name><name>args</name>-&gt;<name>value_p</name></name>) = <name>NULL</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>proplist</name></expr>)</condition><then>
    <expr_stmt><expr>*(<name><name>args</name>-&gt;<name>value_p</name></name>) = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>propname</name></name></expr></argument>,
                                    <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_node_prop</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>value_p</name></decl></param>,
               <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_prop_args</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>value_p</name></name>  = &amp;<name>value</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root</name></name>     = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name>     = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>propname</name></name> = <name>propname</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_node_prop</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>value_p</name> = <name>value</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>node_proplist_args</name> <block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_node_proplist</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_proplist_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name><name>args</name>-&gt;<name>table_p</name></name> = <name>proplist</name> ? <name>proplist</name> : <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_node_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>node_proplist_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>table_p</name></name> = &amp;<name>table</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_node_proplist</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>table_p</name> = <name>table</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>change_node_prop_args</name> <block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_change_node_prop</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                          <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>change_node_prop_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>args</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>base_fs_data_t</name> *</type><name>bfd</name> <init>= <expr><name><name>trail</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to see if path is locked; if so, check that we can use it.
     Notice that we're doing this non-recursively, regardless of node kind. */</comment>
  <if>if <condition>(<expr><name><name>args</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__allow_locked_operation</name>
            <argument_list>(<argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>,
                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there's no proplist, but we're just deleting a property, exit now. */</comment>
  <if>if <condition>(<expr>(! <name>proplist</name>) &amp;&amp; (! <name><name>args</name>-&gt;<name>value</name></name>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Now, if there's no proplist, we know we need to make one. */</comment>
  <if>if <condition>(<expr>! <name>proplist</name></expr>)</condition><then>
    <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Set the property. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Overwrite the node's proplist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_set_proplist</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>proplist</name></expr></argument>,
                                        <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this was a change to the mergeinfo property, and our version
     of the filesystem cares, we have some extra recording to do. 

     ### If the format *doesn't* support mergeinfo recording, should
     ### we fuss about attempts to change the svn:mergeinfo property
     ### in any way save to delete it?  */</comment>
  <if>if <condition>(<expr>(<name><name>bfd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name>)
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>had_mergeinfo</name></decl>, <decl><type ref="prev"/><name>has_mergeinfo</name> <init>= <expr><name><name>args</name>-&gt;<name>value</name></name> ? <name>TRUE</name> : <name>FALSE</name></expr></init></decl>;</decl_stmt>
      
      <comment type="block">/* First, note on our node that it has mergeinfo. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_set_has_mergeinfo</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
                                                 <argument><expr><name>has_mergeinfo</name></expr></argument>, 
                                                 <argument><expr>&amp;<name>had_mergeinfo</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, 
                                                 <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <comment type="block">/* If this is a change from the old state, we need to update our
         node's parents' mergeinfo counts by a factor of 1. */</comment>
      <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name> &amp;&amp; ((! <name>had_mergeinfo</name>) != (! <name>has_mergeinfo</name>))</expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>adjust_parent_mergeinfo_counts</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                               <argument><expr><name>has_mergeinfo</name> ? 1 : -1</expr></argument>,
                                               <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                     <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_change_node_prop</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>change_node_prop_args</name></type> <name>args</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>args</name>.<name>root</name></name>  = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name>  = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>name</name></name>  = <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>value</name></name> = <name>value</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_change_node_prop</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>things_changed_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name> *</type><name>changed_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_props_changed</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>things_changed_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node1</name></decl>, *<decl><type ref="prev"/><name>node2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node1</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root1</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path1</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node2</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root2</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path2</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__things_different</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>changed_p</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>node1</name></expr></argument>, <argument><expr><name>node2</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_props_changed</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>changed_p</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>things_changed_args</name></type> <name>args</name></decl>;</decl_stmt>

  <comment type="block">/* Check that roots are in the same fs. */</comment>
  <if>if <condition>(<expr><name><name>root1</name>-&gt;<name>fs</name></name> != <name><name>root2</name>-&gt;<name>fs</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot compare property value between two different filesystems"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>args</name>.<name>root1</name></name>      = <name>root1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root2</name></name>      = <name>root2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path1</name></name>      = <name>path1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path2</name></name>      = <name>path2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>changed_p</name></name>  = <name>changed_p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>pool</name></name>       = <name>pool</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root1</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_props_changed</name></expr></argument>,
                                 <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Getting a directory's entries */</comment>


<struct>struct <name>dir_entries_args</name>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* *(BATON-&gt;table_p) will never be NULL on successful return */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_dir_entries</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                     <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_entries_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the entries for PARENT_PATH. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Potentially initialize the return value to an empty hash. */</comment>
  <expr_stmt><expr>*<name><name>args</name>-&gt;<name>table_p</name></name> = <name>entries</name> ? <name>entries</name> : <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_dir_entries</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_entries_args</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>table_p</name></name> = &amp;<name>table</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root</name></name>    = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name>    = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_dir_entries</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add in the kind data. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>node_kind_args</name></type> <name>nk_args</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* KEY will be the entry name in ancestor (about which we
         simply don't care), VAL the dirent. */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>entry</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>nk_args</name>.<name>id</name></name> = <name><name>entry</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_node_kind</name></expr></argument>, <argument><expr>&amp;<name>nk_args</name></expr></argument>,
                                     <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>entry</name>-&gt;<name>kind</name></name> = <name><name>nk_args</name>.<name>kind</name></name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>table_p</name> = <name>table</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Merges and commits. */</comment>


<struct>struct <name>deltify_committed_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt> <comment type="block">/* the filesystem */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt> <comment type="block">/* revision just committed */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt> <comment type="block">/* transaction just committed */</comment>
}</block>;</struct>


<struct>struct <name>txn_deltify_args</name>
<block>{
  <comment type="block">/* The target is what we're deltifying. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>tgt_id</name></decl>;</decl_stmt>

  <comment type="block">/* The base is what we're deltifying against.  It's not necessarily
     the "next" revision of the node; skip deltas mean we sometimes
     deltify against a successor many generations away. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>base_id</name></decl>;</decl_stmt>

  <comment type="block">/* We only deltify props for directories.
     ### Didn't we try removing this horrid little optimization once?
     ### What was the result?  I would have thought that skip deltas
     ### mean directory undeltification is cheap enough now. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_txn_deltify</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>txn_deltify_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>tgt_node</name></decl>, *<decl><type ref="prev"/><name>base_node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>tgt_node</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>tgt_id</name></name></expr></argument>,
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>base_node</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>base_id</name></name></expr></argument>,
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_deltify</name><argument_list>(<argument><expr><name>tgt_node</name></expr></argument>, <argument><expr><name>base_node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>is_dir</name></name></expr></argument>,
                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>txn_pred_count_args</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pred_count</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_pred_count</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>txn_pred_count_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>,
                                        <argument><expr><name><name>args</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>-&gt;<name>pred_count</name></name> = <name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>txn_pred_id_args</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>      <comment type="block">/* The node id whose predecessor we want. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt> <comment type="block">/* The returned predecessor id. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>           <comment type="block">/* The pool in which to allocate pred_id. */</comment>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_pred_id</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>nr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>txn_pred_id_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>nr</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>nr</name>-&gt;<name>predecessor_id</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>args</name>-&gt;<name>pred_id</name></name> = <call><name>svn_fs_base__id_copy</name><argument_list>(<argument><expr><name><name>nr</name>-&gt;<name>predecessor_id</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>args</name>-&gt;<name>pred_id</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Deltify PATH in ROOT's predecessor iff PATH is mutable under TXN_ID
   in FS.  If PATH is a mutable directory, recurse.

   NODE_ID is the node revision ID for PATH in ROOT, or NULL if that
   value isn't known.  KIND is the node kind for PATH in ROOT, or
   svn_node_unknown is the kind isn't known.

   Use POOL for necessary allocations.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>deltify_mutable</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl></param>,
                <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name> <init>= <expr><name>node_id</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>txn_deltify_args</name></type> <name>td_args</name></decl>;</decl_stmt>

  <comment type="block">/* Get the ID for PATH under ROOT if it wasn't provided. */</comment>
  <if>if <condition>(<expr>! <name>node_id</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_node_id</name><argument_list>(<argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Check for mutability.  Not mutable?  Go no further.  This is safe
     to do because for items in the tree to be mutable, their parent
     dirs must also be mutable.  Therefore, if a directory is not
     mutable under TXN_ID, its children cannot be.  */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_txn_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Is this a directory?  */</comment>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_unknown</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If this is a directory, read its entries.  */</comment>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If there are entries, recurse on 'em.  */</comment>
  <if>if <condition>(<expr><name>entries</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <comment type="block">/* KEY will be the entry name, VAL the dirent */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>entry</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>entry</name> = <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>deltify_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                                  <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name><name>entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Finally, deltify old data against this node. */</comment>
  <block>{
    <comment type="block">/* Redeltify predecessor node-revisions of the one we added.  The
       idea is to require at most 2*lg(N) deltas to be applied to get
       to any node-revision in a chain of N predecessors.  We do this
       using a technique derived from skip lists:

          - Always redeltify the immediate parent

          - If the number of predecessors is divisible by 2,
              redeltify the revision two predecessors back

          - If the number of predecessors is divisible by 4,
              redeltify the revision four predecessors back

       ... and so on.

       That's the theory, anyway.  Unfortunately, if we strictly
       follow that theory we get a bunch of overhead up front and no
       great benefit until the number of predecessors gets large.  So,
       stop at redeltifying the parent if the number of predecessors
       is less than 32, and also skip the second level (redeltifying
       two predecessors back), since that doesn't help much.  Also,
       don't redeltify the oldest node-revision; it's potentially
       expensive and doesn't help retrieve any other revision.
       (Retrieving the oldest node-revision will still be fast, just
       not as blindingly so.)  */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>pred_count</name></decl>, <decl><type ref="prev"/><name>nlevels</name></decl>, <decl><type ref="prev"/><name>lev</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>txn_pred_count_args</name></type> <name>tpc_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name><name>subpools</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>active_subpool</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>tpc_args</name>.<name>id</name></name> = <name>id</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_pred_count</name></expr></argument>, <argument><expr>&amp;<name>tpc_args</name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pred_count</name> = <name><name>tpc_args</name>.<name>pred_count</name></name></expr>;</expr_stmt>

    <comment type="block">/* If nothing to deltify, then we're done. */</comment>
    <if>if <condition>(<expr><name>pred_count</name> == 0</expr>)</condition><then>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

    <comment type="block">/* Decide how many predecessors to redeltify.  To save overhead,
       don't redeltify anything but the immediate predecessor if there
       are less than 32 predecessors. */</comment>
    <expr_stmt><expr><name>nlevels</name> = 1</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pred_count</name> &gt;= 32</expr>)</condition><then>
      <block>{
        <while>while <condition>(<expr><name>pred_count</name> % 2 == 0</expr>)</condition>
          <block>{
            <expr_stmt><expr><name>pred_count</name> /= 2</expr>;</expr_stmt>
            <expr_stmt><expr><name>nlevels</name>++</expr>;</expr_stmt>
          }</block></while>

        <comment type="block">/* Don't redeltify the oldest revision. */</comment>
        <if>if <condition>(<expr>1 &lt;&lt; (<name>nlevels</name> - 1) == <name>pred_count</name></expr>)</condition><then>
          <expr_stmt><expr><name>nlevels</name>--</expr>;</expr_stmt></then></if>
      }</block></then></if>

    <comment type="block">/* Redeltify the desired number of predecessors. */</comment>
    <expr_stmt><expr><name>count</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>pred_id</name> = <name>id</name></expr>;</expr_stmt>

    <comment type="block">/* We need to use two alternating pools because the id used in the
       call to txn_body_pred_id is allocated by the previous inner
       loop iteration.  If we would clear the pool each iteration we
       would free the previous result.  */</comment>
    <expr_stmt><expr><name><name>subpools</name><index>[<expr>0</expr>]</index></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>subpools</name><index>[<expr>1</expr>]</index></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>lev</name> = 0</expr>;</init> <condition><expr><name>lev</name> &lt; <name>nlevels</name></expr>;</condition> <incr><expr><name>lev</name>++</expr></incr>)
      <block>{
        <comment type="block">/* To save overhead, skip the second level (that is, never
           redeltify the node-revision two predecessors back). */</comment>
        <if>if <condition>(<expr><name>lev</name> == 1</expr>)</condition><then>
          <continue>continue;</continue></then></if>

        <comment type="block">/* Note that COUNT is not reset between levels, and neither is
           PREDNODE; we just keep counting from where we were up to
           where we're supposed to get. */</comment>
        <while>while <condition>(<expr><name>count</name> &lt; (1 &lt;&lt; <name>lev</name>)</expr>)</condition>
          <block>{
            <decl_stmt><decl><type>struct <name>txn_pred_id_args</name></type> <name>tpi_args</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>active_subpool</name> = !<name>active_subpool</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>subpools</name><index>[<expr><name>active_subpool</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>tpi_args</name>.<name>id</name></name> = <name>pred_id</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>tpi_args</name>.<name>pool</name></name> = <name><name>subpools</name><index>[<expr><name>active_subpool</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_pred_id</name></expr></argument>, <argument><expr>&amp;<name>tpi_args</name></expr></argument>,
                                           <argument><expr><name><name>subpools</name><index>[<expr><name>active_subpool</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>pred_id</name> = <name><name>tpi_args</name>.<name>pred_id</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>pred_id</name> == <name>NULL</name></expr>)</condition><then>
              <return>return <expr><call><name>svn_error_create</name>
                <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr>0</expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Corrupt DB: faulty predecessor count"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

            <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt>
          }</block></while>

        <comment type="block">/* Finally, do the deltification. */</comment>
        <expr_stmt><expr><name><name>td_args</name>.<name>tgt_id</name></name> = <name>pred_id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>td_args</name>.<name>base_id</name></name> = <name>id</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>td_args</name>.<name>is_dir</name></name> = (<name>kind</name> == <name>svn_node_dir</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_txn_deltify</name></expr></argument>, <argument><expr>&amp;<name>td_args</name></expr></argument>,
                                       <argument><expr><name><name>subpools</name><index>[<expr><name>active_subpool</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      }</block></for>
    <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>subpools</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>subpools</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>get_root_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Set ARGS-&gt;node to the root node of ARGS-&gt;root.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_get_root</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_root_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>node</name></name>)</expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>update_ancestry</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>target_id</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                <param><decl><type><name>int</name></type> <name>source_pred_count</name></decl></param>,
                <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Set target's predecessor-id to source_id.  */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_txn_id</name><argument_list>(<argument><expr><name>target_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unexpected immutable node at '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <name>source_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> = <name>source_pred_count</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt></then></if>
  <return>return <expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Set the contents of CONFLICT_PATH to PATH, and return an
   SVN_ERR_FS_CONFLICT error that indicates that there was a conflict
   at PATH.  Perform all allocations in POOL (except the allocation of
   CONFLICT_PATH, which should be handled outside this function).  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>conflict_err</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict_path</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>conflict_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CONFLICT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Conflict at '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Merge changes between ANCESTOR and SOURCE into TARGET as part of
 * TRAIL.  ANCESTOR and TARGET must be distinct node revisions.
 * TARGET_PATH should correspond to TARGET's full path in its
 * filesystem, and is used for reporting conflict location.
 *
 * SOURCE, TARGET, and ANCESTOR are generally directories; this
 * function recursively merges the directories' contents.  If any are
 * files, this function simply returns an error whenever SOURCE,
 * TARGET, and ANCESTOR are all distinct node revisions.
 *
 * If there are differences between ANCESTOR and SOURCE that conflict
 * with changes between ANCESTOR and TARGET, this function returns an
 * SVN_ERR_FS_CONFLICT error, and updates CONFLICT_P to the name of the
 * conflicting node in TARGET, with TARGET_PATH prepended as a path.
 *
 * If there are no conflicting differences, CONFLICT_P is updated to
 * the empty string.
 *
 * CONFLICT_P must point to a valid svn_stringbuf_t.
 *
 * Do any necessary temporary allocation in POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict_p</name></decl></param>,
      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
      <param><decl><type><name>dag_node_t</name> *</type><name>target</name></decl></param>,
      <param><decl><type><name>dag_node_t</name> *</type><name>source</name></decl></param>,
      <param><decl><type><name>dag_node_t</name> *</type><name>ancestor</name></decl></param>,
      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
      <param><decl><type><name>apr_int64_t</name> *</type><name>mergeinfo_increment_out</name></decl></param>,
      <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl>, *<decl><type ref="prev"/><name>target_id</name></decl>, *<decl><type ref="prev"/><name>ancestor_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>s_entries</name></decl>, *<decl><type ref="prev"/><name>t_entries</name></decl>, *<decl><type ref="prev"/><name>a_entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pred_count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_increment</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>base_fs_data_t</name> *</type><name>bfd</name> <init>= <expr><name><name>trail</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make sure everyone comes from the same filesystem. */</comment>
  <expr_stmt><expr><name>fs</name> = <call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>fs</name> != <call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call>)
      || (<name>fs</name> != <call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; ancestor, source, and target not all in same fs"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* We have the same fs, now check it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>source_id</name>   = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>target_id</name>   = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ancestor_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It's improper to call this function with ancestor == target. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><name>ancestor_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= <expr><call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; target '%s' has id '%s', same as ancestor"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_stringbuf_setempty</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Base cases:
   * Either no change made in source, or same change as made in target.
   * Both mean nothing to merge here.
   */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><name>ancestor_id</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>)</argument_list></call>
      || (<call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><name>source_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Else proceed, knowing all three are distinct node revisions.
   *
   * How to merge from this point:
   *
   * if (not all 3 are directories)
   *   {
   *     early exit with conflict;
   *   }
   *
   * // Property changes may only be made to up-to-date
   * // directories, because once the client commits the prop
   * // change, it bumps the directory's revision, and therefore
   * // must be able to depend on there being no other changes to
   * // that directory in the repository.
   * if (target's property list differs from ancestor's)
   *    conflict;
   *
   * For each entry NAME in the directory ANCESTOR:
   *
   *   Let ANCESTOR-ENTRY, SOURCE-ENTRY, and TARGET-ENTRY be the IDs of
   *   the name within ANCESTOR, SOURCE, and TARGET respectively.
   *   (Possibly null if NAME does not exist in SOURCE or TARGET.)
   *
   *   If ANCESTOR-ENTRY == SOURCE-ENTRY, then:
   *     No changes were made to this entry while the transaction was in
   *     progress, so do nothing to the target.
   *
   *   Else if ANCESTOR-ENTRY == TARGET-ENTRY, then:
   *     A change was made to this entry while the transaction was in
   *     process, but the transaction did not touch this entry.  Replace
   *     TARGET-ENTRY with SOURCE-ENTRY.
   *
   *   Else:
   *     Changes were made to this entry both within the transaction and
   *     to the repository while the transaction was in progress.  They
   *     must be merged or declared to be in conflict.
   *
   *     If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a
   *     double delete; flag a conflict.
   *
   *     If any of the three entries is of type file, declare a conflict.
   *
   *     If either SOURCE-ENTRY or TARGET-ENTRY is not a direct
   *     modification of ANCESTOR-ENTRY (determine by comparing the
   *     node-id fields), declare a conflict.  A replacement is
   *     incompatible with a modification or other replacement--even
   *     an identical replacement.
   *
   *     Direct modifications were made to the directory ANCESTOR-ENTRY
   *     in both SOURCE and TARGET.  Recursively merge these
   *     modifications.
   *
   * For each leftover entry NAME in the directory SOURCE:
   *
   *   If NAME exists in TARGET, declare a conflict.  Even if SOURCE and
   *   TARGET are adding exactly the same thing, two additions are not
   *   auto-mergeable with each other.
   *
   *   Add NAME to TARGET with the entry from SOURCE.
   *
   * Now that we are done merging the changes from SOURCE into the
   * directory TARGET, update TARGET's predecessor to be SOURCE.
   */</comment>

  <if>if <condition>(<expr>(<call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)
      || (<call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)
      || (<call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>


  <comment type="block">/* Possible early merge failure: if target and ancestor have
     different property lists, then the merge should fail.
     Propchanges can *only* be committed on an up-to-date directory.
     ### TODO: see issue #418 about the inelegance of this.

     Another possible, similar, early merge failure: if source and
     ancestor have different property lists (meaning someone else
     changed directory properties while our commit transaction was
     happening), the merge should fail.  See issue #2751.
  */</comment>
  <block>{
    <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>tgt_nr</name></decl>, *<decl><type ref="prev"/><name>anc_nr</name></decl>, *<decl><type ref="prev"/><name>src_nr</name></decl>;</decl_stmt>

    <comment type="block">/* Get node revisions for our id's. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>tgt_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>,
                                          <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>anc_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ancestor_id</name></expr></argument>,
                                          <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>src_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>,
                                          <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now compare the prop-keys of the skels.  Note that just because
       the keys are different -doesn't- mean the proplists have
       different contents.  But merge() isn't concerned with contents;
       it doesn't do a brute-force comparison on textual contents, so
       it won't do that here either.  Checking to see if the propkey
       atoms are `equal' is enough. */</comment>
    <if>if <condition>(<expr>! <call><name>svn_fs_base__same_keys</name><argument_list>(<argument><expr><name><name>tgt_nr</name>-&gt;<name>prop_key</name></name></expr></argument>, <argument><expr><name><name>anc_nr</name>-&gt;<name>prop_key</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr>! <call><name>svn_fs_base__same_keys</name><argument_list>(<argument><expr><name><name>src_nr</name>-&gt;<name>prop_key</name></name></expr></argument>, <argument><expr><name><name>anc_nr</name>-&gt;<name>prop_key</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  }</block>

  <comment type="block">/* ### todo: it would be more efficient to simply check for a NULL
     entries hash where necessary below than to allocate an empty hash
     here, but another day, another day... */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>s_entries</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>s_entries</name></expr>)</condition><then>
    <expr_stmt><expr><name>s_entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>t_entries</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>t_entries</name></expr>)</condition><then>
    <expr_stmt><expr><name>t_entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>a_entries</name></expr></argument>, <argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>a_entries</name></expr>)</condition><then>
    <expr_stmt><expr><name>a_entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* for each entry E in a_entries... */</comment>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>a_entries</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>, *<decl><type ref="prev"/><name>a_entry</name></decl>;</decl_stmt>

      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* KEY will be the entry name in ancestor, VAL the dirent */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>a_entry</name> = <name>val</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>s_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>t_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* No changes were made to this entry while the transaction was
         in progress, so do nothing to the target. */</comment>
      <if>if <condition>(<expr><name>s_entry</name> &amp;&amp; <call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>end</name>;</goto></then>

      <comment type="block">/* A change was made to this entry while the transaction was in
         process, but the transaction did not touch this entry. */</comment>
      <else>else <if>if <condition>(<expr><name>t_entry</name> &amp;&amp; <call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>t_ent_node</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_start</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>t_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                            <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>mergeinfo_start</name></expr></argument>,
                                                       <argument><expr><name>t_ent_node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                                       <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mergeinfo_increment</name> -= <name>mergeinfo_start</name></expr>;</expr_stmt>

           <if>if <condition>(<expr><name>s_entry</name></expr>)</condition><then>
             <block>{
              <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_end</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                                <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, 
                                                <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, 
                                                           <argument><expr>&amp;<name>mergeinfo_end</name></expr></argument>,
                                                           <argument><expr><name>s_ent_node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                                           <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>mergeinfo_increment</name> += <name>mergeinfo_end</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_set_entry</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>,
                                                 <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_delete</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                              <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>

      <comment type="block">/* Changes were made to this entry both within the transaction
         and to the repository while the transaction was in progress.
         They must be merged or declared to be in conflict. */</comment>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>, *<decl><type ref="prev"/><name>t_ent_node</name></decl>, *<decl><type ref="prev"/><name>a_ent_node</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_tpath</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>sub_mergeinfo_increment</name></decl>;</decl_stmt>

          <comment type="block">/* If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a
             double delete; flag a conflict. */</comment>
          <if>if <condition>(<expr><name>s_entry</name> == <name>NULL</name> || <name>t_entry</name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
                                <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                              <argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* If either SOURCE-ENTRY or TARGET-ENTRY is not a direct
             modification of ANCESTOR-ENTRY, declare a conflict. */</comment>
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_node_id</name><argument_list>(<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><call><name>svn_fs_base__id_node_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
              || <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
              || <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_node_id</name><argument_list>(<argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>svn_fs_base__id_node_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
              || <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
            <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
                                <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                              <argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* Fetch the nodes for our entries. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                            <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>t_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                            <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>a_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                            <argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If any of the three entries is of type file, flag a conflict. */</comment>
          <if>if <condition>(<expr>(<call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>s_ent_node</name></expr></argument>)</argument_list></call> == <name>svn_node_file</name>)
              || (<call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>t_ent_node</name></expr></argument>)</argument_list></call> == <name>svn_node_file</name>)
              || (<call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>a_ent_node</name></expr></argument>)</argument_list></call> == <name>svn_node_file</name>)</expr>)</condition><then>
            <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
                                <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                              <argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* Direct modifications were made to the directory
             ANCESTOR-ENTRY in both SOURCE and TARGET.  Recursively
             merge these modifications. */</comment>
          <expr_stmt><expr><name>new_tpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>new_tpath</name></expr></argument>,
                        <argument><expr><name>t_ent_node</name></expr></argument>, <argument><expr><name>s_ent_node</name></expr></argument>, <argument><expr><name>a_ent_node</name></expr></argument>,
                        <argument><expr><name>txn_id</name></expr></argument>, <argument><expr>&amp;<name>sub_mergeinfo_increment</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mergeinfo_increment</name> += <name>sub_mergeinfo_increment</name></expr>;</expr_stmt>
        }</block></else></if></else></if>

      <comment type="block">/* We've taken care of any possible implications E could have.
         Remove it from source_entries, so it's easy later to loop
         over all the source entries that didn't exist in
         ancestor_entries. */</comment>
    <label><name>end</name>:</label>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* For each entry E in source but not in ancestor */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>s_entries</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_s</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>s_entry</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>t_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If NAME exists in TARGET, declare a conflict. */</comment>
      <if>if <condition>(<expr><name>t_entry</name></expr>)</condition><then>
        <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
                            <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                          <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                          <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                        <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>mergeinfo_s</name></expr></argument>,
                                                   <argument><expr><name>s_ent_node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                                   <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>mergeinfo_increment</name> += <name>mergeinfo_s</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_set_entry</name>
              <argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now that TARGET has absorbed all of the history between ANCESTOR
     and SOURCE, we can update its predecessor to point to SOURCE.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_predecessor_count</name><argument_list>(<argument><expr>&amp;<name>pred_count</name></expr></argument>, <argument><expr><name>source</name></expr></argument>,
                                                 <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_ancestry</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                          <argument><expr><name>pred_count</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Tweak mergeinfo data if our format supports it. */</comment>
  <if>if <condition>(<expr><name><name>bfd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_adjust_mergeinfo_count</name><argument_list>(<argument><expr><name>target</name></expr></argument>, 
                                                      <argument><expr><name>mergeinfo_increment</name></expr></argument>,
                                                      <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>mergeinfo_increment_out</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>mergeinfo_increment_out</name> = <name>mergeinfo_increment</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>merge_args</name>
<block>{
  <comment type="block">/* The ancestor for the merge.  If this is null, then TXN's base is
     used as the ancestor for the merge. */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>ancestor_node</name></decl>;</decl_stmt>

  <comment type="block">/* This is the SOURCE node for the merge.  It may not be null. */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>source_node</name></decl>;</decl_stmt>

  <comment type="block">/* This is the TARGET of the merge.  It may not be null.  If
     ancestor_node above is null, then this txn's base is used as the
     ancestor for the merge. */</comment>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>

  <comment type="block">/* If a conflict results, this is updated to the path in the txn that
     conflicted.  It must point to a valid svn_stringbuf_t before calling
     svn_fs_base__retry_txn, as this determines the pool used to allocate any
     required memory. */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Merge changes between an ancestor and BATON-&gt;source_node into
   BATON-&gt;txn.  The ancestor is either BATON-&gt;ancestor_node, or if
   that is null, BATON-&gt;txn's base node.

   If the merge is successful, BATON-&gt;txn's base will become
   BATON-&gt;source_node, and its root node will have a new ID, a
   successor of BATON-&gt;source_node. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_merge</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>merge_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>source_node</name></decl>, *<decl><type ref="prev"/><name>txn_root_node</name></decl>, *<decl><type ref="prev"/><name>ancestor_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>args</name>-&gt;<name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>args</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>source_node</name> = <name><name>args</name>-&gt;<name>source_node</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>ancestor_node</name> = <name><name>args</name>-&gt;<name>ancestor_node</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>source_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>source_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_txn_root</name><argument_list>(<argument><expr>&amp;<name>txn_root_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>ancestor_node</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_txn_base_root</name><argument_list>(<argument><expr>&amp;<name>ancestor_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                             <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>ancestor_node</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>txn_root_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* If no changes have been made in TXN since its current base,
         then it can't conflict with any changes since that base.  So
         we just set *both* its base and root to source, making TXN
         in effect a repeat of source. */</comment>

      <comment type="block">/* ### kff todo: this would, of course, be a mighty silly thing
         for the caller to do, and we might want to consider whether
         this response is really appropriate. */</comment>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__set_txn_base</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__set_txn_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>pred_count</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>conflict</name></name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>txn_root_node</name></expr></argument>, <argument><expr><name>source_node</name></expr></argument>, 
                    <argument><expr><name>ancestor_node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_predecessor_count</name><argument_list>(<argument><expr>&amp;<name>pred_count</name></expr></argument>,
                                                     <argument><expr><name>source_node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* After the merge, txn's new "ancestor" is now really the node
         at source_id, so record that fact.  Think of this as
         ratcheting the txn forward in time, so it can't backslide and
         forget the merging work that's already been done. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_ancestry</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>,
                              <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>txn_root_node</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>txn_id</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>pred_count</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__set_txn_base</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Verify that there are registered with TRAIL-&gt;fs all the locks
   necessary to permit all the changes associated with TXN_NAME. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>verify_locks</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl></param>,
             <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>changed_paths</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>last_recursed</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch the changes for this transaction. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__changes_fetch</name><argument_list>(<argument><expr>&amp;<name>changes</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_name</name></expr></argument>,
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make an array of the changed paths, and sort them depth-first-ily.  */</comment>
  <expr_stmt><expr><name>changed_paths</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>changes</name></expr></argument>)</argument_list></call> + 1</expr></argument>,
                                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>changes</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>key</name></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>changed_paths</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>changed_paths</name>-&gt;<name>nelts</name></name></expr></argument>,
        <argument><expr><name><name>changed_paths</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>svn_sort_compare_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, traverse the array of changed paths, verify locks.  Note
     that if we need to do a recursive verification a path, we'll skip
     over children of that path when we get to them. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>changed_paths</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_path_change_t</name> *</type><name>change</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>recurse</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this path has already been verified as part of a recursive
         check of one of its parents, no need to do it again.  */</comment>
      <if>if <condition>(<expr><name>last_recursed</name>
          &amp;&amp; <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>last_recursed</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* Fetch the change associated with our path.  */</comment>
      <expr_stmt><expr><name>change</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>changes</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* What does it mean to succeed at lock verification for a given
         path?  For an existing file or directory getting modified
         (text, props), it means we hold the lock on the file or
         directory.  For paths being added or removed, we need to hold
         the locks for that path and any children of that path.

         WHEW!  We have no reliable way to determine the node kind of
         deleted items, but fortunately we are going to do a recursive
         check on deleted paths regardless of their kind.  */</comment>
      <if>if <condition>(<expr><name><name>change</name>-&gt;<name>change_kind</name></name> == <name>svn_fs_path_change_modify</name></expr>)</condition><then>
        <expr_stmt><expr><name>recurse</name> = <name>FALSE</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>,
                                                  <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we just did a recursive check, remember the path we
         checked (so children can be skipped).  */</comment>
      <if>if <condition>(<expr><name>recurse</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>! <name>last_recursed</name></expr>)</condition><then>
            <expr_stmt><expr><name>last_recursed</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>last_recursed</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>commit_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>new_rev</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Commit ARGS-&gt;txn, setting ARGS-&gt;new_rev to the resulting new
 * revision, if ARGS-&gt;txn is up-to-date with respect to the repository.
 *
 * Up-to-date means that ARGS-&gt;txn's base root is the same as the root
 * of the youngest revision.  If ARGS-&gt;txn is not up-to-date, the
 * error SVN_ERR_FS_TXN_OUT_OF_DATE is returned, and the commit fails: no
 * new revision is created, and ARGS-&gt;new_rev is not touched.
 *
 * If the commit succeeds, ARGS-&gt;txn is destroyed.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_commit</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>commit_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name> <init>= <expr><name><name>args</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name> <init>= <expr><name><name>txn</name>-&gt;<name>id</name></name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>y_rev_root_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>txn_base_root_node</name></decl>;</decl_stmt>

  <comment type="block">/* Getting the youngest revision locks the revisions table until
     this trail is done. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the root of the youngest revision is the same as txn's base,
     then no further merging is necessary and we can commit. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rev_get_root</name><argument_list>(<argument><expr>&amp;<name>y_rev_root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>youngest_rev</name></expr></argument>,
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_txn_base_root</name><argument_list>(<argument><expr>&amp;<name>txn_base_root_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_name</name></expr></argument>,
                                         <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* ### kff todo: it seems weird to grab the ID for one, and the node
     for the other.  We can certainly do the comparison we need, but
     it would be nice to grab the same type of information from the
     start, instead of having to transform one of them. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><name>y_rev_root_id</name></expr></argument>,
                           <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>txn_base_root_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= <expr><call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name>y_rev_root_id</name></expr></argument>,
                                                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_TXN_OUT_OF_DATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Transaction '%s' out-of-date with respect to revision '%s'"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name>txn_name</name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Locks may have been added (or stolen) between the calling of
     previous svn_fs.h functions and svn_fs_commit_txn(), so we need
     to re-examine every changed-path in the txn and re-verify all
     discovered locks. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_locks</name><argument_list>(<argument><expr><name>txn_name</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Else, commit the txn. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_commit_txn</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>new_rev</name></name>)</expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                      <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Note:  it is acceptable for this function to call back into
   top-level FS interfaces because it does not itself use trails.  */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__commit_txn</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>conflict_p</name></decl></param>,
                        <param><decl><type><name>svn_revnum_t</name> *</type><name>new_rev</name></decl></param>,
                        <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* How do commits work in Subversion?
   *
   * When you're ready to commit, here's what you have:
   *
   *    1. A transaction, with a mutable tree hanging off it.
   *    2. A base revision, against which TXN_TREE was made.
   *    3. A latest revision, which may be newer than the base rev.
   *
   * The problem is that if latest != base, then one can't simply
   * attach the txn root as the root of the new revision, because that
   * would lose all the changes between base and latest.  It is also
   * not acceptable to insist that base == latest; in a busy
   * repository, commits happen too fast to insist that everyone keep
   * their entire tree up-to-date at all times.  Non-overlapping
   * changes should not interfere with each other.
   *
   * The solution is to merge the changes between base and latest into
   * the txn tree [see the function merge()].  The txn tree is the
   * only one of the three trees that is mutable, so it has to be the
   * one to adjust.
   *
   * You might have to adjust it more than once, if a new latest
   * revision gets committed while you were merging in the previous
   * one.  For example:
   *
   *    1. Jane starts txn T, based at revision 6.
   *    2. Someone commits (or already committed) revision 7.
   *    3. Jane's starts merging the changes between 6 and 7 into T.
   *    4. Meanwhile, someone commits revision 8.
   *    5. Jane finishes the 6--&gt;7 merge.  T could now be committed
   *       against a latest revision of 7, if only that were still the
   *       latest.  Unfortunately, 8 is now the latest, so...
   *    6. Jane starts merging the changes between 7 and 8 into T.
   *    7. Meanwhile, no one commits any new revisions.  Whew.
   *    8. Jane commits T, creating revision 9, whose tree is exactly
   *       T's tree, except immutable now.
   *
   * Lather, rinse, repeat.
   */</comment>

  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Initialize output params. */</comment>
  <expr_stmt><expr>*<name>new_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>conflict_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>conflict_p</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

  <while>while <condition>(<expr>1729</expr>)</condition>
    <block>{
      <decl_stmt><decl><type>struct <name>get_root_args</name></type> <name>get_root_args</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>merge_args</name></type> <name>merge_args</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>commit_args</name></type> <name>commit_args</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngish_rev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>youngish_root</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>youngish_root_node</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the *current* youngest revision, in one short-lived
         Berkeley transaction.  (We don't want the revisions table
         locked while we do the main merge.)  We call it "youngish"
         because new revisions might get committed after we've
         obtained it. */</comment>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngish_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__revision_root</name><argument_list>(<argument><expr>&amp;<name>youngish_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>youngish_rev</name></expr></argument>,
                                         <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the dag node for the youngest revision, also in one
         Berkeley transaction.  Later we'll use it as the SOURCE
         argument to a merge, and if the merge succeeds, this youngest
         root node will become the new base root for the svn txn that
         was the target of the merge (but note that the youngest rev
         may have changed by then -- that's why we're careful to get
         this root in its own bdb txn here). */</comment>
      <expr_stmt><expr><name><name>get_root_args</name>.<name>root</name></name> = <name>youngish_root</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_get_root</name></expr></argument>,
                                     <argument><expr>&amp;<name>get_root_args</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>youngish_root_node</name> = <name><name>get_root_args</name>.<name>node</name></name></expr>;</expr_stmt>

      <comment type="block">/* Try to merge.  If the merge succeeds, the base root node of
         TARGET's txn will become the same as youngish_root_node, so
         any future merges will only be between that node and whatever
         the root node of the youngest rev is by then. */</comment>
      <expr_stmt><expr><name><name>merge_args</name>.<name>ancestor_node</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_args</name>.<name>source_node</name></name> = <name>youngish_root_node</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_args</name>.<name>txn</name></name> = <name>txn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>merge_args</name>.<name>conflict</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* use pool */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_merge</name></expr></argument>, <argument><expr>&amp;<name>merge_args</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>(<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_CONFLICT</name>) &amp;&amp; <name>conflict_p</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>conflict_p</name> = <name><name>merge_args</name>.<name>conflict</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>
          <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>

      <comment type="block">/* Try to commit. */</comment>
      <expr_stmt><expr><name><name>commit_args</name>.<name>txn</name></name> = <name>txn</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_commit</name></expr></argument>, <argument><expr>&amp;<name>commit_args</name></expr></argument>,
                                   <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_TXN_OUT_OF_DATE</name>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* Did someone else finish committing a new revision while we
             were in mid-merge or mid-commit?  If so, we'll need to
             loop again to merge the new changes in, then try to
             commit again.  Or if that's not what happened, then just
             return the error. */</comment>
          <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err2</name> <init>= <expr><call><name>svn_fs_base__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                                        <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><name>err2</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>err2</name></expr>;</return>  <comment type="block">/* err2 is bad, it should not occur */</comment>
            }</block></then>
          <else>else <if>if <condition>(<expr><name>youngest_rev</name> == <name>youngish_rev</name></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then>
          <else>else
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <return>return <expr><name>err</name></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* Set the return value -- our brand spankin' new revision! */</comment>
          <expr_stmt><expr>*<name>new_rev</name> = <name><name>commit_args</name>.<name>new_rev</name></name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></else></if></else></if>
    }</block></while>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Note:  it is acceptable for this function to call back into
   public FS API interfaces because it does not itself use trails.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_merge</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>conflict_p</name></decl></param>,
           <param><decl><type><name>svn_fs_root_t</name> *</type><name>source_root</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
           <param><decl><type><name>svn_fs_root_t</name> *</type><name>target_root</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
           <param><decl><type><name>svn_fs_root_t</name> *</type><name>ancestor_root</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ancestor_path</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>source</name></decl>, *<decl><type ref="prev"/><name>ancestor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>get_root_args</name></type> <name>get_root_args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>merge_args</name></type> <name>merge_args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>target_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>target_root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Paranoia. */</comment>
  <expr_stmt><expr><name>fs</name> = <name><name>ancestor_root</name>-&gt;<name>fs</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name><name>source_root</name>-&gt;<name>fs</name></name> != <name>fs</name>) || (<name><name>target_root</name>-&gt;<name>fs</name></name> != <name>fs</name>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; ancestor, source, and target not all in same fs"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* ### kff todo: is there any compelling reason to get the nodes in
     one db transaction?  Right now we don't; txn_body_get_root() gets
     one node at a time.  This will probably need to change:

     Jim Blandy &lt;jimb@zwingli.cygnus.com&gt; writes:
     &gt; svn_fs_merge needs to be a single transaction, to protect it against
     &gt; people deleting parents of nodes it's working on, etc.
  */</comment>

  <comment type="block">/* Get the ancestor node. */</comment>
  <expr_stmt><expr><name><name>get_root_args</name>.<name>root</name></name> = <name>ancestor_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_get_root</name></expr></argument>, <argument><expr>&amp;<name>get_root_args</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ancestor</name> = <name><name>get_root_args</name>.<name>node</name></name></expr>;</expr_stmt>

  <comment type="block">/* Get the source node. */</comment>
  <expr_stmt><expr><name><name>get_root_args</name>.<name>root</name></name> = <name>source_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_get_root</name></expr></argument>, <argument><expr>&amp;<name>get_root_args</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>source</name> = <name><name>get_root_args</name>.<name>node</name></name></expr>;</expr_stmt>

  <comment type="block">/* Open a txn for the txn root into which we're merging. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__open_txn</name><argument_list>(<argument><expr>&amp;<name>txn</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>target_root</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Merge changes between ANCESTOR and SOURCE into TXN. */</comment>
  <expr_stmt><expr><name><name>merge_args</name>.<name>source_node</name></name> = <name>source</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_args</name>.<name>ancestor_node</name></name> = <name>ancestor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_args</name>.<name>txn</name></name> = <name>txn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>merge_args</name>.<name>conflict</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_merge</name></expr></argument>, <argument><expr>&amp;<name>merge_args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>(<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_CONFLICT</name>) &amp;&amp; <name>conflict_p</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>conflict_p</name> = <name><name>merge_args</name>.<name>conflict</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>rev_get_txn_id_args</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>txn_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_rev_get_txn_id</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rev_get_txn_id_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>svn_fs_base__rev_get_txn_id</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>,
                                     <argument><expr><name><name>args</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__deltify</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                     <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rev_get_txn_id_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>txn_id</name></name> = &amp;<name>txn_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>revision</name></name> = <name>revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_rev_get_txn_id</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>deltify_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>svn_node_dir</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Modifying directories */</comment>


<struct>struct <name>make_dir_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_make_dir</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                  <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>make_dir_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><name><name>args</name>-&gt;<name>root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><name><name>args</name>-&gt;<name>path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>sub_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>open_path_last_optional</name></expr></argument>,
                    <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there's already a sub-directory by that name, complain.  This
     also catches the case of trying to make a subdirectory named `/'.  */</comment>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__ALREADY_EXISTS</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check to see if some lock is 'reserving' a file-path or dir-path
     at that location, or even some child-path;  if so, check that we
     can use it. */</comment>
  <if>if <condition>(<expr><name><name>args</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                  <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Create the subdirectory.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_make_dir</name><argument_list>(<argument><expr>&amp;<name>sub_dir</name></expr></argument>,
                                    <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                    <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                    <argument><expr><name>txn_id</name></expr></argument>,
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                     <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>sub_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_add</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, 
                     <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_make_dir</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>make_dir_args</name></type> <name>args</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_make_dir</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<struct>struct <name>delete_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* If this returns SVN_ERR_FS_NO_SUCH_ENTRY, it means that the
   basename of PATH is missing from its parent, that is, the final
   target of the deletion is missing.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_delete</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>delete_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><name><name>args</name>-&gt;<name>root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><name><name>args</name>-&gt;<name>path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>base_fs_data_t</name> *</type><name>bfd</name> <init>= <expr><name><name>trail</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We can't remove the root of the filesystem.  */</comment>
  <if>if <condition>(<expr>! <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_ROOT_DIR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The root directory cannot be deleted"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check to see if path (or any child thereof) is locked; if so,
     check that we can use the existing lock(s). */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                  <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Make the parent directory mutable. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Decrement mergeinfo counts on the parents of this node by the
     count it previously carried, if our format supports it. */</comment>
  <if>if <condition>(<expr><name><name>bfd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_count</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>mergeinfo_count</name></expr></argument>,
                                                   <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
                                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>adjust_parent_mergeinfo_counts</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                             <argument><expr>-<name>mergeinfo_count</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, 
                                             <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Do the deletion. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_delete</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                  <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                  <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                     <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_delete</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_delete_node</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>delete_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>root</name></name>        = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name>        = <name>path</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_delete</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<struct>struct <name>copy_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>preserve_history</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_copy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
              <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>copy_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name> <init>= <expr><name><name>args</name>-&gt;<name>from_root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name> <init>= <expr><name><name>args</name>-&gt;<name>from_path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name> <init>= <expr><name><name>args</name>-&gt;<name>to_root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name> <init>= <expr><name><name>args</name>-&gt;<name>to_path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>from_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>to_parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>to_root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the NODE for FROM_PATH in FROM_ROOT.*/</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>from_node</name></expr></argument>, <argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Build up the parent path from TO_PATH in TO_ROOT.  If the last
     component does not exist, it's not that big a deal.  We'll just
     make one there. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>to_parent_path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>,
                    <argument><expr><name>open_path_last_optional</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to see if to-path (or any child thereof) is locked, or at
     least 'reserved', whether it exists or not; if so, check that we
     can use the existing lock(s). */</comment>
  <if>if <condition>(<expr><name><name>to_root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__allow_locked_operation</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                  <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If the destination node already exists as the same node as the
     source (in other words, this operation would result in nothing
     happening at all), just do nothing an return successfully,
     proud that you saved yourself from a tiresome task. */</comment>
  <if>if <condition>(<expr>(<name><name>to_parent_path</name>-&gt;<name>node</name></name>)
      &amp;&amp; (<call><name>svn_fs_base__id_compare</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>svn_fs_base__dag_get_id</name>
                                  <argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr>! <name><name>from_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>new_node</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>old_mergeinfo_count</name> <init>= <expr>0</expr></init>, <name>mergeinfo_count</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>base_fs_data_t</name> *</type><name>bfd</name> <init>= <expr><name><name>trail</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If TO_PATH already existed prior to the copy, note that this
         operation is a replacement, not an addition. */</comment>
      <if>if <condition>(<expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>kind</name> = <name>svn_fs_path_change_replace</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>kind</name> = <name>svn_fs_path_change_add</name></expr>;</expr_stmt></else></if>

      <comment type="block">/* Make sure the target node's parents are mutable.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>, <argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this is a replacement operation, we need to know the old
         node's mergeinfo count. */</comment>
      <if>if <condition>(<expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, 
                                                     <argument><expr>&amp;<name>old_mergeinfo_count</name></expr></argument>,
                                                     <argument><expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr></argument>,
                                                     <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <comment type="block">/* Do the copy. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_copy</name><argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                    <argument><expr><name><name>to_parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                    <argument><expr><name>from_node</name></expr></argument>,
                                    <argument><expr><name><name>args</name>-&gt;<name>preserve_history</name></name></expr></argument>,
                                    <argument><expr><name><name>from_root</name>-&gt;<name>rev</name></name></expr></argument>,
                                    <argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Adjust the mergeinfo counts of the destination's parents if
         our format supports it. */</comment>
      <if>if <condition>(<expr><name><name>bfd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, 
                                                       <argument><expr>&amp;<name>mergeinfo_count</name></expr></argument>, 
                                                       <argument><expr><name>from_node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, 
                                                       <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>adjust_parent_mergeinfo_counts</name>
                  <argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name></name></expr></argument>, 
                   <argument><expr><name>mergeinfo_count</name> - <name>old_mergeinfo_count</name></expr></argument>,
                   <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Make a record of this modification in the changes table. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>new_node</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>,
                         <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* See IZ Issue #436 */</comment>
      <comment type="block">/* Copying from transaction roots not currently available.

         ### cmpilato todo someday: make this not so. :-) Note that
         when copying from mutable trees, you have to make sure that
         you aren't creating a cyclic graph filesystem, and a simple
         referencing operation won't cut it.  Currently, we should not
         be able to reach this clause, and the interface reports that
         this only works from immutable trees anyway, but JimB has
         stated that this requirement need not be necessary in the
         future. */</comment>

      <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *SAME_P to TRUE if FS1 and FS2 have the same UUID, else set to FALSE.
   Use POOL for temporary allocation only.
   Note: this code is duplicated between libsvn_fs_fs and libsvn_fs_base. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_same_p</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>same_p</name></decl></param>,
          <param><decl><type><name>svn_fs_t</name> *</type><name>fs1</name></decl></param>,
          <param><decl><type><name>svn_fs_t</name> *</type><name>fs2</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid2</name></decl>;</decl_stmt>

  <comment type="block">/* Random thought: if fetching UUIDs to compare filesystems is too
     expensive, one solution would be to cache the UUID in each fs
     object (copying the UUID into fs-&gt;pool, of course). */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>fs1</name>-&gt;<name>vtable</name>-&gt;<name>get_uuid</name></name><argument_list>(<argument><expr><name>fs1</name></expr></argument>, <argument><expr>&amp;<name>uuid1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>fs2</name>-&gt;<name>vtable</name>-&gt;<name>get_uuid</name></name><argument_list>(<argument><expr><name>fs2</name></expr></argument>, <argument><expr>&amp;<name>uuid2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>same_p</name> = ! <call><name>strcmp</name><argument_list>(<argument><expr><name>uuid1</name></expr></argument>, <argument><expr><name>uuid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>copy_helper</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>,
            <param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
            <param><decl><type><name>svn_boolean_t</name></type> <name>preserve_history</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>copy_args</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same_p</name></decl>;</decl_stmt>

  <comment type="block">/* Use an error check, not an assert, because even the caller cannot
     guarantee that a filesystem's UUID has not changed "on the fly". */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_same_p</name><argument_list>(<argument><expr>&amp;<name>same_p</name></expr></argument>, <argument><expr><name><name>from_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>same_p</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot copy between two different filesystems ('%s' and '%s')"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name><name>from_root</name>-&gt;<name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>to_root</name>-&gt;<name>fs</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr>! <name><name>to_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>from_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Copy from mutable tree not currently supported"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>args</name>.<name>from_root</name></name>         = <name>from_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>from_path</name></name>         = <name>from_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>to_root</name></name>           = <name>to_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>to_path</name></name>           = <name>to_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>preserve_history</name></name>  = <name>preserve_history</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_copy</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_copy</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>,
          <param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>copy_helper</name><argument_list>(<argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_revision_link</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>copy_helper</name><argument_list>(<argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<struct>struct <name>copied_from_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>      <comment type="block">/* Root for the node whose ancestry we seek. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>         <comment type="block">/* Path for the node whose ancestry we seek. */</comment>

  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>result_rev</name></decl>;</decl_stmt>  <comment type="block">/* Revision, if any, of the ancestor. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_path</name></decl>;</decl_stmt>  <comment type="block">/* Path, if any, of the ancestor. */</comment>

  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>         <comment type="block">/* Allocate `result_path' here. */</comment>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_copied_from</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>copied_from_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>, *<decl><type ref="prev"/><name>pred_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>args</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Clear the return variables. */</comment>
  <expr_stmt><expr><name><name>args</name>-&gt;<name>result_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>-&gt;<name>result_rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* Fetch the NODE in question. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the node's predecessor-ID.  If it doesn't have one, it
     isn't a copy. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                              <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>pred_id</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If NODE's copy-ID is the same as that of its predecessor... */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__key_compare</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name>pred_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* ... then NODE was either the target of a copy operation,
         a copied subtree item.  We examine the actual copy record
         to determine which is the case.  */</comment>
      <decl_stmt><decl><type><name>copy_t</name> *</type><name>copy</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_copy</name><argument_list>(<argument><expr>&amp;<name>copy</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                   <argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name><name>copy</name>-&gt;<name>kind</name></name> == <name>copy_kind_real</name>)
          &amp;&amp; <call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>args</name>-&gt;<name>result_path</name></name> = <name><name>copy</name>-&gt;<name>src_path</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__txn_get_revision</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>result_rev</name></name>)</expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                                <argument><expr><name><name>copy</name>-&gt;<name>src_txn_id</name></name></expr></argument>,
                                                <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_copied_from</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev_p</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>copied_from_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>,
                                 <argument><expr><name>txn_body_copied_from</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>rev_p</name>  = <name><name>args</name>.<name>result_rev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>path_p</name> = <name><name>args</name>.<name>result_path</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Files.  */</comment>


<struct>struct <name>make_file_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_make_file</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                   <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>make_file_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><name><name>args</name>-&gt;<name>root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><name><name>args</name>-&gt;<name>path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>child</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>open_path_last_optional</name></expr></argument>,
                    <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there's already a file by that name, complain.
     This also catches the case of trying to make a file named `/'.  */</comment>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__ALREADY_EXISTS</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check to see if some lock is 'reserving' a file-path or dir-path
     at that location, or even some child-path;  if so, check that we
     can use it. */</comment>
  <if>if <condition>(<expr><name><name>args</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                  <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Create the file.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_make_file</name><argument_list>(<argument><expr>&amp;<name>child</name></expr></argument>,
                                     <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                     <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                                      <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                     <argument><expr><name>txn_id</name></expr></argument>,
                                     <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, 
                     <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_add</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, 
                     <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_make_file</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>make_file_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_make_file</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<struct>struct <name>file_length_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>length</name></decl>;</decl_stmt>       <comment type="block">/* OUT parameter */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_file_length</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                     <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>file_length_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>file</name></decl>;</decl_stmt>

  <comment type="block">/* First create a dag_node_t from the root/path pair. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now fetch its length */</comment>
  <return>return <expr><call><name>svn_fs_base__dag_file_length</name><argument_list>(<argument><expr>&amp;<name><name>args</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
                                      <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_file_length</name><parameter_list>(<param><decl><type><name>svn_filesize_t</name> *</type><name>length_p</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>file_length_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_file_length</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>length_p</name> = <name><name>args</name>.<name>length</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>file_checksum_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>digest</name></decl>;</decl_stmt>  <comment type="block">/* OUT parameter, APR_MD5_DIGESTSIZE bytes long */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_file_checksum</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                       <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>file_checksum_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>file</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_base__dag_file_checksum</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>digest</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_file_md5_checksum</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[]</index></name></decl></param>,
                       <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>file_checksum_args</name></type> <name>args</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>digest</name></name> = <name>digest</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_file_checksum</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* --- Machinery for svn_fs_file_contents() ---  */</comment>


<comment type="block">/* Local baton type for txn_body_get_file_contents. */</comment>
<typedef>typedef <type><struct>struct <name>file_contents_baton_t</name>
<block>{
  <comment type="block">/* The file we want to read. */</comment>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* The dag_node that will be made from the above. */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* The pool in which `file_stream' (below) is allocated. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <comment type="block">/* The readable file stream that will be made from the
     dag_node. (And returned to the caller.) */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>file_stream</name></decl>;</decl_stmt>

}</block></struct></type> <name>file_contents_baton_t</name>;</typedef>


<comment type="block">/* Main body of svn_fs_file_contents;  converts a root/path pair into
   a readable file stream (in the context of a db txn). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_get_file_contents</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>file_contents_baton_t</name> *</type><name>fb</name> <init>= <expr>(<name>file_contents_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First create a dag_node_t from the root/path pair. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;(<name><name>fb</name>-&gt;<name>node</name></name>)</expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Then create a readable stream from the dag_node_t. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_contents</name><argument_list>(<argument><expr>&amp;(<name><name>fb</name>-&gt;<name>file_stream</name></name>)</expr></argument>,
                                        <argument><expr><name><name>fb</name>-&gt;<name>node</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_file_contents</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>file_contents_baton_t</name> *</type><name>fb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>fb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fb</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fb</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <comment type="block">/* Create the readable stream in the context of a db txn.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_get_file_contents</name></expr></argument>,
                                 <argument><expr><name>fb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents</name> = <name><name>fb</name>-&gt;<name>file_stream</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- End machinery for svn_fs_file_contents() ---  */</comment>



<comment type="block">/* --- Machinery for svn_fs_apply_textdelta() ---  */</comment>


<comment type="block">/* Local baton type for all the helper functions below. */</comment>
<typedef>typedef <type><struct>struct <name>txdelta_baton_t</name>
<block>{
  <comment type="block">/* This is the custom-built window consumer given to us by the delta
     library;  it uniquely knows how to read data from our designated
     "source" stream, interpret the window, and write data to our
     designated "target" stream (in this case, our repos file.) */</comment>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>interpreter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>interpreter_baton</name></decl>;</decl_stmt>

  <comment type="block">/* The original file info */</comment>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* Derived from the file info */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>source_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>target_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>string_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>target_string</name></decl>;</decl_stmt>

  <comment type="block">/* Hex MD5 digest for the base text against which a delta is to be
     applied, and for the resultant fulltext, respectively.  Either or
     both may be null, in which case ignored. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl>;</decl_stmt>

  <comment type="block">/* Pool used by db txns */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

}</block></struct></type> <name>txdelta_baton_t</name>;</typedef>


<comment type="block">/* A trail-ready wrapper around svn_fs_base__dag_finalize_edits.
 * This closes BATON-&gt;target_stream.
 *
 * Note: If you're confused about how this function relates to another
 * of similar name, think of it this way:
 *
 * svn_fs_apply_textdelta() ==&gt; ... ==&gt; txn_body_txdelta_finalize_edits()
 * svn_fs_apply_text()      ==&gt; ... ==&gt; txn_body_fulltext_finalize_edits()
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_txdelta_finalize_edits</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>svn_fs_base__dag_finalize_edits</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
                                         <argument><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name></expr></argument>,
                                         <argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></argument>,
                                         <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* ### see comment in window_consumer() regarding this function. */</comment>

<comment type="block">/* Helper function of generic type `svn_write_fn_t'.  Implements a
   writable stream which appends to an svn_stringbuf_t. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_to_string</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_string</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* The main window handler returned by svn_fs_apply_textdelta. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>window_consumer</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> *</type><name>window</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Send the window right through to the custom window interpreter.
     In theory, the interpreter will then write more data to
     cb-&gt;target_string. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>tb</name>-&gt;<name>interpreter</name></name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>interpreter_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### the write_to_string() callback for the txdelta's output stream
     ### should be doing all the flush determination logic, not here.
     ### in a drastic case, a window could generate a LOT more than the
     ### maximum buffer size. we want to flush to the underlying target
     ### stream much sooner (e.g. also in a streamy fashion). also, by
     ### moving this logic inside the stream, the stream becomes nice
     ### and encapsulated: it holds all the logic about buffering and
     ### flushing.
     ###
     ### further: I believe the buffering should be removed from tree.c
     ### the buffering should go into the target_stream itself, which
     ### is defined by reps-string.c. Specifically, I think the
     ### rep_write_contents() function will handle the buffering and
     ### the spill to the underlying DB. by locating it there, then
     ### anybody who gets a writable stream for FS content can take
     ### advantage of the buffering capability. this will be important
     ### when we export an FS API function for writing a fulltext into
     ### the FS, rather than forcing that fulltext thru apply_textdelta.
  */</comment>

  <comment type="block">/* Check to see if we need to purge the portion of the contents that
     have been written thus far. */</comment>
  <if>if <condition>(<expr>(! <name>window</name>) || (<name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>len</name></name> &gt; <name>WRITE_BUFFER_SIZE</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_stream</name></name></expr></argument>,
                               <argument><expr><name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>data</name></name></expr></argument>,
                               <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_string</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Is the window NULL?  If so, we're done. */</comment>
  <if>if <condition>(<expr>! <name>window</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Close the internal-use stream.  ### This used to be inside of
         txn_body_fulltext_finalize_edits(), but that invoked a nested
         Berkeley DB transaction -- scandalous! */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Tell the dag subsystem that we're finished with our edits. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>,
                                     <argument><expr><name>txn_body_txdelta_finalize_edits</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>,
                                     <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_apply_textdelta</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Call open_path with no flags, as we want this to return an error
     if the node for which we are searching doesn't exist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to see if path is locked;  if so, check that we can use it. */</comment>
  <if>if <condition>(<expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__allow_locked_operation</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now, make sure this path is mutable. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>node</name></name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex</name></decl>;</decl_stmt>

      <comment type="block">/* Until we finalize the node, its data_key points to the old
         contents, in other words, the base text. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
                                             <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>hex</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>hex</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_CHECKSUM_MISMATCH</name></expr></argument>,
           <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Base checksum mismatch on '%s':\n"
             "   expected:  %s\n"
             "     actual:  %s\n"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Make a readable "source" stream out of the current contents of
     ROOT/PATH; obviously, this must done in the context of a db_txn.
     The stream is returned in tb-&gt;source_stream. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_contents</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>source_stream</name></name>)</expr></argument>,
                                        <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a writable "target" stream */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_edit_stream</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>target_stream</name></name>)</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
                                           <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a writable "string" stream which writes data to
     tb-&gt;target_string. */</comment>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>target_string</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>string_stream</name></name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>string_stream</name></name></expr></argument>, <argument><expr><name>write_to_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, create a custom window handler that uses our two streams. */</comment>
  <expr_stmt><expr><call><name>svn_txdelta_apply</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>source_stream</name></name></expr></argument>,
                    <argument><expr><name><name>tb</name>-&gt;<name>string_stream</name></name></expr></argument>,
                    <argument><expr><name>NULL</name></expr></argument>,
                    <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
                    <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>,
                    <argument><expr>&amp;(<name><name>tb</name>-&gt;<name>interpreter</name></name>)</expr></argument>,
                    <argument><expr>&amp;(<name><name>tb</name>-&gt;<name>interpreter_baton</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
                     <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_apply_textdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>contents_p</name></decl></param>,
                     <param><decl><type><name>void</name> **</type><name>contents_baton_p</name></decl></param>,
                     <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>tb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>tb</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>base_checksum</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>result_checksum</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>result_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_apply_textdelta</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents_p</name> = <name>window_consumer</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>contents_baton_p</name> = <name>tb</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- End machinery for svn_fs_apply_textdelta() ---  */</comment>

<comment type="block">/* --- Machinery for svn_fs_apply_text() ---  */</comment>

<comment type="block">/* Baton for svn_fs_apply_text(). */</comment>
<struct>struct <name>text_baton_t</name>
<block>{
  <comment type="block">/* The original file info */</comment>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* Derived from the file info */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* The returned stream that will accept the file's new contents. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <comment type="block">/* The actual fs stream that the returned stream will write to. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>file_stream</name></decl>;</decl_stmt>

  <comment type="block">/* Hex MD5 digest for the final fulltext written to the file.  May
     be null, in which case ignored. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl>;</decl_stmt>

  <comment type="block">/* Pool used by db txns */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* A trail-ready wrapper around svn_fs_base__dag_finalize_edits, but for
 * fulltext data, not text deltas.  Closes BATON-&gt;file_stream.
 *
 * Note: If you're confused about how this function relates to another
 * of similar name, think of it this way:
 *
 * svn_fs_apply_textdelta() ==&gt; ... ==&gt; txn_body_txdelta_finalize_edits()
 * svn_fs_apply_text()      ==&gt; ... ==&gt; txn_body_fulltext_finalize_edits()
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_fulltext_finalize_edits</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>svn_fs_base__dag_finalize_edits</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
                                         <argument><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name></expr></argument>,
                                         <argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></argument>,
                                         <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Write function for the publically returned stream. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>text_stream_writer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                   <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Psst, here's some data.  Pass it on to the -real- file stream. */</comment>
  <return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>file_stream</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Close function for the publically returned stream. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>text_stream_closer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Close the internal-use stream.  ### This used to be inside of
     txn_body_fulltext_finalize_edits(), but that invoked a nested
     Berkeley DB transaction -- scandalous! */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>file_stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Need to tell fs that we're done sending text */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>,
                                 <argument><expr><name>txn_body_fulltext_finalize_edits</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>,
                                 <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_apply_text</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Call open_path with no flags, as we want this to return an error
     if the node for which we are searching doesn't exist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to see if path is locked;  if so, check that we can use it. */</comment>
  <if>if <condition>(<expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__allow_locked_operation</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now, make sure this path is mutable. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>node</name></name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>

  <comment type="block">/* Make a writable stream for replacing the file's text. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_edit_stream</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>file_stream</name></name>)</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
                                           <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a 'returnable' stream which writes to the file_stream. */</comment>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>stream</name></name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>text_stream_writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>text_stream_closer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
                     <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_apply_text</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents_p</name></decl></param>,
                <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>tb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>tb</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>result_checksum</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>result_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_apply_text</name></expr></argument>, <argument><expr><name>tb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents_p</name> = <name><name>tb</name>-&gt;<name>stream</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- End machinery for svn_fs_apply_text() ---  */</comment>


<comment type="block">/* Note: we're sharing the `things_changed_args' struct with
   svn_fs_props_changed(). */</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_contents_changed</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>things_changed_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node1</name></decl>, *<decl><type ref="prev"/><name>node2</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node1</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root1</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path1</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node2</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root2</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path2</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__things_different</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>changed_p</name></name></expr></argument>,
                                        <argument><expr><name>node1</name></expr></argument>, <argument><expr><name>node2</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Note:  it is acceptable for this function to call back into
   top-level interfaces because it does not itself use trails.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_contents_changed</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>changed_p</name></decl></param>,
                      <param><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                      <param><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>things_changed_args</name></type> <name>args</name></decl>;</decl_stmt>

  <comment type="block">/* Check that roots are in the same fs. */</comment>
  <if>if <condition>(<expr><name><name>root1</name>-&gt;<name>fs</name></name> != <name><name>root2</name>-&gt;<name>fs</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot compare file contents between two different filesystems"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check that both paths are files. */</comment>
  <block>{
    <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  }</block>

  <expr_stmt><expr><name><name>args</name>.<name>root1</name></name>      = <name>root1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root2</name></name>      = <name>root2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path1</name></name>      = <name>path1</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path2</name></name>      = <name>path2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>changed_p</name></name>  = <name>changed_p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>pool</name></name>       = <name>pool</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root1</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_contents_changed</name></expr></argument>,
                                 <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Public interface to computing file text deltas.  */</comment>

<comment type="block">/* Note:  it is acceptable for this function to call back into
   public FS API interfaces because it does not itself use trails.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_get_file_delta_stream</name><parameter_list>(<param><decl><type><name>svn_txdelta_stream_t</name> **</type><name>stream_p</name></decl></param>,
                           <param><decl><type><name>svn_fs_root_t</name> *</type><name>source_root</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
                           <param><decl><type><name>svn_fs_root_t</name> *</type><name>target_root</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>source</name></decl>, *<decl><type ref="prev"/><name>target</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_stream_t</name> *</type><name>delta_stream</name></decl>;</decl_stmt>

  <comment type="block">/* Get read functions for the source file contents.  */</comment>
  <if>if <condition>(<expr><name>source_root</name> &amp;&amp; <name>source_path</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_file_contents</name><argument_list>(<argument><expr>&amp;<name>source</name></expr></argument>, <argument><expr><name>source_root</name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>source</name> = <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* Get read functions for the target file contents.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_file_contents</name><argument_list>(<argument><expr>&amp;<name>target</name></expr></argument>, <argument><expr><name>target_root</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a delta stream that turns the ancestor into the target.  */</comment>
  <expr_stmt><expr><call><name>svn_txdelta</name><argument_list>(<argument><expr>&amp;<name>delta_stream</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>stream_p</name> = <name>delta_stream</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Finding Changes */</comment>

<struct>struct <name>paths_changed_args</name>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_paths_changed</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                       <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* WARNING: This is called *without* the protection of a Berkeley DB
     transaction.  If you modify this function, keep that in mind. */</comment>

  <decl_stmt><decl><type>struct <name>paths_changed_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>args</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the transaction ID from ROOT. */</comment>
  <if>if <condition>(<expr>! <name><name>args</name>-&gt;<name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rev_get_txn_id</name><argument_list>(<argument><expr>&amp;<name>txn_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name>-&gt;<name>rev</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>txn_id</name> = <name><name>args</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr>;</expr_stmt></else></if>

  <return>return <expr><call><name>svn_fs_bdb__changes_fetch</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>changes</name></name>)</expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_paths_changed</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>changed_paths_p</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>paths_changed_args</name></type> <name>args</name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>changes</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_paths_changed</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>changed_paths_p</name> = <name><name>args</name>.<name>changes</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Our coolio opaque history object. */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* filesystem object */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>

  <comment type="block">/* path and revision of historical location */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>

  <comment type="block">/* internal-use hints about where to resume the history search. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl>;</decl_stmt>

  <comment type="block">/* FALSE until the first call to svn_fs_history_prev(). */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl>;</decl_stmt>
}</block></struct></type> <name>base_history_data_t</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>svn_fs_history_t</name> *</type><name>assemble_history</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                          <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
                                          <param><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl></param>,
                                          <param><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_node_history</name><parameter_list>(<param><decl><type><name>svn_fs_history_t</name> **</type><name>history_p</name></decl></param>,
                  <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* We require a revision root. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_REVISION_ROOT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* And we require that the path exist in the root. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_FOUND</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Okay, all seems well.  Build our history object and return it. */</comment>
  <expr_stmt><expr>*<name>history_p</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>,
                                <argument><expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Examine the PARENT_PATH structure chain to determine how copy IDs
   would be doled out in the event that PARENT_PATH was made mutable.
   Return the ID of the copy that last affected PARENT_PATH (and the
   COPY itself, if we've already fetched it).
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>examine_copy_inheritance</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>copy_id</name></decl></param>,
                         <param><decl><type><name>copy_t</name> **</type><name>copy</name></decl></param>,
                         <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                         <param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
                         <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* The default response -- our current copy ID, and no fetched COPY. */</comment>
  <expr_stmt><expr>*<name>copy_id</name> = <call><name>svn_fs_base__id_copy_id</name>
    <argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>copy</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* If we have no parent (we are looking at the root node), or if
     this node is supposed to inherit from itself, return that fact. */</comment>
  <if>if <condition>(<expr>! <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* We could be a branch destination (which would answer our question
     altogether)!  But then, again, we might just have been modified
     in this revision, so all bets are off. */</comment>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> == <name>copy_id_inherit_self</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* A copy ID of "0" means we've never been branched.  Therefore,
         there are no copies relevant to our history. */</comment>
      <if>if <condition>(<expr>((*<name>copy_id</name>)<index>[<expr>0</expr>]</index> == '0') &amp;&amp; ((*<name>copy_id</name>)<index>[<expr>1</expr>]</index> == '\0')</expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <comment type="block">/* Get the COPY record.  If it was a real copy (not an implicit
         one), we have our answer.  Otherwise, we fall through to the
         recursive case. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_copy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr>*<name>copy_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>(*<name>copy</name>)-&gt;<name>kind</name></name> != <name>copy_kind_soft</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Otherwise, our answer is dependent upon our parent. */</comment>
  <return>return <expr><call><name>examine_copy_inheritance</name><argument_list>(<argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                  <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<struct>struct <name>history_prev_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>cross_copies</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_history_prev</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>history_prev_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history</name> <init>= <expr><name><name>args</name>-&gt;<name>prev_history_p</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name> <init>= <expr><name><name>args</name>-&gt;<name>history</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>base_history_data_t</name> *</type><name>bhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>commit_path</name></decl>, *<decl><type ref="prev"/><name>src_path</name></decl>, *<decl><type ref="prev"/><name>path</name> <init>= <expr><name><name>bhd</name>-&gt;<name>path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>commit_rev</name></decl>, <decl><type ref="prev"/><name>src_rev</name></decl>, <decl><type ref="prev"/><name>dst_rev</name></decl>, <decl><type ref="prev"/><name>revision</name> <init>= <expr><name><name>bhd</name>-&gt;<name>revision</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>retpool</name> <init>= <expr><name><name>args</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>bhd</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end_copy_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>revision_root_args</name></type> <name>rr_args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>reported</name> <init>= <expr><name><name>bhd</name>-&gt;<name>is_interesting</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>copy_t</name> *</type><name>copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retry</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Initialize our return value. */</comment>
  <expr_stmt><expr>*<name>prev_history</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* If our last history report left us hints about where to pickup
     the chase, then our last report was on the destination of a
     copy.  If we are crossing copies, start from those locations,
     otherwise, we're all done here.  */</comment>
  <if>if <condition>(<expr><name><name>bhd</name>-&gt;<name>path_hint</name></name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>bhd</name>-&gt;<name>rev_hint</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>reported</name> = <name>FALSE</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name><name>args</name>-&gt;<name>cross_copies</name></name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
      <expr_stmt><expr><name>path</name> = <name><name>bhd</name>-&gt;<name>path_hint</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>revision</name> = <name><name>bhd</name>-&gt;<name>rev_hint</name></name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Construct a ROOT for the current revision. */</comment>
  <expr_stmt><expr><name><name>rr_args</name>.<name>root_p</name></name> = &amp;<name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rr_args</name>.<name>rev</name></name> = <name>revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>txn_body_revision_root</name><argument_list>(<argument><expr>&amp;<name>rr_args</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open PATH/REVISION, and get its node and a bunch of other
     goodies.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rev_get_txn_id</name><argument_list>(<argument><expr>&amp;<name>txn_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                      <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>node</name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>commit_path</name> = <call><name>svn_fs_base__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>commit_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The Subversion filesystem is written in such a way that a given
     line of history may have at most one interesting history point
     per filesystem revision.  Either that node was edited (and
     possibly copied), or it was copied but not edited.  And a copy
     source cannot be from the same revision as its destination.  So,
     if our history revision matches its node's commit revision, we
     know that ... */</comment>
  <if>if <condition>(<expr><name>revision</name> == <name>commit_rev</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name>reported</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ... we either have not yet reported on this revision (and
             need now to do so) ... */</comment>
          <expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,
                                           <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>commit_path</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>commit_rev</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* ... or we *have* reported on this revision, and must now
             progress toward this node's predecessor (unless there is
             no predecessor, in which case we're all done!). */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                                      <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name>pred_id</name></expr>)</condition><then>
            <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

          <comment type="block">/* Replace NODE and friends with the information from its
             predecessor. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pred_id</name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>commit_path</name> = <call><name>svn_fs_base__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>commit_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                                <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* Calculate a possibly relevant copy ID. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>examine_copy_inheritance</name><argument_list>(<argument><expr>&amp;<name>end_copy_id</name></expr></argument>, <argument><expr>&amp;<name>copy</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                   <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize some state variables. */</comment>
  <expr_stmt><expr><name>src_path</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>src_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>dst_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* If our current copy ID (which is either the real copy ID of our
     node, or the last copy ID which would affect our node if it were
     to be made mutable) diffs at all from that of its predecessor
     (which is either a real predecessor, or is the node itself
     playing the predecessor role to an imaginary mutable successor),
     then we need to report a copy.  */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__key_compare</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>end_copy_id</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>remainder</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>dst_node</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_dst</name></decl>;</decl_stmt>

      <comment type="block">/* Get the COPY record if we haven't already fetched it. */</comment>
      <if>if <condition>(<expr>! <name>copy</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_copy</name><argument_list>(<argument><expr>&amp;<name>copy</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>end_copy_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                     <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Figure out the destination path of the copy operation. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>dst_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                        <argument><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>copy_dst</name> = <call><name>svn_fs_base__dag_get_created_path</name><argument_list>(<argument><expr><name>dst_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If our current path was the very destination of the copy,
         then our new current path will be the copy source.  If our
         current path was instead the *child* of the destination of
         the copy, then figure out its previous location by taking its
         path relative to the copy destination and appending that to
         the copy source.  Finally, if our current path doesn't meet
         one of these other criteria ... ### for now just fallback to
         the old copy hunt algorithm. */</comment>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>copy_dst</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>remainder</name> = ""</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>remainder</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>copy_dst</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <if>if <condition>(<expr><name>remainder</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If we get here, then our current path is the destination
             of, or the child of the destination of, a copy.  Fill
             in the return values and get outta here.  */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__txn_get_revision</name>
                  <argument_list>(<argument><expr>&amp;<name>src_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>copy</name>-&gt;<name>src_txn_id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__txn_get_revision</name>
                  <argument_list>(<argument><expr>&amp;<name>dst_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                   <argument><expr><call><name>svn_fs_base__id_txn_id</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>src_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>src_path</name></name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>,
                                   <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>copy</name>-&gt;<name>kind</name></name> == <name>copy_kind_soft</name></expr>)</condition><then>
            <expr_stmt><expr><name>retry</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* If we calculated a copy source path and revision, and the
     copy source revision doesn't pre-date a revision in which we
     *know* our node was modified, we'll make a 'copy-style' history
     object. */</comment>
  <if>if <condition>(<expr><name>src_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>src_rev</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>src_rev</name> &gt;= <name>commit_rev</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* It's possible for us to find a copy location that is the same
         as the history point we've just reported.  If that happens,
         we simply need to take another trip through this history
         search. */</comment>
      <if>if <condition>(<expr>(<name>dst_rev</name> == <name>revision</name>) &amp;&amp; <name>reported</name></expr>)</condition><then>
        <expr_stmt><expr><name>retry</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

      <expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>dst_rev</name></expr></argument>, <argument><expr><name>retry</name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>,
                                       <argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>src_rev</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>commit_path</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>commit_rev</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_history_prev</name><parameter_list>(<param><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history_p</name></decl></param>,
                  <param><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>cross_copies</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>prev_history</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>base_history_data_t</name> *</type><name>bhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>bhd</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Special case: the root directory changes in every single
     revision, no exceptions.  And, the root can't be the target (or
     child of a target -- duh) of a copy.  So, if that's our path,
     then we need only decrement our revision by 1, and there you go. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>bhd</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name><name>bhd</name>-&gt;<name>is_interesting</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>bhd</name>-&gt;<name>revision</name></name></expr></argument>,
                                        <argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><name><name>bhd</name>-&gt;<name>revision</name></name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>bhd</name>-&gt;<name>revision</name></name> - 1</expr></argument>,
                                        <argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type>struct <name>history_prev_args</name></type> <name>args</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>prev_history</name> = <name>history</name></expr>;</expr_stmt>

      <while>while <condition>(<expr>1</expr>)</condition>
        <block>{
          <comment type="block">/* Get a trail, and get to work. */</comment>

          <expr_stmt><expr><name><name>args</name>.<name>prev_history_p</name></name> = &amp;<name>prev_history</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>args</name>.<name>history</name></name> = <name>prev_history</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>args</name>.<name>cross_copies</name></name> = <name>cross_copies</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>args</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_history_prev</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name>prev_history</name></expr>)</condition><then>
            <break>break;</break></then></if>
          <expr_stmt><expr><name>bhd</name> = <name><name>prev_history</name>-&gt;<name>fsap_data</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>bhd</name>-&gt;<name>is_interesting</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
        }</block></while>
    }</block></else></if>

  <expr_stmt><expr>*<name>prev_history_p</name> = <name>prev_history</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_history_location</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
                      <param><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>base_history_data_t</name> *</type><name>bhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>bhd</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>revision</name> = <name><name>bhd</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>history_vtable_t</name></type> <name>history_vtable</name> <init>= <expr><block>{
  <expr><name>base_history_prev</name></expr>,
  <expr><name>base_history_location</name></expr>
}</block></expr></init></decl>;</decl_stmt>



<struct>struct <name>closest_copy_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_closest_copy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>closest_copy_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><name><name>args</name>-&gt;<name>root</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><name><name>args</name>-&gt;<name>path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>, *<decl><type ref="prev"/><name>copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>copy_t</name> *</type><name>copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copy_dst_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>path_node_in_copy_dst</name></decl>, *<decl><type ref="prev"/><name>copy_dst_node</name></decl>, *<decl><type ref="prev"/><name>copy_dst_root_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_dst_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copy_dst_rev</name></decl>, <decl><type ref="prev"/><name>created_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr>*(<name><name>args</name>-&gt;<name>path_p</name></name>) = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr>*(<name><name>args</name>-&gt;<name>root_p</name></name>) = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Get the transaction ID associated with our root. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>txn_id</name> = <name><name>root</name>-&gt;<name>txn</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rev_get_txn_id</name><argument_list>(<argument><expr>&amp;<name>txn_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* Open PATH in ROOT -- it must exist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, examine the copy inheritance rules in play should our path
     be made mutable in the future (if it isn't already).  This will
     tell us about the youngest affecting copy.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>examine_copy_inheritance</name><argument_list>(<argument><expr>&amp;<name>copy_id</name></expr></argument>, <argument><expr>&amp;<name>copy</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>,
                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Easy out:  if the copy ID is 0, there's nothing of interest here. */</comment>
  <if>if <condition>(<expr>((<name>copy_id</name>)<index>[<expr>0</expr>]</index> == '0') &amp;&amp; ((<name>copy_id</name>)<index>[<expr>1</expr>]</index> == '\0')</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Fetch our copy if examine_copy_inheritance() didn't do it for us. */</comment>
  <if>if <condition>(<expr>! <name>copy</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_copy</name><argument_list>(<argument><expr>&amp;<name>copy</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Figure out the destination path and revision of the copy operation. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>copy_dst_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name></expr></argument>,
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>copy_dst_path</name> = <call><name>svn_fs_base__dag_get_created_path</name><argument_list>(<argument><expr><name>copy_dst_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>copy_dst_rev</name></expr></argument>, <argument><expr><name>copy_dst_node</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Turn that revision into a revision root. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_revision_root</name><argument_list>(<argument><expr>&amp;<name>copy_dst_root_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                         <argument><expr><name>copy_dst_rev</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>copy_dst_root</name> = <call><name>make_revision_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copy_dst_rev</name></expr></argument>,
                                     <argument><expr><name>copy_dst_root_node</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It is possible that this node was created from scratch at some
     revision between COPY_DST_REV and the transaction associated with
     our ROOT.  Make sure that PATH exists as of COPY_DST_REV and is
     related to this node-rev. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>path_node_in_copy_dst</name></expr></argument>, <argument><expr><name>copy_dst_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>(<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>)
          || (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_DIRECTORY</name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>
  <if>if <condition>(<expr>(<call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>path_node_in_copy_dst</name></expr></argument>)</argument_list></call> == <name>svn_node_none</name>)
      || (! (<call><name>svn_fs_base__id_check_related</name>
             <argument_list>(<argument><expr><name>node_id</name></expr></argument>, <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>path_node_in_copy_dst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>))</expr>)</condition><then>
    <block>{
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* One final check must be done here.  If you copy a directory and
     create a new entity somewhere beneath that directory in the same
     txn, then we can't claim that the copy affected the new entity.
     For example, if you do:

        copy dir1 dir2
        create dir2/new-thing
        commit

     then dir2/new-thing was not affected by the copy of dir1 to dir2.
     We detect this situation by asking if PATH@COPY_DST_REV's
     created-rev is COPY_DST_REV, and that node-revision has no
     predecessors, then there is no relevant closest copy.
  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>created_rev</name></expr></argument>, <argument><expr><name>path_node_in_copy_dst</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>created_rev</name> == <name>copy_dst_rev</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>,
                                                  <argument><expr><name>path_node_in_copy_dst</name></expr></argument>,
                                                  <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>pred_id</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
    }</block></then></if>

  <expr_stmt><expr>*(<name><name>args</name>-&gt;<name>path_p</name></name>) = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>copy_dst_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*(<name><name>args</name>-&gt;<name>root_p</name></name>) = <name>copy_dst_root</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_closest_copy</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
                  <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>closest_copy_args</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>closest_root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>closest_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>args</name>.<name>root_p</name></name> = &amp;<name>closest_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path_p</name></name> = &amp;<name>closest_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_closest_copy</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>root_p</name> = <name>closest_root</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>path_p</name> = <name>closest_path</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Return a new history object (marked as "interesting") for PATH and
   REVISION, allocated in POOL, and with its members set to the values
   of the parameters provided.  Note that PATH and PATH_HINT are not
   duped into POOL -- it is the responsibility of the caller to ensure
   that this happens. */</comment>
<function><type><specifier>static</specifier> <name>svn_fs_history_t</name> *</type>
<name>assemble_history</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>history</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>base_history_data_t</name> *</type><name>bhd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>bhd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>bhd</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bhd</name>-&gt;<name>revision</name></name> = <name>revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bhd</name>-&gt;<name>is_interesting</name></name> = <name>is_interesting</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bhd</name>-&gt;<name>path_hint</name></name> = <name>path_hint</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bhd</name>-&gt;<name>rev_hint</name></name> = <name>rev_hint</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bhd</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>history</name>-&gt;<name>vtable</name></name> = &amp;<name>history_vtable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>history</name>-&gt;<name>fsap_data</name></name> = <name>bhd</name></expr>;</expr_stmt>
  <return>return <expr><name>history</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__get_path_kind</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                           <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>head_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl>, *<decl><type ref="prev"/><name>path_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Get HEAD revision, */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>head_rev</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Then convert it into a root_t, */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_revision_root</name><argument_list>(<argument><expr>&amp;<name>root_dir</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>head_rev</name></expr></argument>,
                                         <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>root</name> = <call><name>make_revision_root</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>head_rev</name></expr></argument>, <argument><expr><name>root_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* And get the dag_node for path in the root_t. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>path_node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>kind</name> = <name>svn_node_none</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>

  <expr_stmt><expr>*<name>kind</name> = <call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>path_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__get_path_created_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                  <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>head_rev</name></decl>, <decl><type ref="prev"/><name>created_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl>, *<decl><type ref="prev"/><name>path_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Get HEAD revision, */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>head_rev</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Then convert it into a root_t, */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_revision_root</name><argument_list>(<argument><expr>&amp;<name>root_dir</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>head_rev</name></expr></argument>,
                                         <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>root</name> = <call><name>make_revision_root</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>head_rev</name></expr></argument>, <argument><expr><name>root_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* And get the dag_node for path in the root_t. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>path_node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>

  <comment type="block">/* Find the created_rev of the dag_node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>created_rev</name></expr></argument>, <argument><expr><name>path_node</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>rev</name> = <name>created_rev</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Finding the Origin of a Line of History ***/</comment>

<comment type="block">/* Set *PREV_PATH and *PREV_REV to the path and revision which
   represent the location at which PATH in FS was located immediately
   prior to REVISION iff there was a copy operation (to PATH or one of
   its parent directories) between that previous location and
   PATH@REVISION.

   If there was no such copy operation in that portion of PATH's
   history, set *PREV_PATH to NULL and *PREV_REV to SVN_INVALID_REVNUM.

   WARNING:  Do *not* call this from inside a trail. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prev_location</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>prev_path</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name> *</type><name>prev_rev</name></decl></param>,
              <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
              <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_path</name></decl>, *<decl><type ref="prev"/><name>copy_src_path</name></decl>, *<decl><type ref="prev"/><name>remainder</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copy_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copy_src_rev</name></decl>;</decl_stmt>

  <comment type="block">/* Ask about the most recent copy which affected PATH@REVISION.  If
     there was no such copy, we're done.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_closest_copy</name><argument_list>(<argument><expr>&amp;<name>copy_root</name></expr></argument>, <argument><expr>&amp;<name>copy_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>copy_root</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>prev_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>prev_path</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Ultimately, it's not the path of the closest copy's source that
     we care about -- it's our own path's location in the copy source
     revision.  So we'll tack the relative path that expresses the
     difference between the copy destination and our path in the copy
     revision onto the copy source path to determine this information.

     In other words, if our path is "/branches/my-branch/foo/bar", and
     we know that the closest relevant copy was a copy of "/trunk" to
     "/branches/my-branch", then that relative path under the copy
     destination is "/foo/bar".  Tacking that onto the copy source
     path tells us that our path was located at "/trunk/foo/bar"
     before the copy.
  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_copied_from</name><argument_list>(<argument><expr>&amp;<name>copy_src_rev</name></expr></argument>, <argument><expr>&amp;<name>copy_src_path</name></expr></argument>,
                           <argument><expr><name>copy_root</name></expr></argument>, <argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <expr_stmt><expr><name>remainder</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr>*<name>prev_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>copy_src_path</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>prev_rev</name> = <name>copy_src_rev</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>id_created_rev_args</name> <block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_id_created_rev</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>id_created_rev_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>id</name></name></expr></argument>, 
                                    <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_revision</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>revision</name></name>)</expr></argument>, <argument><expr><name>node</name></expr></argument>, 
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>get_set_node_origin_args</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>origin_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_get_node_origin</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_set_node_origin_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>svn_fs_bdb__get_node_origin</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>origin_id</name></name>)</expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, 
                                     <argument><expr><name><name>args</name>-&gt;<name>node_id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_set_node_origin</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_set_node_origin_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>svn_fs_bdb__set_node_origin</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>node_id</name></name></expr></argument>, 
                                     <argument><expr><name><name>args</name>-&gt;<name>origin_id</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_node_origin_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
                     <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>get_set_node_origin_args</name></type> <name>args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>, *<decl><type ref="prev"/><name>origin_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>id_created_rev_args</name></type> <name>icr_args</name></decl>;</decl_stmt>

  <comment type="block">/* Verify that our filesystem version supports node origins stuff. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__test_required_feature_format</name>
          <argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>"node-origins"</expr></argument>, <argument><expr><name>SVN_FS_BASE__MIN_NODE_ORIGINS_FORMAT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_node_id</name><argument_list>(<argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>args</name>.<name>node_id</name></name> = <call><name>svn_fs_base__id_node_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_get_node_origin</name></expr></argument>, 
                               <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we got a value for the origin node-revision-ID, that's great.
     If we didn't, that's sad but non-fatal -- we'll just figure it
     out the hard way, then record it so we don't have suffer again
     the next time. */</comment>
  <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>origin_id</name> = <name><name>args</name>.<name>origin_id</name></name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NO_SUCH_NODE_ORIGIN</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>curroot</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>lastpath</name> <init>= 
        <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>lastrev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt>
      
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>

      <comment type="block">/* Walk the closest-copy chain back to the first copy in our history.
         
         NOTE: We merely *assume* that this is faster than walking the
         predecessor chain, because we *assume* that copies of parent
         directories happen less often than modifications to a given item. */</comment>
      <while>while <condition>(<expr>1</expr>)</condition>
        <block>{
          <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>currev</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>curpath</name> <init>= <expr><name><name>lastpath</name>-&gt;<name>data</name></name></expr></init></decl>;</decl_stmt>
          
          <comment type="block">/* Get a root pointing to LASTREV.  (The first time around,
             LASTREV is invalid, but that's cool because CURROOT is
             already initialized.)  */</comment>
          <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>lastrev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__revision_root</name><argument_list>(<argument><expr>&amp;<name>curroot</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, 
                                               <argument><expr><name>lastrev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* Find the previous location using the closest-copy shortcut. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prev_location</name><argument_list>(<argument><expr>&amp;<name>curpath</name></expr></argument>, <argument><expr>&amp;<name>currev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>curroot</name></expr></argument>, 
                                <argument><expr><name>curpath</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name>curpath</name></expr>)</condition><then>
            <break>break;</break></then></if>

          <comment type="block">/* Update our LASTPATH and LASTREV variables (which survive 
             SUBPOOL). */</comment>
          <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>lastpath</name></expr></argument>, <argument><expr><name>curpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

      <comment type="block">/* Walk the predecessor links back to origin. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>base_node_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>curroot</name></expr></argument>, <argument><expr><name><name>lastpath</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while <condition>(<expr>1</expr>)</condition>
        <block>{
          <decl_stmt><decl><type>struct <name>txn_pred_id_args</name></type> <name>pid_args</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pid_args</name>.<name>id</name></name> = <name>pred_id</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pid_args</name>.<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_pred_id</name></expr></argument>, 
                                         <argument><expr>&amp;<name>pid_args</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name><name>pid_args</name>.<name>pred_id</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
          <expr_stmt><expr><name>pred_id</name> = <name><name>pid_args</name>.<name>pred_id</name></name></expr>;</expr_stmt>
        }</block></while>
      
      <comment type="block">/* Okay.  PRED_ID should hold our origin ID now.  Let's remember
         this value from now on, shall we?  */</comment>
      <expr_stmt><expr><name><name>args</name>.<name>origin_id</name></name> = <name>origin_id</name> = <call><name>svn_fs_base__id_copy</name><argument_list>(<argument><expr><name>pred_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_set_node_origin</name></expr></argument>, 
                                      <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <return>return <expr><name>err</name></expr>;</return>
    }</block></else></if></else></if>

  <comment type="block">/* Okay.  We have an origin node-revision-ID.  Let's get a created
     revision from it. */</comment>
  <expr_stmt><expr><name><name>icr_args</name>.<name>id</name></name> = <name>origin_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_body_id_created_rev</name></expr></argument>, 
                                 <argument><expr>&amp;<name>icr_args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>revision</name> = <name><name>icr_args</name>.<name>revision</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Mergeinfo Queries */</comment>

<comment type="block">/* Examine directory NODE's immediately children for mergeinfo.  

   For those which have explicit mergeinfo, add their mergeinfo to
   RESULT_CATALOG (allocated in RESULT_CATALOG's pool).  

   For those which don't, but sit atop trees which contain mergeinfo
   somewhere deeper, add them to *CHILDREN_ATOP_MERGEINFO_TREES, a
   hash mapping dirent names to dag_node_t * objects, allocated
   from that hash's pool.

   For those which neither have explicit mergeinfo nor sit atop trees
   which contain mergeinfo, ignore them.

   Use TRAIL-&gt;pool for temporary allocations. */</comment>

<struct>struct <name>get_mergeinfo_data_and_entries_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>children_atop_mergeinfo_trees</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_path</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_get_mergeinfo_data_and_entries</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_mergeinfo_data_and_entries_baton</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name> <init>= <expr><name><name>args</name>-&gt;<name>node</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>result_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>result_catalog</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>children_pool</name> <init>= 
    <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>children_atop_mergeinfo_trees</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> == <name>svn_node_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>child_id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>child_node</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>kid_count</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>child_id</name> = <name><name>dirent</name>-&gt;<name>id</name></name></expr>;</expr_stmt>

      <comment type="block">/* Get the node for this child. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>child_node</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>child_id</name></expr></argument>, 
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Query the child node's mergeinfo stats. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr>&amp;<name>has_mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>kid_count</name></expr></argument>,
                                                   <argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, 
                                                   <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If the child has mergeinfo, add it to the result catalog. */</comment>
      <if>if <condition>(<expr><name>has_mergeinfo</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>plist</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>child_mergeinfo</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>pval</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>plist</name></expr></argument>, <argument><expr><name>child_node</name></expr></argument>, 
                                                <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>pval</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>plist</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name>pval</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= <expr><call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>, 
                                                             <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Node-revision '%s' claims to have "
                                         "mergeinfo but doesn't"</expr></argument>)</argument_list></call></expr></argument>, 
                                       <argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>child_mergeinfo</name></expr></argument>, <argument><expr><name><name>pval</name>-&gt;<name>data</name></name></expr></argument>, 
                                      <argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>result_catalog</name></name></expr></argument>, 
                       <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>node_path</name></name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>name</name></name></expr></argument>, 
                                     <argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                       <argument><expr><name>child_mergeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* If the child has descendants with mergeinfo -- that is, if
         the count of descendants beneath it carrying mergeinfo, not
         including itself, is non-zero -- then add it to the
         children_atop_mergeinfo_trees hash to be crawled later. */</comment>
      <if>if <condition>(<expr>(<name>kid_count</name> - (<name>has_mergeinfo</name> ? 1 : 0)) &gt; 0</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= <expr><call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>, 
                                                             <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Node-revision '%s' claims to sit "
                                         "atop a tree containing mergeinfo "
                                         "but is not a directory"</expr></argument>)</argument_list></call></expr></argument>, 
                                       <argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>children_atop_mergeinfo_trees</name></name></expr></argument>, 
                       <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>children_pool</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, 
                       <argument><expr><call><name>svn_fs_base__dag_dup</name><argument_list>(<argument><expr><name>child_node</name></expr></argument>, <argument><expr><name>children_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>crawl_directory_for_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                              <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_path</name></decl></param>,
                              <param><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_mergeinfo_data_and_entries_baton</name></type> <name>gmdae_args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>children_atop_mergeinfo_trees</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <comment type="block">/* Add mergeinfo for immediate children that have it, and fetch
     immediate children that *don't* have it but sit atop trees that do. */</comment>
  <expr_stmt><expr><name><name>gmdae_args</name>.<name>result_catalog</name></name> = <name>result_catalog</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gmdae_args</name>.<name>children_atop_mergeinfo_trees</name></name> = <name>children_atop_mergeinfo_trees</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gmdae_args</name>.<name>node</name></name> = <name>node</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>gmdae_args</name>.<name>node_path</name></name> = <name>node_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_get_mergeinfo_data_and_entries</name></expr></argument>,
                                 <argument><expr>&amp;<name>gmdae_args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If no children sit atop trees with mergeinfo, we're done.
     Otherwise, recurse on those children. */</comment>

  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>children_atop_mergeinfo_trees</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>children_atop_mergeinfo_trees</name></expr></argument>)</argument_list></call></expr>;</init> 
       <condition><expr><name>hi</name></expr>;</condition> 
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>crawl_directory_for_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, 
                                    <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>node_path</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>result_catalog</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper for get_mergeinfo_for_path() that will append REL_PATH
   (which may contain slashes) to each path that exists in the
   mergeinfo INPUT, and return a new mergeinfo in *OUTPUT.  Deep
   copies the values.  Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>append_to_merged_froms</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_t</name> *</type><name>output</name></decl></param>,
                       <param><decl><type><name>svn_mergeinfo_t</name></type> <name>input</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel_path</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>output</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>output</name></expr></argument>, <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, 
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><call><name>svn_rangelist_dup</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Calculate the mergeinfo for PATH under revision ROOT using
   inheritance type INHERIT.  Set *MERGEINFO to the mergeinfo, or to
   NULL if there is none.  Results are allocated in POOL; TRAIL-&gt;pool
   is used for temporary allocations.  */</comment>

<struct>struct <name>get_mergeinfo_for_path_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name> *</type><name>mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_get_mergeinfo_for_path</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_mergeinfo_for_path_baton</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>, *<decl><type ref="prev"/><name>nearest_ancestor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mergeinfo_string</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*(<name><name>args</name>-&gt;<name>mergeinfo</name></name>) = <name>NULL</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, 
                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Init the nearest ancestor. */</comment>
  <expr_stmt><expr><name>nearest_ancestor</name> = <name>parent_path</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>args</name>-&gt;<name>inherit</name></name> == <name>svn_mergeinfo_nearest_ancestor</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
      <expr_stmt><expr><name>nearest_ancestor</name> = <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>count</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>node</name> = <name><name>nearest_ancestor</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr>&amp;<name>has_mergeinfo</name></expr></argument>, <argument><expr>&amp;<name>count</name></expr></argument>,
                                                   <argument><expr><name>node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>has_mergeinfo</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="block">/* No need to loop if we're looking for explicit mergeinfo. */</comment>
      <if>if <condition>(<expr><name><name>args</name>-&gt;<name>inherit</name></name> == <name>svn_mergeinfo_explicit</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      
      <expr_stmt><expr><name>nearest_ancestor</name> = <name><name>nearest_ancestor</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>

      <comment type="block">/* Run out?  There's no mergeinfo. */</comment>
      <if>if <condition>(<expr>! <name>nearest_ancestor</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></while>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mergeinfo_string</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>,
                                  <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>mergeinfo_string</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= 
        <expr><call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Node-revision '%s' claims to have "
                                 "mergeinfo but doesn't"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* If our nearest ancestor is the very path we inquired about, we
     can return the mergeinfo results directly.  Otherwise, we're
     inheriting the mergeinfo, so we need to a) remove non-inheritable
     ranges and b) telescope the merged-from paths.  */</comment>
  <if>if <condition>(<expr><name>nearest_ancestor</name> == <name>parent_path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>mergeinfo</name></name></expr></argument>, 
                                  <argument><expr><name><name>mergeinfo_string</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>tmp_mergeinfo</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>tmp_mergeinfo</name></expr></argument>,
                                  <argument><expr><name><name>mergeinfo_string</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_inheritable</name><argument_list>(<argument><expr>&amp;<name>tmp_mergeinfo</name></expr></argument>,
                                        <argument><expr><name>tmp_mergeinfo</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                        <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>append_to_merged_froms</name><argument_list>(<argument><expr><name><name>args</name>-&gt;<name>mergeinfo</name></name></expr></argument>,
                                     <argument><expr><name>tmp_mergeinfo</name></expr></argument>,
                                     <argument><expr><call><name>parent_path_relpath</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>,
                                                         <argument><expr><name>nearest_ancestor</name></expr></argument>,
                                                         <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name><name>args</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Set **NODE to the dag node for PATH in ROOT (allocated in POOL),
   and query its mergeinfo stats, setting HAS_MERGEINFO and
   CHILD_MERGEINFO_COUNT appropriately. */</comment>

<struct>struct <name>get_node_mergeinfo_stats_baton</name>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>child_mergeinfo_count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_get_node_mergeinfo_stats</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_node_mergeinfo_stats_baton</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>node</name></name>)</expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>args</name>-&gt;<name>path</name></name></expr></argument>, 
                  <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_mergeinfo_stats</name><argument_list>(<argument><expr>&amp;(<name><name>args</name>-&gt;<name>has_mergeinfo</name></name>)</expr></argument>, 
                                               <argument><expr>&amp;(<name><name>args</name>-&gt;<name>child_mergeinfo_count</name></name>)</expr></argument>,
                                               <argument><expr><name><name>args</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, 
                                               <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Get the mergeinfo for a set of paths, returned in
   *MERGEINFO_CATALOG.  Returned values are allocated in POOL, while
   temporary values are allocated in a sub-pool. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_mergeinfos_for_paths</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                         <param><decl><type><name>svn_mergeinfo_catalog_t</name> *</type><name>mergeinfo_catalog</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>paths</name></decl></param>,
                         <param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>include_descendants</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>paths</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>path_mergeinfo</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>get_mergeinfo_for_path_baton</name></type> <name>gmfp_args</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>path</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the mergeinfo for PATH itself. */</comment>
      <expr_stmt><expr><name><name>gmfp_args</name>.<name>mergeinfo</name></name> = &amp;<name>path_mergeinfo</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>gmfp_args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>gmfp_args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>gmfp_args</name>.<name>inherit</name></name> = <name>inherit</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>gmfp_args</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, 
                                     <argument><expr><name>txn_body_get_mergeinfo_for_path</name></expr></argument>,
                                     <argument><expr>&amp;<name>gmfp_args</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>path_mergeinfo</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>result_catalog</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                     <argument><expr><name>path_mergeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* If we're including descendants, do so. */</comment>
      <if>if <condition>(<expr><name>include_descendants</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>do_crawl</name></decl>;</decl_stmt>
          <decl_stmt><decl><type>struct <name>get_node_mergeinfo_stats_baton</name></type> <name>gnms_args</name></decl>;</decl_stmt>

          <comment type="block">/* Query the node and its mergeinfo stats. */</comment>
          <expr_stmt><expr><name><name>gnms_args</name>.<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>gnms_args</name>.<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, 
                                         <argument><expr><name>txn_body_get_node_mergeinfo_stats</name></expr></argument>,
                                         <argument><expr>&amp;<name>gnms_args</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Determine if there's anything worth crawling here. */</comment>
          <if>if <condition>(<expr><call><name>svn_fs_base__dag_node_kind</name><argument_list>(<argument><expr><name><name>gnms_args</name>.<name>node</name></name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name></expr>)</condition><then>
            <expr_stmt><expr><name>do_crawl</name> = <name>FALSE</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>do_crawl</name> = ((<name><name>gnms_args</name>.<name>child_mergeinfo_count</name></name> &gt; 1)
                        || ((<name><name>gnms_args</name>.<name>child_mergeinfo_count</name></name> == 1)
                            &amp;&amp; (! <name><name>gnms_args</name>.<name>has_mergeinfo</name></name>)))</expr>;</expr_stmt></else></if>

          <comment type="block">/* If it's worth crawling, crawl. */</comment>
          <if>if <condition>(<expr><name>do_crawl</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>crawl_directory_for_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>gnms_args</name>.<name>node</name></name></expr></argument>,
                                                  <argument><expr><name>path</name></expr></argument>, <argument><expr><name>result_catalog</name></expr></argument>, 
                                                  <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>mergeinfo_catalog</name> = <name>result_catalog</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Implements svn_fs_get_mergeinfo. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>base_get_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_catalog_t</name> *</type><name>catalog</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>paths</name></decl></param>,
                   <param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>include_descendants</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Verify that our filesystem version supports mergeinfo stuff. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__test_required_feature_format</name>
          <argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>"mergeinfo"</expr></argument>, <argument><expr><name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We require a revision root. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_REVISION_ROOT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Retrieve a path -&gt; mergeinfo mapping. */</comment>
  <return>return <expr><call><name>get_mergeinfos_for_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>paths</name></expr></argument>,
                                  <argument><expr><name>inherit</name></expr></argument>, <argument><expr><name>include_descendants</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* Creating root objects.  */</comment>


<decl_stmt><decl><type><specifier>static</specifier> <name>root_vtable_t</name></type> <name>root_vtable</name> <init>= <expr><block>{
  <expr><name>base_paths_changed</name></expr>,
  <expr><name>base_check_path</name></expr>,
  <expr><name>base_node_history</name></expr>,
  <expr><name>base_node_id</name></expr>,
  <expr><name>base_node_created_rev</name></expr>,
  <expr><name>base_node_origin_rev</name></expr>,
  <expr><name>base_node_created_path</name></expr>,
  <expr><name>base_delete_node</name></expr>,
  <expr><name>base_copied_from</name></expr>,
  <expr><name>base_closest_copy</name></expr>,
  <expr><name>base_node_prop</name></expr>,
  <expr><name>base_node_proplist</name></expr>,
  <expr><name>base_change_node_prop</name></expr>,
  <expr><name>base_props_changed</name></expr>,
  <expr><name>base_dir_entries</name></expr>,
  <expr><name>base_make_dir</name></expr>,
  <expr><name>base_copy</name></expr>,
  <expr><name>base_revision_link</name></expr>,
  <expr><name>base_file_length</name></expr>,
  <expr><name>base_file_md5_checksum</name></expr>,
  <expr><name>base_file_contents</name></expr>,
  <expr><name>base_make_file</name></expr>,
  <expr><name>base_apply_textdelta</name></expr>,
  <expr><name>base_apply_text</name></expr>,
  <expr><name>base_contents_changed</name></expr>,
  <expr><name>base_get_file_delta_stream</name></expr>,
  <expr><name>base_merge</name></expr>,
  <expr><name>base_get_mergeinfo</name></expr>,
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Construct a new root object in FS, allocated from POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* We create a subpool for each root object to allow us to implement
     svn_fs_close_root.  */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>root</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>base_root_data_t</name> *</type><name>brd</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>brd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>root</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>

  <comment type="block">/* Init the node ID cache. */</comment>
  <expr_stmt><expr><name><name>brd</name>-&gt;<name>node_cache</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>brd</name>-&gt;<name>node_cache_idx</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>vtable</name></name> = &amp;<name>root_vtable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>fsap_data</name></name> = <name>brd</name></expr>;</expr_stmt>

  <return>return <expr><name>root</name></expr>;</return>
}</block></function>


<comment type="block">/* Construct a root object referring to the root of REVISION in FS,
   whose root directory is ROOT_DIR.  Create the new root in POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                   <param><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>make_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>base_root_data_t</name> *</type><name>brd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>root</name>-&gt;<name>is_txn_root</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>rev</name></name> = <name>rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>brd</name>-&gt;<name>root_dir</name></name> = <name>root_dir</name></expr>;</expr_stmt>

  <return>return <expr><name>root</name></expr>;</return>
}</block></function>


<comment type="block">/* Construct a root object referring to the root of the transaction
   named TXN and based on revision BASE_REV in FS.  FLAGS represents
   the behavior of the transaction.  Create the new root in POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>base_rev</name></decl></param>,
              <param><decl><type><name>apr_uint32_t</name></type> <name>flags</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>make_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>is_txn_root</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>txn</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>txn_flags</name></name> = <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>rev</name></name> = <name>base_rev</name></expr>;</expr_stmt>

  <return>return <expr><name>root</name></expr>;</return>
}</block></function>
</unit>
