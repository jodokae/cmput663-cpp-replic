<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_base/bdb/dbt.h"><comment type="block">/* dbt.h --- interface to DBT-frobbing functions
 *
 * ====================================================================
 * Copyright (c) 2000-2004 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SVN_LIBSVN_FS_DBT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LIBSVN_FS_DBT_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APU_WANT_DB</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apu_want.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/skel.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<escape char="0xc"/>
<comment type="block">/* Set all fields of DBT to zero.  Return DBT.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__clear_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Set DBT to retrieve no data.  This is useful when you're just
   probing the table to see if an entry exists, or to find a key, but
   don't care what the value is.  Return DBT.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__nodata_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Set DBT to refer to the SIZE bytes at DATA.  Return DBT.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__set_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><name>u_int32_t</name></type> <name>size</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Prepare DBT to hold data returned from Berkeley DB.  Return DBT.

   Clear all its fields to zero, but set the DB_DBT_MALLOC flag,
   requesting that Berkeley DB place the returned data in a freshly
   malloc'd block.  If the database operation succeeds, the caller
   then owns the data block, and is responsible for making sure it
   gets freed.

   You can use this with svn_fs_base__track_dbt:

       svn_fs_base__result_dbt (&amp;foo);
       ... some Berkeley DB operation that puts data in foo ...
       svn_fs_base__track_dbt (&amp;foo, pool);

   This arrangement is:
   - thread-safe --- the returned data is allocated via malloc, and
     won't be overwritten if some other thread performs an operation
     on the same table.  See the explanation of ``Retrieved key/data
     permanence'' in the section of the Berkeley DB manual on the DBT
     type.
   - pool-friendly --- the data returned by Berkeley DB is now guaranteed
     to be freed when POOL is cleared.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__result_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Arrange for POOL to `track' DBT's data: when POOL is cleared,
   DBT-&gt;data will be freed, using `free'.  If DBT-&gt;data is zero,
   do nothing.

   This is meant for use with svn_fs_base__result_dbt; see the explanation
   there.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__track_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Prepare DBT for use as a key into a RECNO table.  This call makes
   DBT refer to the db_recno_t pointed to by RECNO as its buffer; the
   record number you assign to *RECNO will be the table key.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__recno_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><name>db_recno_t</name> *</type><name>recno</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Compare two DBT values in byte-by-byte lexicographic order.  */</comment>
<function_decl><type><name>int</name></type> <name>svn_fs_base__compare_dbt</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>DBT</name> *</type><name>a</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>DBT</name> *</type><name>b</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Set DBT to the unparsed form of ID; allocate memory from POOL.
   Return DBT.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__id_to_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Set DBT to the unparsed form of SKEL; allocate memory from POOL.
   Return DBT.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__skel_to_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Set DBT to the text of the null-terminated string STR.  DBT will
   refer to STR's storage.  Return DBT.  */</comment>
<function_decl><type><name>DBT</name> *</type><name>svn_fs_base__str_to_dbt</name><parameter_list>(<param><decl><type><name>DBT</name> *</type><name>dbt</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_LIBSVN_FS_DBT_H */</comment>
</unit>
