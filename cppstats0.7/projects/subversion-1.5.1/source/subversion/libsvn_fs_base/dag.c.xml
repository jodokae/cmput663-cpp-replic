<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_base/dag.c"><comment type="block">/* dag.c : DAG-like interface filesystem, private to libsvn_fs
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"key-gen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"node-rev.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"trail.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"reps-strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"revs-txns.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util/fs_skels.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/txn-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/rev-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/nodes-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/copies-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/reps-table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/strings-table.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_fs_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../libsvn_fs/fs-loader.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/* Initializing a filesystem.  */</comment>

<struct>struct <name>dag_node_t</name>
<block>{
  <comment type="block">/*** NOTE: Keeping in-memory representations of disk data that can
       be changed by other accessors is a nasty business.  Such
       representations are basically a cache with some pretty complex
       invalidation rules.  For example, the "node revision"
       associated with a DAG node ID can look completely different to
       a process that has modified that information as part of a
       Berkeley DB transaction than it does to some other process.
       That said, there are some aspects of a "node revision" which
       never change, like its 'id' or 'kind'.  Our best bet is to
       limit ourselves to exposing outside of this interface only
       those immutable aspects of a DAG node representation.  ***/</comment>

  <comment type="block">/* The filesystem this dag node came from. */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>

  <comment type="block">/* The node revision ID for this dag node. */</comment>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>

  <comment type="block">/* The node's type (file, dir, etc.) */</comment>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* the path at which this node was created. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>created_path</name></decl>;</decl_stmt>
}</block>;</struct>


<escape char="0xc"/>
<comment type="block">/* Trivial helper/accessor functions. */</comment>
<function><type><name>svn_node_kind_t</name></type> <name>svn_fs_base__dag_node_kind</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>node</name>-&gt;<name>kind</name></name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type>
<name>svn_fs_base__dag_get_id</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>node</name>-&gt;<name>id</name></name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_fs_base__dag_get_created_path</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>node</name>-&gt;<name>created_path</name></name></expr>;</return>
}</block></function>


<function><type><name>svn_fs_t</name> *</type>
<name>svn_fs_base__dag_get_fs</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>node</name>-&gt;<name>fs</name></name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type> <name>svn_fs_base__dag_check_mutable</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_base__id_txn_id</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call> == 0)</expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_get_node</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node</name></decl></param>,
                          <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                          <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>new_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Construct the node. */</comment>
  <expr_stmt><expr><name>new_node</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>id</name></name> = <call><name>svn_fs_base__id_copy</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Grab the contents so we can cache some of the immutable parts of it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the KIND and CREATED_PATH attributes */</comment>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>kind</name></name> = <name><name>noderev</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>created_path</name></name> = <name><name>noderev</name>-&gt;<name>created_path</name></name></expr>;</expr_stmt>

  <comment type="block">/* Return a fresh new node */</comment>
  <expr_stmt><expr>*<name>node</name> = <name>new_node</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_get_revision</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>,
                              <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                              <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Use the txn ID from the NODE's id to look up the transaction and
     get its revision number.  */</comment>
  <return>return <expr><call><name>svn_fs_base__txn_get_revision</name>
    <argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><call><name>svn_fs_base__id_txn_id</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_get_predecessor_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
                                    <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                    <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>id_p</name> = <name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_get_predecessor_count</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>count</name></decl></param>,
                                       <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                       <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>count</name> = <name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Trail body for svn_fs_base__dag_init_fs. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>txn_body_dag_init_fs</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                     <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name></type> <name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>revision_t</name></type> <name>revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>date</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>root_id</name> <init>= <expr><call><name>svn_fs_base__id_create</name><argument_list>(<argument><expr>"0"</expr></argument>, <argument><expr>"0"</expr></argument>, <argument><expr>"0"</expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Create empty root directory with node revision 0.0.0. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>noderev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>.<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>.<name>created_path</name></name> = "/"</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr>&amp;<name>noderev</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a new transaction (better have an id of "0") */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__create_txn</name><argument_list>(<argument><expr>&amp;<name>txn_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>txn_id</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr>0</expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Corrupt DB: initial transaction id not '0' in filesystem '%s'"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create a default copy (better have an id of "0") */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__reserve_copy_id</name><argument_list>(<argument><expr>&amp;<name>copy_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>copy_id</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr>0</expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Corrupt DB: initial copy id not '0' in filesystem '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__create_copy</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>,
                                  <argument><expr><name>copy_kind_real</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Link it into filesystem revision 0. */</comment>
  <expr_stmt><expr><name><name>revision</name>.<name>txn_id</name></name> = <name>txn_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr>&amp;<name>revision</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>rev</name> != 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Corrupt DB: initial revision number "
                               "is not '0' in filesystem '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Promote our transaction to a "committed" transaction. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__txn_make_committed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                                          <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set a date on revision 0. */</comment>
  <expr_stmt><expr><name><name>date</name>.<name>data</name></name> = <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>date</name>.<name>len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>date</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_base__set_rev_prop</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>, <argument><expr>&amp;<name>date</name></expr></argument>,
                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name><name>trail</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_init_fs</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_fs_base__retry_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_body_dag_init_fs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Directory node functions ***/</comment>

<comment type="block">/* Some of these are helpers for functions outside this section. */</comment>

<comment type="block">/* Given directory NODEREV in FS, set *ENTRIES_P to its entries list
   hash, as part of TRAIL, or to NULL if NODEREV has no entries.  The
   entries list will be allocated in POOL, and the entries in that
   list will not have interesting value in their 'kind' fields.  If
   NODEREV is not a directory, return the error SVN_ERR_FS_NOT_DIRECTORY. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_dir_entries</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>entries_p</name></decl></param>,
                <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>entries_raw</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>entries_skel</name></decl>;</decl_stmt>

  <comment type="block">/* Error if this is not a directory. */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to create entry in non-directory parent"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If there's a DATA-KEY, there might be entries to fetch. */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Now we have a rep, follow through to get the entries. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents</name><argument_list>(<argument><expr>&amp;<name>entries_raw</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>entries_skel</name> = <call><name>svn_fs_base__parse_skel</name><argument_list>(<argument><expr><name><name>entries_raw</name>.<name>data</name></name></expr></argument>,
                                             <argument><expr><name><name>entries_raw</name>.<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Were there entries?  Make a hash from them. */</comment>
      <if>if <condition>(<expr><name>entries_skel</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__parse_entries_skel</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>entries_skel</name></expr></argument>,
                                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* No hash?  No problem.  */</comment>
  <expr_stmt><expr>*<name>entries_p</name> = <name>NULL</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>entries</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Else, convert the hash from a name-&gt;id mapping to a name-&gt;dirent one.  */</comment>
  <expr_stmt><expr>*<name>entries_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>dirent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* KEY will be the entry name in ancestor, VAL the id.  */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dirent</name>-&gt;<name>name</name></name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dirent</name>-&gt;<name>id</name></name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dirent</name>-&gt;<name>kind</name></name> = <name>svn_node_unknown</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>entries_p</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>dirent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Return our findings. */</comment>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *ID_P to the node-id for entry NAME in PARENT, as part of
   TRAIL.  If no such entry, set *ID_P to NULL but do not error.  The
   entry is allocated in POOL or in the same pool as PARENT;
   the caller should copy if it cares.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>dir_entry_id_from_node</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
                       <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                       <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>entries</name></expr>)</condition><then>
    <expr_stmt><expr><name>dirent</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>dirent</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr>*<name>id_p</name> = <name>dirent</name> ? <name><name>dirent</name>-&gt;<name>id</name></name> : <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Add or set in PARENT a directory entry NAME pointing to ID.
   Allocations are done in TRAIL.

   Assumptions:
   - PARENT is a mutable directory.
   - ID does not refer to an ancestor of parent
   - NAME is a single path component
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_entry</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
          <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>parent_noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rep_key</name></decl>, *<decl><type ref="prev"/><name>mutable_rep_key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>wstream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>raw_entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>raw_entries_buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>entries_skel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the parent's node-revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>parent_noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>parent</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rep_key</name> = <name><name>parent_noderev</name>-&gt;<name>data_key</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__get_mutable_rep</name><argument_list>(<argument><expr>&amp;<name>mutable_rep_key</name></expr></argument>, <argument><expr><name>rep_key</name></expr></argument>,
                                       <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the parent node already pointed at a mutable representation,
     we don't need to do anything.  But if it didn't, either because
     the parent didn't refer to any rep yet or because it referred to
     an immutable one, we must make the parent refer to the mutable
     rep we just created. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__same_keys</name><argument_list>(<argument><expr><name>rep_key</name></expr></argument>, <argument><expr><name>mutable_rep_key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>parent_noderev</name>-&gt;<name>data_key</name></name> = <name>mutable_rep_key</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>parent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>parent_noderev</name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If the new representation inherited nothing, start a new entries
     list for it.  Else, go read its existing entries list. */</comment>
  <if>if <condition>(<expr><name>rep_key</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents</name><argument_list>(<argument><expr>&amp;<name>raw_entries</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rep_key</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>entries_skel</name> = <call><name>svn_fs_base__parse_skel</name><argument_list>(<argument><expr><name><name>raw_entries</name>.<name>data</name></name></expr></argument>,
                                             <argument><expr><name><name>raw_entries</name>.<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>entries_skel</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__parse_entries_skel</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>entries_skel</name></expr></argument>,
                                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* If we still have no ENTRIES hash, make one here.  */</comment>
  <if>if <condition>(<expr>! <name>entries</name></expr>)</condition><then>
    <expr_stmt><expr><name>entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now, add our new entry to the entries list. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Finally, replace the old entries list with the new one. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__unparse_entries_skel</name><argument_list>(<argument><expr>&amp;<name>entries_skel</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>raw_entries_buf</name> = <call><name>svn_fs_base__unparse_skel</name><argument_list>(<argument><expr><name>entries_skel</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents_write_stream</name><argument_list>(<argument><expr>&amp;<name>wstream</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                                 <argument><expr><name>mutable_rep_key</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                                 <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> = <name><name>raw_entries_buf</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>wstream</name></expr></argument>, <argument><expr><name><name>raw_entries_buf</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>wstream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Make a new entry named NAME in PARENT, as part of TRAIL.  If IS_DIR
   is true, then the node revision the new entry points to will be a
   directory, else it will be a file.  The new node will be allocated
   in POOL.  PARENT must be mutable, and must not have an entry
   named NAME.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>make_entry</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
           <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
           <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>new_node_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name></type> <name>new_noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure that NAME is a single path component. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to create a node with an illegal name '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure that parent is a directory */</comment>
  <if>if <condition>(<expr><name><name>parent</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to create entry in non-directory parent"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check that the parent is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to clone child of non-mutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check that parent does not already have an entry named NAME. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dir_entry_id_from_node</name><argument_list>(<argument><expr>&amp;<name>new_node_id</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>new_node_id</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_ALREADY_EXISTS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to create entry that already exists"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the new node's NODE-REVISION */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>new_noderev</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_noderev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_noderev</name>.<name>kind</name></name> = <name>is_dir</name> ? <name>svn_node_dir</name> : <name>svn_node_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_noderev</name>.<name>created_path</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__create_node</name>
          <argument_list>(<argument><expr>&amp;<name>new_node_id</name></expr></argument>, <argument><expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>new_noderev</name></expr></argument>,
           <argument><expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a new dag_node_t for our new node */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>,
                                    <argument><expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>new_node_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We can safely call set_entry because we already know that
     PARENT is mutable, and we just created CHILD, so we know it has
     no ancestors (therefore, PARENT cannot be an ancestor of CHILD) */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>set_entry</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr>*<name>child_p</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_dir_entries</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>entries</name></decl></param>,
                             <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                             <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>get_dir_entries</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_set_entry</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>entry_name</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                           <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Check it's a directory. */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to set entry in non-directory node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check it's mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to set entry in immutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>set_entry</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>entry_name</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Proplists. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_get_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>proplist_p</name></decl></param>,
                              <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                              <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>raw_proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>proplist_skel</name></decl>;</decl_stmt>

  <comment type="block">/* Go get a fresh NODE-REVISION for this node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get property key (returning early if there isn't one) . */</comment>
  <if>if <condition>(<expr>! <name><name>noderev</name>-&gt;<name>prop_key</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>proplist_p</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Get the string associated with the property rep, parsing it as a
     skel, and then attempt to parse *that* into a property hash.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents</name><argument_list>(<argument><expr>&amp;<name>raw_proplist</name></expr></argument>,
                                    <argument><expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>noderev</name>-&gt;<name>prop_key</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>proplist_skel</name> = <call><name>svn_fs_base__parse_skel</name><argument_list>(<argument><expr><name><name>raw_proplist</name>.<name>data</name></name></expr></argument>,
                                          <argument><expr><name><name>raw_proplist</name>.<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>proplist_skel</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__parse_proplist_skel</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>,
                                             <argument><expr><name>proplist_skel</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr>*<name>proplist_p</name> = <name>proplist</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_set_proplist</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                              <param><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                              <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rep_key</name></decl>, *<decl><type ref="prev"/><name>mutable_rep_key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Sanity check: this node better be mutable! */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>idstr</name> <init>= <expr><call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set proplist on *immutable* node-revision %s"</expr></argument>)</argument_list></call></expr></argument>, 
         <argument><expr><name><name>idstr</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Go get a fresh NODE-REVISION for this node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rep_key</name> = <name><name>noderev</name>-&gt;<name>prop_key</name></name></expr>;</expr_stmt>

  <comment type="block">/* Get a mutable version of this rep (updating the node revision if
     this isn't a NOOP)  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__get_mutable_rep</name><argument_list>(<argument><expr>&amp;<name>mutable_rep_key</name></expr></argument>, <argument><expr><name>rep_key</name></expr></argument>,
                                       <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__same_keys</name><argument_list>(<argument><expr><name>mutable_rep_key</name></expr></argument>, <argument><expr><name>rep_key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>prop_key</name></name> = <name>mutable_rep_key</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Replace the old property list with the new one. */</comment>
  <block>{
    <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>wstream</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>skel_t</name> *</type><name>proplist_skel</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>raw_proplist_buf</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__unparse_proplist_skel</name><argument_list>(<argument><expr>&amp;<name>proplist_skel</name></expr></argument>,
                                               <argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>raw_proplist_buf</name> = <call><name>svn_fs_base__unparse_skel</name><argument_list>(<argument><expr><name>proplist_skel</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents_write_stream</name><argument_list>(<argument><expr>&amp;<name>wstream</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                                   <argument><expr><name>mutable_rep_key</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                                   <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <name><name>raw_proplist_buf</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>wstream</name></expr></argument>, <argument><expr><name><name>raw_proplist_buf</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>wstream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Roots. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_revision_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
                               <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                               <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                               <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>root_id</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rev_get_root</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_txn_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
                          <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                          <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>root_id</name></decl>, *<decl><type ref="prev"/><name>ignored</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__get_txn_ids</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr>&amp;<name>ignored</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_txn_base_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
                               <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                               <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>base_root_id</name></decl>, *<decl><type ref="prev"/><name>ignored</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__get_txn_ids</name><argument_list>(<argument><expr>&amp;<name>ignored</name></expr></argument>, <argument><expr>&amp;<name>base_root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>base_root_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_clone_child</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
                             <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                             <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>cur_entry</name></decl>;</decl_stmt> <comment type="block">/* parent's current entry named NAME */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>new_node_id</name></decl>;</decl_stmt> <comment type="block">/* node id we'll put into NEW_NODE */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First check that the parent is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to clone child of non-mutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure that NAME is a single path component. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to make a child clone with an illegal name '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Find the node named NAME in PARENT's entries list if it exists. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_open</name><argument_list>(<argument><expr>&amp;<name>cur_entry</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for mutability in the node we found.  If it's mutable, we
     don't need to clone it. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>cur_entry</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* This has already been cloned */</comment>
      <expr_stmt><expr><name>new_node_id</name> = <name><name>cur_entry</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

      <comment type="block">/* Go get a fresh NODE-REVISION for current child node. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cur_entry</name>-&gt;<name>id</name></name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Do the clone thingy here. */</comment>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <name><name>cur_entry</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
        <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>created_path</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__create_successor</name><argument_list>(<argument><expr>&amp;<name>new_node_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cur_entry</name>-&gt;<name>id</name></name></expr></argument>,
                                            <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Replace the ID in the parent's ENTRY list with the ID which
         refers to the mutable clone of this child. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>set_entry</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>new_node_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Initialize the youngster. */</comment>
  <return>return <expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>new_node_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_clone_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>root_p</name></decl></param>,
                            <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                            <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>base_root_id</name></decl>, *<decl><type ref="prev"/><name>root_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Get the node ID's of the root directories of the transaction and
     its base revision.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__get_txn_ids</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr>&amp;<name>base_root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                   <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Oh, give me a clone...
     (If they're the same, we haven't cloned the transaction's root
     directory yet.)  */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__id_eq</name><argument_list>(<argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>base_root_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_copy_id</name> <init>= <expr><call><name>svn_fs_base__id_copy_id</name><argument_list>(<argument><expr><name>base_root_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Of my own flesh and bone...
         (Get the NODE-REVISION for the base node, and then write
         it back out as the clone.) */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>base_root_id</name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* With its Y-chromosome changed to X...
         (Store it with an updated predecessor count.) */</comment>
      <comment type="block">/* ### TODO: Does it even makes sense to have a different copy id for
         the root node?  That is, does this function need a copy_id
         passed in?  */</comment>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <call><name>svn_fs_base__id_copy</name><argument_list>(<argument><expr><name>base_root_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
        <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__create_successor</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>base_root_id</name></expr></argument>,
                                            <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>base_copy_id</name></expr></argument>,
                                            <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* ... And when it is grown
       *      Then my own little clone
       *        Will be of the opposite sex!
       */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__set_txn_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* One way or another, root_id now identifies a cloned root node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr><name>root_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * (Sung to the tune of "Home, Home on the Range", with thanks to
   * Randall Garrett and Isaac Asimov.)
   */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Delete the directory entry named NAME from PARENT, as part of
   TRAIL.  PARENT must be mutable.  NAME must be a single path
   component.  If REQUIRE_EMPTY is true and the node being deleted is
   a directory, it must be empty.

   If return SVN_ERR_FS_NO_SUCH_ENTRY, then there is no entry NAME in
   PARENT.  */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_delete</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                        <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>parent_noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rep_key</name></decl>, *<decl><type ref="prev"/><name>mutable_rep_key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>entries_skel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>parent</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure parent is a directory. */</comment>
  <if>if <condition>(<expr><name><name>parent</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to delete entry '%s' from *non*-directory node"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure parent is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to delete entry '%s' from immutable directory node"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure that NAME is a single path component. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to delete a node with an illegal name '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get a fresh NODE-REVISION for the parent node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>parent_noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>parent</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the key for the parent's entries list (data) representation. */</comment>
  <expr_stmt><expr><name>rep_key</name> = <name><name>parent_noderev</name>-&gt;<name>data_key</name></name></expr>;</expr_stmt>

  <comment type="block">/* No REP_KEY means no representation, and no representation means
     no data, and no data means no entries...there's nothing here to
     delete! */</comment>
  <if>if <condition>(<expr>! <name>rep_key</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_ENTRY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Delete failed: directory has no entry '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Ensure we have a key to a mutable representation of the entries
     list.  We'll have to update the NODE-REVISION if it points to an
     immutable version.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__get_mutable_rep</name><argument_list>(<argument><expr>&amp;<name>mutable_rep_key</name></expr></argument>, <argument><expr><name>rep_key</name></expr></argument>,
                                       <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__same_keys</name><argument_list>(<argument><expr><name>mutable_rep_key</name></expr></argument>, <argument><expr><name>rep_key</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>parent_noderev</name>-&gt;<name>data_key</name></name> = <name>mutable_rep_key</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>parent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>parent_noderev</name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Read the representation, then use it to get the string that holds
     the entries list.  Parse that list into a skel, and parse *that*
     into a hash. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rep_key</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>entries_skel</name> = <call><name>svn_fs_base__parse_skel</name><argument_list>(<argument><expr><name><name>str</name>.<name>data</name></name></expr></argument>, <argument><expr><name><name>str</name>.<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>entries_skel</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__parse_entries_skel</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>entries_skel</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Find NAME in the ENTRIES skel.  */</comment>
  <if>if <condition>(<expr><name>entries</name></expr>)</condition><then>
    <expr_stmt><expr><name>id</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If we never found ID in ENTRIES (perhaps because there are no
     ENTRIES, perhaps because ID just isn't in the existing ENTRIES
     ... it doesn't matter), return an error.  */</comment>
  <if>if <condition>(<expr>! <name>id</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_ENTRY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Delete failed: directory has no entry '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Use the ID of this ENTRY to get the entry's node.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If mutable, remove it and any mutable children from db. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_delete_if_mutable</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                             <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove this entry from its parent's entries list. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Replace the old entries list with the new one. */</comment>
  <block>{
    <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>ws</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>unparsed_entries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__unparse_entries_skel</name><argument_list>(<argument><expr>&amp;<name>entries_skel</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>unparsed_entries</name> = <call><name>svn_fs_base__unparse_skel</name><argument_list>(<argument><expr><name>entries_skel</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents_write_stream</name><argument_list>(<argument><expr>&amp;<name>ws</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>mutable_rep_key</name></expr></argument>,
                                                   <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <name><name>unparsed_entries</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>ws</name></expr></argument>, <argument><expr><name><name>unparsed_entries</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>ws</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_remove_node</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                             <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch the node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If immutable, do nothing and return immediately. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted removal of immutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get a fresh node-revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Delete any mutable property representation. */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>prop_key</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__delete_rep_if_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>prop_key</name></name></expr></argument>,
                                               <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Delete any mutable data representation. */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__delete_rep_if_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr></argument>,
                                               <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Delete any mutable edit representation (files only). */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>edit_key</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__delete_rep_if_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name></expr></argument>,
                                               <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Delete the node revision itself. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__delete_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, 
                                            <argument><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> 
                                              ? <name>FALSE</name> : <name>TRUE</name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_delete_if_mutable</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                                   <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* Get the node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If immutable, do nothing and return immediately. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Else it's mutable.  Recurse on directories... */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

      <comment type="block">/* Loop over hash entries */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>entries</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init>
               <condition><expr><name>hi</name></expr>;</condition>
               <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_delete_if_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>,
                                                         <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                                         <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* ... then delete the node itself, after deleting any mutable
     representations and strings it points to. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_remove_node</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_make_file</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
                           <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                           <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Call our little helper function */</comment>
  <return>return <expr><call><name>make_entry</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                    <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_make_dir</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
                          <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                          <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Call our little helper function */</comment>
  <return>return <expr><call><name>make_entry</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                    <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_get_contents</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents</name></decl></param>,
                              <param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                              <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure our node is a file. */</comment>
  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to get textual contents of a *non*-file node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Go get a fresh node-revision for FILE. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Our job is to _return_ a stream on the file's contents, so the
     stream has to be trail-independent.  Here, we pass NULL to tell
     the stream that we're not providing it a trail that lives across
     reads.  This means the stream will do each read in a one-off,
     temporary trail.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents_read_stream</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>fs</name></name></expr></argument>,
                                                <argument><expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr></argument>,
                                                <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Note that we're not registering any `close' func, because there's
     nothing to cleanup outside of our trail.  When the trail is
     freed, the stream/baton will be too. */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_file_length</name><parameter_list>(<param><decl><type><name>svn_filesize_t</name> *</type><name>length</name></decl></param>,
                             <param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                             <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure our node is a file. */</comment>
  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to get length of a *non*-file node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Go get a fresh node-revision for FILE, and . */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents_size</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>fs</name></name></expr></argument>,
                                           <argument><expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>length</name> = 0</expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_file_checksum</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[]</index></name></decl></param>,
                               <param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                               <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to get checksum of a *non*-file node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>fs</name></name></expr></argument>,
                                               <argument><expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr></argument>,
                                               <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_get_edit_stream</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents</name></decl></param>,
                                 <param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                                 <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>file</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* just for nicer indentation */</comment>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mutable_rep_key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>ws</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure our node is a file. */</comment>
  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to set textual contents of a *non*-file node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure our node is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to set textual contents of an immutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get the node revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this node already has an EDIT-DATA-KEY, destroy the data
     associated with that key.  */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>edit_key</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__delete_rep_if_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name></expr></argument>,
                                               <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now, let's ensure that we have a new EDIT-DATA-KEY available for
     use. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__get_mutable_rep</name><argument_list>(<argument><expr>&amp;<name>mutable_rep_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                       <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We made a new rep, so update the node revision. */</comment>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name> = <name>mutable_rep_key</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return a writable stream with which to set new contents. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents_write_stream</name><argument_list>(<argument><expr>&amp;<name>ws</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>mutable_rep_key</name></expr></argument>,
                                                 <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>contents</name> = <name>ws</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_finalize_edits</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>checksum</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                                <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>file</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>   <comment type="block">/* just for nicer indentation */</comment>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_data_key</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure our node is a file. */</comment>
  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to set textual contents of a *non*-file node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure our node is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to set textual contents of an immutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get the node revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this node has no EDIT-DATA-KEY, this is a no-op. */</comment>
  <if>if <condition>(<expr>! <name><name>noderev</name>-&gt;<name>edit_key</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>checksum</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_contents_checksum</name>
              <argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>hex</name> = <call><name>svn_md5_digest_to_cstring_display</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_CHECKSUM_MISMATCH</name></expr></argument>,
           <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Checksum mismatch, rep '%s':\n"
             "   expected:  %s\n"
             "     actual:  %s\n"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Now, we want to delete the old representation and replace it with
     the new.  Of course, we don't actually delete anything until
     everything is being properly referred to by the node-revision
     skel. */</comment>
  <expr_stmt><expr><name>old_data_key</name> = <name><name>noderev</name>-&gt;<name>data_key</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>data_key</name></name> = <name><name>noderev</name>-&gt;<name>edit_key</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Only *now* can we safely destroy the old representation (if it
     even existed in the first place). */</comment>
  <if>if <condition>(<expr><name>old_data_key</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__delete_rep_if_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>old_data_key</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                               <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>dag_node_t</name> *</type>
<name>svn_fs_base__dag_dup</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Allocate our new node. */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>new_node</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>fs</name></name> = <name><name>node</name>-&gt;<name>fs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>id</name></name> = <call><name>svn_fs_base__id_copy</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>kind</name></name> = <name><name>node</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>created_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>created_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>new_node</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_open</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
                      <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                      <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>

  <comment type="block">/* Ensure that NAME exists in PARENT's entry list. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dir_entry_id_from_node</name><argument_list>(<argument><expr>&amp;<name>node_id</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>node_id</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to open non-existent child node '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure that NAME is a single path component. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to open node with an illegal name '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Now get the node that was requested. */</comment>
  <return>return <expr><call><name>svn_fs_base__dag_get_node</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_copy</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>to_node</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>entry</name></decl></param>,
                      <param><decl><type><name>dag_node_t</name> *</type><name>from_node</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>preserve_history</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name></type> <name>from_rev</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                      <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>preserve_history</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>src_id</name> <init>= <expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_txn_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Make a copy of the original node revision. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>from_node</name>-&gt;<name>id</name></name></expr></argument>,
                                            <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Reserve a copy ID for this new copy. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__reserve_copy_id</name><argument_list>(<argument><expr>&amp;<name>copy_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Create a successor with its predecessor pointing at the copy
         source. */</comment>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <call><name>svn_fs_base__id_copy</name><argument_list>(<argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
        <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>created_path</name></name> = <call><name>svn_path_join</name>
        <argument_list>(<argument><expr><call><name>svn_fs_base__dag_get_created_path</name><argument_list>(<argument><expr><name>to_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__create_successor</name><argument_list>(<argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>,
                                            <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Translate FROM_REV into a transaction ID. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rev_get_txn_id</name><argument_list>(<argument><expr>&amp;<name>from_txn_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>from_rev</name></expr></argument>,
                                          <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now that we've done the copy, we need to add the information
         about the copy to the `copies' table, using the COPY_ID we
         reserved above.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__create_copy</name>
              <argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>,
               <argument><expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>from_txn_id</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>copy_kind_real</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Finally, add the COPY_ID to the transaction's list of copies
         so that, if this transaction is aborted, the `copies' table
         entry we added above will be cleaned up. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__add_txn_copy</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else  <comment type="block">/* don't preserve history */</comment>
    <block>{
      <expr_stmt><expr><name>id</name> = <call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Set the entry in to_node to the new id. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__dag_set_entry</name><argument_list>(<argument><expr><name>to_node</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                     <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Deltification ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_deltify</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>target</name></decl></param>,
                         <param><decl><type><name>dag_node_t</name> *</type><name>source</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>props_only</name></decl></param>,
                         <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>source_nr</name></decl>, *<decl><type ref="prev"/><name>target_nr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get node revisions for the two nodes.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>target_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>target</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>source_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>source</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If TARGET and SOURCE both have properties, and are not sharing a
     property key, deltify TARGET's properties.  */</comment>
  <if>if <condition>(<expr><name><name>target_nr</name>-&gt;<name>prop_key</name></name>
      &amp;&amp; <name><name>source_nr</name>-&gt;<name>prop_key</name></name>
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>target_nr</name>-&gt;<name>prop_key</name></name></expr></argument>, <argument><expr><name><name>source_nr</name>-&gt;<name>prop_key</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_deltify</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>target_nr</name>-&gt;<name>prop_key</name></name></expr></argument>,
                                     <argument><expr><name><name>source_nr</name>-&gt;<name>prop_key</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If we are not only attending to properties, and if TARGET and
     SOURCE both have data, and are not sharing a data key, deltify
     TARGET's data.  */</comment>
  <if>if <condition>(<expr>(! <name>props_only</name>)
      &amp;&amp; <name><name>target_nr</name>-&gt;<name>data_key</name></name>
      &amp;&amp; <name><name>source_nr</name>-&gt;<name>data_key</name></name>
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>target_nr</name>-&gt;<name>data_key</name></name></expr></argument>, <argument><expr><name><name>source_nr</name>-&gt;<name>data_key</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__rep_deltify</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>target_nr</name>-&gt;<name>data_key</name></name></expr></argument>,
                                     <argument><expr><name><name>source_nr</name>-&gt;<name>data_key</name></name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/*** Committing ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_commit_txn</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>new_rev</name></decl></param>,
                            <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                            <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>revision_t</name></type> <name>revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>date</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>txnprops</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>txn</name>-&gt;<name>id</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Remove any temporary transaction properties initially created by
     begin_txn().  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__txn_proplist_in_trail</name><argument_list>(<argument><expr>&amp;<name>txnprops</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add new revision entry to `revisions' table. */</comment>
  <expr_stmt><expr><name><name>revision</name>.<name>txn_id</name></name> = <name>txn_id</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>new_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_rev</name><argument_list>(<argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr>&amp;<name>revision</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_OOD</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__set_txn_prop</name>
            <argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_OOD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_LOCKS</name></expr></argument>, 
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__set_txn_prop</name>
            <argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_LOCKS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Promote the unfinished transaction to a committed one. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__txn_make_committed</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr>*<name>new_rev</name></expr></argument>,
                                          <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set a date on the commit.  We wait until now to fetch the date,
     so it's definitely newer than any previous revision's date. */</comment>
  <expr_stmt><expr><name><name>date</name>.<name>data</name></name> = <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>date</name>.<name>len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>date</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__set_rev_prop</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>*<name>new_rev</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>,
                                    <argument><expr>&amp;<name>date</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Comparison. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__things_different</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>props_changed</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name> *</type><name>contents_changed</name></decl></param>,
                              <param><decl><type><name>dag_node_t</name> *</type><name>node1</name></decl></param>,
                              <param><decl><type><name>dag_node_t</name> *</type><name>node2</name></decl></param>,
                              <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev1</name></decl>, *<decl><type ref="prev"/><name>noderev2</name></decl>;</decl_stmt>

  <comment type="block">/* If we have no place to store our results, don't bother doing
     anything. */</comment>
  <if>if <condition>(<expr>! <name>props_changed</name> &amp;&amp; ! <name>contents_changed</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* The the node revision skels for these two nodes. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev1</name></expr></argument>, <argument><expr><name><name>node1</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>node1</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev2</name></expr></argument>, <argument><expr><name><name>node2</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>node2</name>-&gt;<name>id</name></name></expr></argument>,
                                        <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compare property keys. */</comment>
  <if>if <condition>(<expr><name>props_changed</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>props_changed</name> = (! <call><name>svn_fs_base__same_keys</name><argument_list>(<argument><expr><name><name>noderev1</name>-&gt;<name>prop_key</name></name></expr></argument>,
                                               <argument><expr><name><name>noderev2</name>-&gt;<name>prop_key</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

  <comment type="block">/* Compare contents keys. */</comment>
  <if>if <condition>(<expr><name>contents_changed</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>contents_changed</name> = (! <call><name>svn_fs_base__same_keys</name><argument_list>(<argument><expr><name><name>noderev1</name>-&gt;<name>data_key</name></name></expr></argument>,
                                                  <argument><expr><name><name>noderev2</name>-&gt;<name>data_key</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Mergeinfo tracking stuff ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_get_mergeinfo_stats</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>has_mergeinfo</name></decl></param>,
                                     <param><decl><type><name>apr_int64_t</name> *</type><name>count</name></decl></param>,
                                     <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                     <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>node_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name> <init>= <expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>node_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>has_mergeinfo</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>has_mergeinfo</name> = <name><name>node_rev</name>-&gt;<name>has_mergeinfo</name></name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>count</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>count</name> = <name><name>node_rev</name>-&gt;<name>mergeinfo_count</name></name></expr>;</expr_stmt></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_set_has_mergeinfo</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                   <param><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl></param>,
                                   <param><decl><type><name>svn_boolean_t</name> *</type><name>had_mergeinfo</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                                   <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>node_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name> <init>= <expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__test_required_feature_format</name>
          <argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>"mergeinfo"</expr></argument>, <argument><expr><name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted merge tracking info change on "
                               "immutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>node_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>had_mergeinfo</name> = <name><name>node_rev</name>-&gt;<name>has_mergeinfo</name></name></expr>;</expr_stmt>

  <comment type="block">/* Are we changing the node? */</comment>
  <if>if <condition>(<expr>(! <name>has_mergeinfo</name>) != (! *<name>had_mergeinfo</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* Note the new has-mergeinfo state. */</comment>
      <expr_stmt><expr><name><name>node_rev</name>-&gt;<name>has_mergeinfo</name></name> = <name>has_mergeinfo</name></expr>;</expr_stmt>

      <comment type="block">/* Increment or decrement the mergeinfo count as necessary. */</comment>
      <if>if <condition>(<expr><name>has_mergeinfo</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>node_rev</name>-&gt;<name>mergeinfo_count</name></name>++</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name><name>node_rev</name>-&gt;<name>mergeinfo_count</name></name>--</expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>node_rev</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__dag_adjust_mergeinfo_count</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                        <param><decl><type><name>apr_int64_t</name></type> <name>count_delta</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                                        <param><decl><type><name>trail_t</name> *</type><name>trail</name></decl></param>,
                                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>node_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_base__dag_get_fs</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name> <init>= <expr><call><name>svn_fs_base__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__test_required_feature_format</name>
          <argument_list>(<argument><expr><name><name>trail</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>"mergeinfo"</expr></argument>, <argument><expr><name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <call><name>svn_fs_base__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted mergeinfo count change on "
                               "immutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>count_delta</name> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>node_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node_rev</name>-&gt;<name>mergeinfo_count</name></name> = <name><name>node_rev</name>-&gt;<name>mergeinfo_count</name></name> + <name>count_delta</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name><name>node_rev</name>-&gt;<name>mergeinfo_count</name></name> &lt; 0) 
      || ((<name><name>node</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>) &amp;&amp; (<name><name>node_rev</name>-&gt;<name>mergeinfo_count</name></name> &gt; 1))</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                          <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid value (%%%s) for node "
                                            "revision mergeinfo count"</expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>APR_INT64_T_FMT</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>node_rev</name>-&gt;<name>mergeinfo_count</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_bdb__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>node_rev</name></expr></argument>, <argument><expr><name>trail</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
