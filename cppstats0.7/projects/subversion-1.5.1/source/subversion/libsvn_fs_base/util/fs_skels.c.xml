<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_base/util/fs_skels.c"><comment type="block">/* fs_skels.c --- conversion between fs native types and skeletons
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs_skels.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"skel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../id.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>skel_err</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>skel_type</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_MALFORMED_SKEL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr>"Malformed%s%s skeleton"</expr></argument>,
                           <argument><expr><name>skel_type</name> ? " " : ""</expr></argument>,
                           <argument><expr><name>skel_type</name> ? <name>skel_type</name> : ""</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Validity Checking ***/</comment>

<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_checksum_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"md5"</expr></argument>)</argument_list></call>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_proplist_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<name>len</name> &gt;= 0) &amp;&amp; (<name>len</name> &amp; 1) == 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>skel_t</name> *</type><name>elt</name></decl>;</decl_stmt>

      <for>for (<init><expr><name>elt</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</init> <condition><expr><name>elt</name></expr>;</condition> <incr><expr><name>elt</name> = <name><name>elt</name>-&gt;<name>next</name></name></expr></incr>)
        <if>if <condition>(<expr>! <name><name>elt</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
          <return>return <expr><name>FALSE</name></expr>;</return></then></if></for>

      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_revision_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<name>len</name> == 2)
      &amp;&amp; <call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"revision"</expr></argument>)</argument_list></call>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_transaction_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>transaction_kind_t</name> *</type><name>kind</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>len</name> != 5</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* Determine (and verify) the kind. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr>*<name>kind</name> = <name>transaction_kind_normal</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"committed"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr>*<name>kind</name> = <name>transaction_kind_committed</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"dead"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr>*<name>kind</name> = <name>transaction_kind_dead</name></expr>;</expr_stmt></then>
  <else>else
    <return>return <expr><name>FALSE</name></expr>;</return></else></if></else></if></else></if>

  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)
      &amp;&amp; (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_rep_delta_chunk_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>window</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>diff</name></decl>;</decl_stmt>

  <comment type="block">/* check the delta skel. */</comment>
  <if>if <condition>(<expr>(<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> != 2)
      || (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* check the window. */</comment>
  <expr_stmt><expr><name>window</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> = <call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>len</name> &lt; 3) || (<name>len</name> &gt; 4)</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>
  <if>if <condition>(<expr>! ((! <name><name>window</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>)
         &amp;&amp; (<name><name>window</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)
         &amp;&amp; (<name><name>window</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>))</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>
  <if>if <condition>(<expr>(<name>len</name> == 4)
      &amp;&amp; (! <name><name>window</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* check the diff. ### currently we support only svndiff version
     0 delta data. */</comment>
  <expr_stmt><expr><name>diff</name> = <name><name>window</name>-&gt;<name>children</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call> == 3)
      &amp;&amp; (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>diff</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"svndiff"</expr></argument>)</argument_list></call>)
      &amp;&amp; ((<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>diff</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call>)
          || (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>diff</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call>))
      &amp;&amp; (<name><name>diff</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_representation_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>header</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>header_len</name></decl>;</decl_stmt>

  <comment type="block">/* the rep has at least two items in it, a HEADER list, and at least
     one piece of kind-specific data. */</comment>
  <if>if <condition>(<expr><name>len</name> &lt; 2</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* check the header.  it must have KIND and TXN atoms, and
     optionally a CHECKSUM (which is a list form). */</comment>
  <expr_stmt><expr><name>header</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>header_len</name> = <call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! (((<name>header_len</name> == 2)     <comment type="block">/* 2 means old repository, checksum absent */</comment>
          &amp;&amp; (<name><name>header</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>)
          &amp;&amp; (<name><name>header</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>))
         || ((<name>header_len</name> == 3)  <comment type="block">/* 3 means checksum present */</comment>
             &amp;&amp; (<name><name>header</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>)
             &amp;&amp; (<name><name>header</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)
             &amp;&amp; (<call><name>is_valid_checksum_skel</name><argument_list>(<argument><expr><name><name>header</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></call>)))</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* check for fulltext rep. */</comment>
  <if>if <condition>(<expr>(<name>len</name> == 2)
      &amp;&amp; (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>header</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"fulltext"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <comment type="block">/* check for delta rep. */</comment>
  <if>if <condition>(<expr>(<name>len</name> &gt;= 2)
      &amp;&amp; (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>header</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"delta"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* it's a delta rep.  check the validity.  */</comment>
      <decl_stmt><decl><type><name>skel_t</name> *</type><name>chunk</name> <init>= <expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* loop over chunks, checking each one. */</comment>
      <while>while <condition>(<expr><name>chunk</name></expr>)</condition>
        <block>{
          <if>if <condition>(<expr>! <call><name>is_valid_rep_delta_chunk_skel</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>FALSE</name></expr>;</return></then></if>
          <expr_stmt><expr><name>chunk</name> = <name><name>chunk</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>

      <comment type="block">/* all good on this delta rep. */</comment>
      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_node_revision_header_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>skel_t</name> **</type><name>kind_p</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>len</name> &lt; 2</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* set the *KIND_P pointer. */</comment>
  <expr_stmt><expr>*<name>kind_p</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</expr_stmt>

  <comment type="block">/* check for valid lengths. */</comment>
  <if>if <condition>(<expr>! ((<name>len</name> == 2) || (<name>len</name> == 3) || (<name>len</name> == 4) || (<name>len</name> == 6))</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* got mergeinfo stuff? */</comment>
  <if>if <condition>(<expr>(<name>len</name> &gt; 4)
      &amp;&amp; (! (<name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
             &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>))</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>
      
  <comment type="block">/* got predecessor count? */</comment>
  <if>if <condition>(<expr>(<name>len</name> &gt; 3)
      &amp;&amp; (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* got predecessor? */</comment>
  <if>if <condition>(<expr>(<name>len</name> &gt; 2)
      &amp;&amp; (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* got the basics? */</comment>
  <if>if <condition>(<expr>! (<name><name>skel</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>
         &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
         &amp;&amp; (<name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name><index>[<expr>0</expr>]</index></name> == '/'))</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_node_revision_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>len</name> &gt;= 1</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>skel_t</name> *</type><name>header</name> <init>= <expr><name><name>skel</name>-&gt;<name>children</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>skel_t</name> *</type><name>kind</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><call><name>is_valid_node_revision_header_skel</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr>"dir"</expr></argument>)</argument_list></call>
              &amp;&amp; <name>len</name> == 3
              &amp;&amp; <name><name>header</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
              &amp;&amp; <name><name>header</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
            <return>return <expr><name>TRUE</name></expr>;</return></then></if>

          <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr>"file"</expr></argument>)</argument_list></call>
              &amp;&amp; ((<name>len</name> == 3) || (<name>len</name> == 4))
              &amp;&amp; <name><name>header</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
              &amp;&amp; <name><name>header</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr>(<name>len</name> == 4) &amp;&amp; (! <name><name>header</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
                <return>return <expr><name>FALSE</name></expr>;</return></then></if>
              <return>return <expr><name>TRUE</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_copy_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(((<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> == 4)
           &amp;&amp; (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"copy"</expr></argument>)</argument_list></call>
               || <call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"soft-copy"</expr></argument>)</argument_list></call>)
           &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
           &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
           &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>) ? <name>TRUE</name> : <name>FALSE</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_change_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>svn_fs_path_change_kind_t</name> *</type><name>kind</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>(<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> == 6)
      &amp;&amp; <call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"change"</expr></argument>)</argument_list></call>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>skel_t</name> *</type><name>kind_skel</name> <init>= <expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* check the kind (and return it) */</comment>
      <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"reset"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_reset</name></expr>;</expr_stmt></then></if>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"add"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_add</name></expr>;</expr_stmt></then></if>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"delete"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_delete</name></expr>;</expr_stmt></then></if>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_replace</name></expr>;</expr_stmt></then></if>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"modify"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_modify</name></expr>;</expr_stmt></then></if>
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_lock_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>(<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> == 8)
      &amp;&amp; <call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"lock"</expr></argument>)</argument_list></call>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Parsing (conversion from skeleton to native FS type) ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_proplist_skel</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>proplist_p</name></decl></param>,
                                 <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>elt</name></decl>;</decl_stmt>

  <comment type="block">/* Validate the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_proplist_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"proplist"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the returned structure */</comment>
  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <for>for (<init><expr><name>elt</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</init> <condition><expr><name>elt</name></expr>;</condition> <incr><expr><name>elt</name> = <name><name>elt</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name> <init>= <expr><call><name>svn_string_ncreate</name><argument_list>(<argument><expr><name><name>elt</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                               <argument><expr><name><name>elt</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>,
                   <argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name><name>elt</name>-&gt;<name>len</name></name></expr></argument>,
                   <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>proplist_p</name> = <name>proplist</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_revision_skel</name><parameter_list>(<param><decl><type><name>revision_t</name> **</type><name>revision_p</name></decl></param>,
                                 <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>revision_t</name> *</type><name>revision</name></decl>;</decl_stmt>

  <comment type="block">/* Validate the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_revision_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the returned structure */</comment>
  <expr_stmt><expr><name>revision</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>revision</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>revision</name>-&gt;<name>txn_id</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                    <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>revision_p</name> = <name>revision</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_transaction_skel</name><parameter_list>(<param><decl><type><name>transaction_t</name> **</type><name>transaction_p</name></decl></param>,
                                    <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>transaction_t</name> *</type><name>transaction</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>transaction_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>root_id</name></decl>, *<decl><type ref="prev"/><name>base_id_or_rev</name></decl>, *<decl><type ref="prev"/><name>proplist</name></decl>, *<decl><type ref="prev"/><name>copies</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* Validate the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_transaction_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>root_id</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>base_id_or_rev</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>proplist</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>copies</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>

  <comment type="block">/* Create the returned structure */</comment>
  <expr_stmt><expr><name>transaction</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>transaction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* KIND */</comment>
  <expr_stmt><expr><name><name>transaction</name>-&gt;<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>

  <comment type="block">/* REVISION or BASE-ID */</comment>
  <if>if <condition>(<expr><name>kind</name> == <name>transaction_kind_committed</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Committed transactions have a revision number... */</comment>
      <expr_stmt><expr><name><name>transaction</name>-&gt;<name>base_id</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>transaction</name>-&gt;<name>revision</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>base_id_or_rev</name>-&gt;<name>data</name></name></expr></argument>,
                                                  <argument><expr><name><name>base_id_or_rev</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>

    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* ...where unfinished transactions have a base node-revision-id. */</comment>
      <expr_stmt><expr><name><name>transaction</name>-&gt;<name>revision</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>transaction</name>-&gt;<name>base_id</name></name> = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>base_id_or_rev</name>-&gt;<name>data</name></name></expr></argument>,
                                                   <argument><expr><name><name>base_id_or_rev</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* ROOT-ID */</comment>
  <expr_stmt><expr><name><name>transaction</name>-&gt;<name>root_id</name></name> = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>root_id</name>-&gt;<name>data</name></name></expr></argument>,
                                               <argument><expr><name><name>root_id</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* PROPLIST */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__parse_proplist_skel</name><argument_list>(<argument><expr>&amp;(<name><name>transaction</name>-&gt;<name>proplist</name></name>)</expr></argument>,
                                           <argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* COPIES */</comment>
  <if>if <condition>(<expr>(<name>len</name> = <call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>copies</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>txncopies</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>skel_t</name> *</type><name>cpy</name> <init>= <expr><name><name>copies</name>-&gt;<name>children</name></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>txncopies</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>copy_id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>cpy</name></expr>)</condition>
        <block>{
          <expr_stmt><expr><name>copy_id</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>cpy</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>cpy</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>txncopies</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>copy_id</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cpy</name> = <name><name>cpy</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>
      <expr_stmt><expr><name><name>transaction</name>-&gt;<name>copies</name></name> = <name>txncopies</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>transaction_p</name> = <name>transaction</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_representation_skel</name><parameter_list>(<param><decl><type><name>representation_t</name> **</type><name>rep_p</name></decl></param>,
                                       <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>representation_t</name> *</type><name>rep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>header_skel</name></decl>;</decl_stmt>

  <comment type="block">/* Validate the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_representation_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"representation"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>header_skel</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</expr_stmt>

  <comment type="block">/* Create the returned structure */</comment>
  <expr_stmt><expr><name>rep</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* KIND */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>header_skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"fulltext"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name><name>rep</name>-&gt;<name>kind</name></name> = <name>rep_kind_fulltext</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>rep</name>-&gt;<name>kind</name></name> = <name>rep_kind_delta</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* TXN */</comment>
  <expr_stmt><expr><name><name>rep</name>-&gt;<name>txn_id</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                               <argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* CHECKSUM */</comment>
  <if>if <condition>(<expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>,
             <argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
             <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Older repository, no checksum, so manufacture an all-zero checksum */</comment>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* KIND-SPECIFIC stuff */</comment>
  <if>if <condition>(<expr><name><name>rep</name>-&gt;<name>kind</name></name> == <name>rep_kind_fulltext</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* "fulltext"-specific. */</comment>
      <expr_stmt><expr><name><name>rep</name>-&gt;<name>contents</name>.<name>fulltext</name>.<name>string_key</name></name>
        = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                         <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                         <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* "delta"-specific. */</comment>
      <decl_stmt><decl><type><name>skel_t</name> *</type><name>chunk_skel</name> <init>= <expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>rep_delta_chunk_t</name> *</type><name>chunk</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>chunks</name></decl>;</decl_stmt>

      <comment type="block">/* Alloc the chunk array. */</comment>
      <expr_stmt><expr><name>chunks</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> - 1</expr></argument>,
                              <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Process the chunks. */</comment>
      <while>while <condition>(<expr><name>chunk_skel</name></expr>)</condition>
        <block>{
          <decl_stmt><decl><type><name>skel_t</name> *</type><name>window_skel</name> <init>= <expr><name><name>chunk_skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>skel_t</name> *</type><name>diff_skel</name> <init>= <expr><name><name>window_skel</name>-&gt;<name>children</name></name></expr></init></decl>;</decl_stmt>

          <comment type="block">/* Allocate a chunk and its window */</comment>
          <expr_stmt><expr><name>chunk</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Populate the window */</comment>
          <expr_stmt><expr><name><name>chunk</name>-&gt;<name>version</name></name>
            = (<name>apr_byte_t</name>)<call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name>
                               <argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><name><name>diff_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                <argument><expr><name><name>diff_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>chunk</name>-&gt;<name>string_key</name></name>
            = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                             <argument><expr><name><name>diff_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                             <argument><expr><name><name>diff_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>chunk</name>-&gt;<name>size</name></name>
            = <call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                  <argument><expr><name><name>window_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                  <argument><expr><name><name>window_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>chunk</name>-&gt;<name>rep_key</name></name>
            = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                             <argument><expr><name><name>window_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                             <argument><expr><name><name>window_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>chunk</name>-&gt;<name>offset</name></name> =
            <call><name>svn__atoui64</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                        <argument><expr><name><name>chunk_skel</name>-&gt;<name>children</name>-&gt;<name>data</name></name></expr></argument>,
                                        <argument><expr><name><name>chunk_skel</name>-&gt;<name>children</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Add this chunk to the array. */</comment>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>rep_delta_chunk_t</name> *</expr></argument>)</argument_list></call> = <name>chunk</name></expr>;</expr_stmt>

          <comment type="block">/* Next... */</comment>
          <expr_stmt><expr><name>chunk_skel</name> = <name><name>chunk_skel</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>

      <comment type="block">/* Add the chunks array to the representation. */</comment>
      <expr_stmt><expr><name><name>rep</name>-&gt;<name>contents</name>.<name>delta</name>.<name>chunks</name></name> = <name>chunks</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>rep_p</name> = <name>rep</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_node_revision_skel</name><parameter_list>(<param><decl><type><name>node_revision_t</name> **</type><name>noderev_p</name></decl></param>,
                                      <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>header_skel</name></decl>, *<decl><type ref="prev"/><name>cur_skel</name></decl>;</decl_stmt>

  <comment type="block">/* Validate the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_node_revision_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"node-revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>header_skel</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</expr_stmt>

  <comment type="block">/* Create the returned structure */</comment>
  <expr_stmt><expr><name>noderev</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>noderev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* KIND */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>header_skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"dir"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* CREATED-PATH */</comment>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>created_path</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                         <argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                         <argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* PREDECESSOR-ID */</comment>
  <if>if <condition>(<expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>cur_skel</name> = <name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>cur_skel</name>-&gt;<name>data</name></name></expr></argument>, 
                                                        <argument><expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* PREDECESSOR-COUNT */</comment>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> = -1</expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>cur_skel</name>-&gt;<name>next</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>cur_skel</name> = <name><name>cur_skel</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                             <argument><expr><name><name>cur_skel</name>-&gt;<name>data</name></name></expr></argument>,
                                                             <argument><expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* HAS-MERGEINFO and MERGEINFO-COUNT */</comment>
          <if>if <condition>(<expr><name><name>cur_skel</name>-&gt;<name>next</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>cur_skel</name> = <name><name>cur_skel</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                           <argument><expr><name><name>cur_skel</name>-&gt;<name>data</name></name></expr></argument>,
                                                           <argument><expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> 
                                         ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> = 
                <call><name>apr_atoi64</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                          <argument><expr><name><name>cur_skel</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                          <argument><expr><name><name>cur_skel</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* PROP-KEY */</comment>
  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>prop_key</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                       <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* DATA-KEY */</comment>
  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>data_key</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                       <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* EDIT-DATA-KEY (optional, files only) */</comment>
  <if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>)
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name>
      &amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name>
      = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                       <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>noderev_p</name> = <name>noderev</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_copy_skel</name><parameter_list>(<param><decl><type><name>copy_t</name> **</type><name>copy_p</name></decl></param>,
                             <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>copy_t</name> *</type><name>copy</name></decl>;</decl_stmt>

  <comment type="block">/* Validate the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_copy_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"copy"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the returned structure */</comment>
  <expr_stmt><expr><name>copy</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* KIND */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"soft-copy"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name><name>copy</name>-&gt;<name>kind</name></name> = <name>copy_kind_soft</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>copy</name>-&gt;<name>kind</name></name> = <name>copy_kind_real</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* SRC-PATH */</comment>
  <expr_stmt><expr><name><name>copy</name>-&gt;<name>src_path</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                  <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                  <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* SRC-TXN-ID */</comment>
  <expr_stmt><expr><name><name>copy</name>-&gt;<name>src_txn_id</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                    <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* DST-NODE-ID */</comment>
  <expr_stmt><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name>
    = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                            <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>copy_p</name> = <name>copy</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_entries_skel</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>entries_p</name></decl></param>,
                                <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>elt</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! (<name>len</name> &gt;= 0)</expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"entries"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* Else, allocate a hash and populate it. */</comment>
      <expr_stmt><expr><name>entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check entries are well-formed as we go along. */</comment>
      <for>for (<init><expr><name>elt</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</init> <condition><expr><name>elt</name></expr>;</condition> <incr><expr><name>elt</name> = <name><name>elt</name>-&gt;<name>next</name></name></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>

          <comment type="block">/* ENTRY must be a list of two elements. */</comment>
          <if>if <condition>(<expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then>
            <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"entries"</expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* Get the entry's name and ID. */</comment>
          <expr_stmt><expr><name>name</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>data</name></name></expr></argument>,
                                <argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>id</name> = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                     <argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Add the entry to the hash. */</comment>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>entries_p</name> = <name>entries</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_change_skel</name><parameter_list>(<param><decl><type><name>change_t</name> **</type><name>change_p</name></decl></param>,
                               <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>change_t</name> *</type><name>change</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* Validate the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_change_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"change"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the returned structure */</comment>
  <expr_stmt><expr><name>change</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>change</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* PATH */</comment>
  <expr_stmt><expr><name><name>change</name>-&gt;<name>path</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                                <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NODE-REV-ID */</comment>
  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>change</name>-&gt;<name>noderev_id</name></name> = <call><name>svn_fs_base__id_parse</name>
      <argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>,
       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* KIND */</comment>
  <expr_stmt><expr><name><name>change</name>-&gt;<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>

  <comment type="block">/* TEXT-MOD */</comment>
  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>change</name>-&gt;<name>text_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* PROP-MOD */</comment>
  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>change</name>-&gt;<name>prop_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>change_p</name> = <name>change</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_lock_skel</name><parameter_list>(<param><decl><type><name>svn_lock_t</name> **</type><name>lock_p</name></decl></param>,
                             <param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>timestr</name></decl>;</decl_stmt>

  <comment type="block">/* Validate the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_lock_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"lock"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the returned structure */</comment>
  <expr_stmt><expr><name>lock</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>lock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* PATH */</comment>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>path</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                              <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* LOCK-TOKEN */</comment>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>token</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                               <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                               <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* OWNER */</comment>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>owner</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                               <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                               <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* COMMENT  (could be just an empty atom) */</comment>
  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>comment</name></name> =
      <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                     <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
                     <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* XML_P */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name>
      <argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>is_dav_comment</name></name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>is_dav_comment</name></name> = <name>FALSE</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* CREATION-DATE */</comment>
  <expr_stmt><expr><name>timestr</name> = <call><name>apr_pstrmemdup</name>
    <argument_list>(<argument><expr><name>pool</name></expr></argument>,
     <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
     <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;(<name><name>lock</name>-&gt;<name>creation_date</name></name>)</expr></argument>,
                                <argument><expr><name>timestr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* EXPIRATION-DATE  (could be just an empty atom) */</comment>
  <if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>timestr</name> =
        <call><name>apr_pstrmemdup</name>
        <argument_list>(<argument><expr><name>pool</name></expr></argument>,
         <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
         <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;(<name><name>lock</name>-&gt;<name>expiration_date</name></name>)</expr></argument>,
                                    <argument><expr><name>timestr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Return the structure. */</comment>
  <expr_stmt><expr>*<name>lock_p</name> = <name>lock</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Unparsing (conversion from native FS type to skeleton) ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_proplist_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                                   <param><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <comment type="block">/* Create the skel. */</comment>
  <if>if <condition>(<expr><name>proplist</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Loop over hash entries */</comment>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>proplist</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>value</name> = <name>val</name></expr>;</expr_stmt>

          <comment type="block">/* VALUE */</comment>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>,
                                                     <argument><expr><name><name>value</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* NAME */</comment>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Validate and return the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_proplist_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"proplist"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_revision_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>revision_t</name> *</type><name>revision</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>

  <comment type="block">/* Create the skel. */</comment>
  <expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* TXN_ID */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>revision</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* "revision" */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"revision"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Validate and return the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_revision_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_transaction_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>transaction_t</name> *</type><name>transaction</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>proplist_skel</name></decl>, *<decl><type ref="prev"/><name>copies_skel</name></decl>, *<decl><type ref="prev"/><name>header_skel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>transaction_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* Create the skel. */</comment>
  <expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name><name>transaction</name>-&gt;<name>kind</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>transaction_kind_committed</name></expr>:
      <expr_stmt><expr><name>header_skel</name> = <call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"committed"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name><name>transaction</name>-&gt;<name>base_id</name></name>)
          || (! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
      <break>break;</break>
    </case><case>case <expr><name>transaction_kind_dead</name></expr>:
      <expr_stmt><expr><name>header_skel</name> = <call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"dead"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(! <name><name>transaction</name>-&gt;<name>base_id</name></name>)
          || (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
      <break>break;</break>
    </case><case>case <expr><name>transaction_kind_normal</name></expr>:
      <expr_stmt><expr><name>header_skel</name> = <call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"transaction"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(! <name><name>transaction</name>-&gt;<name>base_id</name></name>)
          || (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
      <break>break;</break>
    </case><default>default:
      <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>


  <comment type="block">/* COPIES */</comment>
  <expr_stmt><expr><name>copies_skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>transaction</name>-&gt;<name>copies</name></name> &amp;&amp; <name><name>transaction</name>-&gt;<name>copies</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>i</name> = <name><name>transaction</name>-&gt;<name>copies</name>-&gt;<name>nelts</name></name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
                               <argument_list>(<argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>copies</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                              <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>copies_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>copies_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* PROPLIST */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__unparse_proplist_skel</name><argument_list>(<argument><expr>&amp;<name>proplist_skel</name></expr></argument>,
                                             <argument><expr><name><name>transaction</name>-&gt;<name>proplist</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>proplist_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* REVISION or BASE-ID */</comment>
  <if>if <condition>(<expr><name><name>transaction</name>-&gt;<name>kind</name></name> == <name>transaction_kind_committed</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Committed transactions have a revision number... */</comment>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
                           <argument_list>(<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>,
                                         <argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* ...where other transactions have a base node revision ID. */</comment>
      <expr_stmt><expr><name>id_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>base_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>len</name></name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* ROOT-ID */</comment>
  <expr_stmt><expr><name>id_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>root_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>len</name></name></expr></argument>,
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* KIND (see above) */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>header_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Validate and return the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_transaction_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><name>kind</name> != <name><name>transaction</name>-&gt;<name>kind</name></name></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_representation_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>representation_t</name> *</type><name>rep</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>header_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/** Some parts of the header are common to all representations; do
      those parts first. **/</comment>

  <comment type="block">/* CHECKSUM */</comment>
  <block>{
    <decl_stmt><decl><type><name>skel_t</name> *</type><name>checksum_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name>
                         <argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>checksum_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"md5"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>checksum_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>checksum_skel</name></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <comment type="block">/* TXN */</comment>
  <if>if <condition>(<expr><name><name>rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/** Do the kind-specific stuff. **/</comment>

  <if>if <condition>(<expr><name><name>rep</name>-&gt;<name>kind</name></name> == <name>rep_kind_fulltext</name></expr>)</condition><then>
    <block>{
      <comment type="block">/*** Fulltext Representation. ***/</comment>

      <comment type="block">/* STRING-KEY */</comment>
      <if>if <condition>(<expr>(! <name><name>rep</name>-&gt;<name>contents</name>.<name>fulltext</name>.<name>string_key</name></name>)
          || (! *<name><name>rep</name>-&gt;<name>contents</name>.<name>fulltext</name>.<name>string_key</name></name>)</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
                             <argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>contents</name>.<name>fulltext</name>.<name>string_key</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <comment type="block">/* "fulltext" */</comment>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"fulltext"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* header */</comment>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>header_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>rep</name>-&gt;<name>kind</name></name> == <name>rep_kind_delta</name></expr>)</condition><then>
    <block>{
      <comment type="block">/*** Delta Representation. ***/</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>chunks</name> <init>= <expr><name><name>rep</name>-&gt;<name>contents</name>.<name>delta</name>.<name>chunks</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Loop backwards through the windows, creating and prepending skels. */</comment>
      <for>for (<init><expr><name>i</name> = <name><name>chunks</name>-&gt;<name>nelts</name></name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>skel_t</name> *</type><name>window_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>skel_t</name> *</type><name>chunk_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>skel_t</name> *</type><name>diff_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>size_str</name></decl>, *<decl><type ref="prev"/><name>offset_str</name></decl>, *<decl><type ref="prev"/><name>version_str</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>rep_delta_chunk_t</name> *</type><name>chunk</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>i</name> - 1</expr></argument>,
                                                   <argument><expr><name>rep_delta_chunk_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <comment type="block">/* OFFSET */</comment>
          <expr_stmt><expr><name>offset_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%" <name>SVN_FILESIZE_T_FMT</name></expr></argument>,
                                    <argument><expr><name><name>chunk</name>-&gt;<name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* SIZE */</comment>
          <expr_stmt><expr><name>size_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%" <name>APR_SIZE_T_FMT</name></expr></argument>, <argument><expr><name><name>chunk</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* VERSION */</comment>
          <expr_stmt><expr><name>version_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name><name>chunk</name>-&gt;<name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* DIFF */</comment>
          <if>if <condition>(<expr>(! <name><name>chunk</name>-&gt;<name>string_key</name></name>) || (! *<name><name>chunk</name>-&gt;<name>string_key</name></name>)</expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>diff_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>chunk</name>-&gt;<name>string_key</name></name></expr></argument>,
                                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>diff_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>version_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>diff_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"svndiff"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>diff_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* REP-KEY */</comment>
          <if>if <condition>(<expr>(! <name><name>chunk</name>-&gt;<name>rep_key</name></name>) || (! *(<name><name>chunk</name>-&gt;<name>rep_key</name></name>))</expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>window_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>chunk</name>-&gt;<name>rep_key</name></name></expr></argument>,
                                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>window_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>size_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>window_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>diff_skel</name></expr></argument>, <argument><expr><name>window_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* window header. */</comment>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>window_skel</name></expr></argument>, <argument><expr><name>chunk_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>offset_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>chunk_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Add this window item to the main skel. */</comment>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>chunk_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

      <comment type="block">/* "delta" */</comment>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"delta"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* header */</comment>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>header_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <comment type="block">/* unknown kind */</comment>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if></else></if>

  <comment type="block">/* Validate and return the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_representation_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"representation"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_node_revision_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                                        <param><decl><type><name>int</name></type> <name>format</name></decl></param>,
                                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>header_skel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>num_str</name></decl>;</decl_stmt>

  <comment type="block">/* Create the skel. */</comment>
  <expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>header_skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Store mergeinfo stuffs only if the schema level supports it. */</comment>
  <if>if <condition>(<expr><name>format</name> &gt;= <name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* MERGEINFO-COUNT */</comment>
      <expr_stmt><expr><name>num_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%" <name>APR_INT64_T_FMT</name></expr></argument>, 
                             <argument><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>num_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 
      <comment type="block">/* HAS-MERGEINFO */</comment>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name> 
                                                 ? "1" : "0"</expr></argument>,
                                                 <argument><expr>1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

      <comment type="block">/* PREDECESSOR-COUNT padding (only if we *don't* have a valid
         value; if we do, we'll pick that up below) */</comment>
      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> == -1</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, 
                               <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* PREDECESSOR-COUNT */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>count_str</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%d"</expr></argument>,
                                           <argument><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>count_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* PREDECESSOR-ID */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= <expr><call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr></argument>,
                                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>len</name></name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* CREATED-PATH */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>created_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* KIND */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"file"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"dir"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if></else></if>

  <comment type="block">/* ### do we really need to check *node-&gt;FOO_key ? if a key doesn't
     ### exist, then the field should be NULL ...  */</comment>

  <comment type="block">/* EDIT-DATA-KEY (optional) */</comment>
  <if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>edit_key</name></name>) &amp;&amp; (*<name><name>noderev</name>-&gt;<name>edit_key</name></name>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* DATA-KEY */</comment>
  <if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>data_key</name></name>) &amp;&amp; (*<name><name>noderev</name>-&gt;<name>data_key</name></name>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* PROP-KEY */</comment>
  <if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>prop_key</name></name>) &amp;&amp; (*<name><name>noderev</name>-&gt;<name>prop_key</name></name>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>prop_key</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* HEADER */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>header_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Validate and return the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_node_revision_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"node-revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_copy_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>copy_t</name> *</type><name>copy</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>tmp_str</name></decl>;</decl_stmt>

  <comment type="block">/* Create the skel. */</comment>
  <expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* DST-NODE-ID */</comment>
  <expr_stmt><expr><name>tmp_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>tmp_str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>tmp_str</name>-&gt;<name>len</name></name></expr></argument>,
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* SRC-TXN-ID */</comment>
  <if>if <condition>(<expr>(<name><name>copy</name>-&gt;<name>src_txn_id</name></name>) &amp;&amp; (*<name><name>copy</name>-&gt;<name>src_txn_id</name></name>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>src_txn_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* SRC-PATH */</comment>
  <if>if <condition>(<expr>(<name><name>copy</name>-&gt;<name>src_path</name></name>) &amp;&amp; (*<name><name>copy</name>-&gt;<name>src_path</name></name>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>src_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* "copy" */</comment>
  <if>if <condition>(<expr><name><name>copy</name>-&gt;<name>kind</name></name> == <name>copy_kind_real</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"copy"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"soft-copy"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* Validate and return the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_copy_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"copy"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_entries_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                                  <param><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <comment type="block">/* Create the skel. */</comment>
  <if>if <condition>(<expr><name>entries</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Loop over hash entries */</comment>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>value</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>skel_t</name> *</type><name>entry_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>value</name> = <name>val</name></expr>;</expr_stmt>

          <comment type="block">/* VALUE */</comment>
          <expr_stmt><expr><name>id_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>,
                                                     <argument><expr><name><name>id_str</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>entry_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* NAME */</comment>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>entry_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Add entry to the entries skel. */</comment>
          <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>entry_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Return the skel. */</comment>
  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_change_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>change_t</name> *</type><name>change</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>tmp_str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* Create the skel. */</comment>
  <expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* PROP-MOD */</comment>
  <if>if <condition>(<expr><name><name>change</name>-&gt;<name>prop_mod</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"1"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* TEXT-MOD */</comment>
  <if>if <condition>(<expr><name><name>change</name>-&gt;<name>text_mod</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"1"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* KIND */</comment>
  <switch>switch <condition>(<expr><name><name>change</name>-&gt;<name>kind</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_fs_path_change_reset</name></expr>:
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"reset"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_fs_path_change_add</name></expr>:
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"add"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_fs_path_change_delete</name></expr>:
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"delete"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_fs_path_change_replace</name></expr>:
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"replace"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_fs_path_change_modify</name></expr>:
    </case><default>default:
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"modify"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </default>}</block></switch>

  <comment type="block">/* NODE-REV-ID */</comment>
  <if>if <condition>(<expr><name><name>change</name>-&gt;<name>noderev_id</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>tmp_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>noderev_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>tmp_str</name>-&gt;<name>data</name></name></expr></argument>,
                                                 <argument><expr><name><name>tmp_str</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* PATH */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* "change" */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"change"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Validate and return the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_change_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"change"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><name>kind</name> != <name><name>change</name>-&gt;<name>kind</name></name></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"change"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_lock_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>svn_lock_t</name> *</type><name>lock</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>

  <comment type="block">/* Create the skel. */</comment>
  <expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* EXP-DATE is optional.  If not present, just use an empty atom. */</comment>
  <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>expiration_date</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name>
      <argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
       <argument_list>(<argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>expiration_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* CREATION-DATE */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name>
    <argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
     <argument_list>(<argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>creation_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* XML_P */</comment>
  <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>is_dav_comment</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"1"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"0"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* COMMENT */</comment>
  <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>comment</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>comment</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* OWNER */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>owner</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* LOCK-TOKEN */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>token</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* PATH */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* "lock" */</comment>
  <expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"lock"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Validate and return the skel. */</comment>
  <if>if <condition>(<expr>! <call><name>is_valid_lock_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"lock"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
