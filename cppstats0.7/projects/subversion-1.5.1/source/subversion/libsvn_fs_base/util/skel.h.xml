<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_base/util/skel.h"><comment type="block">/* skel.h : interface to `skeleton' functions
 *
 * ====================================================================
 * Copyright (c) 2000-2004 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SVN_LIBSVN_FS_SKEL_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LIBSVN_FS_SKEL_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<escape char="0xc"/>
<comment type="block">/* What is a skel?  */</comment>

<comment type="block">/* Subversion needs to read a lot of structured data from database
   records.  Instead of writing a half-dozen parsers and getting lazy
   about error-checking, we define a reasonably dense, open-ended
   syntax for strings and lists, and then use that for the concrete
   representation of files, directories, property lists, etc.  This
   lets us handle all the fussy character-by-character testing and
   sanity checks all in one place, allowing the users of this library
   to focus on higher-level consistency.

   A `skeleton' (or `skel') is either an atom, or a list.  A list may
   contain zero or more elements, each of which may be an atom or a
   list.

   Here's a description of the syntax of a skel:

   A "whitespace" byte is either 9, 10, 12, 13, or 32 (ASCII tab,
   newline, form feed, and space).

   A "digit" byte is 48 -- 57 (ASCII digits).

   A "name" byte is 65 -- 90, or 97 -- 122 (ASCII upper- and
   lower-case characters).

   An atom has one the following two forms:
   - any string of bytes whose first byte is a name character, and
     which contains no whitespace characters, bytes 40 (ASCII '(') or
     bytes 41 (ASCII ')') (`implicit-length form'), or
   - a string of digit bytes, followed by exactly one whitespace
     character, followed by N bytes, where N is the value of the digit
     bytes as a decimal number (`explicit-length form').

   In the first case, the `contents' of the atom are the entire string
   of characters.  In the second case, the contents of the atom are
   the N bytes after the count and whitespace.

   A list consists of a byte 40 (ASCII '('), followed by a series of
   atoms or lists, followed by a byte 41 (ASCII ')').  There may be
   zero or more whitespace characters after the '(' and before the
   ')', and between any pair of elements.  If two consecutive elements
   are atoms, they must be separated by at least one whitespace
   character.  */</comment>

<escape char="0xc"/>
<comment type="block">/* The `skel' structure.  */</comment>

<comment type="block">/* A structure representing the results of parsing an array of bytes
   as a skel.  */</comment>
<struct>struct <name>skel_t</name> <block>{

  <comment type="block">/* True if the string was an atom, false if it was a list.

     If the string is an atom, DATA points to the beginning of its
     contents, and LEN gives the content length, in bytes.

     If the string is a list, DATA and LEN delimit the entire body of
     the list.  */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_atom</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* If the string is a list, CHILDREN is a pointer to a
     null-terminated linked list of skel objects representing the
     elements of the list, linked through their NEXT pointers.  */</comment>
  <decl_stmt><decl><type>struct <name>skel_t</name> *</type><name>children</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>skel_t</name> *</type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>
<typedef>typedef <type>struct <name>skel_t</name></type> <name>skel_t</name>;</typedef>


<escape char="0xc"/>
<comment type="block">/* Operations on skels.  */</comment>


<comment type="block">/* Parse the LEN bytes at DATA as the concrete representation of a
   skel, and return a skel object allocated from POOL describing its
   contents.  If the data is not a properly-formed SKEL object, return
   zero.

   The returned skel objects point into the block indicated by DATA
   and LEN; we don't copy the contents. */</comment>
<function_decl><type><name>skel_t</name> *</type><name>svn_fs_base__parse_skel</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Create an atom skel whose contents are the C string STR, allocated
   from POOL.  */</comment>
<function_decl><type><name>skel_t</name> *</type><name>svn_fs_base__str_atom</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Create an atom skel whose contents are the LEN bytes at ADDR,
   allocated from POOL.  */</comment>
<function_decl><type><name>skel_t</name> *</type><name>svn_fs_base__mem_atom</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>addr</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Create an empty list skel, allocated from POOL.  */</comment>
<function_decl><type><name>skel_t</name> *</type><name>svn_fs_base__make_empty_list</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Prepend SKEL to LIST.  */</comment>
<function_decl><type><name>void</name></type> <name>svn_fs_base__prepend</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>skel_t</name> *</type><name>list</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Append SKEL to LIST.  This is not as efficient as prepending skels,
   so prepend in places where you can sensibly do so, and you want to
   save a couple clock cycles. */</comment>
<function_decl><type><name>void</name></type> <name>svn_fs_base__append</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>skel_t</name> *</type><name>list</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Return a string whose contents are a concrete representation of
   SKEL.  Allocate the string from POOL.  */</comment>
<function_decl><type><name>svn_stringbuf_t</name> *</type><name>svn_fs_base__unparse_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Return true iff SKEL is an atom whose data is the same as STR.  */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_fs_base__matches_atom</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Return true iff SKEL is an atom whose data is the same as STR.  */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_fs_base__atom_matches_string</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Return the length of the list skel SKEL.  Atoms have a length of -1.  */</comment>
<function_decl><type><name>int</name></type> <name>svn_fs_base__list_length</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Return TRUE if SKEL1 and SKEL2 are the same in structure and contents,
   or 0 if they are not.  This is like a lisp `equal' not `eq': atoms
   are equal if their lengths and contents are the same, lists are
   equal if they have the same number and order of equal elements. */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_fs_base__skels_are_equal</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel1</name></decl></param>, <param><decl><type><name>skel_t</name> *</type><name>skel2</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Make a copy of SKEL and its data in POOL.  */</comment>
<function_decl><type><name>skel_t</name> *</type><name>svn_fs_base__copy_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_LIBSVN_FS_SKEL_H */</comment>
</unit>
