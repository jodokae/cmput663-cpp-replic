<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_base/fs.h"><comment type="block">/* fs.h : interface to Subversion filesystem, private to libsvn_fs
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SVN_LIBSVN_FS_BASE_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_LIBSVN_FS_BASE_H</name></cpp:macro></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APU_WANT_DB</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apu_want.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bdb/env.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<escape char="0xc"/>
<comment type="block">/*** Filesystem schema versions ***/</comment>

<comment type="block">/* The format number of this filesystem.  This is independent of the
   repository format number, and independent of any other FS back
   ends.  See the SVN_FS_BASE__MIN_*_FORMAT defines to get a sense of
   what changes and features were added in which versions of this
   back-end's format.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_FS_BASE__FORMAT_NUMBER</name></cpp:macro>                <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Minimum format number that supports node-origins tracking */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_FS_BASE__MIN_NODE_ORIGINS_FORMAT</name></cpp:macro>      <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Minimum format number that supports mergeinfo */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></cpp:macro>         <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Minimum format number that supports svndiff version 1.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_FS_BASE__MIN_SVNDIFF1_FORMAT</name></cpp:macro>          <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* Return SVN_ERR_UNSUPPORTED_FEATURE if the version of filesystem FS does
   not indicate support for FEATURE (which REQUIRES a newer version). */</comment>
<function_decl><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__test_required_feature_format</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, 
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>feature</name></decl></param>, 
                                          <param><decl><type><name>int</name></type> <name>requires</name></decl></param>)</parameter_list>;</function_decl>


<escape char="0xc"/>
<comment type="block">/*** The filesystem structure.  ***/</comment>

<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* A Berkeley DB environment for all the filesystem's databases.
     This establishes the scope of the filesystem's transactions.  */</comment>
  <decl_stmt><decl><type><name>bdb_env_baton_t</name> *</type><name>bdb</name></decl>;</decl_stmt>

  <comment type="block">/* The filesystem's various tables.  See `structure' for details.  */</comment>
  <decl_stmt><decl><type><name>DB</name> *</type><name>changes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>copies</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>nodes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>representations</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>revisions</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>strings</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>transactions</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>uuids</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>locks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>lock_tokens</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DB</name> *</type><name>node_origins</name></decl>;</decl_stmt>

  <comment type="block">/* A boolean for tracking when we have a live Berkeley DB
     transaction trail alive. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>in_txn_trail</name></decl>;</decl_stmt>

  <comment type="block">/* The filesystem UUID (or NULL if not-yet-known; see svn_fs_get_uuid). */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl>;</decl_stmt>

  <comment type="block">/* The format number of this FS. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>format</name></decl>;</decl_stmt>

}</block></struct></type> <name>base_fs_data_t</name>;</typedef>


<comment type="block">/*** Filesystem Revision ***/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* id of the transaction that was committed to create this
     revision. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>

}</block></struct></type> <name>revision_t</name>;</typedef>


<comment type="block">/*** Transaction Kind ***/</comment>
<typedef>typedef <type><enum>enum
<block>{
  <decl><name>transaction_kind_normal</name> <init>= <expr>1</expr></init></decl>,  <comment type="block">/* normal, uncommitted */</comment>
  <decl><name>transaction_kind_committed</name></decl>,   <comment type="block">/* committed */</comment>
  <decl><name>transaction_kind_dead</name></decl>         <comment type="block">/* uncommitted and dead */</comment>

}</block></enum></type> <name>transaction_kind_t</name>;</typedef>


<comment type="block">/*** Filesystem Transaction ***/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* kind of transaction. */</comment>
  <decl_stmt><decl><type><name>transaction_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* revision which this transaction was committed to create, or an
     invalid revision number if this transaction was never committed. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>

  <comment type="block">/* property list (const char * name, svn_string_t * value).
     may be NULL if there are no properties.  */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>

  <comment type="block">/* node revision id of the root node.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>root_id</name></decl>;</decl_stmt>

  <comment type="block">/* node revision id of the node which is the root of the revision
     upon which this txn is base.  (unfinished only) */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>base_id</name></decl>;</decl_stmt>

  <comment type="block">/* copies list (const char * copy_ids), or NULL if there have been
     no copies in this transaction.  */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>copies</name></decl>;</decl_stmt>

}</block></struct></type> <name>transaction_t</name>;</typedef>


<comment type="block">/*** Node-Revision ***/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* node kind */</comment>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* predecessor node revision id, or NULL if there is no predecessor
     for this node revision */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>predecessor_id</name></decl>;</decl_stmt>

  <comment type="block">/* number of predecessors this node revision has (recursively), or
     -1 if not known (for backward compatibility). */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>predecessor_count</name></decl>;</decl_stmt>

  <comment type="block">/* representation key for this node's properties.  may be NULL if
     there are no properties.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_key</name></decl>;</decl_stmt>

  <comment type="block">/* representation key for this node's text data (files) or entries
     list (dirs).  may be NULL if there are no contents.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data_key</name></decl>;</decl_stmt>

  <comment type="block">/* representation key for this node's text-data-in-progess (files
     only).  NULL if no edits are currently in-progress.  This field
     is always NULL for kinds other than "file".  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_key</name></decl>;</decl_stmt>

  <comment type="block">/* path at which this node first came into existence.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>created_path</name></decl>;</decl_stmt>

  <comment type="block">/* does this node revision have the mergeinfo tracking property set
     on it?  (only valid for FS schema 3 and newer) */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl>;</decl_stmt>

  <comment type="block">/* number of children of this node which have the mergeinfo tracking
     property set  (0 for files; valid only for FS schema 3 and newer). */</comment>
  <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_count</name></decl>;</decl_stmt>

}</block></struct></type> <name>node_revision_t</name>;</typedef>


<comment type="block">/*** Representation Kind ***/</comment>
<typedef>typedef <type><enum>enum
<block>{
  <decl><name>rep_kind_fulltext</name> <init>= <expr>1</expr></init></decl>, <comment type="block">/* fulltext */</comment>
  <decl><name>rep_kind_delta</name></decl>         <comment type="block">/* delta */</comment>

}</block></enum></type> <name>rep_kind_t</name>;</typedef>


<comment type="block">/*** "Delta" Offset/Window Chunk ***/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* diff format version number ### at this point, "svndiff" is the
     only format used. */</comment>
  <decl_stmt><decl><type><name>apr_byte_t</name></type> <name>version</name></decl>;</decl_stmt>

  <comment type="block">/* starting offset of the data represented by this chunk */</comment>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>offset</name></decl>;</decl_stmt>

  <comment type="block">/* string-key to which this representation points. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string_key</name></decl>;</decl_stmt>

  <comment type="block">/* size of the fulltext data represented by this delta window. */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>size</name></decl>;</decl_stmt>

  <comment type="block">/* representation-key to use when needed source data for
     undeltification. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rep_key</name></decl>;</decl_stmt>

  <comment type="block">/* apr_off_t rep_offset;  ### not implemented */</comment>

}</block></struct></type> <name>rep_delta_chunk_t</name>;</typedef>


<comment type="block">/*** Representation ***/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* representation kind */</comment>
  <decl_stmt><decl><type><name>rep_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* transaction ID under which representation was created (used as a
     mutability flag when compared with a current editing
     transaction). */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>

  <comment type="block">/* MD5 checksum for the contents produced by this representation.
     This checksum is for the contents the rep shows to consumers,
     regardless of how the rep stores the data under the hood.  It is
     independent of the storage (fulltext, delta, whatever).

     If all the bytes are 0, then for compatibility behave as though
     this checksum matches the expected checksum. */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>checksum</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* kind-specific stuff */</comment>
  <union>union
  <block>{
    <comment type="block">/* fulltext stuff */</comment>
    <struct>struct
    <block>{
      <comment type="block">/* string-key which holds the fulltext data */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string_key</name></decl>;</decl_stmt>

    }</block> <decl><name>fulltext</name></decl>;</struct>

    <comment type="block">/* delta stuff */</comment>
    <struct>struct
    <block>{
      <comment type="block">/* an array of rep_delta_chunk_t * chunks of delta
         information */</comment>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>chunks</name></decl>;</decl_stmt>

    }</block> <decl><name>delta</name></decl>;</struct>
  }</block> <decl><name>contents</name></decl>;</union>
}</block></struct></type> <name>representation_t</name>;</typedef>


<comment type="block">/*** Copy Kind ***/</comment>
<typedef>typedef <type><enum>enum
<block>{
  <decl><name>copy_kind_real</name> <init>= <expr>1</expr></init></decl>, <comment type="block">/* real copy */</comment>
  <decl><name>copy_kind_soft</name></decl>      <comment type="block">/* soft copy */</comment>

}</block></enum></type> <name>copy_kind_t</name>;</typedef>


<comment type="block">/*** Copy ***/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* What kind of copy occurred. */</comment>
  <decl_stmt><decl><type><name>copy_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* Path of copy source. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_path</name></decl>;</decl_stmt>

  <comment type="block">/* Transaction id of copy source. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_txn_id</name></decl>;</decl_stmt>

  <comment type="block">/* Node-revision of copy destination. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>dst_noderev_id</name></decl>;</decl_stmt>

}</block></struct></type> <name>copy_t</name>;</typedef>


<comment type="block">/*** Change ***/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* Path of the change. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* Node revision ID of the change. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>noderev_id</name></decl>;</decl_stmt>

  <comment type="block">/* The kind of change. */</comment>
  <decl_stmt><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* Text or property mods? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_mod</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>prop_mod</name></decl>;</decl_stmt>

}</block></struct></type> <name>change_t</name>;</typedef>


<comment type="block">/*** Lock node ***/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* entries list, maps (const char *) name --&gt; (const char *) lock-node-id */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>

  <comment type="block">/* optional lock-token, might be NULL. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl>;</decl_stmt>

}</block></struct></type> <name>lock_node_t</name>;</typedef>


<escape char="0xc"/>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_LIBSVN_FS_BASE_H */</comment>
</unit>
