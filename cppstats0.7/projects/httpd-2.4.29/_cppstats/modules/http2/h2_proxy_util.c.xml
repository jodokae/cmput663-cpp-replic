<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="modules/http2/h2_proxy_util.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_mutex.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_cond.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_request.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mod_proxy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nghttp2/nghttp2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_proxy_util.h"</cpp:file></cpp:include>
<expr_stmt><expr><call><name>APLOG_USE_MODULE</name><argument_list>(<argument><expr><name>proxy_http2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>unsigned</name> <name>char</name></type> <name>h2_proxy_log2</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>lz</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>n</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0xffff0000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 16</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 16)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0xff000000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 8</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 8)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0xf0000000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 4</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 4)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0xc0000000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 2)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0x80000000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 1</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>31 - <name>lz</name></expr>;</return>
}</block></function>
<struct>struct <name>h2_proxy_ihash_t</name> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ioff</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>ihash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><name>apr_ssize_t</name> *</type><name>klen</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call>(<name>unsigned</name> <name>int</name>)<argument_list>(<argument><expr>*((<name>int</name>*)<name>key</name>)</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>h2_proxy_ihash_t</name> *</type><name>h2_proxy_ihash_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>offset_of_int</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_proxy_ihash_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ih</name>-&gt;<name>hash</name></name> = <call><name>apr_hash_make_custom</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>ihash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ih</name>-&gt;<name>ioff</name></name> = <name>offset_of_int</name></expr>;</expr_stmt>
<return>return <expr><name>ih</name></expr>;</return>
}</block></function>
<function><type><name>size_t</name></type> <name>h2_proxy_ihash_count</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_ihash_empty</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>
<function><type><name>void</name> *</type><name>h2_proxy_ihash_get</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>h2_proxy_ihash_iter_t</name> *</type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>iter_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ihash_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>iter_ctx</name> *</type><name>ictx</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>ictx</name>-&gt;<name>iter</name></name><argument_list>(<argument><expr><name><name>ictx</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_ihash_iter</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>h2_proxy_ihash_iter_t</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>iter_ctx</name></type> <name>ictx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ictx</name>.<name>iter</name></name> = <name>fn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ictx</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
<return>return <expr><call><name>apr_hash_do</name><argument_list>(<argument><expr><name>ihash_iter</name></expr></argument>, <argument><expr>&amp;<name>ictx</name></expr></argument>, <argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_proxy_ihash_add</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>, <argument><expr>((<name>char</name> *)<name>val</name> + <name><name>ih</name>-&gt;<name>ioff</name></name>)</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>h2_proxy_ihash_remove</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>h2_proxy_ihash_remove_val</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr>*(<call>(<name>int</name>*)<argument_list>(<argument><expr>(<name>char</name> *)<name>val</name> + <name><name>ih</name>-&gt;<name>ioff</name></name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>h2_proxy_ihash_clear</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>apr_hash_clear</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> **</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>collect_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>collect_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>x</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>collect_ctx</name> *</type><name>ctx</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>len</name></name> &lt; <name><name>ctx</name>-&gt;<name>max</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>buffer</name><index>[<expr><name><name>ctx</name>-&gt;<name>len</name></name>++</expr>]</index></name> = <name>val</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>size_t</name></type> <name>h2_proxy_ihash_shift</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> **</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>max</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>collect_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>ih</name></name> = <name>ih</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>buffer</name></name> = <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>max</name></name> = <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>len</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_proxy_ihash_iter</name><argument_list>(<argument><expr><name>ih</name></expr></argument>, <argument><expr><name>collect_iter</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ctx</name>.<name>len</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><call><name>h2_proxy_ihash_remove_val</name><argument_list>(<argument><expr><name>ih</name></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name><name>ctx</name>.<name>len</name></name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>icollect_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>icollect_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>x</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>icollect_ctx</name> *</type><name>ctx</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>len</name></name> &lt; <name><name>ctx</name>-&gt;<name>max</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>buffer</name><index>[<expr><name><name>ctx</name>-&gt;<name>len</name></name>++</expr>]</index></name> = *(<call>(<name>int</name>*)<argument_list>(<argument><expr>(<name>char</name> *)<name>val</name> + <name><name>ctx</name>-&gt;<name>ih</name>-&gt;<name>ioff</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>size_t</name></type> <name>h2_proxy_ihash_ishift</name><parameter_list>(<param><decl><type><name>h2_proxy_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>int</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>max</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>icollect_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>ih</name></name> = <name>ih</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>buffer</name></name> = <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>max</name></name> = <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>len</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_proxy_ihash_iter</name><argument_list>(<argument><expr><name>ih</name></expr></argument>, <argument><expr><name>icollect_iter</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ctx</name>.<name>len</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><call><name>h2_proxy_ihash_remove</name><argument_list>(<argument><expr><name>ih</name></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name><name>ctx</name>.<name>len</name></name></expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>iq_grow</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>nlen</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>iq_swap</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>j</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iq_bubble_up</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>top</name></decl></param>,
<param><decl><type><name>h2_proxy_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iq_bubble_down</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>bottom</name></decl></param>,
<param><decl><type><name>h2_proxy_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<function><type><name>h2_proxy_iqueue</name> *</type><name>h2_proxy_iq_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_proxy_iqueue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>q</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>q</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iq_grow</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>nelts</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>q</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_iq_empty</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>q</name>-&gt;<name>nelts</name></name> == 0</expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_iq_count</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>q</name>-&gt;<name>nelts</name></name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_proxy_iq_add</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>, <param><decl><type><name>h2_proxy_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>q</name>-&gt;<name>nelts</name></name> &gt;= <name><name>q</name>-&gt;<name>nalloc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>iq_grow</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>nalloc</name></name> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>i</name> = (<name><name>q</name>-&gt;<name>head</name></name> + <name><name>q</name>-&gt;<name>nelts</name></name>) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name> = <name>sid</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>q</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cmp</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>iq_bubble_up</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_iq_remove</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>sid</name> == <name><name>q</name>-&gt;<name>elts</name><index>[<expr>(<name><name>q</name>-&gt;<name>head</name></name> + <name>i</name>) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>]</index></name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>i</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr>(<name><name>q</name>-&gt;<name>head</name></name>+<name>i</name>-1)%<name><name>q</name>-&gt;<name>nalloc</name></name></expr>]</index></name> = <name><name>q</name>-&gt;<name>elts</name><index>[<expr>(<name><name>q</name>-&gt;<name>head</name></name>+<name>i</name>)%<name><name>q</name>-&gt;<name>nalloc</name></name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>--<name><name>q</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_proxy_iq_clear</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>q</name>-&gt;<name>nelts</name></name> = 0</expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>h2_proxy_iq_sort</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>h2_proxy_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>q</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ni</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
<expr_stmt><expr><name>last</name> = <name>i</name> = (<name><name>q</name>-&gt;<name>head</name></name> + <name><name>q</name>-&gt;<name>nelts</name></name> - 1) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> != <name><name>q</name>-&gt;<name>head</name></name></expr>)</condition> <block>{
<expr_stmt><expr><name>prev</name> = (<name><name>q</name>-&gt;<name>nalloc</name></name> + <name>i</name> - 1) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ni</name> = <call><name>iq_bubble_up</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ni</name> == <name>prev</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>iq_bubble_down</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>i</name> = <name>prev</name></expr>;</expr_stmt>
}</block></while><empty_stmt>;</empty_stmt>
}</block></then></if>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_iq_shift</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sid</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>q</name>-&gt;<name>nelts</name></name> &lt;= 0</expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>sid</name> = <name><name>q</name>-&gt;<name>elts</name><index>[<expr><name><name>q</name>-&gt;<name>head</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>head</name></name> = (<name><name>q</name>-&gt;<name>head</name></name> + 1) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>nelts</name></name>--</expr>;</expr_stmt>
<return>return <expr><name>sid</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>iq_grow</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>nlen</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>nlen</name> &gt; <name><name>q</name>-&gt;<name>nalloc</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name> *</type><name>nq</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>q</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * <name>nlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>q</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr>((<name><name>q</name>-&gt;<name>head</name></name> + <name><name>q</name>-&gt;<name>nelts</name></name>) % <name><name>q</name>-&gt;<name>nalloc</name></name>) - <name><name>q</name>-&gt;<name>head</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>nq</name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>elts</name></name> + <name><name>q</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>l</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>remain</name> <init>= <expr><name><name>q</name>-&gt;<name>nelts</name></name> - <name>l</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>nq</name> + <name>l</name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * <name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name></name> = <name>nq</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>nalloc</name></name> = <name>nlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>head</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>iq_swap</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>j</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>j</name></expr>]</index></name> = <name>x</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iq_bubble_up</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>top</name></decl></param>,
<param><decl><type><name>h2_proxy_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>prev</name></decl>;</decl_stmt>
<while>while <condition>(<expr>((<name>prev</name> = (<name><name>q</name>-&gt;<name>nalloc</name></name> + <name>i</name> - 1) % <name><name>q</name>-&gt;<name>nalloc</name></name>), <name>i</name> != <name>top</name>)
&amp;&amp; <call>(*<name>cmp</name>)<argument_list>(<argument><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>prev</name></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>iq_swap</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>prev</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>i</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iq_bubble_down</name><parameter_list>(<param><decl><type><name>h2_proxy_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>bottom</name></decl></param>,
<param><decl><type><name>h2_proxy_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>;</decl_stmt>
<while>while <condition>(<expr>((<name>next</name> = (<name><name>q</name>-&gt;<name>nalloc</name></name> + <name>i</name> + 1) % <name><name>q</name>-&gt;<name>nalloc</name></name>), <name>i</name> != <name>bottom</name>)
&amp;&amp; <call>(*<name>cmp</name>)<argument_list>(<argument><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>next</name></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>iq_swap</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>next</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>i</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_HD_MATCH_LIT_CS</name><parameter_list>(<param><type><name>l</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((strlen(name) == sizeof(l) - 1) &amp;&amp; !apr_strnatcasecmp(l, name))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>h2_util_ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"connection"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| <call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"proxy-connection"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| <call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"upgrade"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| <call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"keep-alive"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| <call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"transfer-encoding"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>count_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>h2_util_ignore_header</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>(*((<name>size_t</name>*)<name>ctx</name>))++</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NV_ADD_LIT_CS</name><parameter_list>(<param><type><name>nv</name></type></param>, <param><type><name>k</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>add_header(nv, k, sizeof(k) - 1, v, strlen(v))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NV_ADD_CS_CS</name><parameter_list>(<param><type><name>nv</name></type></param>, <param><type><name>k</name></type></param>, <param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>add_header(nv, k, strlen(k), v, strlen(v))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>add_header</name><parameter_list>(<param><decl><type><name>h2_proxy_ngheader</name> *</type><name>ngh</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>key_len</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>val_len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nghttp2_nv</name> *</type><name>nv</name> <init>= <expr>&amp;<name><name>ngh</name>-&gt;<name>nv</name><index>[<expr><name><name>ngh</name>-&gt;<name>nvlen</name></name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>nv</name>-&gt;<name>name</name></name> = (<name>uint8_t</name>*)<name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nv</name>-&gt;<name>namelen</name></name> = <name>key_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nv</name>-&gt;<name>value</name></name> = (<name>uint8_t</name>*)<name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nv</name>-&gt;<name>valuelen</name></name> = <name>val_len</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>add_table_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>h2_util_ignore_header</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>add_header</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><name>h2_proxy_ngheader</name> *</type><name>h2_proxy_util_nghd_make_req</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>h2_proxy_request</name> *</type><name>req</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_proxy_ngheader</name> *</type><name>ngh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>authority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = 4</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>count_header</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>headers</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ngh</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_proxy_ngheader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ngh</name>-&gt;<name>nv</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>nghttp2_nv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NV_ADD_LIT_CS</name><argument_list>(<argument><expr><name>ngh</name></expr></argument>, <argument><expr>":scheme"</expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NV_ADD_LIT_CS</name><argument_list>(<argument><expr><name>ngh</name></expr></argument>, <argument><expr>":authority"</expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>authority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NV_ADD_LIT_CS</name><argument_list>(<argument><expr><name>ngh</name></expr></argument>, <argument><expr>":path"</expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>NV_ADD_LIT_CS</name><argument_list>(<argument><expr><name>ngh</name></expr></argument>, <argument><expr>":method"</expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>add_table_header</name></expr></argument>, <argument><expr><name>ngh</name></expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>headers</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ngh</name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>literal</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_DEF_LITERAL</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ (n), (sizeof(n)-1) }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_LIT_ARGS</name><parameter_list>(<param><type><name>a</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(a),H2_ALEN(a)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>literal</name></type> <name><name>IgnoredRequestHeaders</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"upgrade"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"connection"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"keep-alive"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"http2-settings"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"proxy-connection"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"transfer-encoding"</expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>literal</name></type> <name><name>IgnoredProxyRespHds</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"alt-svc"</expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>literal</name> *</type><name>lits</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>llen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>literal</name> *</type><name>lit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>llen</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>lit</name> = &amp;<name><name>lits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lit</name>-&gt;<name>len</name></name> == <name>nlen</name> &amp;&amp; !<call><name>apr_strnatcasecmp</name><argument_list>(<argument><expr><name><name>lit</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>h2_proxy_req_ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ignore_header</name><argument_list>(<argument><expr><call><name>H2_LIT_ARGS</name><argument_list>(<argument><expr><name>IgnoredRequestHeaders</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_res_ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<call><name>h2_proxy_req_ignore_header</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>
|| <call><name>ignore_header</name><argument_list>(<argument><expr><call><name>H2_LIT_ARGS</name><argument_list>(<argument><expr><name>IgnoredProxyRespHds</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_proxy_util_camel_case_header</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>start</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>start</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &gt;= 'a' &amp;&amp; <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &lt;= 'z'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> -= 'a' - 'A'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>start</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></for>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_HD_MATCH_LIT</name><parameter_list>(<param><type><name>l</name></type></param>, <param><type><name>name</name></type></param>, <param><type><name>nlen</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((nlen == sizeof(l) - 1) &amp;&amp; !apr_strnatcasecmp(l, name))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>h2_headers_add_h1</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nlen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>vlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>hname</name></decl>, *<decl><type ref="prev"/><name>hvalue</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>h2_proxy_req_ignore_header</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"cookie"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>existing</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"cookie"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>existing</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>nval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>hvalue</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nval</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s; %s"</expr></argument>, <argument><expr><name>existing</name></expr></argument>, <argument><expr><name>hvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"Cookie"</expr></argument>, <argument><expr><name>nval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"host"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"Host"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
}</block></then></if></else></if></else></if>
<expr_stmt><expr><name>hname</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hvalue</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_proxy_util_camel_case_header</name><argument_list>(<argument><expr><name>hname</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>hname</name></expr></argument>, <argument><expr><name>hvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>h2_proxy_request</name> *</type><name>h2_proxy_req_createn</name><parameter_list>(<param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>method</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authority</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_table_t</name> *</type><name>header</name></decl></param>,
<param><decl><type><name>int</name></type> <name>serialize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_proxy_request</name> *</type><name>req</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_proxy_request</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>method</name></name> = <name>method</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>scheme</name></name> = <name>scheme</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>authority</name></name> = <name>authority</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>headers</name></name> = <name>header</name>? <name>header</name> : <call><name>apr_table_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>request_time</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>serialize</name></name> = <name>serialize</name></expr>;</expr_stmt>
<return>return <expr><name>req</name></expr>;</return>
}</block></function>
<function><type><name>h2_proxy_request</name> *</type><name>h2_proxy_req_create</name><parameter_list>(<param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>serialize</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>h2_proxy_req_createn</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>serialize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block></struct></type> <name>h1_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>set_h1_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h1_ctx</name> *</type><name>x</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>klen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>h2_proxy_req_ignore_header</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_headers_add_h1</name><argument_list>(<argument><expr><name><name>x</name>-&gt;<name>headers</name></name></expr></argument>, <argument><expr><name><name>x</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_req_make</name><parameter_list>(<param><decl><type><name>h2_proxy_request</name> *</type><name>req</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>method</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authority</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h1_ctx</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>method</name></name> = <name>method</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>scheme</name></name> = <name>scheme</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>authority</name></name> = <name>authority</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>authority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name>.<name>headers</name></name> = <name><name>req</name>-&gt;<name>headers</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>set_h1_header</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_util_frame_print</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nghttp2_frame</name> *</type><name>frame</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>maxlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>scratch</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>s_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>scratch</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>frame</name>-&gt;<name>hd</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>NGHTTP2_DATA</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"DATA[length=%d, flags=%d, stream=%d, padlen=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>, <argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>data</name>.<name>padlen</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_HEADERS</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"HEADERS[length=%d, hend=%d, stream=%d, eos=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr>!!(<name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name> &amp; <name>NGHTTP2_FLAG_END_HEADERS</name>)</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>,
<argument><expr>!!(<name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name> &amp; <name>NGHTTP2_FLAG_END_STREAM</name>)</expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_PRIORITY</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"PRIORITY[length=%d, flags=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_RST_STREAM</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"RST_STREAM[length=%d, flags=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_SETTINGS</name></expr>: <block>{
<if>if <condition>(<expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name> &amp; <name>NGHTTP2_FLAG_ACK</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"SETTINGS[ack=1, stream=%d]"</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"SETTINGS[length=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_PUSH_PROMISE</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"PUSH_PROMISE[length=%d, hend=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr>!!(<name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name> &amp; <name>NGHTTP2_FLAG_END_HEADERS</name>)</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_PING</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"PING[length=%d, ack=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name>&amp;<name>NGHTTP2_FLAG_ACK</name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_GOAWAY</name></expr>: <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr>(<name><name>frame</name>-&gt;<name>goaway</name>.<name>opaque_data_len</name></name> &lt; <name>s_len</name>)?
<name><name>frame</name>-&gt;<name>goaway</name>.<name>opaque_data_len</name></name> : <name>s_len</name>-1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>goaway</name>.<name>opaque_data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>scratch</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr>"GOAWAY[error=%d, reason='%s', "
"last_stream=%d]"</expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>goaway</name>.<name>error_code</name></name></expr></argument>,
<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>goaway</name>.<name>last_stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_WINDOW_UPDATE</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"WINDOW_UPDATE[stream=%d, incr=%d]"</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>window_update</name>.<name>window_size_increment</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><default>default:
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"type=%d[length=%d, flags=%d, stream=%d]"</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>type</name></name></expr></argument>, <argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>proxy_dir_conf</name> *</type><name>conf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>slen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>server_uri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>su_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>real_backend_uri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rbu_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p_server_uri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>psu_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>link_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>link_end</name></decl>;</decl_stmt>
}</block></struct></type> <name>link_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>attr_char</name><parameter_list>(<param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>'!'</expr>:
</case><case>case <expr>'#'</expr>:
</case><case>case <expr>'$'</expr>:
</case><case>case <expr>'&amp;'</expr>:
</case><case>case <expr>'+'</expr>:
</case><case>case <expr>'-'</expr>:
</case><case>case <expr>'.'</expr>:
</case><case>case <expr>'^'</expr>:
</case><case>case <expr>'_'</expr>:
</case><case>case <expr>'`'</expr>:
</case><case>case <expr>'|'</expr>:
</case><case>case <expr>'~'</expr>:
<return>return <expr>1</expr>;</return>
</case><default>default:
<return>return <expr><call><name>apr_isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ptoken_char</name><parameter_list>(<param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>'!'</expr>:
</case><case>case <expr>'#'</expr>:
</case><case>case <expr>'$'</expr>:
</case><case>case <expr>'&amp;'</expr>:
</case><case>case <expr>'\''</expr>:
</case><case>case <expr>'('</expr>:
</case><case>case <expr>')'</expr>:
</case><case>case <expr>'*'</expr>:
</case><case>case <expr>'+'</expr>:
</case><case>case <expr>'-'</expr>:
</case><case>case <expr>'.'</expr>:
</case><case>case <expr>'/'</expr>:
</case><case>case <expr>':'</expr>:
</case><case>case <expr>'&lt;'</expr>:
</case><case>case <expr>'='</expr>:
</case><case>case <expr>'&gt;'</expr>:
</case><case>case <expr>'?'</expr>:
</case><case>case <expr>'@'</expr>:
</case><case>case <expr>'['</expr>:
</case><case>case <expr>']'</expr>:
</case><case>case <expr>'^'</expr>:
</case><case>case <expr>'_'</expr>:
</case><case>case <expr>'`'</expr>:
</case><case>case <expr>'{'</expr>:
</case><case>case <expr>'|'</expr>:
</case><case>case <expr>'}'</expr>:
</case><case>case <expr>'~'</expr>:
<return>return <expr>1</expr>;</return>
</case><default>default:
<return>return <expr><call><name>apr_isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_ws</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>ctx</name>-&gt;<name>i</name></name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name>
&amp;&amp; (((<name>c</name> = <name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name><name>ctx</name>-&gt;<name>i</name></name></expr>]</index></name>) == ' ') || (<name>c</name> == '\t'))</expr>)</condition> <block>{
<expr_stmt><expr>++<name><name>ctx</name>-&gt;<name>i</name></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr>(<name><name>ctx</name>-&gt;<name>i</name></name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>find_chr</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>char</name></type> <name>c</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pidx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = <name><name>ctx</name>-&gt;<name>i</name></name></expr>;</init> <condition><expr><name>j</name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name>j</name></expr>]</index></name> == <name>c</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pidx</name> = <name>j</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read_chr</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>i</name></name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name> &amp;&amp; <name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name><name>ctx</name>-&gt;<name>i</name></name></expr>]</index></name> == <name>c</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name><name>ctx</name>-&gt;<name>i</name></name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_qstring</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'\"'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>end</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>find_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'\"'</expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = <name>end</name> + 1</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_ptoken</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name><name>ctx</name>-&gt;<name>i</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name> &amp;&amp; <call><name>ptoken_char</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
}</block></for>
<if>if <condition>(<expr><name>i</name> &gt; <name><name>ctx</name>-&gt;<name>i</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = <name>i</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read_link</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>link_start</name></name> = <name><name>ctx</name>-&gt;<name>link_end</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'&lt;'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>end</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>find_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'&gt;'</expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>link_start</name></name> = <name><name>ctx</name>-&gt;<name>i</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>link_end</name></name> = <name>end</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = <name>end</name> + 1</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_pname</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name><name>ctx</name>-&gt;<name>i</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name> &amp;&amp; <call><name>attr_char</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
}</block></for>
<if>if <condition>(<expr><name>i</name> &gt; <name><name>ctx</name>-&gt;<name>i</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = <name>i</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_pvalue</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>skip_qstring</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> || <call><name>skip_ptoken</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_param</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>skip_pname</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>skip_pvalue</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>read_sep</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>subst_str</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>int</name></type> <name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>end</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ns</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>olen</name></decl>, <decl><type ref="prev"/><name>nlen</name></decl>, <decl><type ref="prev"/><name>plen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>delta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>olen</name> = <name>end</name> - <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nlen</name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>delta</name> = <name>nlen</name> - <name>olen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>plen</name> = <name><name>ctx</name>-&gt;<name>slen</name></name> + <name>delta</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>s</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>p</name> + <name>start</name></expr></argument>, <argument><expr><name>ns</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name> + <name>start</name> + <name>nlen</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>s</name></name> + <name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>s</name></name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>slen</name></name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>i</name></name> &gt;= <name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> += <name>delta</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>nlen</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>map_link</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>link_start</name></name> &lt; <name><name>ctx</name>-&gt;<name>link_end</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>HUGE_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_len</name></decl>, <decl><type ref="prev"/><name>link_len</name></decl>, <decl><type ref="prev"/><name>buffer_len</name></decl>, <decl><type ref="prev"/><name>prepend_p_server</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mapped</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>buffer_len</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>link_len</name> = <name><name>ctx</name>-&gt;<name>link_end</name></name> - <name><name>ctx</name>-&gt;<name>link_start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>need_len</name> = <name>link_len</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>prepend_p_server</name> = (<name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name><name>ctx</name>-&gt;<name>link_start</name></name></expr>]</index></name> == '/')</expr>;</expr_stmt>
<if>if <condition>(<expr><name>prepend_p_server</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>need_len</name> += <name><name>ctx</name>-&gt;<name>psu_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p_server_uri</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer_len</name> = <name><name>ctx</name>-&gt;<name>psu_len</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>need_len</name> &gt; <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03482</expr></argument>)</argument_list></call>
"link_reverse_map uri too long, skipped: %s"</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name> + <name>buffer_len</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>s</name></name> + <name><name>ctx</name>-&gt;<name>link_start</name></name></expr></argument>, <argument><expr><name>link_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer_len</name> += <name>link_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>buffer_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>prepend_p_server</name>
&amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>real_backend_uri</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p_server_uri</name></name></expr></argument>)</argument_list></call>
&amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>real_backend_uri</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>rbu_len</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>path_start</name> <init>= <expr><name><name>ctx</name>-&gt;<name>link_start</name></name> + <name><name>ctx</name>-&gt;<name>rbu_len</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>link_len</name> -= <name><name>ctx</name>-&gt;<name>rbu_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p_server_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name> + <name><name>ctx</name>-&gt;<name>psu_len</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>s</name></name> + <name>path_start</name></expr></argument>, <argument><expr><name>link_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer_len</name> = <name><name>ctx</name>-&gt;<name>psu_len</name></name> + <name>link_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>buffer_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>mapped</name> = <call><name>ap_proxy_location_reverse_map</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>conf</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>,
<argument><expr>"reverse_map[%s] %s --&gt; %s"</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p_server_uri</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>mapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mapped</name> != <name>buffer</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>prepend_p_server</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>server_uri</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>server_uri</name></name> = <call><name>ap_construct_url</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>su_len</name></name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>server_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>mapped</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>server_uri</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>su_len</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>mapped</name> += <name><name>ctx</name>-&gt;<name>su_len</name></name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>subst_str</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>link_start</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>link_end</name></name></expr></argument>, <argument><expr><name>mapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type><name>h2_proxy_link_reverse_map</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
<param><decl><type><name>proxy_dir_conf</name> *</type><name>conf</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>real_backend_uri</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proxy_server_uri</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>link_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>r</name>-&gt;<name>proxyreq</name></name> != <name>PROXYREQ_REVERSE</name></expr>)</condition><then> <block>{
<return>return <expr><name>s</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>conf</name></name> = <name>conf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>real_backend_uri</name></name> = <name>real_backend_uri</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>rbu_len</name></name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name>.<name>real_backend_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>p_server_uri</name></name> = <name>proxy_server_uri</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>psu_len</name></name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name>.<name>p_server_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>s</name></name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>slen</name></name> = (<name>int</name>)<call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>read_link</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<while>while <condition>(<expr><call><name>skip_param</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
}</block></while>
<expr_stmt><expr><call><name>map_link</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>read_sep</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
}</block></while>
<expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
<argument><expr>"link_reverse_map %s --&gt; %s"</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>ctx</name>.<name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ctx</name>.<name>s</name></name></expr>;</return>
}</block></function>
<struct>struct <name>h2_proxy_fifo</name> <block>{
<decl_stmt><decl><type><name>void</name> **</type><name>elems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nelems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>aborted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_cond_t</name> *</type><name>not_empty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_cond_t</name> *</type><name>not_full</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nth_index</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name><name>fifo</name>-&gt;<name>head</name></name> + <name>n</name>) % <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fifo_destroy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_of</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>fifo</name>-&gt;<name>count</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>elem</name> == <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><then> <block>{
<return>return <expr><name>i</name></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>create_int</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><name>int</name></type> <name>capacity</name></decl></param>, <param><decl><type><name>int</name></type> <name>as_set</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fifo</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>fifo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fifo</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>,
<argument><expr><name>APR_THREAD_MUTEX_UNNESTED</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>elems</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>nelems</name></name> = <name>capacity</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>set</name></name> = <name>as_set</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pfifo</name> = <name>fifo</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>fifo_destroy</name></expr></argument>, <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_create</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>create_int</name><argument_list>(<argument><expr><name>pfifo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_set_create</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>create_int</name><argument_list>(<argument><expr><name>pfifo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_term</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_interrupt</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_fifo_count</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>fifo</name>-&gt;<name>count</name></name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_proxy_fifo_capacity</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>fifo</name>-&gt;<name>nelems</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>check_not_empty</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>block</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EAGAIN</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == 0</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fifo_push</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>set</name></name> &amp;&amp; <call><name>index_of</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_EEXIST</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>block</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_EAGAIN</name></expr>;</return>
}</block></else></if>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>count</name></name> &lt; <name><name>fifo</name>-&gt;<name>nelems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>count</name></name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>elem</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>fifo</name>-&gt;<name>count</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_push</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_push</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_try_push</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_push</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> *</type><name>pull_head</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>elem</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>count</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>elem</name> = <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><name><name>fifo</name>-&gt;<name>head</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>--<name><name>fifo</name>-&gt;<name>count</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>head</name></name> = <call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name>+1 == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>elem</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fifo_pull</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>rv</name> = <call><name>check_not_empty</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pelem</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>count</name></name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pelem</name> = <call><name>pull_head</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_pull</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_pull</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>pelem</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_try_pull</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_pull</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>pelem</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_proxy_fifo_remove</name><parameter_list>(<param><decl><type><name>h2_proxy_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>fifo</name>-&gt;<name>count</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>e</name> = <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>e</name> == <name>elem</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>rc</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name>-<name>rc</name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>e</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></for>
<if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>count</name></name> -= <name>rc</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> + <name>rc</name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rv</name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
</unit>
