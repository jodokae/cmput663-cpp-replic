<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="modules/http2/h2_util.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_mutex.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_cond.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_request.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nghttp2/nghttp2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_util.h"</cpp:file></cpp:include>
<function><type><name>unsigned</name> <name>char</name></type> <name>h2_log2</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>lz</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>n</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0xffff0000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 16</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 16)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0xff000000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 8</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 8)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0xf0000000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 4</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 4)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0xc0000000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>n</name> &lt;&lt; 2)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!(<name>n</name> &amp; 0x80000000u)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>lz</name> += 1</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>31 - <name>lz</name></expr>;</return>
}</block></function>
<function><type><name>size_t</name></type> <name>h2_util_hex_dump</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>maxlen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>datalen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>maxoffset</name> <init>= <expr>(<name>maxlen</name>-4)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>datalen</name> &amp;&amp; <name>offset</name> &lt; <name>maxoffset</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name> <init>= <expr>(<name>i</name> &amp;&amp; <name>i</name> % 16 == 0)? "\n" : " "</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name>+<name>offset</name></expr></argument>, <argument><expr><name>maxoffset</name>-<name>offset</name></expr></argument>,
<argument><expr>"%2x%s"</expr></argument>, <argument><expr>((<name>unsigned</name> <name>int</name>)<name><name>data</name><index>[<expr><name>i</name></expr>]</index></name>&amp;0xff)</expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>offset</name> += <name>n</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buffer</name>+<name>offset</name></expr></argument>, <argument><expr>(<name>i</name>&lt;<name>datalen</name>)? "..." : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>size_t</name></type> <name>h2_util_header_print</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>maxlen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>namelen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>valuelen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>namelen</name> &amp;&amp; <name>offset</name> &lt; <name>maxlen</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>offset</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> = <name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 2 &amp;&amp; <name>offset</name> &lt; <name>maxlen</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>offset</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> = ": "<index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
}</block></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>valuelen</name> &amp;&amp; <name>offset</name> &lt; <name>maxlen</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>offset</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> = <name><name>value</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>offset</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_util_camel_case_header</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>start</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>start</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &gt;= 'a' &amp;&amp; <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &lt;= 'z'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> -= 'a' - 'A'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>start</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></for>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>BASE64URL_UINT6</name><index>[]</index></name> <init>= <expr><block>{
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>62</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>52</expr>, <expr>53</expr>, <expr>54</expr>, <expr>55</expr>, <expr>56</expr>, <expr>57</expr>, <expr>58</expr>, <expr>59</expr>, <expr>60</expr>, <expr>61</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>4</expr>, <expr>5</expr>, <expr>6</expr>, <expr>7</expr>, <expr>8</expr>, <expr>9</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>,
<expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>, <expr>22</expr>, <expr>23</expr>, <expr>24</expr>, <expr>25</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>63</expr>,
<expr>-1</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>30</expr>, <expr>31</expr>, <expr>32</expr>, <expr>33</expr>, <expr>34</expr>, <expr>35</expr>, <expr>36</expr>, <expr>37</expr>, <expr>38</expr>, <expr>39</expr>, <expr>40</expr>,
<expr>41</expr>, <expr>42</expr>, <expr>43</expr>, <expr>44</expr>, <expr>45</expr>, <expr>46</expr>, <expr>47</expr>, <expr>48</expr>, <expr>49</expr>, <expr>50</expr>, <expr>51</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>,
<expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>, <expr>-1</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>BASE64URL_CHARS</name><index>[]</index></name> <init>= <expr><block>{
<expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'G'</expr>, <expr>'H'</expr>, <expr>'I'</expr>, <expr>'J'</expr>,
<expr>'K'</expr>, <expr>'L'</expr>, <expr>'M'</expr>, <expr>'N'</expr>, <expr>'O'</expr>, <expr>'P'</expr>, <expr>'Q'</expr>, <expr>'R'</expr>, <expr>'S'</expr>, <expr>'T'</expr>,
<expr>'U'</expr>, <expr>'V'</expr>, <expr>'W'</expr>, <expr>'X'</expr>, <expr>'Y'</expr>, <expr>'Z'</expr>, <expr>'a'</expr>, <expr>'b'</expr>, <expr>'c'</expr>, <expr>'d'</expr>,
<expr>'e'</expr>, <expr>'f'</expr>, <expr>'g'</expr>, <expr>'h'</expr>, <expr>'i'</expr>, <expr>'j'</expr>, <expr>'k'</expr>, <expr>'l'</expr>, <expr>'m'</expr>, <expr>'n'</expr>,
<expr>'o'</expr>, <expr>'p'</expr>, <expr>'q'</expr>, <expr>'r'</expr>, <expr>'s'</expr>, <expr>'t'</expr>, <expr>'u'</expr>, <expr>'v'</expr>, <expr>'w'</expr>, <expr>'x'</expr>,
<expr>'y'</expr>, <expr>'z'</expr>, <expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>,
<expr>'8'</expr>, <expr>'9'</expr>, <expr>'-'</expr>, <expr>'_'</expr>, <expr>' '</expr>, <expr>' '</expr>, <expr>' '</expr>, <expr>' '</expr>, <expr>' '</expr>, <expr>' '</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>apr_size_t</name></type> <name>h2_util_base64url_decode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>decoded</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoded</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>encoded</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name> <init>= <expr><name>e</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>mlen</name></decl>, <decl><type ref="prev"/><name>remain</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>p</name> &amp;&amp; <name><name>BASE64URL_UINT6</name><index>[ <expr>*<name>p</name></expr> ]</index></name> != -1</expr>)</condition> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>len</name> = <name>p</name> - <name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mlen</name> = (<name>len</name>/4)*4</expr>;</expr_stmt>
<expr_stmt><expr>*<name>decoded</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = (<name>unsigned</name> <name>char</name>*)*<name>decoded</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>mlen</name></expr>;</condition> <incr><expr><name>i</name> += 4</expr></incr>) <block>{
<expr_stmt><expr><name>n</name> = ((<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>i</name>+0</expr>]</index></name></expr> ]</index></name> &lt;&lt; 18) +
(<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr> ]</index></name> &lt;&lt; 12) +
(<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>i</name>+2</expr>]</index></name></expr> ]</index></name> &lt;&lt; 6) +
(<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>i</name>+3</expr>]</index></name></expr> ]</index></name>))</expr>;</expr_stmt>
<expr_stmt><expr>*<name>d</name>++ = <name>n</name> &gt;&gt; 16</expr>;</expr_stmt>
<expr_stmt><expr>*<name>d</name>++ = <name>n</name> &gt;&gt; 8 &amp; 0xffu</expr>;</expr_stmt>
<expr_stmt><expr>*<name>d</name>++ = <name>n</name> &amp; 0xffu</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>remain</name> = <name>len</name> - <name>mlen</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>remain</name></expr>)</condition> <block>{
<case>case <expr>2</expr>:
<expr_stmt><expr><name>n</name> = ((<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>mlen</name>+0</expr>]</index></name></expr> ]</index></name> &lt;&lt; 18) +
(<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>mlen</name>+1</expr>]</index></name></expr> ]</index></name> &lt;&lt; 12))</expr>;</expr_stmt>
<expr_stmt><expr>*<name>d</name>++ = <name>n</name> &gt;&gt; 16</expr>;</expr_stmt>
<expr_stmt><expr><name>remain</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><name>n</name> = ((<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>mlen</name>+0</expr>]</index></name></expr> ]</index></name> &lt;&lt; 18) +
(<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>mlen</name>+1</expr>]</index></name></expr> ]</index></name> &lt;&lt; 12) +
(<name><name>BASE64URL_UINT6</name><index>[ <expr><name><name>e</name><index>[<expr><name>mlen</name>+2</expr>]</index></name></expr> ]</index></name> &lt;&lt; 6))</expr>;</expr_stmt>
<expr_stmt><expr>*<name>d</name>++ = <name>n</name> &gt;&gt; 16</expr>;</expr_stmt>
<expr_stmt><expr>*<name>d</name>++ = <name>n</name> &gt;&gt; 8 &amp; 0xffu</expr>;</expr_stmt>
<expr_stmt><expr><name>remain</name> = 2</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<return>return <expr><name>mlen</name>/4*3 + <name>remain</name></expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type><name>h2_util_base64url_encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>dlen</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr>(<name>int</name>)<name>dlen</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>slen</name> <init>= <expr>((<name>dlen</name>+2)/3)*4 + 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>udata</name> <init>= <expr>(const <name>unsigned</name> <name>char</name>*)<name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>enc</name></decl>, *<decl><type ref="prev"/><name>p</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>enc</name> = <name>p</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name>-2</expr>;</condition> <incr><expr><name>i</name>+= 3</expr></incr>) <block>{
<expr_stmt><expr>*<name>p</name>++ = <name><name>BASE64URL_CHARS</name><index>[ <expr>(<name><name>udata</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 2) &amp; 0x3fu</expr> ]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>BASE64URL_CHARS</name><index>[ <expr>((<name><name>udata</name><index>[<expr><name>i</name></expr>]</index></name> &lt;&lt; 4) + (<name><name>udata</name><index>[<expr><name>i</name>+1</expr>]</index></name> &gt;&gt; 4)) &amp; 0x3fu</expr> ]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>BASE64URL_CHARS</name><index>[ <expr>((<name><name>udata</name><index>[<expr><name>i</name>+1</expr>]</index></name> &lt;&lt; 2) + (<name><name>udata</name><index>[<expr><name>i</name>+2</expr>]</index></name> &gt;&gt; 6)) &amp; 0x3fu</expr> ]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>BASE64URL_CHARS</name><index>[ <expr><name><name>udata</name><index>[<expr><name>i</name>+2</expr>]</index></name> &amp; 0x3fu</expr> ]</index></name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = <name><name>BASE64URL_CHARS</name><index>[ <expr>(<name><name>udata</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 2) &amp; 0x3fu</expr> ]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> == (<name>len</name> - 1)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = <name><name>BASE64URL_CHARS</name><index>[ <expr>(<name><name>udata</name><index>[<expr><name>i</name></expr>]</index></name> &lt;&lt; 4) &amp; 0x3fu</expr> ]</index></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>p</name>++ = <name><name>BASE64URL_CHARS</name><index>[ <expr>((<name><name>udata</name><index>[<expr><name>i</name></expr>]</index></name> &lt;&lt; 4) + (<name><name>udata</name><index>[<expr><name>i</name>+1</expr>]</index></name> &gt;&gt; 4)) &amp; 0x3fu</expr> ]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>BASE64URL_CHARS</name><index>[ <expr>(<name><name>udata</name><index>[<expr><name>i</name>+1</expr>]</index></name> &lt;&lt; 2) &amp; 0x3fu</expr> ]</index></name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr>*<name>p</name>++ = '\0'</expr>;</expr_stmt>
<return>return <expr><name>enc</name></expr>;</return>
}</block></function>
<struct>struct <name>h2_ihash_t</name> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ioff</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>ihash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><name>apr_ssize_t</name> *</type><name>klen</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call>(<name>unsigned</name> <name>int</name>)<argument_list>(<argument><expr>*((<name>int</name>*)<name>key</name>)</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>h2_ihash_t</name> *</type><name>h2_ihash_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>offset_of_int</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_ihash_t</name> *</type><name>ih</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_ihash_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ih</name>-&gt;<name>hash</name></name> = <call><name>apr_hash_make_custom</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>ihash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ih</name>-&gt;<name>ioff</name></name> = <name>offset_of_int</name></expr>;</expr_stmt>
<return>return <expr><name>ih</name></expr>;</return>
}</block></function>
<function><type><name>size_t</name></type> <name>h2_ihash_count</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_ihash_empty</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block></function>
<function><type><name>void</name> *</type><name>h2_ihash_get</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>h2_ihash_iter_t</name> *</type><name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>iter_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ihash_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>iter_ctx</name> *</type><name>ictx</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>ictx</name>-&gt;<name>iter</name></name><argument_list>(<argument><expr><name><name>ictx</name>-&gt;<name>ctx</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name>val</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_ihash_iter</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>h2_ihash_iter_t</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>iter_ctx</name></type> <name>ictx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ictx</name>.<name>iter</name></name> = <name>fn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ictx</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
<return>return <expr><call><name>apr_hash_do</name><argument_list>(<argument><expr><name>ihash_iter</name></expr></argument>, <argument><expr>&amp;<name>ictx</name></expr></argument>, <argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_ihash_add</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>, <argument><expr>((<name>char</name> *)<name>val</name> + <name><name>ih</name>-&gt;<name>ioff</name></name>)</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>h2_ihash_remove</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>h2_ihash_remove_val</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr>*(<call>(<name>int</name>*)<argument_list>(<argument><expr>(<name>char</name> *)<name>val</name> + <name><name>ih</name>-&gt;<name>ioff</name></name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>h2_ihash_clear</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>apr_hash_clear</name><argument_list>(<argument><expr><name><name>ih</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> **</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>collect_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>collect_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>x</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>collect_ctx</name> *</type><name>ctx</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>len</name></name> &lt; <name><name>ctx</name>-&gt;<name>max</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>buffer</name><index>[<expr><name><name>ctx</name>-&gt;<name>len</name></name>++</expr>]</index></name> = <name>val</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>size_t</name></type> <name>h2_ihash_shift</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> **</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>max</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>collect_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>ih</name></name> = <name>ih</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>buffer</name></name> = <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>max</name></name> = <name>max</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>len</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name>ih</name></expr></argument>, <argument><expr><name>collect_iter</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ctx</name>.<name>len</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><call><name>h2_ihash_remove_val</name><argument_list>(<argument><expr><name>ih</name></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name><name>ctx</name>.<name>len</name></name></expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>iq_grow</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>nlen</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>iq_swap</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>j</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iq_bubble_up</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>top</name></decl></param>,
<param><decl><type><name>h2_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>iq_bubble_down</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>bottom</name></decl></param>,
<param><decl><type><name>h2_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<function><type><name>h2_iqueue</name> *</type><name>h2_iq_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_iqueue</name> *</type><name>q</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_iqueue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>q</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>q</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>iq_grow</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>nelts</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>q</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_iq_empty</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>q</name>-&gt;<name>nelts</name></name> == 0</expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_iq_count</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>q</name>-&gt;<name>nelts</name></name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_iq_add</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>, <param><decl><type><name>h2_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>h2_iq_contains</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>q</name>-&gt;<name>nelts</name></name> &gt;= <name><name>q</name>-&gt;<name>nalloc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>iq_grow</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>nalloc</name></name> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>i</name> = (<name><name>q</name>-&gt;<name>head</name></name> + <name><name>q</name>-&gt;<name>nelts</name></name>) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name> = <name>sid</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>q</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cmp</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>iq_bubble_up</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_iq_append</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>h2_iq_add</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_iq_remove</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>sid</name> == <name><name>q</name>-&gt;<name>elts</name><index>[<expr>(<name><name>q</name>-&gt;<name>head</name></name> + <name>i</name>) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>]</index></name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>i</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr>(<name><name>q</name>-&gt;<name>head</name></name>+<name>i</name>-1)%<name><name>q</name>-&gt;<name>nalloc</name></name></expr>]</index></name> = <name><name>q</name>-&gt;<name>elts</name><index>[<expr>(<name><name>q</name>-&gt;<name>head</name></name>+<name>i</name>)%<name><name>q</name>-&gt;<name>nalloc</name></name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>--<name><name>q</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_iq_clear</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>q</name>-&gt;<name>nelts</name></name> = 0</expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>h2_iq_sort</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>h2_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>q</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ni</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>, <decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
<expr_stmt><expr><name>last</name> = <name>i</name> = (<name><name>q</name>-&gt;<name>head</name></name> + <name><name>q</name>-&gt;<name>nelts</name></name> - 1) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> != <name><name>q</name>-&gt;<name>head</name></name></expr>)</condition> <block>{
<expr_stmt><expr><name>prev</name> = (<name><name>q</name>-&gt;<name>nalloc</name></name> + <name>i</name> - 1) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ni</name> = <call><name>iq_bubble_up</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ni</name> == <name>prev</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>iq_bubble_down</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>i</name> = <name>prev</name></expr>;</expr_stmt>
}</block></while><empty_stmt>;</empty_stmt>
}</block></then></if>
}</block></function>
<function><type><name>int</name></type> <name>h2_iq_shift</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sid</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>q</name>-&gt;<name>nelts</name></name> &lt;= 0</expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>sid</name> = <name><name>q</name>-&gt;<name>elts</name><index>[<expr><name><name>q</name>-&gt;<name>head</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>head</name></name> = (<name><name>q</name>-&gt;<name>head</name></name> + 1) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>nelts</name></name>--</expr>;</expr_stmt>
<return>return <expr><name>sid</name></expr>;</return>
}</block></function>
<function><type><name>size_t</name></type> <name>h2_iq_mshift</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pint</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>max</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>max</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>pint</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>h2_iq_shift</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pint</name><index>[<expr><name>i</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
}</block></for>
<return>return <expr><name>i</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>iq_grow</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>nlen</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>nlen</name> &gt; <name><name>q</name>-&gt;<name>nalloc</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name> *</type><name>nq</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>q</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * <name>nlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>q</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr>((<name><name>q</name>-&gt;<name>head</name></name> + <name><name>q</name>-&gt;<name>nelts</name></name>) % <name><name>q</name>-&gt;<name>nalloc</name></name>) - <name><name>q</name>-&gt;<name>head</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>nq</name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>elts</name></name> + <name><name>q</name>-&gt;<name>head</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>l</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>remain</name> <init>= <expr><name><name>q</name>-&gt;<name>nelts</name></name> - <name>l</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>nq</name> + <name>l</name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * <name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name></name> = <name>nq</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>nalloc</name></name> = <name>nlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>head</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>iq_swap</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>j</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name> <init>= <expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>j</name></expr>]</index></name> = <name>x</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iq_bubble_up</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>top</name></decl></param>,
<param><decl><type><name>h2_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>prev</name></decl>;</decl_stmt>
<while>while <condition>(<expr>((<name>prev</name> = (<name><name>q</name>-&gt;<name>nalloc</name></name> + <name>i</name> - 1) % <name><name>q</name>-&gt;<name>nalloc</name></name>), <name>i</name> != <name>top</name>)
&amp;&amp; <call>(*<name>cmp</name>)<argument_list>(<argument><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>prev</name></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>iq_swap</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>prev</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>i</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iq_bubble_down</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>, <param><decl><type><name>int</name></type> <name>bottom</name></decl></param>,
<param><decl><type><name>h2_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>;</decl_stmt>
<while>while <condition>(<expr>((<name>next</name> = (<name><name>q</name>-&gt;<name>nalloc</name></name> + <name>i</name> + 1) % <name><name>q</name>-&gt;<name>nalloc</name></name>), <name>i</name> != <name>bottom</name>)
&amp;&amp; <call>(*<name>cmp</name>)<argument_list>(<argument><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>q</name>-&gt;<name>elts</name><index>[<expr><name>next</name></expr>]</index></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>iq_swap</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>next</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>i</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_iq_contains</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>q</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>sid</name> == <name><name>q</name>-&gt;<name>elts</name><index>[<expr>(<name><name>q</name>-&gt;<name>head</name></name> + <name>i</name>) % <name><name>q</name>-&gt;<name>nalloc</name></name></expr>]</index></name></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<struct>struct <name>h2_fifo</name> <block>{
<decl_stmt><decl><type><name>void</name> **</type><name>elems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nelems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>aborted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_cond_t</name> *</type><name>not_empty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_cond_t</name> *</type><name>not_full</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nth_index</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name><name>fifo</name>-&gt;<name>head</name></name> + <name>n</name>) % <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fifo_destroy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_fifo</name> *</type><name>fifo</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>index_of</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>fifo</name>-&gt;<name>count</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>elem</name> == <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><then> <block>{
<return>return <expr><name>i</name></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>create_int</name><parameter_list>(<param><decl><type><name>h2_fifo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><name>int</name></type> <name>capacity</name></decl></param>, <param><decl><type><name>int</name></type> <name>as_set</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fifo</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>fifo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fifo</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>,
<argument><expr><name>APR_THREAD_MUTEX_UNNESTED</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>void</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>elems</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>nelems</name></name> = <name>capacity</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>set</name></name> = <name>as_set</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pfifo</name> = <name>fifo</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>fifo_destroy</name></expr></argument>, <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_create</name><parameter_list>(<param><decl><type><name>h2_fifo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>create_int</name><argument_list>(<argument><expr><name>pfifo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_set_create</name><parameter_list>(<param><decl><type><name>h2_fifo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>create_int</name><argument_list>(<argument><expr><name>pfifo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_term</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_interrupt</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_fifo_count</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>fifo</name>-&gt;<name>count</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>check_not_empty</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == 0</expr>)</condition> <block>{
<if>if <condition>(<expr>!<name>block</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EAGAIN</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fifo_push_int</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>set</name></name> &amp;&amp; <call><name>index_of</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then> <block>{
<return>return <expr><name>APR_EEXIST</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>block</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></then> <else>else <block>{
<return>return <expr><name>APR_EAGAIN</name></expr>;</return>
}</block></else></if>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>count</name></name> &lt; <name><name>fifo</name>-&gt;<name>nelems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>count</name></name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>elem</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>fifo</name>-&gt;<name>count</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fifo_push</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>fifo_push_int</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_push</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_push</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_try_push</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_push</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>pull_head</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>check_not_empty</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pelem</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>pelem</name> = <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><name><name>fifo</name>-&gt;<name>head</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>--<name><name>fifo</name>-&gt;<name>count</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>head</name></name> = <call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name>+1 == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fifo_pull</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>pull_head</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>pelem</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_pull</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_pull</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>pelem</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_try_pull</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_pull</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>pelem</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fifo_peek</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_fifo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>elem</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>APR_SUCCESS</name> == (<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>APR_SUCCESS</name> == (<name>rv</name> = <call><name>pull_head</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr>&amp;<name>elem</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><call><name>fn</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>H2_FIFO_OP_PULL</name></expr>:
<break>break;</break>
</case><case>case <expr><name>H2_FIFO_OP_REPUSH</name></expr>:
<expr_stmt><expr><name>rv</name> = <call><name>fifo_push_int</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_peek</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_fifo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_peek</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_try_peek</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_fifo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fifo_peek</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_fifo_remove</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>fifo</name>-&gt;<name>count</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>e</name> = <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>e</name> == <name>elem</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>rc</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>nth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name>-<name>rc</name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>e</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></for>
<if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>count</name></name> -= <name>rc</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> + <name>rc</name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rv</name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<struct>struct <name>h2_ififo</name> <block>{
<decl_stmt><decl><type><name>int</name> *</type><name>elems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nelems</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>set</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>head</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>aborted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_cond_t</name> *</type><name>not_empty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_cond_t</name> *</type><name>not_full</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>int</name></type> <name>inth_index</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name><name>fifo</name>-&gt;<name>head</name></name> + <name>n</name>) % <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ififo_destroy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_ififo</name> *</type><name>fifo</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_destroy</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iindex_of</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>fifo</name>-&gt;<name>count</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>id</name> == <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>inth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition><then> <block>{
<return>return <expr><name>i</name></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>icreate_int</name><parameter_list>(<param><decl><type><name>h2_ififo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><name>int</name></type> <name>capacity</name></decl></param>, <param><decl><type><name>int</name></type> <name>as_set</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fifo</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>fifo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fifo</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>,
<argument><expr><name>APR_THREAD_MUTEX_UNNESTED</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_create</name><argument_list>(<argument><expr>&amp;<name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>elems</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>nelems</name></name> = <name>capacity</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>set</name></name> = <name>as_set</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pfifo</name> = <name>fifo</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>ififo_destroy</name></expr></argument>, <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_create</name><parameter_list>(<param><decl><type><name>h2_ififo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>icreate_int</name><argument_list>(<argument><expr><name>pfifo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_set_create</name><parameter_list>(<param><decl><type><name>h2_ififo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>icreate_int</name><argument_list>(<argument><expr><name>pfifo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_term</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_interrupt</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_ififo_count</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>fifo</name>-&gt;<name>count</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>icheck_not_empty</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == 0</expr>)</condition> <block>{
<if>if <condition>(<expr>!<name>block</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EAGAIN</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ififo_push_int</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>set</name></name> &amp;&amp; <call><name>iindex_of</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call> &gt;= 0</expr>)</condition><then> <block>{
<return>return <expr><name>APR_EEXIST</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>block</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></then> <else>else <block>{
<return>return <expr><name>APR_EAGAIN</name></expr>;</return>
}</block></else></if>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>count</name></name> &lt; <name><name>fifo</name>-&gt;<name>nelems</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>inth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name><name>fifo</name>-&gt;<name>count</name></name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name><name>fifo</name>-&gt;<name>count</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_empty</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ififo_push</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>ififo_push_int</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_push</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ififo_push</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_try_push</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ififo_push</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ipull_head</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pi</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>icheck_not_empty</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pi</name> = 0</expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>pi</name> = <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><name><name>fifo</name>-&gt;<name>head</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>--<name><name>fifo</name>-&gt;<name>count</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>head</name></name> = <call><name>inth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name>+1 == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ififo_pull</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pi</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <call><name>ipull_head</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_pull</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pi</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ififo_pull</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_try_pull</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pi</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ififo_pull</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>pi</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ififo_peek</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_ififo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>int</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>APR_SUCCESS</name> == (<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>APR_SUCCESS</name> == (<name>rv</name> = <call><name>ipull_head</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><call><name>fn</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr><name>H2_FIFO_OP_PULL</name></expr>:
<break>break;</break>
</case><case>case <expr><name>H2_FIFO_OP_REPUSH</name></expr>:
<expr_stmt><expr><name>rv</name> = <call><name>ififo_push_int</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></then></if>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_peek</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_ififo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ififo_peek</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_try_peek</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_ififo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ififo_peek</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_ififo_remove</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>fifo</name>-&gt;<name>count</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>e</name> = <name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>inth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>e</name> == <name>id</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>rc</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>elems</name><index>[<expr><call><name>inth_index</name><argument_list>(<argument><expr><name>fifo</name></expr></argument>, <argument><expr><name>i</name>-<name>rc</name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>e</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></for>
<if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>fifo</name>-&gt;<name>count</name></name> -= <name>rc</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fifo</name>-&gt;<name>count</name></name> + <name>rc</name> == <name><name>fifo</name>-&gt;<name>nelems</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>not_full</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rv</name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>fifo</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>pair_extra</name></decl>;</decl_stmt>
}</block></struct></type> <name>table_bytes_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>count_bytes</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>x</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>table_bytes_ctx</name> *</type><name>ctx</name> <init>= <expr><name>x</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>key</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>bytes</name></name> += <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>bytes</name></name> += <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>bytes</name></name> += <name><name>ctx</name>-&gt;<name>pair_extra</name></name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><name>apr_size_t</name></type> <name>h2_util_table_bytes</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>t</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>pair_extra</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>table_bytes_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>bytes</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>pair_extra</name></name> = <name>pair_extra</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>count_bytes</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ctx</name>.<name>bytes</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>last_not_included</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
<param><decl><type><name>apr_off_t</name></type> <name>maxlen</name></decl></param>,
<param><decl><type><name>int</name></type> <name>same_alloc</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>pfile_buckets_allowed</name></decl></param>,
<param><decl><type><name>apr_bucket</name> **</type><name>pend</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>files_allowed</name> <init>= <expr><name>pfile_buckets_allowed</name>? (<name>int</name>)*<name>pfile_buckets_allowed</name> : 0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>maxlen</name> &gt;= 0</expr>)</condition><then> <block>{
<for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr>(<name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>)</expr>;</condition>
<incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> == ((<name>apr_size_t</name>)-1)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>ilen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>ign</name></expr></argument>, <argument><expr>&amp;<name>ilen</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>status</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>maxlen</name> == 0 &amp;&amp; <name><name>b</name>-&gt;<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pend</name> = <name>b</name></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>same_alloc</name> &amp;&amp; <call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr><name>files_allowed</name> &gt; 0 &amp;&amp; <call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>--<name>files_allowed</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>maxlen</name> &lt; (<name>apr_off_t</name>)<name><name>b</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>(<name>apr_size_t</name>)<name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maxlen</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>maxlen</name> -= <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
}</block></else></if>
}</block></for>
}</block></then></if>
<expr_stmt><expr>*<name>pend</name> = <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_brigade_concat_length</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>dest</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>src</name></decl></param>,
<param><decl><type><name>apr_off_t</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>remain</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>remain</name> == <name><name>b</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr><name>remain</name> &lt;= 0</expr>)</condition><then> <block>{
<return>return <expr><name>status</name></expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> == ((<name>apr_size_t</name>)-1)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>ilen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>ign</name></expr></argument>, <argument><expr>&amp;<name>ilen</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>status</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>remain</name> &lt; <name><name>b</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>remain</name> -= <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_brigade_copy_length</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>dest</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>src</name></decl></param>,
<param><decl><type><name>apr_off_t</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>remain</name> <init>= <expr><name>length</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>b</name> = <name>next</name></expr></incr>) <block>{
<expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>remain</name> == <name><name>b</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr><name>remain</name> &lt;= 0</expr>)</condition><then> <block>{
<return>return <expr><name>status</name></expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> == ((<name>apr_size_t</name>)-1)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>ilen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>ign</name></expr></argument>, <argument><expr>&amp;<name>ilen</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>status</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>remain</name> &lt; <name><name>b</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if></else></if>
}</block></else></if>
<expr_stmt><expr><name>status</name> = <call><name>apr_bucket_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>status</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>remain</name> -= <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_util_has_eos</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><call><name>last_not_included</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>status</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call> &amp;&amp; <name>b</name> != <name>end</name></expr>;</condition>
<incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_util_bb_avail</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
<param><decl><type><name>apr_off_t</name> *</type><name>plen</name></decl></param>, <param><decl><type><name>int</name> *</type><name>peos</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>blen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>status</name> = <call><name>apr_brigade_length</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>status</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>blen</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>plen</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr>*<name>peos</name> = <call><name>h2_util_has_eos</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>blen</name> &lt; *<name>plen</name> || *<name>plen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>plen</name> = <name>blen</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>peos</name> = <call><name>h2_util_has_eos</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr>*<name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_util_bb_readx</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
<param><decl><type><name>h2_util_pass_cb</name> *</type><name>cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><name>apr_off_t</name> *</type><name>plen</name></decl></param>, <param><decl><type><name>int</name> *</type><name>peos</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>consume</name> <init>= <expr>(<name>cb</name> != <name>NULL</name>)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>written</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>avail</name> <init>= <expr>*<name>plen</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>next</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>peos</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr>(<name>status</name> == <name>APR_SUCCESS</name>) &amp;&amp; (<name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>)</expr>;</condition>
<incr><expr><name>b</name> = <name>next</name></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>peos</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>avail</name> &lt;= 0</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>data_len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> == ((<name>apr_size_t</name>)-1)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>data_len</name></expr></argument>, <argument><expr><name>APR_NONBLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>data_len</name> = <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>data_len</name> &gt; <name>avail</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data_len</name> = (<name>apr_size_t</name>)<name>avail</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>consume</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>data</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>data_len</name></expr></argument>,
<argument><expr><name>APR_NONBLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <call><name>cb</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>data_len</name> = <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>avail</name> -= <name>data_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>written</name> += <name>data_len</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>consume</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr>*<name>plen</name> = <name>written</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name> &amp;&amp; !*<name>peos</name> &amp;&amp; !*<name>plen</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_EAGAIN</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><name>apr_size_t</name></type> <name>h2_util_bucket_print</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bmax</name></decl></param>,
<param><decl><type><name>apr_bucket</name> *</type><name>b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>off</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>sep</name> &amp;&amp; *<name>sep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>off</name> += <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name>+<name>off</name></expr></argument>, <argument><expr><name>bmax</name>-<name>off</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>bmax</name> &lt;= <name>off</name></expr>)</condition><then> <block>{
<return>return <expr><name>off</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>off</name> += <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name>+<name>off</name></expr></argument>, <argument><expr><name>bmax</name>-<name>off</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>type</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bmax</name> &gt; <name>off</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>off</name> += <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name>+<name>off</name></expr></argument>, <argument><expr><name>bmax</name>-<name>off</name></expr></argument>, <argument><expr>"%s[%ld]"</expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>type</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><call>(<name>long</name>)<argument_list>(<argument><expr><name><name>b</name>-&gt;<name>length</name></name> == ((<name>apr_size_t</name>)-1)?
-1 : <name><name>b</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if></else></if>
<return>return <expr><name>off</name></expr>;</return>
}</block></function>
<function><type><name>apr_size_t</name></type> <name>h2_util_bb_print</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bmax</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>off</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sp</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>bmax</name> &gt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>bb</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>bmax</name>--</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> += <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name>+<name>off</name></expr></argument>, <argument><expr><name>bmax</name>-<name>off</name></expr></argument>, <argument><expr>"%s("</expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr>(<name>bmax</name> &gt; <name>off</name>) &amp;&amp; (<name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>)</expr>;</condition>
<incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<expr_stmt><expr><name>off</name> += <call><name>h2_util_bucket_print</name><argument_list>(<argument><expr><name>buffer</name>+<name>off</name></expr></argument>, <argument><expr><name>bmax</name>-<name>off</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> = " "</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>bmax</name> &gt; <name>off</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>off</name> += <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name>+<name>off</name></expr></argument>, <argument><expr><name>bmax</name>-<name>off</name></expr></argument>, <argument><expr>")%s"</expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>off</name> += <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name>+<name>off</name></expr></argument>, <argument><expr><name>bmax</name>-<name>off</name></expr></argument>, <argument><expr>"%s(null)%s"</expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>off</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_append_brigade</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>to</name></decl></param>,
<param><decl><type><name>apr_bucket_brigade</name> *</type><name>from</name></decl></param>,
<param><decl><type><name>apr_off_t</name> *</type><name>plen</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>peos</name></decl></param>,
<param><decl><type><name>h2_bucket_gate</name> *</type><name>should_append</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>len</name> <init>= <expr>0</expr></init>, <name>remain</name> <init>= <expr>*<name>plen</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>peos</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>should_append</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<goto>goto <name>leave</name>;</goto>
}</block></then> <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>peos</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>remain</name> &gt; 0 &amp;&amp; <name><name>e</name>-&gt;<name>length</name></name> == ((<name>apr_size_t</name>)-1)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>ilen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>ign</name></expr></argument>, <argument><expr>&amp;<name>ilen</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>remain</name> &lt; <name><name>e</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>remain</name> &lt;= 0</expr>)</condition><then> <block>{
<goto>goto <name>leave</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>(<name>apr_size_t</name>)<name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> += <name><name>e</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>remain</name> -= <name><name>e</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></while>
<label><name>leave</name>:</label>
<expr_stmt><expr>*<name>plen</name> = <name>len</name></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>apr_off_t</name></type> <name>h2_brigade_mem_size</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>total</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<expr_stmt><expr><name>total</name> += <sizeof>sizeof<argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_HEAP</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>
|| <call><name>APR_BUCKET_IS_POOL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>total</name> += <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></for>
<return>return <expr><name>total</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_util_ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"connection"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| <call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"proxy-connection"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| <call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"upgrade"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| <call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"keep-alive"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| <call><name>H2_HD_MATCH_LIT_CS</name><argument_list>(<argument><expr>"transfer-encoding"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>count_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>h2_util_ignore_header</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>(*((<name>size_t</name>*)<name>ctx</name>))++</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>inv_field_name_chr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>ap_scan_http_token</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>token</name> &amp;&amp; *<name>p</name> == ':'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = <call><name>ap_scan_http_token</name><argument_list>(<argument><expr>++<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>p</name> &amp;&amp; *<name>p</name>)? <name>p</name> : <name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>inv_field_value_chr</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>ap_scan_http_field_content</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr>(<name>p</name> &amp;&amp; *<name>p</name>)? <name>p</name> : <name>NULL</name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <name>ngh_ctx</name> <block>{
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>unsafe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_ngheader</name> *</type><name>ngh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
}</block></struct></type> <name>ngh_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>add_header</name><parameter_list>(<param><decl><type><name>ngh_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>nghttp2_nv</name> *</type><name>nv</name> <init>= <expr>&amp;<name>(<name><name>ctx</name>-&gt;<name>ngh</name></name>)-&gt;<name>nv</name></name><index>[<expr><name>(<name><name>ctx</name>-&gt;<name>ngh</name></name>)-&gt;<name>nvlen</name></name>++</expr>]</index></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>unsafe</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>p</name> = <call><name>inv_field_name_chr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr><name>APR_EINVAL</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>,
<argument><expr>"h2_request: head field '%s: %s' has invalid char %s"</expr></argument>,
<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>status</name></name> = <name>APR_EINVAL</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>p</name> = <call><name>inv_field_value_chr</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr><name>APR_EINVAL</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>p</name></name></expr></argument>,
<argument><expr>"h2_request: head field '%s: %s' has invalid char %s"</expr></argument>,
<argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>status</name></name> = <name>APR_EINVAL</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>nv</name>-&gt;<name>name</name></name> = (<name>uint8_t</name>*)<name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nv</name>-&gt;<name>namelen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nv</name>-&gt;<name>value</name></name> = (<name>uint8_t</name>*)<name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nv</name>-&gt;<name>valuelen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>add_table_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>h2_util_ignore_header</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>add_header</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ngheader_create</name><parameter_list>(<param><decl><type><name>h2_ngheader</name> **</type><name>ph</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>int</name></type> <name>unsafe</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>key_count</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>keys</name><index>[]</index></name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>values</name><index>[]</index></name></decl></param>,
<param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ngh_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>p</name></name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>unsafe</name></name> = <name>unsafe</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name>key_count</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>count_header</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>ph</name> = <name><name>ctx</name>.<name>ngh</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_ngheader</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>.<name>ngh</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>ctx</name>.<name>ngh</name>-&gt;<name>nv</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>nghttp2_nv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>ctx</name>.<name>ngh</name>-&gt;<name>nv</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOMEM</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>ctx</name>.<name>status</name></name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>key_count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>add_header</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name><name>ctx</name>.<name>status</name></name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>add_table_header</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ctx</name>.<name>status</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>is_unsafe</name><parameter_list>(<param><decl><type><name>h2_headers</name> *</type><name>h</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>v</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>H2_HDR_CONFORMANCE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr>(<name>v</name> &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>H2_HDR_CONFORMANCE_UNSAFE</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_res_create_ngtrailer</name><parameter_list>(<param><decl><type><name>h2_ngheader</name> **</type><name>ph</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>h2_headers</name> *</type><name>headers</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ngheader_create</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>is_unsafe</name><argument_list>(<argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>headers</name>-&gt;<name>headers</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_res_create_ngheader</name><parameter_list>(<param><decl><type><name>h2_ngheader</name> **</type><name>ph</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>h2_headers</name> *</type><name>headers</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>keys</name><index>[]</index></name> <init>= <expr><block>{
<expr>":status"</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>values</name><index>[]</index></name> <init>= <expr><block>{
<macro><name>apr_psprintf</name><argument_list>(<argument>p</argument>, <argument>"%d"</argument>, <argument>headers-&gt;status</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>ngheader_create</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>is_unsafe</name><argument_list>(<argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>H2_ALEN</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name><name>headers</name>-&gt;<name>headers</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_req_create_ngheader</name><parameter_list>(<param><decl><type><name>h2_ngheader</name> **</type><name>ph</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
<param><decl><type><specifier>const</specifier> struct <name>h2_request</name> *</type><name>req</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>keys</name><index>[]</index></name> <init>= <expr><block>{
<expr>":scheme"</expr>,
<expr>":authority"</expr>,
<expr>":path"</expr>,
<expr>":method"</expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>values</name><index>[]</index></name> <init>= <expr><block>{
<expr><name><name>req</name>-&gt;<name>scheme</name></name></expr>,
<expr><name><name>req</name>-&gt;<name>authority</name></name></expr>,
<expr><name><name>req</name>-&gt;<name>path</name></name></expr>,
<expr><name><name>req</name>-&gt;<name>method</name></name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>authority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ngheader_create</name><argument_list>(<argument><expr><name>ph</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>H2_ALEN</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keys</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>headers</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block></struct></type> <name>literal</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_DEF_LITERAL</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ (n), (sizeof(n)-1) }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_LIT_ARGS</name><parameter_list>(<param><type><name>a</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(a),H2_ALEN(a)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>literal</name></type> <name><name>IgnoredRequestHeaders</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"upgrade"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"connection"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"keep-alive"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"http2-settings"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"proxy-connection"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"transfer-encoding"</expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>literal</name></type> <name><name>IgnoredRequestTrailers</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"te"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"host"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"range"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"cookie"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"expect"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"pragma"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"max-forwards"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"cache-control"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"authorization"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"content-length"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"proxy-authorization"</expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>literal</name></type> <name><name>IgnoredResponseTrailers</name><index>[]</index></name> <init>= <expr><block>{
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"age"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"date"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"vary"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"cookie"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"expires"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"warning"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"location"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"retry-after"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"cache-control"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"www-authenticate"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>H2_DEF_LITERAL</name><argument_list>(<argument><expr>"proxy-authenticate"</expr></argument>)</argument_list></call></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>literal</name> *</type><name>lits</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>llen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>literal</name> *</type><name>lit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>llen</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>lit</name> = &amp;<name><name>lits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lit</name>-&gt;<name>len</name></name> == <name>nlen</name> &amp;&amp; !<call><name>apr_strnatcasecmp</name><argument_list>(<argument><expr><name><name>lit</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_req_ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ignore_header</name><argument_list>(<argument><expr><call><name>H2_LIT_ARGS</name><argument_list>(<argument><expr><name>IgnoredRequestHeaders</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_req_ignore_trailer</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<call><name>h2_req_ignore_header</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>
|| <call><name>ignore_header</name><argument_list>(<argument><expr><call><name>H2_LIT_ARGS</name><argument_list>(<argument><expr><name>IgnoredRequestTrailers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_res_ignore_trailer</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ignore_header</name><argument_list>(<argument><expr><call><name>H2_LIT_ARGS</name><argument_list>(<argument><expr><name>IgnoredResponseTrailers</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_req_add_header</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nlen</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>vlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>hname</name></decl>, *<decl><type ref="prev"/><name>hvalue</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>h2_req_ignore_header</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"cookie"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>existing</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"cookie"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>existing</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>nval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>hvalue</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nval</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s; %s"</expr></argument>, <argument><expr><name>existing</name></expr></argument>, <argument><expr><name>hvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"Cookie"</expr></argument>, <argument><expr><name>nval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"host"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"Host"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then></if>
}</block></then></if></else></if></else></if>
<expr_stmt><expr><name>hname</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hvalue</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>vlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_util_camel_case_header</name><argument_list>(<argument><expr><name>hname</name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>hname</name></expr></argument>, <argument><expr><name>hvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>h2_request</name> *</type><name>h2_req_create</name><parameter_list>(<param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>method</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authority</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_table_t</name> *</type><name>header</name></decl></param>, <param><decl><type><name>int</name></type> <name>serialize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_request</name> *</type><name>req</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_request</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>method</name></name> = <name>method</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>scheme</name></name> = <name>scheme</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>authority</name></name> = <name>authority</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>headers</name></name> = <name>header</name>? <name>header</name> : <call><name>apr_table_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>request_time</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>req</name>-&gt;<name>serialize</name></name> = <name>serialize</name></expr>;</expr_stmt>
<return>return <expr><name>req</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_util_frame_print</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nghttp2_frame</name> *</type><name>frame</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>maxlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>scratch</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>s_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>scratch</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name><name>frame</name>-&gt;<name>hd</name>.<name>type</name></name></expr>)</condition> <block>{
<case>case <expr><name>NGHTTP2_DATA</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"DATA[length=%d, flags=%d, stream=%d, padlen=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>, <argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>data</name>.<name>padlen</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_HEADERS</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"HEADERS[length=%d, hend=%d, stream=%d, eos=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr>!!(<name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name> &amp; <name>NGHTTP2_FLAG_END_HEADERS</name>)</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>,
<argument><expr>!!(<name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name> &amp; <name>NGHTTP2_FLAG_END_STREAM</name>)</expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_PRIORITY</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"PRIORITY[length=%d, flags=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_RST_STREAM</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"RST_STREAM[length=%d, flags=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_SETTINGS</name></expr>: <block>{
<if>if <condition>(<expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name> &amp; <name>NGHTTP2_FLAG_ACK</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"SETTINGS[ack=1, stream=%d]"</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"SETTINGS[length=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_PUSH_PROMISE</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"PUSH_PROMISE[length=%d, hend=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr>!!(<name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name> &amp; <name>NGHTTP2_FLAG_END_HEADERS</name>)</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_PING</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"PING[length=%d, ack=%d, stream=%d]"</expr></argument>,
<argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name>&amp;<name>NGHTTP2_FLAG_ACK</name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_GOAWAY</name></expr>: <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr>(<name><name>frame</name>-&gt;<name>goaway</name>.<name>opaque_data_len</name></name> &lt; <name>s_len</name>)?
<name><name>frame</name>-&gt;<name>goaway</name>.<name>opaque_data_len</name></name> : <name>s_len</name>-1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>goaway</name>.<name>opaque_data</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>scratch</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>, <argument><expr>"GOAWAY[error=%d, reason='%s', "
"last_stream=%d]"</expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>goaway</name>.<name>error_code</name></name></expr></argument>,
<argument><expr><name>scratch</name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>goaway</name>.<name>last_stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><case>case <expr><name>NGHTTP2_WINDOW_UPDATE</name></expr>: <block>{
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"WINDOW_UPDATE[stream=%d, incr=%d]"</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>window_update</name>.<name>window_size_increment</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
</case><default>default:
<return>return <expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>,
<argument><expr>"type=%d[length=%d, flags=%d, stream=%d]"</expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>type</name></name></expr></argument>, <argument><expr>(<name>int</name>)<name><name>frame</name>-&gt;<name>hd</name>.<name>length</name></name></expr></argument>,
<argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>flags</name></name></expr></argument>, <argument><expr><name><name>frame</name>-&gt;<name>hd</name>.<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><name>int</name></type> <name>h2_push_policy_determine</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>push_enabled</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_push_policy</name></type> <name>policy</name> <init>= <expr><name>H2_PUSH_NONE</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>push_enabled</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"accept-push-policy"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>ap_find_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr>"fast-load"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>policy</name> = <name>H2_PUSH_FAST_LOAD</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ap_find_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr>"head"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>policy</name> = <name>H2_PUSH_HEAD</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ap_find_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr>"default"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>policy</name> = <name>H2_PUSH_DEFAULT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ap_find_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr>"none"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>policy</name> = <name>H2_PUSH_NONE</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>policy</name> = <name>H2_PUSH_DEFAULT</name></expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>policy</name> = <name>H2_PUSH_DEFAULT</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>policy</name></expr>;</return>
}</block></function>
</unit>
