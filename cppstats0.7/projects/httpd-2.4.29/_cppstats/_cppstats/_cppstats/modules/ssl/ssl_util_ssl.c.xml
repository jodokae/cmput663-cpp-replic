<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="_cppstats/_cppstats/modules/ssl/ssl_util_ssl.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ssl_private.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>app_data2_idx</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>modssl_init_app_data2_idx</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>app_data2_idx</name> &gt; -1</expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>app_data2_idx</name> =
<call><name>SSL_get_ex_new_index</name><argument_list>(<argument><expr>0</expr></argument>,
<argument><expr>"Second Application Data for SSL"</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><name>void</name> *</type><name>modssl_get_app_data2</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>void</name> *)<call><name>SSL_get_ex_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>app_data2_idx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>modssl_set_app_data2</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>SSL_set_ex_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>app_data2_idx</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></function>
<function><type><name>EVP_PKEY</name> *</type><name>modssl_read_privatekey</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>filename</name></decl></param>, <param><decl><type><name>EVP_PKEY</name> **</type><name>key</name></decl></param>, <param><decl><type><name>pem_password_cb</name> *</type><name>cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>EVP_PKEY</name> *</type><name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>bioS</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>bioF</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>bioS</name>=<call><name>BIO_new_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>PEM_read_bio_PrivateKey</name><argument_list>(<argument><expr><name>bioS</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>bioS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>bioS</name> = <call><name>BIO_new_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>bioF</name> = <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_f_base64</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>bioS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>bioS</name> = <call><name>BIO_push</name><argument_list>(<argument><expr><name>bioF</name></expr></argument>, <argument><expr><name>bioS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>d2i_PrivateKey_bio</name><argument_list>(<argument><expr><name>bioS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_free_all</name><argument_list>(<argument><expr><name>bioS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>bioS</name> = <call><name>BIO_new_file</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>d2i_PrivateKey_bio</name><argument_list>(<argument><expr><name>bioS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>bioS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>rc</name> != <name>NULL</name> &amp;&amp; <name>key</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>key</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>EVP_PKEY_free</name><argument_list>(<argument><expr>*<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>key</name> = <name>rc</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>modssl_smart_shutdown</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flush</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>flush</name> = !(<call><name>SSL_get_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> &amp; <name>SSL_SENT_SHUTDOWN</name>)</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 4</expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>rc</name> = <call><name>SSL_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> &gt;= 0 &amp;&amp; <name>flush</name> &amp;&amp; (<call><name>SSL_get_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> &amp; <name>SSL_SENT_SHUTDOWN</name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>BIO_flush</name><argument_list>(<argument><expr><call><name>SSL_get_wbio</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>rc</name> = -1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>flush</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>rc</name> != 0</expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>BOOL</name></type> <name>modssl_X509_getBC</name><parameter_list>(<param><decl><type><name>X509</name> *</type><name>cert</name></decl></param>, <param><decl><type><name>int</name> *</type><name>ca</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pathlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>BASIC_CONSTRAINTS</name> *</type><name>bc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIGNUM</name> *</type><name>bn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>bc</name> = <call><name>X509_get_ext_d2i</name><argument_list>(<argument><expr><name>cert</name></expr></argument>, <argument><expr><name>NID_basic_constraints</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bc</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>ca</name> = <name><name>bc</name>-&gt;<name>ca</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pathlen</name> = -1</expr> ;</expr_stmt>
<if>if <condition>(<expr><name><name>bc</name>-&gt;<name>pathlen</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>bn</name> = <call><name>ASN1_INTEGER_to_BN</name><argument_list>(<argument><expr><name><name>bc</name>-&gt;<name>pathlen</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BASIC_CONSTRAINTS_free</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>cp</name> = <call><name>BN_bn2dec</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BN_free</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BASIC_CONSTRAINTS_free</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>pathlen</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>OPENSSL_free</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BN_free</name><argument_list>(<argument><expr><name>bn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>BASIC_CONSTRAINTS_free</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>asn1_string_to_utf8</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>ASN1_STRING</name> *</type><name>asn1str</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>bio</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>bio</name> = <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_mem</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>ASN1_STRING_print_ex</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>asn1str</name></expr></argument>, <argument><expr><name>ASN1_STRFLGS_ESC_CTRL</name>|
<name>ASN1_STRFLGS_UTF8_CONVERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>BIO_pending</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>BIO_read</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> = <name>NUL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type><name>modssl_X509_NAME_ENTRY_to_string</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>X509_NAME_ENTRY</name> *</type><name>xsne</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><call><name>asn1_string_to_utf8</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>X509_NAME_ENTRY_get_data</name><argument_list>(<argument><expr><name>xsne</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_xlate_proto_from_ascii</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type><name>modssl_X509_NAME_to_string</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>X509_NAME</name> *</type><name>dn</name></decl></param>, <param><decl><type><name>int</name></type> <name>maxlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>bio</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>bio</name> = <call><name>BIO_new</name><argument_list>(<argument><expr><call><name>BIO_s_mem</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>X509_NAME_print_ex</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>dn</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>XN_FLAG_RFC2253</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>BIO_pending</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>maxlen</name> &gt; 0) ? <name>maxlen</name>+1 : <name>len</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>maxlen</name> &gt; 0 &amp;&amp; <name>maxlen</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>len</name> = <call><name>BIO_read</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>maxlen</name> &gt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>result</name> + <name>maxlen</name> - 3</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>"..."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>len</name> = <call><name>BIO_read</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>len</name></expr>]</index></name> = <name>NUL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_otherName_value</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>ASN1_TYPE</name> *</type><name>value</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>onf</name></decl></param>, <param><decl><type><name>apr_array_header_t</name> **</type><name>entries</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nid</name> <init>= <expr><name>onf</name> ? <call><name>OBJ_txt2nid</name><argument_list>(<argument><expr><name>onf</name></expr></argument>)</argument_list></call> : <name>NID_undef</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>value</name> || (<name>nid</name> == <name>NID_undef</name>) || !*<name>entries</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr>(<name>nid</name> == <name>NID_ms_upn</name>) &amp;&amp; (<name><name>value</name>-&gt;<name>type</name></name> == <name>V_ASN1_UTF8STRING</name>) &amp;&amp;
(<name>str</name> = <call><name>asn1_string_to_utf8</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>value</name>.<name>utf8string</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>entries</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>str</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>strEQ</name><argument_list>(<argument><expr><name>onf</name></expr></argument>, <argument><expr>"id-on-dnsSRV"</expr></argument>)</argument_list></call> &amp;&amp;
(<name><name>value</name>-&gt;<name>type</name></name> == <name>V_ASN1_IA5STRING</name>) &amp;&amp;
(<name>str</name> = <call><name>asn1_string_to_utf8</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>value</name>.<name>ia5string</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>entries</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>str</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></function>
<function><type><name>BOOL</name></type> <name>modssl_X509_getSAN</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>X509</name> *</type><name>x509</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>onf</name></decl></param>,
<param><decl><type><name>int</name></type> <name>idx</name></decl></param>, <param><decl><type><name>apr_array_header_t</name> **</type><name>entries</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>GENERAL_NAME</name></expr></argument>)</argument_list></call> *<name>names</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nid</name> <init>= <expr><name>onf</name> ? <call><name>OBJ_txt2nid</name><argument_list>(<argument><expr><name>onf</name></expr></argument>)</argument_list></call> : <name>NID_undef</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>x509</name> || (<name>type</name> &lt; <name>GEN_OTHERNAME</name>) ||
((<name>type</name> == <name>GEN_OTHERNAME</name>) &amp;&amp; (<name>nid</name> == <name>NID_undef</name>)) ||
(<name>type</name> &gt; <name>GEN_RID</name>) || (<name>idx</name> &lt; -1) ||
!(*<name>entries</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>entries</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>names</name> = <call><name>X509_get_ext_d2i</name><argument_list>(<argument><expr><name>x509</name></expr></argument>, <argument><expr><name>NID_subject_alt_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>GENERAL_NAME</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>utf8str</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>sk_GENERAL_NAME_num</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>name</name> = <call><name>sk_GENERAL_NAME_value</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>name</name>-&gt;<name>type</name></name> != <name>type</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
<case>case <expr><name>GEN_EMAIL</name></expr>:
</case><case>case <expr><name>GEN_DNS</name></expr>:
<if>if <condition>(<expr>((<name>idx</name> == -1) || (<name>n</name> == <name>idx</name>)) &amp;&amp;
(<name>utf8str</name> = <call><name>asn1_string_to_utf8</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>name</name>-&gt;<name>d</name>.<name>ia5</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>entries</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>utf8str</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>GEN_OTHERNAME</name></expr>:
<if>if <condition>(<expr><call><name>OBJ_obj2nid</name><argument_list>(<argument><expr><name><name>name</name>-&gt;<name>d</name>.<name>otherName</name>-&gt;<name>type_id</name></name></expr></argument>)</argument_list></call> == <name>nid</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>((<name>idx</name> == -1) || (<name>n</name> == <name>idx</name>))</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>parse_otherName_value</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>name</name>-&gt;<name>d</name>.<name>otherName</name>-&gt;<name>value</name></name></expr></argument>,
<argument><expr><name>onf</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<if>if <condition>(<expr>(<name>idx</name> != -1) &amp;&amp; (<name>n</name> &gt; <name>idx</name>)</expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<expr_stmt><expr><call><name>sk_GENERAL_NAME_pop_free</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><name>GENERAL_NAME_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><call><name>apr_is_empty_array</name><argument_list>(<argument><expr>*<name>entries</name></expr></argument>)</argument_list></call> ? <name>FALSE</name> : <name>TRUE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>BOOL</name></type> <name>getIDs</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>X509</name> *</type><name>x509</name></decl></param>, <param><decl><type><name>apr_array_header_t</name> **</type><name>ids</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>X509_NAME</name> *</type><name>subj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>x509</name> ||
(<call><name>modssl_X509_getSAN</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>x509</name></expr></argument>, <argument><expr><name>GEN_DNS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>ids</name></expr></argument>)</argument_list></call> == <name>FALSE</name> &amp;&amp; !*<name>ids</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>ids</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>subj</name> = <call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>x509</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>i</name> = <call><name>X509_NAME_get_index_by_NID</name><argument_list>(<argument><expr><name>subj</name></expr></argument>, <argument><expr><name>NID_commonName</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>) != -1</expr>)</condition> <block>{
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>ids</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> =
<call><name>modssl_X509_NAME_ENTRY_to_string</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>X509_NAME_get_entry</name><argument_list>(<argument><expr><name>subj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<return>return <expr><call><name>apr_is_empty_array</name><argument_list>(<argument><expr>*<name>ids</name></expr></argument>)</argument_list></call> ? <name>FALSE</name> : <name>TRUE</name></expr>;</return>
}</block></function>
<function><type><name>BOOL</name></type> <name>modssl_X509_match_name</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>X509</name> *</type><name>x509</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
<param><decl><type><name>BOOL</name></type> <name>allow_wildcard</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>BOOL</name></type> <name>matched</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ids</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>getIDs</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>x509</name></expr></argument>, <argument><expr>&amp;<name>ids</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> **</type><name>id</name> <init>= <expr>(<name>char</name> **)<name><name>ids</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BOOL</name></type> <name>is_wildcard</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ids</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<name><name>id</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>is_wildcard</name> = (*<name><name>id</name><index>[<expr><name>i</name></expr>]</index></name> == '*' &amp;&amp; *(<name><name>id</name><index>[<expr><name>i</name></expr>]</index></name>+1) == '.') ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>allow_wildcard</name> == <name>TRUE</name> &amp;&amp; <name>is_wildcard</name> == <name>TRUE</name> &amp;&amp;
(<name>cp</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call>) &amp;&amp; !<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>id</name><index>[<expr><name>i</name></expr>]</index></name>+1</expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call>) ||
!<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>matched</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>s</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>,
<argument><expr>"[%s] modssl_X509_match_name: expecting name '%s', "
"%smatched by ID '%s'"</expr></argument>,
<argument><expr>(<call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)-&gt;<name>vhost_id</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><name>matched</name> == <name>TRUE</name> ? "" : "NOT "</expr></argument>, <argument><expr><name><name>id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>matched</name> == <name>TRUE</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></then></if>
<if>if <condition>(<expr><name>s</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ssl_log_xerror</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>x509</name></expr></argument>,
<argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02412</expr></argument>)</argument_list></call> "[%s] Cert %s for name '%s'"</expr></argument>,
<argument><expr>(<call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)-&gt;<name>vhost_id</name></expr></argument>,
<argument><expr><name>matched</name> == <name>TRUE</name> ? "matches" : "does not match"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>matched</name></expr>;</return>
}</block></function>
<function><type><name>DH</name> *</type><name>ssl_dh_GetParamFromFile</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>DH</name> *</type><name>dh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>bio</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>bio</name> = <call><name>BIO_new_file</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>dh</name> = <call><name>PEM_read_bio_DHparams</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>dh</name>)</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ECC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>EC_GROUP</name> *</type><name>ssl_ec_GetParamFromFile</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>EC_GROUP</name> *</type><name>group</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BIO</name> *</type><name>bio</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>bio</name> = <call><name>BIO_new_file</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>group</name> = <call><name>PEM_read_bio_ECPKParameters</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>group</name>)</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>char</name> *</type><name>modssl_SSL_SESSION_id2sz</name><parameter_list>(<param><decl><type><name>IDCONST</name> <name>unsigned</name> <name>char</name> *</type><name>id</name></decl></param>, <param><decl><type><name>int</name></type> <name>idlen</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>int</name></type> <name>strsize</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>idlen</name> &gt; <name>SSL_MAX_SSL_SESSION_ID_LENGTH</name></expr>)</condition><then>
<expr_stmt><expr><name>idlen</name> = <name>SSL_MAX_SSL_SESSION_ID_LENGTH</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>idlen</name> &gt; (<name>strsize</name>-1) / 2</expr>)</condition><then>
<expr_stmt><expr><name>idlen</name> = (<name>strsize</name>-1) / 2</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ap_bin2hex</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>str</name></expr>;</return>
}</block></function>
</unit>
