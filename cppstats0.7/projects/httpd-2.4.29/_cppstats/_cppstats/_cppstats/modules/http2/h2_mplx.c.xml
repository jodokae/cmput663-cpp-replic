<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="_cppstats/_cppstats/modules/http2/h2_mplx.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_atomic.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_mutex.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_cond.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mpm_common.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_http2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_bucket_beam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_conn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_ctx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_h2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_mplx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_ngn_shed.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_stream.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_session.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_task.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_workers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_util.h"</cpp:file></cpp:include>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_time_t</name></type> <name>now</name></decl>;</decl_stmt>
}</block></struct></type> <name>stream_iter_ctx</name>;</typedef>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_child_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_MPLX_ENTER</name><parameter_list>(<param><type><name>m</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { apr_status_t rv; if ((rv = apr_thread_mutex_lock(m-&gt;lock)) != APR_SUCCESS) {return rv;} } while(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_MPLX_LEAVE</name><parameter_list>(<param><type><name>m</name></type></param>)</parameter_list></cpp:macro> <cpp:value>apr_thread_mutex_unlock(m-&gt;lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_MPLX_ENTER_ALWAYS</name><parameter_list>(<param><type><name>m</name></type></param>)</parameter_list></cpp:macro> <cpp:value>apr_thread_mutex_lock(m-&gt;lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_MPLX_ENTER_MAYBE</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>lock</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (lock) apr_thread_mutex_lock(m-&gt;lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_MPLX_LEAVE_MAYBE</name><parameter_list>(<param><type><name>m</name></type></param>, <param><type><name>lock</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (lock) apr_thread_mutex_unlock(m-&gt;lock)</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_data_for</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>int</name></type> <name>lock</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stream_output_consumed</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>,
<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name> <init>= <expr><name><name>stream</name>-&gt;<name>task</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>length</name> &gt; 0 &amp;&amp; <name>task</name> &amp;&amp; <name><name>task</name>-&gt;<name>assigned</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_req_engine_out_consumed</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>assigned</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stream_input_ev</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><name><name>stream</name>-&gt;<name>session</name>-&gt;<name>mplx</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_atomic_set32</name><argument_list>(<argument><expr>&amp;<name><name>m</name>-&gt;<name>event_pending</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stream_input_consumed</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>h2_stream_in_consumed</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stream_joined</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>!<name><name>stream</name>-&gt;<name>task</name></name> || <name><name>stream</name>-&gt;<name>task</name>-&gt;<name>worker_done</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_remove</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>spurge</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>stream_cleanup</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>state</name></name> == <name>H2_SS_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>input</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_on_consumed</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_beam_abort</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>output</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_on_produced</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_beam_leave</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>h2_stream_cleanup</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_remove</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_iq_remove</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ififo_remove</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>readyq</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>stream</name>-&gt;<name>task</name></name> || <name><name>stream</name>-&gt;<name>task</name>-&gt;<name>worker_done</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>stream_joined</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>stream</name>-&gt;<name>task</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>stream</name>-&gt;<name>task</name>-&gt;<name>c</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>task_thawed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></function>
<function><type><name>h2_mplx</name> *</type><name>h2_mplx_create</name><parameter_list>(<param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>parent</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>h2_config</name> *</type><name>conf</name></decl></param>,
<param><decl><type><name>h2_workers</name> *</type><name>workers</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>mutex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_ctx</name> *</type><name>ctx</name> <init>= <expr><call><name>h2_ctx_get</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_mplx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>id</name></name> = <name><name>c</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>c</name></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>s</name></name> = (<name>ctx</name>? <call><name>h2_ctx_server_get</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> : <name>NULL</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>m</name>-&gt;<name>s</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>s</name></name> = <name><name>c</name>-&gt;<name>base_server</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>status</name> = <call><name>apr_allocator_create</name><argument_list>(<argument><expr>&amp;<name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_allocator_max_free_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>ap_max_mem_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_create_ex</name><argument_list>(<argument><expr>&amp;<name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>m</name>-&gt;<name>pool</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_allocator_destroy</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_pool_tag</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"h2_mplx"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_allocator_owner_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name>mutex</name></expr></argument>, <argument><expr><name>APR_THREAD_MUTEX_DEFAULT</name></expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_allocator_mutex_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>m</name>-&gt;<name>lock</name></name></expr></argument>, <argument><expr><name>APR_THREAD_MUTEX_DEFAULT</name></expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>status</name> = <call><name>apr_thread_cond_create</name><argument_list>(<argument><expr>&amp;<name><name>m</name>-&gt;<name>task_thawed</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>m</name>-&gt;<name>max_streams</name></name> = <call><name>h2_config_geti</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>H2_CONF_MAX_STREAMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>stream_max_mem</name></name> = <call><name>h2_config_geti</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>H2_CONF_STREAM_MAX_MEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>streams</name></name> = <call><name>h2_ihash_create</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>h2_stream</name></expr></argument>,<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>sredo</name></name> = <call><name>h2_ihash_create</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>h2_stream</name></expr></argument>,<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>shold</name></name> = <call><name>h2_ihash_create</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>h2_stream</name></expr></argument>,<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>spurge</name></name> = <call><name>h2_ihash_create</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>h2_stream</name></expr></argument>,<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>q</name></name> = <call><name>h2_iq_create</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>max_streams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <call><name>h2_ififo_set_create</name><argument_list>(<argument><expr>&amp;<name><name>m</name>-&gt;<name>readyq</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>max_streams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>m</name>-&gt;<name>workers</name></name> = <name>workers</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>max_active</name></name> = <name><name>workers</name>-&gt;<name>max_workers</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>limit_active</name></name> = 6</expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>last_limit_change</name></name> = <name><name>m</name>-&gt;<name>last_idle_block</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>limit_change_interval</name></name> = <call><name>apr_time_from_msec</name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>spare_slaves</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>conn_rec</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>ngn_shed</name></name> = <call><name>h2_ngn_shed_create</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>max_streams</name></name></expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>stream_max_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ngn_shed_set_ctx</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>ngn_shed</name></name></expr></argument> , <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_mplx_shutdown</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>max_stream_started</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>max_stream_started</name> = <name><name>m</name>-&gt;<name>max_stream_started</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_iq_clear</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>max_stream_started</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>input_consumed_signal</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>input</name></name></expr>)</condition><then> <block>{
<return>return <expr><call><name>h2_beam_report_consumption</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>report_consumption_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>input_consumed_signal</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>state</name></name> == <name>H2_SS_CLOSED_L</name>
&amp;&amp; (!<name><name>stream</name>-&gt;<name>task</name></name> || <name><name>stream</name>-&gt;<name>task</name>-&gt;<name>worker_done</name></name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_LOG</name><argument_list>(<argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>10026</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>"remote close missing"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>nghttp2_submit_rst_stream</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>session</name>-&gt;<name>ngh2</name></name></expr></argument>, <argument><expr><name>NGHTTP2_FLAG_NONE</name></expr></argument>,
<argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>NGHTTP2_NO_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>output_consumed_signal</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>task</name>-&gt;<name>output</name>.<name>beam</name></name></expr>)</condition><then> <block>{
<return>return <expr><call><name>h2_beam_report_consumption</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>output</name>.<name>beam</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>task_destroy</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>conn_rec</name> *</type><name>slave</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>reuse_slave</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>slave</name> = <name><name>task</name>-&gt;<name>c</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>s</name>-&gt;<name>keep_alive_max</name></name> == 0 || <name><name>slave</name>-&gt;<name>keepalives</name></name> &lt; <name><name>m</name>-&gt;<name>s</name>-&gt;<name>keep_alive_max</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>reuse_slave</name> = ((<name><name>m</name>-&gt;<name>spare_slaves</name>-&gt;<name>nelts</name></name> &lt; (<name><name>m</name>-&gt;<name>limit_active</name></name> * 3 / 2))
&amp;&amp; !<name><name>task</name>-&gt;<name>rst_error</name></name>)</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>slave</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>reuse_slave</name> &amp;&amp; <name><name>slave</name>-&gt;<name>keepalive</name></name> == <name>AP_CONN_KEEPALIVE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_log</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>output</name>.<name>beam</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>,
<argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03385</expr></argument>)</argument_list></call> "h2_task_destroy, reuse slave"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_task_destroy</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>spare_slaves</name></name></expr></argument>, <argument><expr><name>conn_rec</name>*</expr></argument>)</argument_list></call> = <name>slave</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>h2_beam_log</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>output</name>.<name>beam</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>,
<argument><expr>"h2_task_destroy, destroy slave"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slave</name>-&gt;<name>sbh</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_slave_destroy</name><argument_list>(<argument><expr><name>slave</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stream_destroy_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>h2_ihash_remove</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>spurge</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>state</name></name> == <name>H2_SS_CLEANUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>input</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>input_consumed_signal</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_beam_log</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>"stream_destroy"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_beam_destroy</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name>-&gt;<name>input</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>task</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>task_destroy</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>task</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name>-&gt;<name>task</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>h2_stream_destroy</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>purge_streams</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>int</name></type> <name>lock</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>h2_ihash_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>spurge</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>H2_MPLX_ENTER_MAYBE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>!<call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>spurge</name></name></expr></argument>, <argument><expr><name>stream_destroy_iter</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
}</block></while>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE_MAYBE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>h2_mplx_stream_cb</name> *</type><name>cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>stream_iter_ctx_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stream_iter_wrap</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>stream</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>stream_iter_ctx_t</name> *</type><name>x</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name><name>x</name>-&gt;<name>cb</name></name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name><name>x</name>-&gt;<name>ctx</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_stream_do</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_mplx_stream_cb</name> *</type><name>cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>stream_iter_ctx_t</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name>.<name>cb</name></name> = <name>cb</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name>.<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>stream_iter_wrap</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>report_stream_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name> <init>= <expr><name><name>stream</name>-&gt;<name>task</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"started=%d, scheduled=%d, ready=%d, "
"out_buffer=%ld"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>!!<name><name>stream</name>-&gt;<name>task</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>scheduled</name></name></expr></argument>, <argument><expr><call><name>h2_stream_is_ready</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>(<name>long</name>)<call><name>h2_beam_get_buffered</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>task</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"-&gt;03198: %s %s %s"
"[started=%d/done=%d/frozen=%d]"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>task</name>-&gt;<name>request</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>request</name>-&gt;<name>authority</name></name></expr></argument>,
<argument><expr><name><name>task</name>-&gt;<name>request</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>worker_started</name></name></expr></argument>,
<argument><expr><name><name>task</name>-&gt;<name>worker_done</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"-&gt;03198: no task"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unexpected_stream_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"unexpected, started=%d, scheduled=%d, ready=%d"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>!!<name><name>stream</name>-&gt;<name>task</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>scheduled</name></name></expr></argument>, <argument><expr><call><name>h2_stream_is_ready</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>stream_cancel_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>input</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_on_consumed</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>h2_stream_set_monitor</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_stream_rst</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>H2_ERR_NO_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_stream_dispatch</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>H2_SEV_EOS_SENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stream_cleanup</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_mplx_release_and_join</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>apr_thread_cond_t</name> *</type><name>wait</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>wait_secs</name> <init>= <expr>60</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_workers_unregister</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>workers</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER_ALWAYS</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>!<call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>stream_cancel_iter</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
}</block></while>
<expr_stmt><expr><call><name>h2_ngn_shed_abort</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>ngn_shed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><call><name>h2_ihash_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><call><name>h2_iq_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>join_wait</name></name> = <name>wait</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><call><name>h2_ihash_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>)</argument_list></call> &gt; 0</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>status</name> = <call><name>apr_thread_cond_timedwait</name><argument_list>(<argument><expr><name>wait</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>lock</name></name></expr></argument>, <argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>wait_secs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APR_STATUS_IS_TIMEUP</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03198</expr></argument>)</argument_list></call>
"h2_mplx(%ld): waited %d sec for %d tasks"</expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>i</name>*<name>wait_secs</name></expr></argument>, <argument><expr>(<name>int</name>)<call><name>h2_ihash_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>, <argument><expr><name>report_stream_iter</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>m</name>-&gt;<name>join_wait</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ngn_shed_destroy</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>ngn_shed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>ngn_shed</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>h2_ihash_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03516</expr></argument>)</argument_list></call>
"h2_mplx(%ld): unexpected %d streams in hold"</expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr>(<name>int</name>)<call><name>h2_ihash_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>, <argument><expr><name>unexpected_stream_iter</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): released"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_stream_cleanup</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"cleanup"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>stream_cleanup</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>h2_stream</name> *</type><name>h2_mplx_stream_get</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER_ALWAYS</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>output_produced</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>bytes</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><name><name>stream</name>-&gt;<name>session</name>-&gt;<name>mplx</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>check_data_for</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>out_open</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>int</name></type> <name>stream_id</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>stream_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>stream</name> || !<name><name>stream</name>-&gt;<name>task</name></name> || <name><name>m</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name>-&gt;<name>output</name></name> = <name>beam</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APLOGctrace2</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_log</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>"out_open"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%s): out open"</expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>h2_beam_on_consumed</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>stream_output_consumed</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_beam_on_produced</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name>output_produced</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>task</name>-&gt;<name>output</name>.<name>copy_files</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_on_file_beam</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name>h2_beam_no_files</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>check_data_for</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_out_open</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>int</name></type> <name>stream_id</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>status</name> = <call><name>out_open</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream_id</name></expr></argument>, <argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>out_close</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>task</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>task</name>-&gt;<name>c</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name><name>task</name>-&gt;<name>c</name>-&gt;<name>keepalives</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>stream</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>stream</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%s): close"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <call><name>h2_beam_close</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>output</name>.<name>beam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_beam_log</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>output</name>.<name>beam</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>"out_close"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>output_consumed_signal</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_data_for</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_out_trywait</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl></param>,
<param><decl><type><name>apr_thread_cond_t</name> *</type><name>iowait</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>h2_mplx_has_master_events</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>purge_streams</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>report_consumption_iter</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>added_output</name></name> = <name>iowait</name></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <call><name>apr_thread_cond_timedwait</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>added_output</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>lock</name></name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APLOGctrace2</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): trywait on data for %f ms)"</expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>timeout</name>/1000.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>m</name>-&gt;<name>added_output</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_data_for</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>int</name></type> <name>lock</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>h2_ififo_push</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>readyq</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_atomic_set32</name><argument_list>(<argument><expr>&amp;<name><name>m</name>-&gt;<name>event_pending</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER_MAYBE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>added_output</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_signal</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>added_output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE_MAYBE</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_reprioritize</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_stream_pri_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>h2_iq_sort</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): reprioritize tasks"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>register_if_needed</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name><name>m</name>-&gt;<name>aborted</name></name> &amp;&amp; !<name><name>m</name>-&gt;<name>is_registered</name></name> &amp;&amp; !<call><name>h2_iq_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><call><name>h2_workers_register</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>workers</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>is_registered</name></name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>10021</expr></argument>)</argument_list></call>
"h2_mplx(%ld): register at workers"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_process</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type>struct <name>h2_stream</name> *</type><name>stream</name></decl></param>,
<param><decl><type><name>h2_stream_pri_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>h2_stream_is_ready</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>check_data_for</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"process, add to readyq"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>h2_iq_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>register_if_needed</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"process, added to q"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>h2_task</name> *</type><name>next_stream_task</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sid</name></decl>;</decl_stmt>
<while>while <condition>(<expr>!<name><name>m</name>-&gt;<name>aborted</name></name> &amp;&amp; (<name><name>m</name>-&gt;<name>tasks_active</name></name> &lt; <name><name>m</name>-&gt;<name>limit_active</name></name>)
&amp;&amp; (<name>sid</name> = <call><name>h2_iq_shift</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>stream</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stream</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>conn_rec</name> *</type><name>slave</name></decl>, **<decl><type ref="prev"/><name>pslave</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pslave</name> = (<name>conn_rec</name> **)<call><name>apr_array_pop</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>spare_slaves</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pslave</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>slave</name> = *<name>pslave</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slave</name>-&gt;<name>aborted</name></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>slave</name> = <call><name>h2_slave_create</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<name><name>stream</name>-&gt;<name>task</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>sid</name> &gt; <name><name>m</name>-&gt;<name>max_stream_started</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>max_stream_started</name></name> = <name>sid</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>input</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_on_consumed</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>, <argument><expr><name>stream_input_ev</name></expr></argument>,
<argument><expr><name>stream_input_consumed</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>stream</name>-&gt;<name>task</name></name> = <call><name>h2_task_create</name><argument_list>(<argument><expr><name>slave</name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>,
<argument><expr><name><name>stream</name>-&gt;<name>request</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>,
<argument><expr><name><name>stream</name>-&gt;<name>session</name>-&gt;<name>s</name>-&gt;<name>timeout</name></name></expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>stream_max_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>stream</name>-&gt;<name>task</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>APR_ENOMEM</name></expr></argument>, <argument><expr><name>slave</name></expr></argument>,
<argument><expr><call><name>H2_STRM_LOG</name><argument_list>(<argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02941</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stream</name></expr></argument>,
<argument><expr>"create task"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr>++<name><name>m</name>-&gt;<name>tasks_active</name></name></expr>;</expr_stmt>
<return>return <expr><name><name>stream</name>-&gt;<name>task</name></name></expr>;</return>
}</block></then></if>
}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_pop_task</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_task</name> **</type><name>ptask</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_EOF</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>ptask</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>APR_SUCCESS</name> != (<name>rv</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<return>return <expr><name>rv</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rv</name> = <name>APR_EOF</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>ptask</name> = <call><name>next_stream_task</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = (*<name>ptask</name> != <name>NULL</name> &amp;&amp; !<call><name>h2_iq_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call>)? <name>APR_EAGAIN</name> : <name>APR_SUCCESS</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>APR_EAGAIN</name> != <name>rv</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>is_registered</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>rv</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>task_done</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>, <param><decl><type><name>h2_req_engine</name> *</type><name>ngn</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>task</name>-&gt;<name>frozen</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_task_thaw</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>task_thawed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): task(%s) done"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>out_close</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ngn</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>h2_beam_send</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>output</name>.<name>beam</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_NONBLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bytes</name> += <call><name>h2_beam_get_buffered</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>output</name>.<name>beam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytes</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_req_engine_out_consumed</name><argument_list>(<argument><expr><name>ngn</name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>task</name>-&gt;<name>engine</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>m</name>-&gt;<name>aborted</name></name> &amp;&amp; !<name><name>task</name>-&gt;<name>c</name>-&gt;<name>aborted</name></name>
&amp;&amp; !<call><name>h2_req_engine_is_shutdown</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>engine</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>10022</expr></argument>)</argument_list></call>
"h2_mplx(%ld): task(%s) has not-shutdown "
"engine(%s)"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>,
<argument><expr><call><name>h2_req_engine_get_id</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>engine</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>h2_ngn_shed_done_ngn</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>ngn_shed</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>engine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>task</name>-&gt;<name>worker_done</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>task</name>-&gt;<name>done_at</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%s): request done, %f ms elapsed"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>,
<argument><expr>(<name><name>task</name>-&gt;<name>done_at</name></name> - <name><name>task</name>-&gt;<name>started_at</name></name>) / 1000.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>task</name>-&gt;<name>started_at</name></name> &gt; <name><name>m</name>-&gt;<name>last_idle_block</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>task</name>-&gt;<name>done_at</name></name>- <name><name>m</name>-&gt;<name>last_limit_change</name></name> &gt;= <name><name>m</name>-&gt;<name>limit_change_interval</name></name>
&amp;&amp; <name><name>m</name>-&gt;<name>limit_active</name></name> &lt; <name><name>m</name>-&gt;<name>max_active</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>limit_active</name></name> = <call><name>H2MIN</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>limit_active</name></name> * 2</expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>max_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>last_limit_change</name></name> = <name><name>task</name>-&gt;<name>done_at</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): increase worker limit to %d"</expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>limit_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>stream</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stream</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>m</name>-&gt;<name>aborted</name></name> &amp;&amp; <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>sredo</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_task_redo</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_remove</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>sredo</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_iq_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"task_done, stream open"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>input</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_leave</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>check_data_for</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr>(<name>stream</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>shold</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>stream_id</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"task_done, in hold"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>input</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_beam_leave</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>input</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>stream_joined</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(<name>stream</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>spurge</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>stream_id</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_LOG</name><argument_list>(<argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03517</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>"already in spurge"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>"stream should not be in spurge" == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03518</expr></argument>)</argument_list></call>
"h2_mplx(%s): task_done, stream not found"</expr></argument>,
<argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>"stream should still be available" == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
}</block></function>
<function><type><name>void</name></type> <name>h2_mplx_task_done</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>, <param><decl><type><name>h2_task</name> **</type><name>ptask</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>H2_MPLX_ENTER_ALWAYS</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>task_done</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name><name>m</name>-&gt;<name>tasks_active</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>join_wait</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_thread_cond_signal</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>join_wait</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>ptask</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>ptask</name> = <call><name>next_stream_task</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>register_if_needed</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>latest_repeatable_unsubmitted_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>stream_iter_ctx</name> *</type><name>ctx</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>task</name></name> &amp;&amp; !<name><name>stream</name>-&gt;<name>task</name>-&gt;<name>worker_done</name></name>
&amp;&amp; <call><name>h2_task_can_redo</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>task</name></name></expr></argument>)</argument_list></call>
&amp;&amp; !<call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>m</name>-&gt;<name>sredo</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>h2_stream_is_ready</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>stream</name></name>
|| (<name><name>ctx</name>-&gt;<name>stream</name>-&gt;<name>task</name>-&gt;<name>started_at</name></name> &lt; <name><name>stream</name>-&gt;<name>task</name>-&gt;<name>started_at</name></name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>stream</name></name> = <name>stream</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>h2_stream</name> *</type><name>get_latest_repeatable_unsubmitted_stream</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>stream_iter_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>m</name></name> = <name>m</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>stream</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>latest_repeatable_unsubmitted_iter</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ctx</name>.<name>stream</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>timed_out_busy_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>stream_iter_ctx</name> *</type><name>ctx</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>task</name></name> &amp;&amp; !<name><name>stream</name>-&gt;<name>task</name>-&gt;<name>worker_done</name></name>
&amp;&amp; (<name><name>ctx</name>-&gt;<name>now</name></name> - <name><name>stream</name>-&gt;<name>task</name>-&gt;<name>started_at</name></name>) &gt; <name><name>stream</name>-&gt;<name>task</name>-&gt;<name>timeout</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ctx</name>-&gt;<name>stream</name></name> = <name>stream</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>h2_stream</name> *</type><name>get_timed_out_busy_stream</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>stream_iter_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>m</name></name> = <name>m</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>stream</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>now</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>timed_out_busy_iter</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ctx</name>.<name>stream</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>unschedule_slow_tasks</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = (<name><name>m</name>-&gt;<name>tasks_active</name></name> - <name><name>m</name>-&gt;<name>limit_active</name></name> - (<name>int</name>)<call><name>h2_ihash_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>sredo</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; (<name>stream</name> = <call><name>get_latest_repeatable_unsubmitted_stream</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
<expr_stmt><expr><call><name>h2_task_rst</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>task</name></name></expr></argument>, <argument><expr><name>H2_ERR_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>sredo</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name>n</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr>(<name><name>m</name>-&gt;<name>tasks_active</name></name> - <call><name>h2_ihash_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>sredo</name></name></expr></argument>)</argument_list></call>) &gt; <name><name>m</name>-&gt;<name>limit_active</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><call><name>get_timed_out_busy_stream</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>stream</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_TIMEUP</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_idle</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_time_t</name></type> <name>now</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>scount</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>scount</name> = <call><name>h2_ihash_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>scount</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>tasks_active</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>now</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>m</name>-&gt;<name>last_idle_block</name></name> = <name>now</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>limit_active</name></name> &gt; 2
&amp;&amp; <name>now</name> - <name><name>m</name>-&gt;<name>last_limit_change</name></name> &gt;= <name><name>m</name>-&gt;<name>limit_change_interval</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>limit_active</name></name> &gt; 16</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>limit_active</name></name> = 16</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>m</name>-&gt;<name>limit_active</name></name> &gt; 8</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>limit_active</name></name> = 8</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>m</name>-&gt;<name>limit_active</name></name> &gt; 4</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>limit_active</name></name> = 4</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>m</name>-&gt;<name>limit_active</name></name> &gt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>m</name>-&gt;<name>limit_active</name></name> = 2</expr>;</expr_stmt>
}</block></then></if></else></if></else></if></else></if>
<expr_stmt><expr><name><name>m</name>-&gt;<name>last_limit_change</name></name> = <name>now</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): decrease worker limit to %d"</expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>limit_active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>m</name>-&gt;<name>tasks_active</name></name> &gt; <name><name>m</name>-&gt;<name>limit_active</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <call><name>unschedule_slow_tasks</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>h2_iq_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): idle, but %d streams to process"</expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr>(<name>int</name>)<call><name>h2_iq_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): idle, no tasks ongoing, %d streams"</expr></argument>,
<argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr>(<name>int</name>)<call><name>h2_ihash_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_shift</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr>(<name>void</name>**)&amp;<name>stream</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stream</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_ihash_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>output</name></name> &amp;&amp; !<name><name>stream</name>-&gt;<name>out_checked</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr><call><name>H2_STRM_MSG</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"output closed=%d, mplx idle"
", out has %ld bytes buffered"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>h2_beam_is_closed</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>(<name>long</name>)<call><name>h2_beam_get_buffered</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>output</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_data_for</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stream</name>-&gt;<name>out_checked</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></else></if></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>register_if_needed</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>h2_mplx</name> *</type> <name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_req_engine</name> *</type><name>ngn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>streams_updated</name></decl>;</decl_stmt>
}</block></struct></type> <name>ngn_update_ctx</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ngn_update_window</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ngn_update_ctx</name> *</type><name>uctx</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name> <init>= <expr><name>val</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>stream</name>-&gt;<name>task</name></name> &amp;&amp; <name><name>stream</name>-&gt;<name>task</name>-&gt;<name>assigned</name></name> == <name><name>uctx</name>-&gt;<name>ngn</name></name>
&amp;&amp; <call><name>output_consumed_signal</name><argument_list>(<argument><expr><name><name>uctx</name>-&gt;<name>m</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>task</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name><name>uctx</name>-&gt;<name>streams_updated</name></name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ngn_out_update_windows</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_req_engine</name> *</type><name>ngn</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ngn_update_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>m</name></name> = <name>m</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>ngn</name></name> = <name>ngn</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ctx</name>.<name>streams_updated</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>ngn_update_window</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ctx</name>.<name>streams_updated</name></name>? <name>APR_SUCCESS</name> : <name>APR_EAGAIN</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_req_engine_push</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ngn_type</name></decl></param>,
<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
<param><decl><type><name>http2_req_engine_init</name> *</type><name>einit</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name></decl>;</decl_stmt>
<expr_stmt><expr><name>task</name> = <call><name>h2_ctx_rget_task</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>task</name></expr>)</condition><then> <block>{
<return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <name><name>task</name>-&gt;<name>mplx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stream</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <call><name>h2_ngn_shed_push_request</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>ngn_shed</name></name></expr></argument>, <argument><expr><name>ngn_type</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>einit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>status</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_req_engine_pull</name><parameter_list>(<param><decl><type><name>h2_req_engine</name> *</type><name>ngn</name></decl></param>,
<param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
<param><decl><type><name>int</name></type> <name>capacity</name></decl></param>,
<param><decl><type><name>request_rec</name> **</type><name>pr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_ngn_shed</name> *</type><name>shed</name> <init>= <expr><call><name>h2_ngn_shed_get_shed</name><argument_list>(<argument><expr><name>ngn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><call><name>h2_ngn_shed_get_ctx</name><argument_list>(<argument><expr><name>shed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>want_shutdown</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>want_shutdown</name> = (<name>block</name> == <name>APR_BLOCK_READ</name>)</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ngn_out_update_windows</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>ngn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>want_shutdown</name> &amp;&amp; !<call><name>h2_iq_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = <call><name>h2_ngn_shed_pull_request</name><argument_list>(<argument><expr><name>shed</name></expr></argument>, <argument><expr><name>ngn</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): start block engine pull"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_thread_cond_timedwait</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>task_thawed</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>lock</name></name></expr></argument>,
<argument><expr><call><name>apr_time_from_msec</name><argument_list>(<argument><expr>20</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = <call><name>h2_ngn_shed_pull_request</name><argument_list>(<argument><expr><name>shed</name></expr></argument>, <argument><expr><name>ngn</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>status</name> = <call><name>h2_ngn_shed_pull_request</name><argument_list>(<argument><expr><name>shed</name></expr></argument>, <argument><expr><name>ngn</name></expr></argument>, <argument><expr><name>capacity</name></expr></argument>,
<argument><expr><name>want_shutdown</name></expr></argument>, <argument><expr><name>pr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>h2_mplx_req_engine_done</name><parameter_list>(<param><decl><type><name>h2_req_engine</name> *</type><name>ngn</name></decl></param>, <param><decl><type><name>conn_rec</name> *</type><name>r_conn</name></decl></param>,
<param><decl><type><name>apr_status_t</name></type> <name>status</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name> <init>= <expr><call><name>h2_ctx_cget_task</name><argument_list>(<argument><expr><name>r_conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>task</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>h2_mplx</name> *</type><name>m</name> <init>= <expr><name><name>task</name>-&gt;<name>mplx</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER_ALWAYS</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>stream_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ngn_out_update_windows</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>ngn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ngn_shed_done_task</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>ngn_shed</name></name></expr></argument>, <argument><expr><name>ngn</name></expr></argument>, <argument><expr><name>task</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; <name>stream</name>
&amp;&amp; <call><name>h2_task_can_redo</name><argument_list>(<argument><expr><name>task</name></expr></argument>)</argument_list></call>
&amp;&amp; !<call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>sredo</name></name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>h2_ihash_add</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>sredo</name></name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>task</name>-&gt;<name>engine</name></name></expr>)</condition><then> <block>{
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>task_done</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name>ngn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>int</name></type> <name>h2_mplx_has_master_events</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_atomic_read32</name><argument_list>(<argument><expr>&amp;<name><name>m</name>-&gt;<name>event_pending</name></name></expr></argument>)</argument_list></call> &gt; 0</expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_dispatch_master_events</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>,
<param><decl><type><name>stream_ev_callback</name> *</type><name>on_resume</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>on_ctx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>h2_stream</name> *</type><name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>c</name></name></expr></argument>,
<argument><expr>"h2_mplx(%ld): dispatch events"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_atomic_set32</name><argument_list>(<argument><expr>&amp;<name><name>m</name>-&gt;<name>event_pending</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>h2_ihash_iter</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>report_consumption_iter</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>purge_streams</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>h2_ififo_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>readyq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name> &gt; 0
&amp;&amp; (<call><name>h2_ififo_try_pull</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>readyq</name></name></expr></argument>, <argument><expr>&amp;<name>id</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>)</expr>)</condition> <block>{
<expr_stmt><expr>--<name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>stream</name> = <call><name>h2_ihash_get</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stream</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>on_resume</name><argument_list>(<argument><expr><name>on_ctx</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>apr_status_t</name></type> <name>h2_mplx_keep_active</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>check_data_for</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>h2_mplx_awaits_data</name><parameter_list>(<param><decl><type><name>h2_mplx</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>waiting</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>H2_MPLX_ENTER_ALWAYS</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>h2_ihash_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>streams</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>waiting</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<name><name>m</name>-&gt;<name>tasks_active</name></name> &amp;&amp; !<call><name>h2_ififo_count</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>readyq</name></name></expr></argument>)</argument_list></call>
&amp;&amp; <call><name>h2_iq_empty</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>q</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>waiting</name> = 0</expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>H2_MPLX_LEAVE</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>waiting</name></expr>;</return>
}</block></function>
</unit>
