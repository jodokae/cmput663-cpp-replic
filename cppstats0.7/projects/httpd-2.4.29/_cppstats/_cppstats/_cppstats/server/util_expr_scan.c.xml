<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="_cppstats/_cppstats/server/util_expr_scan.c"><cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>2</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>4</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_INT_ALIGNED</name></cpp:macro> <cpp:value>short int</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_SCANNER</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FLEX_MAJOR_VERSION</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FLEX_MINOR_VERSION</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FLEX_SUBMINOR_VERSION</name></cpp:macro> <cpp:value>35</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YY_FLEX_SUBMINOR_VERSION</name> &gt; 0</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_BETA</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>FLEXINT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEXINT_H</name></cpp:macro></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>__STDC_VERSION__</name> &gt;= 199901L</expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>__STDC_LIMIT_MACROS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__STDC_LIMIT_MACROS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<typedef>typedef <type><name>int8_t</name></type> <name>flex_int8_t</name>;</typedef>
<typedef>typedef <type><name>uint8_t</name></type> <name>flex_uint8_t</name>;</typedef>
<typedef>typedef <type><name>int16_t</name></type> <name>flex_int16_t</name>;</typedef>
<typedef>typedef <type><name>uint16_t</name></type> <name>flex_uint16_t</name>;</typedef>
<typedef>typedef <type><name>int32_t</name></type> <name>flex_int32_t</name>;</typedef>
<typedef>typedef <type><name>uint32_t</name></type> <name>flex_uint32_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>signed</name> <name>char</name></type> <name>flex_int8_t</name>;</typedef>
<typedef>typedef <type><name>short</name> <name>int</name></type> <name>flex_int16_t</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>flex_int32_t</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>flex_uint8_t</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>flex_uint16_t</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>flex_uint32_t</name>;</typedef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>INT8_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT8_MIN</name></cpp:macro> <cpp:value>(-128)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>INT16_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT16_MIN</name></cpp:macro> <cpp:value>(-32767-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>INT32_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32_MIN</name></cpp:macro> <cpp:value>(-2147483647-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>INT8_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT8_MAX</name></cpp:macro> <cpp:value>(127)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>INT16_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT16_MAX</name></cpp:macro> <cpp:value>(32767)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>INT32_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32_MAX</name></cpp:macro> <cpp:value>(2147483647)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>UINT8_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT8_MAX</name></cpp:macro> <cpp:value>(255U)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>UINT16_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT16_MAX</name></cpp:macro> <cpp:value>(65535U)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>UINT32_MAX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT32_MAX</name></cpp:macro> <cpp:value>(4294967295U)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_USE_CONST</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__STDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_USE_CONST</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YY_USE_CONST</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyconst</name></cpp:macro> <cpp:value>const</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyconst</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NULL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_SC_TO_UI</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((unsigned int) (unsigned char) c)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_TYPEDEF_YY_SCANNER_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_TYPEDEF_YY_SCANNER_T</name></cpp:macro></cpp:define>
<typedef>typedef <type><name>void</name>*</type> <name>yyscan_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyin</name></cpp:macro> <cpp:value>yyg-&gt;yyin_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyout</name></cpp:macro> <cpp:value>yyg-&gt;yyout_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyextra</name></cpp:macro> <cpp:value>yyg-&gt;yyextra_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyleng</name></cpp:macro> <cpp:value>yyg-&gt;yyleng_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yytext</name></cpp:macro> <cpp:value>yyg-&gt;yytext_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yylineno</name></cpp:macro> <cpp:value>(YY_CURRENT_BUFFER_LVALUE-&gt;yy_bs_lineno)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yycolumn</name></cpp:macro> <cpp:value>(YY_CURRENT_BUFFER_LVALUE-&gt;yy_bs_column)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yy_flex_debug</name></cpp:macro> <cpp:value>yyg-&gt;yy_flex_debug_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEGIN</name></cpp:macro> <cpp:value>yyg-&gt;yy_start = 1 + 2 *</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_START</name></cpp:macro> <cpp:value>((yyg-&gt;yy_start - 1) / 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTATE</name></cpp:macro> <cpp:value>YY_START</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STATE_EOF</name><parameter_list>(<param><type><name>state</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(YY_END_OF_BUFFER + state + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NEW_FILE</name></cpp:macro> <cpp:value>ap_expr_yyrestart(yyin ,yyscanner )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_END_OF_BUFFER_CHAR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_BUF_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUF_SIZE</name></cpp:macro> <cpp:value>32768</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUF_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STATE_BUF_SIZE</name></cpp:macro> <cpp:value>((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_TYPEDEF_YY_BUFFER_STATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_TYPEDEF_YY_BUFFER_STATE</name></cpp:macro></cpp:define>
<typedef>typedef <type>struct <name>yy_buffer_state</name> *</type><name>YY_BUFFER_STATE</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_ACT_CONTINUE_SCAN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_ACT_END_OF_FILE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_ACT_LAST_MATCH</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_LESS_LINENO</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyless</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { int yyless_macro_arg = (n); YY_LESS_LINENO(yyless_macro_arg);*yy_cp = yyg-&gt;yy_hold_char; YY_RESTORE_YY_MORE_OFFSET yyg-&gt;yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; YY_DO_BEFORE_ACTION; } while ( 0 )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unput</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>yyunput( c, yyg-&gt;yytext_ptr , yyscanner )</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_TYPEDEF_YY_SIZE_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_TYPEDEF_YY_SIZE_T</name></cpp:macro></cpp:define>
<typedef>typedef <type><name>size_t</name></type> <name>yy_size_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_STRUCT_YY_BUFFER_STATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STRUCT_YY_BUFFER_STATE</name></cpp:macro></cpp:define>
<struct>struct <name>yy_buffer_state</name> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>yy_input_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>yy_ch_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>yy_buf_pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>yy_size_t</name></type> <name>yy_buf_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_n_chars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_is_our_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_is_interactive</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_at_bol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_bs_lineno</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_bs_column</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_fill_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_buffer_status</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUFFER_NEW</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUFFER_NORMAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUFFER_EOF_PENDING</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_CURRENT_BUFFER</name></cpp:macro> <cpp:value>( yyg-&gt;yy_buffer_stack ? yyg-&gt;yy_buffer_stack[yyg-&gt;yy_buffer_stack_top] : NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_CURRENT_BUFFER_LVALUE</name></cpp:macro> <cpp:value>yyg-&gt;yy_buffer_stack[yyg-&gt;yy_buffer_stack_top]</cpp:value></cpp:define>
<function_decl><type><name>void</name></type> <name>ap_expr_yyrestart</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type><name>input_file</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yy_switch_to_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>new_buffer</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_create_buffer</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>,<param><decl><type><name>int</name></type> <name>size</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yy_delete_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yy_flush_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yypush_buffer_state</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>new_buffer</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yypop_buffer_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yyensure_buffer_stack</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yy_load_buffer_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yy_init_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param>,<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FLUSH_BUFFER</name></cpp:macro> <cpp:value>ap_expr_yy_flush_buffer(YY_CURRENT_BUFFER ,yyscanner)</cpp:value></cpp:define>
<function_decl><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_buffer</name> <parameter_list>(<param><decl><type><name>char</name> *</type><name>base</name></decl></param>,<param><decl><type><name>yy_size_t</name></type> <name>size</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_string</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type><name>yy_str</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_bytes</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type><name>bytes</name></decl></param>,<param><decl><type><name>int</name></type> <name>len</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name> *</type><name>ap_expr_yyalloc</name> <parameter_list>(<param><decl><type><name>yy_size_t</name></type></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name> *</type><name>ap_expr_yyrealloc</name> <parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>,<param><decl><type><name>yy_size_t</name></type></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyfree</name> <parameter_list>(<param><decl><type><name>void</name> *</type></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yy_new_buffer</name></cpp:macro> <cpp:value>ap_expr_yy_create_buffer</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yy_set_interactive</name><parameter_list>(<param><type><name>is_interactive</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if ( ! YY_CURRENT_BUFFER ){ ap_expr_yyensure_buffer_stack (yyscanner); YY_CURRENT_BUFFER_LVALUE = ap_expr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); } YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive = is_interactive; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yy_set_bol</name><parameter_list>(<param><type><name>at_bol</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if ( ! YY_CURRENT_BUFFER ){ap_expr_yyensure_buffer_stack (yyscanner); YY_CURRENT_BUFFER_LVALUE = ap_expr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); } YY_CURRENT_BUFFER_LVALUE-&gt;yy_at_bol = at_bol; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_AT_BOL</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(YY_CURRENT_BUFFER_LVALUE-&gt;yy_at_bol)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_expr_yywrap</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_SKIP_YYWRAP</name></cpp:macro></cpp:define>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>YY_CHAR</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>yy_state_type</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yytext_ptr</name></cpp:macro> <cpp:value>yytext_r</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>yy_state_type</name></type> <name>yy_get_previous_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>yy_state_type</name></type> <name>yy_try_NUL_trans</name> <parameter_list>(<param><decl><type><name>yy_state_type</name></type> <name>current_state</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yy_get_next_buffer</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_fatal_error</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name></type> <name><name>msg</name><index>[]</index></name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_DO_BEFORE_ACTION</name></cpp:macro> <cpp:value>yyg-&gt;yytext_ptr = yy_bp; yyleng = (size_t) (yy_cp - yy_bp); yyg-&gt;yy_hold_char = *yy_cp; *yy_cp = '\0'; yyg-&gt;yy_c_buf_p = yy_cp;</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NUM_RULES</name></cpp:macro> <cpp:value>67</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_END_OF_BUFFER</name></cpp:macro> <cpp:value>68</cpp:value></cpp:define>
<struct>struct <name>yy_trans_info</name> <block>{
<decl_stmt><decl><type><name>flex_int32_t</name></type> <name>yy_verify</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>flex_int32_t</name></type> <name>yy_nxt</name></decl>;</decl_stmt>
}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_accept</name><index>[<expr>124</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>68</expr>, <expr>66</expr>, <expr>1</expr>, <expr>43</expr>, <expr>2</expr>, <expr>66</expr>, <expr>66</expr>, <expr>66</expr>,
<expr>65</expr>, <expr>66</expr>, <expr>44</expr>, <expr>26</expr>, <expr>63</expr>, <expr>32</expr>, <expr>30</expr>, <expr>34</expr>, <expr>64</expr>, <expr>64</expr>,
<expr>64</expr>, <expr>64</expr>, <expr>64</expr>, <expr>64</expr>, <expr>64</expr>, <expr>64</expr>, <expr>64</expr>, <expr>64</expr>, <expr>64</expr>, <expr>66</expr>,
<expr>14</expr>, <expr>4</expr>, <expr>3</expr>, <expr>17</expr>, <expr>17</expr>, <expr>67</expr>, <expr>17</expr>, <expr>23</expr>, <expr>4</expr>, <expr>22</expr>,
<expr>20</expr>, <expr>21</expr>, <expr>67</expr>, <expr>16</expr>, <expr>16</expr>, <expr>24</expr>, <expr>27</expr>, <expr>29</expr>, <expr>28</expr>, <expr>1</expr>,
<expr>31</expr>, <expr>37</expr>, <expr>19</expr>, <expr>18</expr>, <expr>39</expr>, <expr>63</expr>, <expr>59</expr>, <expr>59</expr>, <expr>59</expr>, <expr>59</expr>,
<expr>59</expr>, <expr>59</expr>, <expr>33</expr>, <expr>30</expr>, <expr>36</expr>, <expr>35</expr>, <expr>64</expr>, <expr>64</expr>, <expr>57</expr>, <expr>64</expr>,
<expr>55</expr>, <expr>54</expr>, <expr>58</expr>, <expr>53</expr>, <expr>52</expr>, <expr>25</expr>, <expr>25</expr>, <expr>56</expr>, <expr>64</expr>, <expr>40</expr>,
<expr>64</expr>, <expr>41</expr>, <expr>14</expr>, <expr>13</expr>, <expr>15</expr>, <expr>12</expr>, <expr>5</expr>, <expr>6</expr>, <expr>10</expr>, <expr>11</expr>,
<expr>7</expr>, <expr>8</expr>, <expr>9</expr>, <expr>20</expr>, <expr>60</expr>, <expr>46</expr>, <expr>48</expr>, <expr>50</expr>, <expr>45</expr>, <expr>49</expr>,
<expr>51</expr>, <expr>47</expr>, <expr>38</expr>, <expr>64</expr>, <expr>42</expr>, <expr>64</expr>, <expr>5</expr>, <expr>6</expr>, <expr>64</expr>, <expr>61</expr>,
<expr>5</expr>, <expr>62</expr>, <expr>0</expr>
}</block></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int32_t</name></type> <name><name>yy_ec</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>2</expr>, <expr>4</expr>, <expr>5</expr>, <expr>6</expr>, <expr>7</expr>, <expr>8</expr>, <expr>9</expr>, <expr>5</expr>, <expr>10</expr>,
<expr>10</expr>, <expr>1</expr>, <expr>1</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <expr>15</expr>, <expr>15</expr>, <expr>15</expr>,
<expr>15</expr>, <expr>15</expr>, <expr>15</expr>, <expr>15</expr>, <expr>15</expr>, <expr>16</expr>, <expr>16</expr>, <expr>17</expr>, <expr>6</expr>, <expr>18</expr>,
<expr>19</expr>, <expr>20</expr>, <expr>6</expr>, <expr>1</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>,
<expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>,
<expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>,
<expr>1</expr>, <expr>22</expr>, <expr>1</expr>, <expr>6</expr>, <expr>23</expr>, <expr>1</expr>, <expr>24</expr>, <expr>25</expr>, <expr>21</expr>, <expr>26</expr>,
<expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>21</expr>, <expr>30</expr>, <expr>21</expr>, <expr>21</expr>, <expr>31</expr>, <expr>32</expr>, <expr>33</expr>,
<expr>34</expr>, <expr>21</expr>, <expr>35</expr>, <expr>36</expr>, <expr>37</expr>, <expr>38</expr>, <expr>39</expr>, <expr>21</expr>, <expr>21</expr>, <expr>21</expr>,
<expr>21</expr>, <expr>21</expr>, <expr>40</expr>, <expr>41</expr>, <expr>42</expr>, <expr>43</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>
}</block></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int32_t</name></type> <name><name>yy_meta</name><index>[<expr>44</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>2</expr>, <expr>1</expr>, <expr>2</expr>, <expr>1</expr>, <expr>2</expr>, <expr>2</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>3</expr>, <expr>3</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>3</expr>, <expr>2</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>,
<expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>2</expr>, <expr>1</expr>
}</block></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_base</name><index>[<expr>133</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>41</expr>, <expr>47</expr>, <expr>89</expr>, <expr>0</expr>, <expr>130</expr>, <expr>136</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>147</expr>, <expr>146</expr>, <expr>175</expr>, <expr>275</expr>, <expr>54</expr>, <expr>28</expr>, <expr>275</expr>, <expr>43</expr>, <expr>134</expr>, <expr>164</expr>,
<expr>275</expr>, <expr>164</expr>, <expr>275</expr>, <expr>275</expr>, <expr>45</expr>, <expr>152</expr>, <expr>32</expr>, <expr>151</expr>, <expr>0</expr>, <expr>136</expr>,
<expr>133</expr>, <expr>143</expr>, <expr>26</expr>, <expr>133</expr>, <expr>35</expr>, <expr>194</expr>, <expr>38</expr>, <expr>129</expr>, <expr>128</expr>, <expr>122</expr>,
<expr>0</expr>, <expr>275</expr>, <expr>275</expr>, <expr>51</expr>, <expr>122</expr>, <expr>221</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>,
<expr>0</expr>, <expr>275</expr>, <expr>275</expr>, <expr>61</expr>, <expr>121</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>76</expr>,
<expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>65</expr>, <expr>0</expr>, <expr>125</expr>, <expr>47</expr>, <expr>126</expr>,
<expr>107</expr>, <expr>130</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>0</expr>, <expr>130</expr>, <expr>0</expr>, <expr>124</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>275</expr>, <expr>0</expr>, <expr>0</expr>, <expr>104</expr>, <expr>0</expr>,
<expr>101</expr>, <expr>275</expr>, <expr>0</expr>, <expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>71</expr>, <expr>131</expr>, <expr>275</expr>, <expr>275</expr>,
<expr>275</expr>, <expr>275</expr>, <expr>275</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>99</expr>, <expr>0</expr>, <expr>61</expr>, <expr>133</expr>, <expr>135</expr>, <expr>57</expr>, <expr>0</expr>,
<expr>138</expr>, <expr>0</expr>, <expr>275</expr>, <expr>259</expr>, <expr>262</expr>, <expr>265</expr>, <expr>79</expr>, <expr>67</expr>, <expr>268</expr>, <expr>271</expr>,
<expr>65</expr>, <expr>42</expr>
}</block></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_def</name><index>[<expr>133</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr>123</expr>, <expr>1</expr>, <expr>124</expr>, <expr>124</expr>, <expr>123</expr>, <expr>5</expr>, <expr>124</expr>, <expr>124</expr>, <expr>125</expr>, <expr>125</expr>,
<expr>126</expr>, <expr>126</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>127</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>128</expr>, <expr>128</expr>,
<expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>123</expr>,
<expr>129</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>130</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>131</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>132</expr>, <expr>132</expr>, <expr>132</expr>, <expr>132</expr>,
<expr>132</expr>, <expr>132</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>,
<expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>123</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>,
<expr>128</expr>, <expr>123</expr>, <expr>129</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>131</expr>, <expr>132</expr>, <expr>132</expr>, <expr>132</expr>, <expr>132</expr>, <expr>132</expr>, <expr>132</expr>,
<expr>132</expr>, <expr>132</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>128</expr>, <expr>123</expr>, <expr>123</expr>, <expr>128</expr>, <expr>128</expr>,
<expr>123</expr>, <expr>128</expr>, <expr>0</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>
}</block></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_nxt</name><index>[<expr>319</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr>14</expr>, <expr>15</expr>, <expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>14</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>,
<expr>21</expr>, <expr>22</expr>, <expr>23</expr>, <expr>24</expr>, <expr>25</expr>, <expr>25</expr>, <expr>21</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>,
<expr>29</expr>, <expr>14</expr>, <expr>14</expr>, <expr>30</expr>, <expr>29</expr>, <expr>29</expr>, <expr>31</expr>, <expr>32</expr>, <expr>33</expr>, <expr>34</expr>,
<expr>35</expr>, <expr>36</expr>, <expr>37</expr>, <expr>38</expr>, <expr>29</expr>, <expr>29</expr>, <expr>29</expr>, <expr>39</expr>, <expr>29</expr>, <expr>21</expr>,
<expr>40</expr>, <expr>21</expr>, <expr>14</expr>, <expr>42</expr>, <expr>105</expr>, <expr>43</expr>, <expr>61</expr>, <expr>44</expr>, <expr>45</expr>, <expr>42</expr>,
<expr>74</expr>, <expr>43</expr>, <expr>81</expr>, <expr>44</expr>, <expr>45</expr>, <expr>60</expr>, <expr>60</expr>, <expr>63</expr>, <expr>63</expr>, <expr>66</expr>,
<expr>66</expr>, <expr>84</expr>, <expr>46</expr>, <expr>82</expr>, <expr>88</expr>, <expr>94</expr>, <expr>94</expr>, <expr>104</expr>, <expr>46</expr>, <expr>77</expr>,
<expr>62</expr>, <expr>89</expr>, <expr>85</expr>, <expr>107</expr>, <expr>75</expr>, <expr>94</expr>, <expr>94</expr>, <expr>60</expr>, <expr>60</expr>, <expr>66</expr>,
<expr>66</expr>, <expr>67</expr>, <expr>47</expr>, <expr>122</expr>, <expr>108</expr>, <expr>117</expr>, <expr>118</expr>, <expr>120</expr>, <expr>47</expr>, <expr>48</expr>,
<expr>48</expr>, <expr>49</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>,
<expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>50</expr>, <expr>48</expr>, <expr>48</expr>, <expr>48</expr>, <expr>51</expr>,
<expr>48</expr>, <expr>48</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>,
<expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>51</expr>, <expr>48</expr>, <expr>48</expr>,
<expr>52</expr>, <expr>48</expr>, <expr>42</expr>, <expr>110</expr>, <expr>53</expr>, <expr>119</expr>, <expr>54</expr>, <expr>55</expr>, <expr>42</expr>, <expr>116</expr>,
<expr>53</expr>, <expr>115</expr>, <expr>54</expr>, <expr>55</expr>, <expr>111</expr>, <expr>118</expr>, <expr>118</expr>, <expr>121</expr>, <expr>118</expr>, <expr>118</expr>,
<expr>118</expr>, <expr>46</expr>, <expr>118</expr>, <expr>118</expr>, <expr>114</expr>, <expr>113</expr>, <expr>112</expr>, <expr>46</expr>, <expr>109</expr>, <expr>106</expr>,
<expr>95</expr>, <expr>95</expr>, <expr>92</expr>, <expr>91</expr>, <expr>90</expr>, <expr>83</expr>, <expr>80</expr>, <expr>79</expr>, <expr>78</expr>, <expr>76</expr>,
<expr>73</expr>, <expr>56</expr>, <expr>65</expr>, <expr>64</expr>, <expr>123</expr>, <expr>59</expr>, <expr>59</expr>, <expr>56</expr>, <expr>66</expr>, <expr>66</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>68</expr>, <expr>123</expr>, <expr>69</expr>, <expr>70</expr>, <expr>71</expr>, <expr>123</expr>, <expr>72</expr>, <expr>86</expr>, <expr>86</expr>, <expr>86</expr>,
<expr>86</expr>, <expr>86</expr>, <expr>123</expr>, <expr>123</expr>, <expr>86</expr>, <expr>86</expr>, <expr>86</expr>, <expr>86</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>86</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>87</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>86</expr>, <expr>97</expr>, <expr>98</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>99</expr>, <expr>123</expr>, <expr>123</expr>, <expr>100</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>101</expr>, <expr>123</expr>, <expr>123</expr>, <expr>102</expr>, <expr>123</expr>, <expr>103</expr>, <expr>41</expr>,
<expr>41</expr>, <expr>41</expr>, <expr>57</expr>, <expr>57</expr>, <expr>57</expr>, <expr>58</expr>, <expr>58</expr>, <expr>58</expr>, <expr>93</expr>, <expr>123</expr>,
<expr>93</expr>, <expr>96</expr>, <expr>96</expr>, <expr>96</expr>, <expr>13</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>
}</block></expr></init></decl> ;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_chk</name><index>[<expr>319</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>3</expr>, <expr>132</expr>, <expr>3</expr>, <expr>16</expr>, <expr>3</expr>, <expr>3</expr>, <expr>4</expr>,
<expr>27</expr>, <expr>4</expr>, <expr>33</expr>, <expr>4</expr>, <expr>4</expr>, <expr>15</expr>, <expr>15</expr>, <expr>18</expr>, <expr>18</expr>, <expr>25</expr>,
<expr>25</expr>, <expr>35</expr>, <expr>3</expr>, <expr>33</expr>, <expr>37</expr>, <expr>44</expr>, <expr>44</expr>, <expr>131</expr>, <expr>4</expr>, <expr>128</expr>,
<expr>16</expr>, <expr>37</expr>, <expr>35</expr>, <expr>69</expr>, <expr>27</expr>, <expr>54</expr>, <expr>54</expr>, <expr>60</expr>, <expr>60</expr>, <expr>66</expr>,
<expr>66</expr>, <expr>127</expr>, <expr>3</expr>, <expr>119</expr>, <expr>69</expr>, <expr>97</expr>, <expr>97</expr>, <expr>116</expr>, <expr>4</expr>, <expr>5</expr>,
<expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>,
<expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>,
<expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>,
<expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>,
<expr>5</expr>, <expr>5</expr>, <expr>7</expr>, <expr>71</expr>, <expr>7</expr>, <expr>114</expr>, <expr>7</expr>, <expr>7</expr>, <expr>8</expr>, <expr>91</expr>,
<expr>8</expr>, <expr>89</expr>, <expr>8</expr>, <expr>8</expr>, <expr>71</expr>, <expr>98</expr>, <expr>98</expr>, <expr>117</expr>, <expr>117</expr>, <expr>118</expr>,
<expr>118</expr>, <expr>7</expr>, <expr>121</expr>, <expr>121</expr>, <expr>80</expr>, <expr>78</expr>, <expr>72</expr>, <expr>8</expr>, <expr>70</expr>, <expr>68</expr>,
<expr>55</expr>, <expr>45</expr>, <expr>40</expr>, <expr>39</expr>, <expr>38</expr>, <expr>34</expr>, <expr>32</expr>, <expr>31</expr>, <expr>30</expr>, <expr>28</expr>,
<expr>26</expr>, <expr>7</expr>, <expr>20</expr>, <expr>19</expr>, <expr>13</expr>, <expr>12</expr>, <expr>11</expr>, <expr>8</expr>, <expr>22</expr>, <expr>22</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>22</expr>, <expr>0</expr>, <expr>22</expr>, <expr>22</expr>, <expr>22</expr>, <expr>0</expr>, <expr>22</expr>, <expr>36</expr>, <expr>36</expr>, <expr>36</expr>,
<expr>36</expr>, <expr>36</expr>, <expr>0</expr>, <expr>0</expr>, <expr>36</expr>, <expr>36</expr>, <expr>36</expr>, <expr>36</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>36</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>36</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>36</expr>, <expr>46</expr>, <expr>46</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>46</expr>, <expr>0</expr>, <expr>0</expr>, <expr>46</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>46</expr>, <expr>0</expr>, <expr>0</expr>, <expr>46</expr>, <expr>0</expr>, <expr>46</expr>, <expr>124</expr>,
<expr>124</expr>, <expr>124</expr>, <expr>125</expr>, <expr>125</expr>, <expr>125</expr>, <expr>126</expr>, <expr>126</expr>, <expr>126</expr>, <expr>129</expr>, <expr>0</expr>,
<expr>129</expr>, <expr>130</expr>, <expr>130</expr>, <expr>130</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>,
<expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>, <expr>123</expr>
}</block></expr></init></decl> ;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REJECT</name></cpp:macro> <cpp:value>reject_used_but_not_detected</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yymore</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>yymore_used_but_not_detected</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_MORE_ADJ</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_RESTORE_YY_MORE_OFFSET</name></cpp:macro></cpp:define>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NO_INPUT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>43</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_expr_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_expr_parse.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>YY_INPUT</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_INPUT</name><parameter_list>(<param><type><name>buf</name></type></param>,<param><type><name>result</name></type></param>,<param><type><name>max_size</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ if ((result = MIN(max_size, yyextra-&gt;inputbuf + yyextra-&gt;inputlen - yyextra-&gt;inputptr)) &lt;= 0) { result = YY_NULL; } else { memcpy(buf, yyextra-&gt;inputptr, result); yyextra-&gt;inputptr += result; } }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_EXTRA_TYPE</name></cpp:macro> <cpp:value>ap_expr_parse_ctx_t*</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PERROR</name><parameter_list>(<param><type><name>msg</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { yyextra-&gt;error2 = msg ; return T_ERROR; } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str_ptr</name></cpp:macro> <cpp:value>(yyextra-&gt;scan_ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str_buf</name></cpp:macro> <cpp:value>(yyextra-&gt;scan_buf)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str_del</name></cpp:macro> <cpp:value>(yyextra-&gt;scan_del)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_APPEND</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { *str_ptr++ = (c); if (str_ptr &gt;= str_buf + sizeof(str_buf)) PERROR("String too long"); } while (0)</cpp:value></cpp:define>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>615</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>var</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vararg</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>regex</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>regex_flags</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_NO_UNISTD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_EXTRA_TYPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_EXTRA_TYPE</name></cpp:macro> <cpp:value>void *</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<struct>struct <name>yyguts_t</name> <block>{
<decl_stmt><decl><type><name>YY_EXTRA_TYPE</name></type> <name>yyextra_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>yyin_r</name></decl>, *<decl><type ref="prev"/><name>yyout_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>yy_buffer_stack_top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>yy_buffer_stack_max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>YY_BUFFER_STATE</name> *</type> <name>yy_buffer_stack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>yy_hold_char</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_n_chars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yyleng_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>yy_c_buf_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_did_buffer_switch_on_eof</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_start_stack_ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_start_stack_depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>yy_start_stack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>yy_state_type</name></type> <name>yy_last_accepting_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>yy_last_accepting_cpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yylineno_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_flex_debug_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>yytext_r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_more_flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_more_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>YYSTYPE</name> *</type> <name>yylval_r</name></decl>;</decl_stmt>
}</block>;</struct>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yy_init_globals</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yylval</name></cpp:macro> <cpp:value>yyg-&gt;yylval_r</cpp:value></cpp:define>
<function_decl><type><name>int</name></type> <name>ap_expr_yylex_init</name> <parameter_list>(<param><decl><type><name>yyscan_t</name>*</type> <name>scanner</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>ap_expr_yylex_init_extra</name> <parameter_list>(<param><decl><type><name>YY_EXTRA_TYPE</name></type> <name>user_defined</name></decl></param>,<param><decl><type><name>yyscan_t</name>*</type> <name>scanner</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>ap_expr_yylex_destroy</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>ap_expr_yyget_debug</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyset_debug</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>debug_flag</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>YY_EXTRA_TYPE</name></type> <name>ap_expr_yyget_extra</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyset_extra</name> <parameter_list>(<param><decl><type><name>YY_EXTRA_TYPE</name></type> <name>user_defined</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>FILE</name> *</type><name>ap_expr_yyget_in</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyset_in</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>in_str</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>FILE</name> *</type><name>ap_expr_yyget_out</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyset_out</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>out_str</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>ap_expr_yyget_leng</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>char</name> *</type><name>ap_expr_yyget_text</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>ap_expr_yyget_lineno</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyset_lineno</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>line_number</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>YYSTYPE</name> *</type> <name>ap_expr_yyget_lval</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyset_lval</name> <parameter_list>(<param><decl><type><name>YYSTYPE</name> *</type> <name>yylval_param</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_SKIP_YYWRAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <function_decl><type><name>int</name></type> <name>ap_expr_yywrap</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl></extern>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>ap_expr_yywrap</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>yytext_ptr</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_flex_strncpy</name> <parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>,<param><decl><type><name>yyconst</name></type> <name>char</name> *</decl></param>,<param><decl><type><name>int</name></type></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YY_NEED_STRLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yy_flex_strlen</name> <parameter_list>(<param><decl><type><name>yyconst</name></type> <name>char</name> *</decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_NO_INPUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yyinput</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>input</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_push_state</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>new_state</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_pop_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_READ_BUF_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__ia64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_READ_BUF_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_READ_BUF_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>ECHO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECHO</name></cpp:macro> <cpp:value>do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_INPUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_INPUT</name><parameter_list>(<param><type><name>buf</name></type></param>,<param><type><name>result</name></type></param>,<param><type><name>max_size</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) { int c = '*'; size_t n; for ( n = 0; n &lt; max_size &amp;&amp; (c = getc( yyin )) != EOF &amp;&amp; c != '\n'; ++n ) buf[n] = (char) c; if ( c == '\n' ) buf[n++] = (char) c; if ( c == EOF &amp;&amp; ferror( yyin ) ) YY_FATAL_ERROR( "input in flex scanner failed" ); result = n; } else { errno=0; while ( (result = fread(buf, 1, max_size, yyin))==0 &amp;&amp; ferror(yyin)) { if( errno != EINTR) { YY_FATAL_ERROR( "input in flex scanner failed" ); break; } errno=0; clearerr(yyin); } }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>yyterminate</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyterminate</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>return YY_NULL</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_START_STACK_INCR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_START_STACK_INCR</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_FATAL_ERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FATAL_ERROR</name><parameter_list>(<param><type><name>msg</name></type></param>)</parameter_list></cpp:macro> <cpp:value>yy_fatal_error( msg , yyscanner)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_DECL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_DECL_IS_OURS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>ap_expr_yylex</name> \
<parameter_list>(<param><decl><type><name>YYSTYPE</name> *</type> <name>yylval_param</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_DECL</name></cpp:macro> <cpp:value>int ap_expr_yylex (YYSTYPE * yylval_param , yyscan_t yyscanner)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_USER_ACTION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_USER_ACTION</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_BREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BREAK</name></cpp:macro> <cpp:value>break;</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_RULE_SETUP</name></cpp:macro> <cpp:value>YY_USER_ACTION</cpp:value></cpp:define>
<macro><name>YY_DECL</name></macro> <block>{
<decl_stmt><decl><type><name>register</name> <name>yy_state_type</name></type> <name>yy_current_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>yy_cp</name></decl>, *<decl><type ref="prev"/><name>yy_bp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>yy_act</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>78</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<decl_stmt><decl><type><name>char</name></type> <name><name>regex_buf</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>regex_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>regex_del</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>yyextra</name>-&gt;<name>at_start</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>yyextra</name>-&gt;<name>at_start</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>yyextra</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_STRING_RESULT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_EXPR_STRING</name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><name>T_EXPR_BOOL</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>886</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>
<expr_stmt><expr><name>yylval</name> = <name>yylval_param</name></expr>;</expr_stmt>
<if>if <condition>( <expr>!<name><name>yyg</name>-&gt;<name>yy_init</name></name></expr> )</condition><then> <block>{
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_init</name></name> = 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YY_USER_INIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>YY_USER_INIT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_start</name></name></expr> )</condition><then>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start</name></name> = 1</expr>;</expr_stmt></then></if>
<if>if <condition>( <expr>! <name>yyin</name></expr> )</condition><then>
<expr_stmt><expr><name>yyin</name> = <name>stdin</name></expr>;</expr_stmt></then></if>
<if>if <condition>( <expr>! <name>yyout</name></expr> )</condition><then>
<expr_stmt><expr><name>yyout</name> = <name>stdout</name></expr>;</expr_stmt></then></if>
<if>if <condition>( <expr>! <name>YY_CURRENT_BUFFER</name></expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>ap_expr_yyensure_buffer_stack</name> <argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> =
<call><name>ap_expr_yy_create_buffer</name><argument_list>(<argument><expr><name>yyin</name></expr></argument>,<argument><expr><name>YY_BUF_SIZE</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>( <expr>1</expr> )</condition> <block>{
<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_bp</name> = <name>yy_cp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_start</name></name></expr>;</expr_stmt>
<label><name>yy_match</name>:</label>
<do>do <block>{
<decl_stmt><decl><type><name>register</name> <name>YY_CHAR</name></type> <name>yy_c</name> <init>= <expr><name><name>yy_ec</name><index>[<expr><call><name>YY_SC_TO_UI</name><argument_list>(<argument><expr>*<name>yy_cp</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr><name><name>yy_accept</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr> )</condition><then> <block>{
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name> = <name>yy_current_state</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name> = <name>yy_cp</name></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>( <expr><name><name>yy_chk</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + <name>yy_c</name></expr>]</index></name> != <name>yy_current_state</name></expr> )</condition> <block>{
<expr_stmt><expr><name>yy_current_state</name> = (<name>int</name>) <name><name>yy_def</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>( <expr><name>yy_current_state</name> &gt;= 124</expr> )</condition><then>
<expr_stmt><expr><name>yy_c</name> = <name><name>yy_meta</name><index>[<expr>(<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt></then></if>
}</block></while>
<expr_stmt><expr><name>yy_current_state</name> = <name><name>yy_nxt</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + (<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>yy_cp</name></expr>;</expr_stmt>
}</block> while <condition>( <expr><name>yy_current_state</name> != 123</expr> )</condition>;</do>
<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name></expr>;</expr_stmt>
<label><name>yy_find_action</name>:</label>
<expr_stmt><expr><name>yy_act</name> = <name><name>yy_accept</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>YY_DO_BEFORE_ACTION</name></expr>;</expr_stmt>
<label><name>do_action</name>:</label>
<switch>switch <condition>( <expr><name>yy_act</name></expr> )</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr>*<name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name></expr>;</expr_stmt>
<goto>goto <name>yy_find_action</name>;</goto>
</case><case>case <expr>1</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>103</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>2</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>110</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>str_del</name> = <name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_STR_BEGIN</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>3</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>116</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<if>if <condition>(<expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name> == <name>str_del</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>YY_START</name> == <name>var</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Unterminated variable in string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>str_ptr</name> == <name>str_buf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_STR_END</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
<return>return <expr><name>T_STRING</name></expr>;</return>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>4</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>138</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Unterminated string or variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>:
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>vararg</name></expr></argument>)</argument_list></call></expr>:
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>141</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Unterminated string or variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>:
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>144</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<if>if <condition>(<expr>!(<name><name>yyextra</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_STRING_RESULT</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Unterminated string or variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_STRING</name></expr>;</return>
}</block></else></if>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>5</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>157</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>sscanf</name><argument_list>(<argument><expr><name>yytext</name>+1</expr></argument>, <argument><expr>"%o"</expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> &gt; 0xff</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Escape sequence out of bound"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>6</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>168</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Bad escape sequence"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>7</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>171</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>8</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>172</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\r'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>9</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>173</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\t'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>10</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>174</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\b'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>11</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>175</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\f'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>12</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>176</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name><name>yytext</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>13</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>179</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<if>if <condition>(<expr><name>str_ptr</name> != <name>str_buf</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_STRING</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>num</name></name> = <name><name>yytext</name><index>[<expr>1</expr>]</index></name> - '0'</expr>;</expr_stmt>
<return>return <expr><name>T_REGEX_BACKREF</name></expr>;</return>
}</block></else></if>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>14</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>194</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<decl_stmt><decl><type><name>char</name> *</type><name>cp</name> <init>= <expr><name>yytext</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>cp</name> != '\0'</expr>)</condition> <block>{
<expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt>
}</block></while>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>15</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>203</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<if>if <condition>(<expr><name>str_ptr</name> != <name>str_buf</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
<return>return <expr><name>T_STRING</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>yy_push_state</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_VAR_BEGIN</name></expr>;</return>
}</block></else></if>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>16</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>218</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>17</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>222</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>18</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>226</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><call><name>yy_push_state</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_VAR_BEGIN</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>19</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>231</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>num</name></name> = <name><name>yytext</name><index>[<expr>1</expr>]</index></name> - '0'</expr>;</expr_stmt>
<return>return <expr><name>T_REGEX_BACKREF</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>20</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>239</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_ID</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>21</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>244</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><call><name>yy_pop_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_VAR_END</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>22</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>249</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>vararg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>23</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>254</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<decl_stmt><decl><type><name>char</name> *</type><name>msg</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>,
<argument><expr>"Invalid character in variable name '%c'"</expr></argument>, <argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>24</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>260</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<if>if <condition>(<expr><name>str_ptr</name> != <name>str_buf</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_STRING</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>yy_pop_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_VAR_END</name></expr>;</return>
}</block></else></if>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>25</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>278</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name>regex_del</name> = <name><name>yytext</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>regex_ptr</name> = <name>regex_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>26</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>283</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name>regex_del</name> = <name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>regex_ptr</name> = <name>regex_buf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>27</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>288</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<if>if <condition>(<expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name> == <name>regex_del</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>regex_ptr</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>regex_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>regex_ptr</name>++ = <name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>regex_ptr</name> &gt;= <name>regex_buf</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>regex_buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Regexp too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>28</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>299</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>regex_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_REGEX_I</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>29</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>304</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>regex_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_REGEX</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>regex_flags</name></expr></argument>)</argument_list></call></expr>:
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>310</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>regex_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_REGEX</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>30</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>319</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_EQ</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>31</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>320</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_NE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>32</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>321</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_LT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>33</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>322</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_LE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>34</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>323</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_GT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>35</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>324</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_GE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>36</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>325</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_REG</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>37</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>326</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NRE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>38</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>327</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_AND</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>39</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>328</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_AND</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>40</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>329</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_OR</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>41</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>330</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_OR</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>42</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>331</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NOT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>43</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>332</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NOT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>44</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>333</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_CONCAT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>45</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>334</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_IN</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>46</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>335</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_EQ</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>47</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>336</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>48</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>337</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_GE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>49</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>338</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_LE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>50</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>339</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_GT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>51</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>340</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_LT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>52</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>343</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_LT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>53</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>344</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_LE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>54</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>345</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_GT</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>55</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>346</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_GE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>56</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>347</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>57</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>348</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_EQ</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>58</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>349</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_IN</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>59</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>351</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_OP_UNARY</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>60</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>356</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_OP_BINARY</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>61</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>364</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_TRUE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>62</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>365</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_FALSE</name></expr>;</return> }</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>63</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>370</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_DIGIT</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>64</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>378</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>T_ID</name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>65</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>386</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<return>return <expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</return>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>66</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>393</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
<decl_stmt><decl><type><name>char</name> *</type><name>msg</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Parse error near '%c'"</expr></argument>, <argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>67</expr>:
<decl_stmt><decl><type><name>YY_RULE_SETUP</name></type>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>398</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"flex scanner jammed"</expr></argument> )</argument_list></decl>;</decl_stmt>
<macro><name>YY_BREAK</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1523</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>:
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>:
<expr_stmt><expr><call><name>yyterminate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</case><case>case <expr><name>YY_END_OF_BUFFER</name></expr>: <block>{
<decl_stmt><decl><type><name>int</name></type> <name>yy_amount_of_matched_text</name> <init>= <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>yy_cp</name> - <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name></expr></argument>)</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
<macro><name>YY_RESTORE_YY_MORE_OFFSET</name></macro>
<if>if <condition>( <expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buffer_status</name></name> == <name>YY_BUFFER_NEW</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_input_file</name></name> = <name>yyin</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buffer_status</name></name> = <name>YY_BUFFER_NORMAL</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> &lt;= &amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>]</index></name></expr> )</condition><then> <block>{
<decl_stmt><decl><type><name>yy_state_type</name></type> <name>yy_next_state</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>yy_amount_of_matched_text</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <call><name>yy_get_previous_state</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_next_state</name> = <call><name>yy_try_NUL_trans</name><argument_list>( <argument><expr><name>yy_current_state</name></expr></argument> , <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_bp</name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</expr_stmt>
<if>if <condition>( <expr><name>yy_next_state</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>yy_cp</name> = ++<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <name>yy_next_state</name></expr>;</expr_stmt>
<goto>goto <name>yy_match</name>;</goto>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name></expr>;</expr_stmt>
<goto>goto <name>yy_find_action</name>;</goto>
}</block></else></if>
}</block></then> <else>else <switch>switch <condition>( <expr><call><name>yy_get_next_buffer</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{
<case>case <expr><name>EOB_ACT_END_OF_FILE</name></expr>: <block>{
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>( <expr><call><name>ap_expr_yywrap</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr> )</condition><then> <block>{
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_act</name> = <call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>YY_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>do_action</name>;</goto>
}</block></then> <else>else <block>{
<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name></expr> )</condition><then>
<expr_stmt><expr><name>YY_NEW_FILE</name></expr>;</expr_stmt></then></if>
}</block></else></if>
<break>break;</break>
}</block>
</case><case>case <expr><name>EOB_ACT_CONTINUE_SCAN</name></expr>:
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> =
<name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>yy_amount_of_matched_text</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <call><name>yy_get_previous_state</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_bp</name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</expr_stmt>
<goto>goto <name>yy_match</name>;</goto>
</case><case>case <expr><name>EOB_ACT_LAST_MATCH</name></expr>:
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> =
&amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <call><name>yy_get_previous_state</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_bp</name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</expr_stmt>
<goto>goto <name>yy_find_action</name>;</goto>
</case>}</block></switch></else></if>
<break>break;</break>
}</block>
</case><default>default:
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>(
<argument><expr>"fatal flex scanner internal error--no action found"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
}</block></while>
}</block>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_get_next_buffer</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>dest</name> <init>= <expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>source</name> <init>= <expr><name><name>yyg</name>-&gt;<name>yytext_ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>number_to_move</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret_val</name></decl>;</decl_stmt>
<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> &gt; &amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> + 1</expr>]</index></name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>(
<argument><expr>"fatal flex scanner internal error--end of buffer missed"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>( <expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_fill_buffer</name></name> == 0</expr> )</condition><then> <block>{
<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> - <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> - <name>YY_MORE_ADJ</name> == 1</expr> )</condition><then> <block>{
<return>return <expr><name>EOB_ACT_END_OF_FILE</name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><name>EOB_ACT_LAST_MATCH</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>number_to_move</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> - <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
<for>for ( <init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>number_to_move</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr> )
<expr_stmt><expr>*(<name>dest</name>++) = *(<name>source</name>++)</expr>;</expr_stmt></for>
<if>if <condition>( <expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buffer_status</name></name> == <name>YY_BUFFER_EOF_PENDING</name></expr> )</condition><then>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name> = <name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>num_to_read</name> <init>=
<expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_size</name></name> - <name>number_to_move</name> - 1</expr></init></decl>;</decl_stmt>
<while>while <condition>( <expr><name>num_to_read</name> &lt;= 0</expr> )</condition> <block>{
<decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name> <init>= <expr><name>YY_CURRENT_BUFFER</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>yy_c_buf_p_offset</name> <init>=
<expr><call>(<name>int</name>) <argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> - <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name></expr> )</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>new_size</name> <init>= <expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> * 2</expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr><name>new_size</name> &lt;= 0</expr> )</condition><then>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> += <name><name>b</name>-&gt;<name>yy_buf_size</name></name> / 8</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> *= 2</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name></name> = (<name>char</name> *)
<call><name>ap_expr_yyrealloc</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr></argument>,<argument><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> + 2</expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name></name> = 0</expr>;</expr_stmt></else></if>
<if>if <condition>( <expr>! <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>(
<argument><expr>"fatal error - scanner input buffer overflow"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = &amp;<name><name>b</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name>yy_c_buf_p_offset</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>num_to_read</name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_size</name></name> -
<name>number_to_move</name> - 1</expr>;</expr_stmt>
}</block></while>
<if>if <condition>( <expr><name>num_to_read</name> &gt; <name>YY_READ_BUF_SIZE</name></expr> )</condition><then>
<expr_stmt><expr><name>num_to_read</name> = <name>YY_READ_BUF_SIZE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>YY_INPUT</name><argument_list>( <argument><expr>(&amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name>number_to_move</name></expr>]</index></name>)</expr></argument>,
<argument><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>num_to_read</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name> = <name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> == 0</expr> )</condition><then> <block>{
<if>if <condition>( <expr><name>number_to_move</name> == <name>YY_MORE_ADJ</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>ret_val</name> = <name>EOB_ACT_END_OF_FILE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yyrestart</name><argument_list>(<argument><expr><name>yyin</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ret_val</name> = <name>EOB_ACT_LAST_MATCH</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buffer_status</name></name> =
<name>YY_BUFFER_EOF_PENDING</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else
<expr_stmt><expr><name>ret_val</name> = <name>EOB_ACT_CONTINUE_SCAN</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><call>(<name>yy_size_t</name>) <argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> + <name>number_to_move</name></expr></argument>)</argument_list></call> &gt; <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_size</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>yy_size_t</name></type> <name>new_size</name> <init>= <expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> + <name>number_to_move</name> + (<name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> &gt;&gt; 1)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name></name> = (<name>char</name> *) <call><name>ap_expr_yyrealloc</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name></name></expr></argument>,<argument><expr><name>new_size</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name></name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in yy_get_next_buffer()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> += <name>number_to_move</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> + 1</expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> = &amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name>ret_val</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>yy_state_type</name></type> <name>yy_get_previous_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>yy_state_type</name></type> <name>yy_current_state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>yy_cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_start</name></name></expr>;</expr_stmt>
<for>for ( <init><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</init> <condition><expr><name>yy_cp</name> &lt; <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</condition> <incr><expr>++<name>yy_cp</name></expr></incr> ) <block>{
<decl_stmt><decl><type><name>register</name> <name>YY_CHAR</name></type> <name>yy_c</name> <init>= <expr>(*<name>yy_cp</name> ? <name><name>yy_ec</name><index>[<expr><call><name>YY_SC_TO_UI</name><argument_list>(<argument><expr>*<name>yy_cp</name></expr></argument>)</argument_list></call></expr>]</index></name> : 1)</expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr><name><name>yy_accept</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr> )</condition><then> <block>{
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name> = <name>yy_current_state</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name> = <name>yy_cp</name></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>( <expr><name><name>yy_chk</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + <name>yy_c</name></expr>]</index></name> != <name>yy_current_state</name></expr> )</condition> <block>{
<expr_stmt><expr><name>yy_current_state</name> = (<name>int</name>) <name><name>yy_def</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>( <expr><name>yy_current_state</name> &gt;= 124</expr> )</condition><then>
<expr_stmt><expr><name>yy_c</name> = <name><name>yy_meta</name><index>[<expr>(<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt></then></if>
}</block></while>
<expr_stmt><expr><name>yy_current_state</name> = <name><name>yy_nxt</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + (<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>yy_current_state</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>yy_state_type</name></type> <name>yy_try_NUL_trans</name> <parameter_list>(<param><decl><type><name>yy_state_type</name></type> <name>yy_current_state</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>yy_is_jam</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>yy_cp</name> <init>= <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>YY_CHAR</name></type> <name>yy_c</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr><name><name>yy_accept</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr> )</condition><then> <block>{
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name> = <name>yy_current_state</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name> = <name>yy_cp</name></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>( <expr><name><name>yy_chk</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + <name>yy_c</name></expr>]</index></name> != <name>yy_current_state</name></expr> )</condition> <block>{
<expr_stmt><expr><name>yy_current_state</name> = (<name>int</name>) <name><name>yy_def</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>( <expr><name>yy_current_state</name> &gt;= 124</expr> )</condition><then>
<expr_stmt><expr><name>yy_c</name> = <name><name>yy_meta</name><index>[<expr>(<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt></then></if>
}</block></while>
<expr_stmt><expr><name>yy_current_state</name> = <name><name>yy_nxt</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + (<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yy_is_jam</name> = (<name>yy_current_state</name> == 123)</expr>;</expr_stmt>
<return>return <expr><name>yy_is_jam</name> ? 0 : <name>yy_current_state</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_NO_INPUT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yyinput</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
static int input <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
<if>if <condition>( <expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> == <name>YY_END_OF_BUFFER_CHAR</name></expr> )</condition><then> <block>{
<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> &lt; &amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>]</index></name></expr> )</condition><then>
<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = '\0'</expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> - <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>++<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<switch>switch <condition>( <expr><call><name>yy_get_next_buffer</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr> )</condition> <block>{
<case>case <expr><name>EOB_ACT_LAST_MATCH</name></expr>:
<expr_stmt><expr><call><name>ap_expr_yyrestart</name><argument_list>(<argument><expr><name>yyin</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</case><case>case <expr><name>EOB_ACT_END_OF_FILE</name></expr>: <block>{
<if>if <condition>( <expr><call><name>ap_expr_yywrap</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr> )</condition><then>
<return>return <expr><name>EOF</name></expr>;</return></then></if>
<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name></expr> )</condition><then>
<expr_stmt><expr><name>YY_NEW_FILE</name></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>yyinput</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>input</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>
</case><case>case <expr><name>EOB_ACT_CONTINUE_SCAN</name></expr>:
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>offset</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>c</name> = *(<name>unsigned</name> <name>char</name> *) <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_hold_char</name></name> = *++<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type> <name>ap_expr_yyrestart</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>input_file</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr>! <name>YY_CURRENT_BUFFER</name></expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>ap_expr_yyensure_buffer_stack</name> <argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> =
<call><name>ap_expr_yy_create_buffer</name><argument_list>(<argument><expr><name>yyin</name></expr></argument>,<argument><expr><name>YY_BUF_SIZE</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_expr_yy_init_buffer</name><argument_list>(<argument><expr><name>YY_CURRENT_BUFFER</name></expr></argument>,<argument><expr><name>input_file</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yy_switch_to_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>new_buffer</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_expr_yyensure_buffer_stack</name> <argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr><name>YY_CURRENT_BUFFER</name> == <name>new_buffer</name></expr> )</condition><then>
<return>return;</return></then></if>
<if>if <condition>( <expr><name>YY_CURRENT_BUFFER</name></expr> )</condition><then> <block>{
<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_pos</name></name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name> = <name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = <name>new_buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name> = 1</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yy_load_buffer_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_pos</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>yyin</name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_input_file</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_hold_char</name></name> = *<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
}</block></function>
<function><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_create_buffer</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>file</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl>;</decl_stmt>
<expr_stmt><expr><name>b</name> = (<name>YY_BUFFER_STATE</name>) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>( <argument>struct <expr><name>yy_buffer_state</name></expr></argument> )</argument_list></sizeof></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yy_create_buffer()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name></name> = (<name>char</name> *) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> + 2</expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yy_create_buffer()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yy_init_buffer</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><name>file</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yy_delete_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
<return>return;</return></then></if>
<if>if <condition>( <expr><name>b</name> == <name>YY_CURRENT_BUFFER</name></expr> )</condition><then>
<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = (<name>YY_BUFFER_STATE</name>) 0</expr>;</expr_stmt></then></if>
<if>if <condition>( <expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name></expr> )</condition><then>
<expr_stmt><expr><call><name>ap_expr_yyfree</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ap_expr_yyfree</name><argument_list>(<argument><expr>(<name>void</name> *) <name>b</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yy_init_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param>, <param><decl><type><name>FILE</name> *</type> <name>file</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>oerrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_expr_yy_flush_buffer</name><argument_list>(<argument><expr><name>b</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_input_file</name></name> = <name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_fill_buffer</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>b</name> != <name>YY_CURRENT_BUFFER</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_bs_lineno</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_bs_column</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_interactive</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = <name>oerrno</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yy_flush_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_n_chars</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name><index>[<expr>0</expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name><index>[<expr>1</expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_pos</name></name> = &amp;<name><name>b</name>-&gt;<name>yy_ch_buf</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_at_bol</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buffer_status</name></name> = <name>YY_BUFFER_NEW</name></expr>;</expr_stmt>
<if>if <condition>( <expr><name>b</name> == <name>YY_CURRENT_BUFFER</name></expr> )</condition><then>
<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yypush_buffer_state</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>new_buffer</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>new_buffer</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>ap_expr_yyensure_buffer_stack</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr><name>YY_CURRENT_BUFFER</name></expr> )</condition><then> <block>{
<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_pos</name></name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name> = <name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>YY_CURRENT_BUFFER</name></expr>)</condition><then>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = <name>new_buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name> = 1</expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yypop_buffer_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>YY_CURRENT_BUFFER</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>ap_expr_yy_delete_buffer</name><argument_list>(<argument><expr><name>YY_CURRENT_BUFFER</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr>--<name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>YY_CURRENT_BUFFER</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name> = 1</expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yyensure_buffer_stack</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>num_to_alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>num_to_alloc</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> = (struct <name>yy_buffer_state</name>**)<call><name>ap_expr_yyalloc</name>
<argument_list>(<argument><expr><name>num_to_alloc</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>yy_buffer_state</name>*</expr></argument>)</argument_list></sizeof></expr></argument>
, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yyensure_buffer_stack()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>num_to_alloc</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>yy_buffer_state</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name> = <name>num_to_alloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name> = 0</expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name> &gt;= (<name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name>) - 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>grow_size</name> <init>= <expr>8</expr></init></decl> ;</decl_stmt>
<expr_stmt><expr><name>num_to_alloc</name> = <name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name> + <name>grow_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> = (struct <name>yy_buffer_state</name>**)<call><name>ap_expr_yyrealloc</name>
<argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr></argument>,
<argument><expr><name>num_to_alloc</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>yy_buffer_state</name>*</expr></argument>)</argument_list></sizeof></expr></argument>
, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yyensure_buffer_stack()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> + <name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>grow_size</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>yy_buffer_state</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name> = <name>num_to_alloc</name></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_buffer</name> <parameter_list>(<param><decl><type><name>char</name> *</type> <name>base</name></decl></param>, <param><decl><type><name>yy_size_t</name></type> <name>size</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl>;</decl_stmt>
<if>if <condition>( <expr><name>size</name> &lt; 2 ||
<name><name>base</name><index>[<expr><name>size</name>-2</expr>]</index></name> != <name>YY_END_OF_BUFFER_CHAR</name> ||
<name><name>base</name><index>[<expr><name>size</name>-1</expr>]</index></name> != <name>YY_END_OF_BUFFER_CHAR</name></expr> )</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>b</name> = (<name>YY_BUFFER_STATE</name>) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>( <argument>struct <expr><name>yy_buffer_state</name></expr></argument> )</argument_list></sizeof></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yy_scan_buffer()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> = <name>size</name> - 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_pos</name></name> = <name><name>b</name>-&gt;<name>yy_ch_buf</name></name> = <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_input_file</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_n_chars</name></name> = <name><name>b</name>-&gt;<name>yy_buf_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_interactive</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_at_bol</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_fill_buffer</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buffer_status</name></name> = <name>YY_BUFFER_NEW</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yy_switch_to_buffer</name><argument_list>(<argument><expr><name>b</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
}</block></function>
<function><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_string</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type> <name>yystr</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ap_expr_yy_scan_bytes</name><argument_list>(<argument><expr><name>yystr</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>yystr</name></expr></argument>)</argument_list></call></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_bytes</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type> <name>yybytes</name></decl></param>, <param><decl><type><name>int</name></type> <name>_yybytes_len</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>yy_size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <name>_yybytes_len</name> + 2</expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = (<name>char</name> *) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name>buf</name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yy_scan_bytes()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<for>for ( <init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>_yybytes_len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr> )
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>yybytes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>_yybytes_len</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>_yybytes_len</name>+1</expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <call><name>ap_expr_yy_scan_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>n</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"bad buffer in ap_expr_yy_scan_bytes()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name> = 1</expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_push_state</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>new_state</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name> &gt;= <name><name>yyg</name>-&gt;<name>yy_start_stack_depth</name></name></expr> )</condition><then> <block>{
<decl_stmt><decl><type><name>yy_size_t</name></type> <name>new_size</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack_depth</name></name> += <name>YY_START_STACK_INCR</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_size</name> = <name><name>yyg</name>-&gt;<name>yy_start_stack_depth</name></name> * <sizeof>sizeof<argument_list>( <argument><expr><name>int</name></expr></argument> )</argument_list></sizeof></expr>;</expr_stmt>
<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_start_stack</name></name></expr> )</condition><then>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name> = (<name>int</name> *) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><name>new_size</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name> = (<name>int</name> *) <call><name>ap_expr_yyrealloc</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>yyg</name>-&gt;<name>yy_start_stack</name></name></expr></argument>,<argument><expr><name>new_size</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_start_stack</name></name></expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of memory expanding start-condition stack"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name>++</expr>]</index></name> = <name>YY_START</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>new_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_pop_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>( <expr>--<name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name> &lt; 0</expr> )</condition><then>
<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"start-condition stack underflow"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>YY_EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_EXIT_FAILURE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_fatal_error</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name>*</type> <name>msg</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>(<name>void</name>) <call><name>fprintf</name><argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>msg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>( <argument><expr><name>YY_EXIT_FAILURE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>yyless</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyless</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { int yyless_macro_arg = (n); YY_LESS_LINENO(yyless_macro_arg);yytext[yyleng] = yyg-&gt;yy_hold_char; yyg-&gt;yy_c_buf_p = yytext + yyless_macro_arg; yyg-&gt;yy_hold_char = *yyg-&gt;yy_c_buf_p; *yyg-&gt;yy_c_buf_p = '\0'; yyleng = yyless_macro_arg; } while ( 0 )</cpp:value></cpp:define>
<function><type><name>YY_EXTRA_TYPE</name></type> <name>ap_expr_yyget_extra</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>yyextra</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>ap_expr_yyget_lineno</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name>YY_CURRENT_BUFFER</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><name>yylineno</name></expr>;</return>
}</block></function>
<function><type><name>FILE</name> *</type><name>ap_expr_yyget_in</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>yyin</name></expr>;</return>
}</block></function>
<function><type><name>FILE</name> *</type><name>ap_expr_yyget_out</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>yyout</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>ap_expr_yyget_leng</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>yyleng</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type><name>ap_expr_yyget_text</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>yytext</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yyset_extra</name> <parameter_list>(<param><decl><type><name>YY_EXTRA_TYPE</name></type> <name>user_defined</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>yyextra</name> = <name>user_defined</name></expr> ;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yyset_lineno</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>line_number</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name>YY_CURRENT_BUFFER</name></expr> )</condition><then>
<expr_stmt><expr><call><name>yy_fatal_error</name><argument_list>( <argument><expr>"ap_expr_yyset_lineno called with no buffer"</expr></argument> , <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>yylineno</name> = <name>line_number</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yyset_in</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>in_str</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>yyin</name> = <name>in_str</name></expr> ;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yyset_out</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>out_str</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>yyout</name> = <name>out_str</name></expr> ;</expr_stmt>
}</block></function>
<function><type><name>int</name></type> <name>ap_expr_yyget_debug</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>yy_flex_debug</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yyset_debug</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>bdebug</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>yy_flex_debug</name> = <name>bdebug</name></expr> ;</expr_stmt>
}</block></function>
<function><type><name>YYSTYPE</name> *</type> <name>ap_expr_yyget_lval</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<return>return <expr><name>yylval</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yyset_lval</name> <parameter_list>(<param><decl><type><name>YYSTYPE</name> *</type> <name>yylval_param</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>yylval</name> = <name>yylval_param</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>int</name></type> <name>ap_expr_yylex_init</name><parameter_list>(<param><decl><type><name>yyscan_t</name>*</type> <name>ptr_yy_globals</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ptr_yy_globals</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>ptr_yy_globals</name> = (<name>yyscan_t</name>) <call><name>ap_expr_yyalloc</name> <argument_list>( <argument><expr><sizeof>sizeof<argument_list>( <argument>struct <expr><name>yyguts_t</name></expr></argument> )</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>ptr_yy_globals</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>ENOMEM</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>*<name>ptr_yy_globals</name></expr></argument>,<argument><expr>0x00</expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>yyguts_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>yy_init_globals</name> <argument_list>( <argument><expr>*<name>ptr_yy_globals</name></expr></argument> )</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>ap_expr_yylex_init_extra</name><parameter_list>(<param><decl><type><name>YY_EXTRA_TYPE</name></type> <name>yy_user_defined</name></decl></param>,<param><decl><type><name>yyscan_t</name>*</type> <name>ptr_yy_globals</name></decl></param> )</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name></type> <name>dummy_yyguts</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_expr_yyset_extra</name> <argument_list>(<argument><expr><name>yy_user_defined</name></expr></argument>, <argument><expr>&amp;<name>dummy_yyguts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr_yy_globals</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>ptr_yy_globals</name> = (<name>yyscan_t</name>) <call><name>ap_expr_yyalloc</name> <argument_list>( <argument><expr><sizeof>sizeof<argument_list>( <argument>struct <expr><name>yyguts_t</name></expr></argument> )</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>dummy_yyguts</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>ptr_yy_globals</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>ENOMEM</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>*<name>ptr_yy_globals</name></expr></argument>,<argument><expr>0x00</expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>yyguts_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yyset_extra</name> <argument_list>(<argument><expr><name>yy_user_defined</name></expr></argument>, <argument><expr>*<name>ptr_yy_globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>yy_init_globals</name> <argument_list>( <argument><expr>*<name>ptr_yy_globals</name></expr></argument> )</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_init_globals</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = (<name>char</name> *) 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_init</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack_depth</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YY_STDINIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>yyin</name> = <name>stdin</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yyout</name> = <name>stdout</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>yyin</name> = (<name>FILE</name> *) 0</expr>;</expr_stmt>
<expr_stmt><expr><name>yyout</name> = (<name>FILE</name> *) 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>ap_expr_yylex_destroy</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
<while>while<condition>(<expr><name>YY_CURRENT_BUFFER</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>ap_expr_yy_delete_buffer</name><argument_list>(<argument><expr><name>YY_CURRENT_BUFFER</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yypop_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>ap_expr_yyfree</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yyfree</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>yy_init_globals</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_expr_yyfree</name> <argument_list>( <argument><expr><name>yyscanner</name></expr></argument> , <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>yyscanner</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>yytext_ptr</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_flex_strncpy</name> <parameter_list>(<param><decl><type><name>char</name>*</type> <name>s1</name></decl></param>, <param><decl><type><name>yyconst</name> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for ( <init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr> )
<expr_stmt><expr><name><name>s1</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>s2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>YY_NEED_STRLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_flex_strlen</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type> <name>s</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>n</name></decl>;</decl_stmt>
<for>for ( <init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr> )
<empty_stmt>;</empty_stmt></for>
<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name> *</type><name>ap_expr_yyalloc</name> <parameter_list>(<param><decl><type><name>yy_size_t</name></type> <name>size</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>void</name> *) <call><name>malloc</name><argument_list>( <argument><expr><name>size</name></expr></argument> )</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>void</name> *</type><name>ap_expr_yyrealloc</name> <parameter_list>(<param><decl><type><name>void</name> *</type> <name>ptr</name></decl></param>, <param><decl><type><name>yy_size_t</name></type> <name>size</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>void</name> *) <call><name>realloc</name><argument_list>( <argument><expr>(<name>char</name> *) <name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument> )</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>ap_expr_yyfree</name> <parameter_list>(<param><decl><type><name>void</name> *</type> <name>ptr</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr>(<name>char</name> *) <name>ptr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYTABLES_NAME</name></cpp:macro> <cpp:value>"yytables"</cpp:value></cpp:define>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>398</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
</unit>
