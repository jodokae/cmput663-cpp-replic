<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="_cppstats/_cppstats/server/util_pcre.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pcre.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>POSIX_MALLOC_THRESHOLD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POSIX_MALLOC_THRESHOLD</name></cpp:macro> <cpp:value>(10)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name><name>pstring</name><index>[]</index></name> <init>= <expr><block>{
<expr>""</expr>,
<expr>"internal error"</expr>,
<expr>"failed to get memory"</expr>,
<expr>"bad argument"</expr>,
<expr>"match failed"</expr>
}</block></expr></init></decl>;</decl_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_size_t</argument>)</argument_list></macro> <macro><name>ap_regerror</name><argument_list>(<argument>int errcode</argument>, <argument>const ap_regex_t *preg</argument>,
<argument>char *errbuf</argument>, <argument>apr_size_t errbuf_size</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl>, *<decl><type ref="prev"/><name>addmessage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>addlength</name></decl>;</decl_stmt>
<expr_stmt><expr><name>message</name> = (<name>errcode</name> &gt;= <call>(<name>int</name>)<argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pstring</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>) ?
"unknown error code" : <name><name>pstring</name><index>[<expr><name>errcode</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>length</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>addmessage</name> = " at offset "</expr>;</expr_stmt>
<expr_stmt><expr><name>addlength</name> = (<name>preg</name> != <name>NULL</name> &amp;&amp; (<name>int</name>)<name><name>preg</name>-&gt;<name>re_erroffset</name></name> != -1) ?
<call><name>strlen</name><argument_list>(<argument><expr><name>addmessage</name></expr></argument>)</argument_list></call> + 6 : 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>errbuf_size</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>addlength</name> &gt; 0 &amp;&amp; <name>errbuf_size</name> &gt;= <name>length</name> + <name>addlength</name></expr>)</condition><then>
<expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errbuf_size</name></expr></argument>, <argument><expr>"%s%s%-6d"</expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>addmessage</name></expr></argument>,
<argument><expr>(<name>int</name>)<name><name>preg</name>-&gt;<name>re_erroffset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>errbuf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<return>return <expr><name>length</name> + <name>addlength</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_regfree</name><argument_list>(<argument>ap_regex_t *preg</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><call>(<name>pcre_free</name>)<argument_list>(<argument><expr><name><name>preg</name>-&gt;<name>re_pcre</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_regcomp</name><argument_list>(<argument>ap_regex_t * preg</argument>, <argument>const char *pattern</argument>, <argument>int cflags</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errorptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>erroffset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>errcode</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><name>PCRE_DUPNAMES</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>cflags</name> &amp; <name>AP_REG_ICASE</name>) != 0</expr>)</condition><then>
<expr_stmt><expr><name>options</name> |= <name>PCRE_CASELESS</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>cflags</name> &amp; <name>AP_REG_NEWLINE</name>) != 0</expr>)</condition><then>
<expr_stmt><expr><name>options</name> |= <name>PCRE_MULTILINE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>cflags</name> &amp; <name>AP_REG_DOTALL</name>) != 0</expr>)</condition><then>
<expr_stmt><expr><name>options</name> |= <name>PCRE_DOTALL</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>preg</name>-&gt;<name>re_pcre</name></name> =
<call><name>pcre_compile2</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr>&amp;<name>errcode</name></expr></argument>, <argument><expr>&amp;<name>errorptr</name></expr></argument>, <argument><expr>&amp;<name>erroffset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preg</name>-&gt;<name>re_erroffset</name></name> = <name>erroffset</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>preg</name>-&gt;<name>re_pcre</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>errcode</name> == 21</expr>)</condition><then>
<return>return <expr><name>AP_REG_ESPACE</name></expr>;</return></then></if>
<return>return <expr><name>AP_REG_INVARG</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>pcre_fullinfo</name><argument_list>(<argument><expr>(const <name>pcre</name> *)<name><name>preg</name>-&gt;<name>re_pcre</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>PCRE_INFO_CAPTURECOUNT</name></expr></argument>, <argument><expr>&amp;(<name><name>preg</name>-&gt;<name>re_nsub</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_regexec</name><argument_list>(<argument>const ap_regex_t *preg</argument>, <argument>const char *string</argument>,
<argument>apr_size_t nmatch</argument>, <argument>ap_regmatch_t *pmatch</argument>,
<argument>int eflags</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_regexec_len</name><argument_list>(<argument><expr><name>preg</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>,
<argument><expr><name>eflags</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_regexec_len</name><argument_list>(<argument>const ap_regex_t *preg</argument>, <argument>const char *buff</argument>,
<argument>apr_size_t len</argument>, <argument>apr_size_t nmatch</argument>,
<argument>ap_regmatch_t *pmatch</argument>, <argument>int eflags</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>ovector</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>small_ovector</name><index>[<expr><name>POSIX_MALLOC_THRESHOLD</name> * 3</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>allocated_ovector</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>eflags</name> &amp; <name>AP_REG_NOTBOL</name>) != 0</expr>)</condition><then>
<expr_stmt><expr><name>options</name> |= <name>PCRE_NOTBOL</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>eflags</name> &amp; <name>AP_REG_NOTEOL</name>) != 0</expr>)</condition><then>
<expr_stmt><expr><name>options</name> |= <name>PCRE_NOTEOL</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr>((<name>ap_regex_t</name> *)<name>preg</name>)-&gt;<name>re_erroffset</name> = <call>(<name>apr_size_t</name>)<argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nmatch</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>nmatch</name> &lt;= <name>POSIX_MALLOC_THRESHOLD</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ovector</name> = &amp;(<name><name>small_ovector</name><index>[<expr>0</expr>]</index></name>)</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ovector</name> = (<name>int</name> *)<call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> * <name>nmatch</name> * 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ovector</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>AP_REG_ESPACE</name></expr>;</return></then></if>
<expr_stmt><expr><name>allocated_ovector</name> = 1</expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>pcre_exec</name><argument_list>(<argument><expr>(const <name>pcre</name> *)<name><name>preg</name>-&gt;<name>re_pcre</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr>(<name>int</name>)<name>len</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>ovector</name></expr></argument>, <argument><expr><name>nmatch</name> * 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>rc</name> = <name>nmatch</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>rc</name> &gt;= 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<name>apr_size_t</name>)<name>rc</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name>.<name>rm_so</name> = <name><name>ovector</name><index>[<expr><name>i</name> * 2</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name>.<name>rm_eo</name> = <name><name>ovector</name><index>[<expr><name>i</name> * 2 + 1</expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>allocated_ovector</name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>nmatch</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name>.<name>rm_so</name> = <name><name>pmatch</name><index>[<expr><name>i</name></expr>]</index></name>.<name>rm_eo</name> = -1</expr>;</expr_stmt></for>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>allocated_ovector</name></expr>)</condition><then>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ovector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<switch>switch <condition>(<expr><name>rc</name></expr>)</condition> <block>{
<case>case <expr><name>PCRE_ERROR_NOMATCH</name></expr>:
<return>return <expr><name>AP_REG_NOMATCH</name></expr>;</return>
</case><case>case <expr><name>PCRE_ERROR_NULL</name></expr>:
<return>return <expr><name>AP_REG_INVARG</name></expr>;</return>
</case><case>case <expr><name>PCRE_ERROR_BADOPTION</name></expr>:
<return>return <expr><name>AP_REG_INVARG</name></expr>;</return>
</case><case>case <expr><name>PCRE_ERROR_BADMAGIC</name></expr>:
<return>return <expr><name>AP_REG_INVARG</name></expr>;</return>
</case><case>case <expr><name>PCRE_ERROR_UNKNOWN_NODE</name></expr>:
<return>return <expr><name>AP_REG_ASSERT</name></expr>;</return>
</case><case>case <expr><name>PCRE_ERROR_NOMEMORY</name></expr>:
<return>return <expr><name>AP_REG_ESPACE</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCRE_ERROR_MATCHLIMIT</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>PCRE_ERROR_MATCHLIMIT</name></expr>:
<return>return <expr><name>AP_REG_ESPACE</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCRE_ERROR_BADUTF8</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>PCRE_ERROR_BADUTF8</name></expr>:
<return>return <expr><name>AP_REG_INVARG</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PCRE_ERROR_BADUTF8_OFFSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>PCRE_ERROR_BADUTF8_OFFSET</name></expr>:
<return>return <expr><name>AP_REG_INVARG</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<return>return <expr><name>AP_REG_ASSERT</name></expr>;</return>
</default>}</block></switch>
}</block></else></if>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_regname</name><argument_list>(<argument>const ap_regex_t *preg</argument>,
<argument>apr_array_header_t *names</argument>, <argument>const char *prefix</argument>,
<argument>int upper</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>namecount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nameentrysize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>nametable</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>pcre_fullinfo</name><argument_list>(<argument><expr>(const <name>pcre</name> *)<name><name>preg</name>-&gt;<name>re_pcre</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>PCRE_INFO_NAMECOUNT</name></expr></argument>, <argument><expr>&amp;<name>namecount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcre_fullinfo</name><argument_list>(<argument><expr>(const <name>pcre</name> *)<name><name>preg</name>-&gt;<name>re_pcre</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>PCRE_INFO_NAMEENTRYSIZE</name></expr></argument>, <argument><expr>&amp;<name>nameentrysize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>pcre_fullinfo</name><argument_list>(<argument><expr>(const <name>pcre</name> *)<name><name>preg</name>-&gt;<name>re_pcre</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>PCRE_INFO_NAMETABLE</name></expr></argument>, <argument><expr>&amp;<name>nametable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>namecount</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>offset</name> <init>= <expr><name>nametable</name> + <name>i</name> * <name>nameentrysize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>capture</name> <init>= <expr>((<name><name>offset</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 8) + <name><name>offset</name><index>[<expr>1</expr>]</index></name>)</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>names</name>-&gt;<name>nelts</name></name> &lt;= <name>capture</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>apr_array_push</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>upper</name> || <name>prefix</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr>((<name>char</name> **) <name><name>names</name>-&gt;<name>elts</name></name>)<index>[<expr><name>capture</name></expr>]</index> =
<name>prefix</name> ? <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>names</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>offset</name> + 2</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> :
<call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>names</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>offset</name> + 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>upper</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_str_toupper</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr>((const <name>char</name> **)<name><name>names</name>-&gt;<name>elts</name></name>)<index>[<expr><name>capture</name></expr>]</index> = <name>offset</name> + 2</expr>;</expr_stmt>
}</block></else></if>
}</block></for>
<return>return <expr><name>namecount</name></expr>;</return>
}</block>
</unit>
