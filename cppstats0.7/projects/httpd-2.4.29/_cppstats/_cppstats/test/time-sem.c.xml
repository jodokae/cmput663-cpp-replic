<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="_cppstats/test/time-sem.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_FCNTL_SERIALIZED_ACCEPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>flock</name></type> <name>lock_it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>flock</name></type> <name>unlock_it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>fcntl_fd</name><init>=<expr>-1</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>accept_mutex_child_init</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>accept_mutex_cleanup</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<function><type><name>void</name></type>
<name>accept_mutex_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>lock_it</name>.<name>l_whence</name></name> = <name>SEEK_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lock_it</name>.<name>l_start</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>lock_it</name>.<name>l_len</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>lock_it</name>.<name>l_type</name></name> = <name>F_WRLCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lock_it</name>.<name>l_pid</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>unlock_it</name>.<name>l_whence</name></name> = <name>SEEK_SET</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unlock_it</name>.<name>l_start</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>unlock_it</name>.<name>l_len</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>unlock_it</name>.<name>l_type</name></name> = <name>F_UNLCK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unlock_it</name>.<name>l_pid</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"opening test-lock-thing in current directory\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fcntl_fd</name> = <call><name>open</name><argument_list>(<argument><expr>"test-lock-thing"</expr></argument>, <argument><expr><name>O_CREAT</name> | <name>O_WRONLY</name> | <name>O_EXCL</name></expr></argument>, <argument><expr>0644</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fcntl_fd</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"open"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Cannot open lock file: %s\n"</expr></argument>, <argument><expr>"test-lock-thing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr>"test-lock-thing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_on</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>ret</name> = <call><name>fcntl</name><argument_list>(<argument><expr><name>fcntl_fd</name></expr></argument>, <argument><expr><name>F_SETLKW</name></expr></argument>, <argument><expr>&amp;<name>lock_it</name></expr></argument>)</argument_list></call>) &lt; 0 &amp;&amp; <name>errno</name> == <name>EINTR</name></expr>)</condition>
<continue>continue;</continue></while>
<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"fcntl lock_it"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_off</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>fcntl</name> <argument_list>(<argument><expr><name>fcntl_fd</name></expr></argument>, <argument><expr><name>F_SETLKW</name></expr></argument>, <argument><expr>&amp;<name>unlock_it</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"fcntl unlock_it"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_FLOCK_SERIALIZED_ACCEPT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>flock_fd</name><init>=<expr>-1</expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FNAME</name></cpp:macro> <cpp:value>"test-lock-thing"</cpp:value></cpp:define>
<function><type><name>void</name></type> <name>accept_mutex_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"opening " <name>FNAME</name> " in current directory\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>flock_fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>FNAME</name></expr></argument>, <argument><expr><name>O_CREAT</name> | <name>O_WRONLY</name> | <name>O_EXCL</name></expr></argument>, <argument><expr>0644</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>flock_fd</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"open"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Cannot open lock file: %s\n"</expr></argument>, <argument><expr>"test-lock-thing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_child_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>flock_fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>FNAME</name></expr></argument>, <argument><expr><name>O_WRONLY</name></expr></argument>, <argument><expr>0600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>flock_fd</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"open"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_cleanup</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>FNAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_on</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>ret</name> = <call><name>flock</name><argument_list>(<argument><expr><name>flock_fd</name></expr></argument>, <argument><expr><name>LOCK_EX</name></expr></argument>)</argument_list></call>) &lt; 0 &amp;&amp; <name>errno</name> == <name>EINTR</name></expr>)</condition>
<continue>continue;</continue></while>
<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"flock(LOCK_EX)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_off</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>flock</name> <argument_list>(<argument><expr><name>flock_fd</name></expr></argument>, <argument><expr><name>LOCK_UN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"flock(LOCK_UN)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>USE_SYSVSEM_SERIALIZED_ACCEPT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ipc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sem.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sem_id</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SEM_UNDO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>sigset_t</name></type> <name>accept_block_mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>sigset_t</name></type> <name>accept_previous_mask</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>accept_mutex_child_init</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>accept_mutex_cleanup</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<function><type><name>void</name></type> <name>accept_mutex_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_UNION_SEMUN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<union>union <name>semun</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>semid_ds</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ushort</name> *</type><name>array</name></decl>;</decl_stmt>
}</block>;</union>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type>union <name>semun</name></type> <name>ick</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sem_id</name> = <call><name>semget</name><argument_list>(<argument><expr>999</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>IPC_CREAT</name> | 0666</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sem_id</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"semget"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>ick</name>.<name>val</name></name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>semctl</name><argument_list>(<argument><expr><name>sem_id</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SETVAL</name></expr></argument>, <argument><expr><name>ick</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"semctl"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SEM_UNDO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sigfillset</name><argument_list>(<argument><expr>&amp;<name>accept_block_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr>&amp;<name>accept_block_mask</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr>&amp;<name>accept_block_mask</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr>&amp;<name>accept_block_mask</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_on</name><parameter_list>()</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>sembuf</name></type> <name>op</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SEM_UNDO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr>&amp;<name>accept_block_mask</name></expr></argument>, <argument><expr>&amp;<name>accept_previous_mask</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"sigprocmask(SIG_BLOCK)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>op</name>.<name>sem_flg</name></name> = 0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>op</name>.<name>sem_flg</name></name> = <name>SEM_UNDO</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>op</name>.<name>sem_num</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>.<name>sem_op</name></name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>semop</name><argument_list>(<argument><expr><name>sem_id</name></expr></argument>, <argument><expr>&amp;<name>op</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"accept_mutex_on"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_off</name><parameter_list>()</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>sembuf</name></type> <name>op</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>op</name>.<name>sem_num</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>op</name>.<name>sem_op</name></name> = 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SEM_UNDO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>op</name>.<name>sem_flg</name></name> = 0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name><name>op</name>.<name>sem_flg</name></name> = <name>SEM_UNDO</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>semop</name><argument_list>(<argument><expr><name>sem_id</name></expr></argument>, <argument><expr>&amp;<name>op</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"accept_mutex_off"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NO_SEM_UNDO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr>&amp;<name>accept_previous_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"sigprocmask(SIG_SETMASK)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>USE_PTHREAD_SERIALIZED_ACCEPT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name> *</type><name>mutex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>sigset_t</name></type> <name>accept_block_mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>sigset_t</name></type> <name>accept_previous_mask</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>accept_mutex_child_init</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>accept_mutex_cleanup</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<function><type><name>void</name></type> <name>accept_mutex_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>mattr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fd</name> = <call><name>open</name> <argument_list>(<argument><expr>"/dev/zero"</expr></argument>, <argument><expr><name>O_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"open(/dev/zero)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>mutex</name> = (<name>pthread_mutex_t</name> *)<call><name>mmap</name> <argument_list>(<argument><expr>(<name>caddr_t</name>)0</expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>*<name>mutex</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>PROT_READ</name>|<name>PROT_WRITE</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mutex</name> == <call>(<name>void</name> *)<argument_list>(<argument><expr><name>caddr_t</name></expr></argument>)</argument_list></call>-1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"mmap"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>close</name> <argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>pthread_mutexattr_init</name><argument_list>(<argument><expr>&amp;<name>mattr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"pthread_mutexattr_init"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>pthread_mutexattr_setpshared</name><argument_list>(<argument><expr>&amp;<name>mattr</name></expr></argument>, <argument><expr><name>PTHREAD_PROCESS_SHARED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"pthread_mutexattr_setpshared"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>, <argument><expr>&amp;<name>mattr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"pthread_mutex_init"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>sigfillset</name><argument_list>(<argument><expr>&amp;<name>accept_block_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr>&amp;<name>accept_block_mask</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr>&amp;<name>accept_block_mask</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr>&amp;<name>accept_block_mask</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_on</name><parameter_list>()</parameter_list> <block>{
<if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr>&amp;<name>accept_block_mask</name></expr></argument>, <argument><expr>&amp;<name>accept_previous_mask</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"sigprocmask(SIG_BLOCK)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>pthread_mutex_lock</name> <argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"pthread_mutex_lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_off</name><parameter_list>()</parameter_list> <block>{
<if>if <condition>(<expr><call><name>pthread_mutex_unlock</name> <argument_list>(<argument><expr><name>mutex</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"pthread_mutex_unlock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr>&amp;<name>accept_previous_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"sigprocmask(SIG_SETMASK)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>USE_USLOCK_SERIALIZED_ACCEPT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ulocks.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>usptr_t</name> *</type><name>us</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ulock_t</name></type> <name>uslock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>accept_mutex_child_init</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>accept_mutex_cleanup</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<function><type><name>void</name></type> <name>accept_mutex_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>ptrdiff_t</name></type> <name>old</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONF_INITUSERS_MAX</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>
<if>if <condition>(<expr>(<name>old</name> = <call><name>usconfig</name><argument_list>(<argument><expr><name>CONF_INITUSERS</name></expr></argument>, <argument><expr><name>CONF_INITUSERS_MAX</name></expr></argument>)</argument_list></call>) == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"usconfig"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>old</name> = <call><name>usconfig</name><argument_list>(<argument><expr><name>CONF_LOCKTYPE</name></expr></argument>, <argument><expr><name>US_NODEBUG</name></expr></argument>)</argument_list></call>) == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"usconfig"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>old</name> = <call><name>usconfig</name><argument_list>(<argument><expr><name>CONF_ARENATYPE</name></expr></argument>, <argument><expr><name>US_SHAREDONLY</name></expr></argument>)</argument_list></call>) == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"usconfig"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>us</name> = <call><name>usinit</name><argument_list>(<argument><expr>"/dev/zero"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"usinit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>uslock</name> = <call><name>usnewlock</name><argument_list>(<argument><expr><name>us</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"usnewlock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_on</name><parameter_list>()</parameter_list> <block>{
<switch>switch<condition>(<expr><call><name>ussetlock</name><argument_list>(<argument><expr><name>uslock</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<break>break;</break>
</case><case>case <expr>0</expr>:
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"didn't get lock\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</case><case>case <expr>-1</expr>:
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"ussetlock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
</case>}</block></switch>
}</block></function>
<function><type><name>void</name></type> <name>accept_mutex_off</name><parameter_list>()</parameter_list> <block>{
<if>if <condition>(<expr><call><name>usunsetlock</name><argument_list>(<argument><expr><name>uslock</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"usunsetlock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>USE_SHMGET_SCOREBOARD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name> *</type><name>get_shared_mem</name><parameter_list>(<param><decl><type><name>apr_size_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = (<name>unsigned</name> <name>long</name> *)<call><name>mmap</name> <argument_list>(<argument><expr>(<name>caddr_t</name>)0</expr></argument>, <argument><expr><name>size</name></expr></argument>,
<argument><expr><name>PROT_READ</name>|<name>PROT_WRITE</name></expr></argument>, <argument><expr><name>MAP_ANON</name>|<name>MAP_SHARED</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <call>(<name>void</name> *)<argument_list>(<argument><expr><name>caddr_t</name></expr></argument>)</argument_list></call>-1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"mmap"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ipc.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_MUTEX_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mutex.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/shm.h&gt;</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>void</name> *</type><name>get_shared_mem</name><parameter_list>(<param><decl><type><name>apr_size_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>key_t</name></type> <name>shmkey</name> <init>= <expr><name>IPC_PRIVATE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shmid</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>result</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MOVEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> *</type><name>obrk</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>(<name>shmid</name> = <call><name>shmget</name><argument_list>(<argument><expr><name>shmkey</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>IPC_CREAT</name> | <name>SHM_R</name> | <name>SHM_W</name></expr></argument>)</argument_list></call>) == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"shmget"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MOVEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name>obrk</name> = <call><name>sbrk</name><argument_list>(<argument><expr><name>MOVEBREAK</name></expr></argument>)</argument_list></call>) == (<name>char</name> *) -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"sbrk"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BADSHMAT</name></cpp:macro> <cpp:value>((void *)(-1))</cpp:value></cpp:define>
<if>if <condition>(<expr>(<name>result</name> = <call><name>shmat</name><argument_list>(<argument><expr><name>shmid</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) == <name>BADSHMAT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"shmat"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>shmctl</name><argument_list>(<argument><expr><name>shmid</name></expr></argument>, <argument><expr><name>IPC_RMID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"shmctl(IPC_RMID)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>result</name> == <name>BADSHMAT</name></expr>)</condition><then>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MOVEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>obrk</name> == (<name>char</name> *) -1</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>sbrk</name><argument_list>(<argument><expr>-(<name>MOVEBREAK</name>)</expr></argument>)</argument_list></call> == (<name>char</name> *) -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name><argument_list>(<argument><expr>"sbrk 2"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_PRIORITY_SCHEDULING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_P</name></cpp:macro> <cpp:value>__P</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sched.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YIELD</name></cpp:macro> <cpp:value>sched_yield()</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YIELD</name></cpp:macro> <cpp:value>do { struct timeval zero; zero.tv_sec = zero.tv_usec = 0; select(0,0,0,0,&amp;zero); } while(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type> <name>main</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>num_iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>first</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>last</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>ms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name> *</type><name>shared_counter</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>argc</name> != 3</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Usage: time-sem num-child num iter\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>num_child</name> = <call><name>atoi</name> <argument_list>(<argument><expr><name><name>argv</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num_iter</name> = <call><name>atoi</name> <argument_list>(<argument><expr><name><name>argv</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shared_counter</name> = <call><name>get_shared_mem</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>shared_counter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>shared_counter</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>accept_mutex_init</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>accept_mutex_on</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_child</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>pid</name> = <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>accept_mutex_child_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_iter</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>accept_mutex_on</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = *<name>shared_counter</name></expr>;</expr_stmt>
<expr_stmt><expr><name>YIELD</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>shared_counter</name> = <name>tmp</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>accept_mutex_off</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>pid</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"fork"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></for>
<if>if <condition>(<expr>*<name>shared_counter</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>puts</name> <argument_list>(<argument><expr>"WTF! shared_counter != 0 before the children have been started!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>gettimeofday</name> <argument_list>(<argument><expr>&amp;<name>first</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>accept_mutex_off</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_child</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>wait</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr>"wait"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>gettimeofday</name> <argument_list>(<argument><expr>&amp;<name>last</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>shared_counter</name> != <name>num_child</name> * <name>num_iter</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"WTF! shared_counter != num_child * num_iter!\n"
"shared_counter = %lu\nnum_child = %d\nnum_iter=%d\n"</expr></argument>,
<argument><expr>*<name>shared_counter</name></expr></argument>,
<argument><expr><name>num_child</name></expr></argument>, <argument><expr><name>num_iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>last</name>.<name>tv_sec</name></name> -= <name><name>first</name>.<name>tv_sec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ms</name> = <name><name>last</name>.<name>tv_usec</name></name> - <name><name>first</name>.<name>tv_usec</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ms</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr>--<name><name>last</name>.<name>tv_sec</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ms</name> += 1000000</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>last</name>.<name>tv_usec</name></name> = <name>ms</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr>"%8lu.%06lu\n"</expr></argument>, <argument><expr><name><name>last</name>.<name>tv_sec</name></name></expr></argument>, <argument><expr><name><name>last</name>.<name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>accept_mutex_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
