<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="_cppstats/server/util.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STDIO</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_PROCESS_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_NETDB_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_base64.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ebcdic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_varbuf.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PWD_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GRP_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_LOADAVG_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/loadavg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test_char.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_CHAR</name><parameter_list>(<param><type><name>c</name></type></param>, <param><type><name>f</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(test_char_table[(unsigned char)(c)] &amp; (f))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CASE_BLIND_FILESYSTEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SLASH</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((s == '/') || (s == '\\'))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLASHES</name></cpp:macro> <cpp:value>"/\\"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SLASH</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(s == '/')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLASHES</name></cpp:macro> <cpp:value>"/"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APLOG_MODULE_INDEX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro> <cpp:value>AP_CORE_MODULE_INDEX</cpp:value></cpp:define>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_field_noparam</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *intype</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>semi</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>intype</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>semi</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>intype</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>semi</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>intype</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<while>while <condition>(<expr>(<name>semi</name> &gt; <name>intype</name>) &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>semi</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>semi</name>--</expr>;</expr_stmt>
}</block></while>
<return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>intype</name></expr></argument>, <argument><expr><name>semi</name> - <name>intype</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_ht_time</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>apr_time_t t</argument>, <argument>const char *fmt</argument>,
<argument>int gmt</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>retcode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>ts</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>tf</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>xt</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>gmt</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>strp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_time_exp_gmt</name><argument_list>(<argument><expr>&amp;<name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for(<init><expr><name>strp</name> = <name>tf</name></expr>, <expr><name>f</name> = <name>fmt</name></expr>;</init> <condition><expr><name>strp</name> &lt; <name>tf</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>tf</name></expr></argument>)</argument_list></sizeof> - 6 &amp;&amp; (*<name>strp</name> = *<name>f</name>)</expr>
;</condition> <incr><expr><name>f</name>++</expr>, <expr><name>strp</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>f</name> != '%'</expr>)</condition><then> <continue>continue;</continue></then></if>
<switch>switch <condition>(<expr><name><name>f</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{
<case>case <expr>'%'</expr>:
<expr_stmt><expr>*++<name>strp</name> = *++<name>f</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'Z'</expr>:
<expr_stmt><expr>*<name>strp</name>++ = 'G'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>strp</name>++ = 'M'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>strp</name> = 'T'</expr>;</expr_stmt>
<expr_stmt><expr><name>f</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'z'</expr>:
<expr_stmt><expr>*<name>strp</name>++ = '+'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>strp</name>++ = '0'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>strp</name>++ = '0'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>strp</name>++ = '0'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>strp</name> = '0'</expr>;</expr_stmt>
<expr_stmt><expr><name>f</name>++</expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></for>
<expr_stmt><expr>*<name>strp</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>fmt</name> = <name>tf</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>apr_strftime</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr>&amp;<name>retcode</name></expr></argument>, <argument><expr><name>MAX_STRING_LEN</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr>&amp;<name>xt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ts</name><index>[<expr><name>MAX_STRING_LEN</name> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_strcmp_match</name><argument_list>(<argument>const char *str</argument>, <argument>const char *expected</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<for>for (<init><expr><name>x</name> = 0</expr>, <expr><name>y</name> = 0</expr>;</init> <condition><expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr>;</condition> <incr><expr>++<name>y</name></expr>, <expr>++<name>x</name></expr></incr>) <block>{
<if>if <condition>(<expr>(!<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name>) &amp;&amp; (<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> != '*')</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> == '*'</expr>)</condition><then> <block>{
<while>while <condition>(<expr><name><name>expected</name><index>[<expr>++<name>y</name></expr>]</index></name> == '*'</expr>)</condition><empty_stmt>;</empty_stmt></while>
<if>if <condition>(<expr>!<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<while>while <condition>(<expr><name><name>str</name><index>[<expr><name>x</name></expr>]</index></name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>ret</name> = <call><name>ap_strcmp_match</name><argument_list>(<argument><expr>&amp;<name><name>str</name><index>[<expr><name>x</name>++</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr></argument>)</argument_list></call>) != 1</expr>)</condition><then>
<return>return <expr><name>ret</name></expr>;</return></then></if>
}</block></while>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr>(<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> != '?') &amp;&amp; (<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> != <name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name>)</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if></else></if>
}</block></for>
<return>return <expr>(<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> != '\0')</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_strcasecmp_match</name><argument_list>(<argument>const char *str</argument>, <argument>const char *expected</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<for>for (<init><expr><name>x</name> = 0</expr>, <expr><name>y</name> = 0</expr>;</init> <condition><expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr>;</condition> <incr><expr>++<name>y</name></expr>, <expr>++<name>x</name></expr></incr>) <block>{
<if>if <condition>(<expr>!<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> &amp;&amp; <name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> != '*'</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> == '*'</expr>)</condition><then> <block>{
<while>while <condition>(<expr><name><name>expected</name><index>[<expr>++<name>y</name></expr>]</index></name> == '*'</expr>)</condition><empty_stmt>;</empty_stmt></while>
<if>if <condition>(<expr>!<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<while>while <condition>(<expr><name><name>str</name><index>[<expr><name>x</name></expr>]</index></name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>ret</name> = <call><name>ap_strcasecmp_match</name><argument_list>(<argument><expr>&amp;<name><name>str</name><index>[<expr><name>x</name>++</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr></argument>)</argument_list></call>) != 1</expr>)</condition><then>
<return>return <expr><name>ret</name></expr>;</return></then></if>
}</block></while>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> != '?'
&amp;&amp; <call><name>apr_tolower</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call> != <call><name>apr_tolower</name><argument_list>(<argument><expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if></else></if>
}</block></for>
<return>return <expr>(<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> != '\0')</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_os_is_path_absolute</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *dir</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>newpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ourdir</name> <init>= <expr><name>dir</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_filepath_root</name><argument_list>(<argument><expr>&amp;<name>newpath</name></expr></argument>, <argument><expr>&amp;<name>dir</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name>
|| <call><name>strncmp</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>ourdir</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_matchexp</name><argument_list>(<argument>const char *str</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
<for>for (<init><expr><name>x</name> = 0</expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
<if>if <condition>(<expr>(<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> == '*') || (<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> == '?')</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if></for>
<return>return <expr>0</expr>;</return>
}</block>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>regex_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>preg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>ap_regfree</name><argument_list>(<argument><expr>(<name>ap_regex_t</name> *) <name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_regex_t *</argument>)</argument_list></macro> <macro><name>ap_pregcomp</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *pattern</argument>,
<argument>int cflags</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>preg</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof *<name>preg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>ap_regcomp</name><argument_list>(<argument><expr><name>preg</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>err</name> == <name>AP_REG_ESPACE</name></expr>)</condition><then>
<expr_stmt><expr><call><name>ap_abort_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>void</name> *) <name>preg</name></expr></argument>, <argument><expr><name>regex_cleanup</name></expr></argument>,
<argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>preg</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_pregfree</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>ap_regex_t *reg</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><call><name>ap_regfree</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_pool_cleanup_kill</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>void</name> *) <name>reg</name></expr></argument>, <argument><expr><name>regex_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_strcasestr</name><argument_list>(<argument>const char *s1</argument>, <argument>const char *s2</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>s2</name> == '\0'</expr>)</condition><then> <block>{
<return>return<expr>((<name>char</name> *)<name>s1</name>)</expr>;</return>
}</block></then></if>
<while>while<condition>(<expr>1</expr>)</condition> <block>{
<for>for ( <init>;</init> <condition><expr>(*<name>s1</name> != '\0') &amp;&amp; (<call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>s1</name></expr></argument>)</argument_list></call> != <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>s2</name></expr></argument>)</argument_list></call>)</expr>;</condition> <incr><expr><name>s1</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
<if>if <condition>(<expr>*<name>s1</name> == '\0'</expr>)</condition><then> <block>{
<return>return<expr>(<name>NULL</name>)</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p1</name> = (<name>char</name> *)<name>s1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p2</name> = (<name>char</name> *)<name>s2</name></expr>;</expr_stmt>
<for>for (<init><expr>++<name>p1</name></expr>, <expr>++<name>p2</name></expr>;</init> <condition><expr><call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>p1</name></expr></argument>)</argument_list></call> == <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>p2</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>p1</name></expr>, <expr>++<name>p2</name></expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p1</name> == '\0'</expr>)</condition><then> <block>{
<return>return<expr>((<name>char</name> *)<name>s1</name>)</expr>;</return>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr>*<name>p2</name> == '\0'</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>s1</name>++</expr>;</expr_stmt>
}</block></while>
<return>return<expr>((<name>char</name> *)<name>s1</name>)</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_stripprefix</name><argument_list>(<argument>const char *bigstring</argument>,
<argument>const char *prefix</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p1</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>prefix</name> == '\0'</expr>)</condition><then>
<return>return <expr><name>bigstring</name></expr>;</return></then></if>
<expr_stmt><expr><name>p1</name> = <name>bigstring</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>p1</name> &amp;&amp; *<name>prefix</name></expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>p1</name>++ != *<name>prefix</name>++</expr>)</condition><then>
<return>return <expr><name>bigstring</name></expr>;</return></then></if>
}</block></while>
<if>if <condition>(<expr>*<name>prefix</name> == '\0'</expr>)</condition><then>
<return>return <expr><name>p1</name></expr>;</return></then></if>
<return>return <expr><name>bigstring</name></expr>;</return>
}</block>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>regsub_core</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> **</type><name>result</name></decl></param>,
<param><decl><type>struct <name>ap_varbuf</name> *</type><name>vb</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nmatch</name></decl></param>,
<param><decl><type><name>ap_regmatch_t</name></type> <name><name>pmatch</name><index>[]</index></name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>maxlen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name> <init>= <expr><name>input</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>no</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr>(<name>result</name> &amp;&amp; <name>p</name> &amp;&amp; !<name>vb</name>) || (<name>vb</name> &amp;&amp; !<name>p</name> &amp;&amp; !<name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>source</name> || <name>nmatch</name>&gt;<name>AP_MAX_REG_MATCH</name></expr>)</condition><then>
<return>return <expr><name>APR_EINVAL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<name>nmatch</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>maxlen</name> &gt; 0 &amp;&amp; <name>len</name> &gt;= <name>maxlen</name></expr>)</condition><then>
<return>return <expr><name>APR_ENOMEM</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<name>vb</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>result</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_varbuf_strmemcat</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<while>while <condition>(<expr>(<name>c</name> = *<name>src</name>++) != '\0'</expr>)</condition> <block>{
<if>if <condition>(<expr><name>c</name> == '$' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>no</name> = *<name>src</name>++ - '0'</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>no</name> = <name>AP_MAX_REG_MATCH</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>no</name> &gt;= <name>AP_MAX_REG_MATCH</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>c</name> == '\\' &amp;&amp; *<name>src</name></expr>)</condition><then>
<expr_stmt><expr><name>src</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>len</name>++</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>no</name> &lt; <name>nmatch</name> &amp;&amp; <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name> &lt; <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>APR_SIZE_MAX</name> - <name>len</name> &lt;= <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name></expr>)</condition><then>
<return>return <expr><name>APR_ENOMEM</name></expr>;</return></then></if>
<expr_stmt><expr><name>len</name> += <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></while>
<if>if <condition>(<expr><name>len</name> &gt;= <name>maxlen</name> &amp;&amp; <name>maxlen</name> &gt; 0</expr>)</condition><then>
<return>return <expr><name>APR_ENOMEM</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<name>vb</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>result</name> = <name>dst</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name></expr>)</condition><then>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> + <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst</name> = <name><name>vb</name>-&gt;<name>buf</name></name> + <name><name>vb</name>-&gt;<name>strlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> += <name>len</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>src</name> = <name>input</name></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>c</name> = *<name>src</name>++) != '\0'</expr>)</condition> <block>{
<if>if <condition>(<expr><name>c</name> == '$' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>no</name> = *<name>src</name>++ - '0'</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>no</name> = <name>AP_MAX_REG_MATCH</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>no</name> &gt;= <name>AP_MAX_REG_MATCH</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>c</name> == '\\' &amp;&amp; *<name>src</name></expr>)</condition><then>
<expr_stmt><expr><name>c</name> = *<name>src</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>dst</name>++ = <name>c</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>no</name> &lt; <name>nmatch</name> &amp;&amp; <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name> &lt; <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>len</name> = <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>source</name> + <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst</name> += <name>len</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></while>
<expr_stmt><expr>*<name>dst</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>AP_PREGSUB_MAXLEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_PREGSUB_MAXLEN</name></cpp:macro> <cpp:value>(HUGE_STRING_LEN * 8)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_pregsub</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *input</argument>,
<argument>const char *source</argument>, <argument>apr_size_t nmatch</argument>,
<argument>ap_regmatch_t pmatch[]</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><call><name>regsub_core</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>,
<argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>AP_PREGSUB_MAXLEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pregsub_ex</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **result</argument>,
<argument>const char *input</argument>, <argument>const char *source</argument>,
<argument>apr_size_t nmatch</argument>, <argument>ap_regmatch_t pmatch[]</argument>,
<argument>apr_size_t maxlen</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><call><name>regsub_core</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>,
<argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
<expr_stmt><expr>*<name>result</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_getparents</name><argument_list>(<argument>char *name</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>first_dot</name></decl>;</decl_stmt>
<for>for (<init><expr><name>next</name> = <name>name</name></expr>;</init> <condition><expr>*<name>next</name> &amp;&amp; (*<name>next</name> != '.')</expr>;</condition> <incr><expr><name>next</name>++</expr></incr>) <block>{
}</block></for>
<expr_stmt><expr><name>l</name> = <name>w</name> = <name>first_dot</name> = <name>next</name> - <name>name</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> != '\0'</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> == '.' &amp;&amp; <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call>
&amp;&amp; (<name>l</name> == 0 || <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<expr_stmt><expr><name>l</name> += 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>name</name><index>[<expr><name>w</name>++</expr>]</index></name> = <name><name>name</name><index>[<expr><name>l</name>++</expr>]</index></name></expr>;</expr_stmt></else></if>
}</block></while>
<if>if <condition>(<expr><name>w</name> == 1 &amp;&amp; <name><name>name</name><index>[<expr>0</expr>]</index></name> == '.'</expr>)</condition><then>
<expr_stmt><expr><name>w</name>--</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>w</name> &gt; 1 &amp;&amp; <name><name>name</name><index>[<expr><name>w</name> - 1</expr>]</index></name> == '.' &amp;&amp; <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>w</name> - 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>w</name>--</expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr><name><name>name</name><index>[<expr><name>w</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> = <name>first_dot</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> != '\0'</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr><name>l</name> + 1</expr>]</index></name> == '.' &amp;&amp; <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> + 2</expr>]</index></name></expr></argument>)</argument_list></call>
&amp;&amp; (<name>l</name> == 0 || <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><name>l</name> + 3</expr></init>, <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>l</name> = <name>l</name> - 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>l</name> &gt;= 0</expr>)</condition><then> <block>{
<while>while <condition>(<expr><name>l</name> &gt;= 0 &amp;&amp; !<call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>l</name>--</expr>;</expr_stmt></while>
<expr_stmt><expr><name>l</name>++</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>l</name> = 0</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>n</name> = <name>l</name></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name><name>name</name><index>[<expr><name>n</name></expr>]</index></name> = <name><name>name</name><index>[<expr><name>m</name></expr>]</index></name>)</expr>)</condition>
<expr_stmt><expr>(++<name>n</name>, ++<name>m</name>)</expr>;</expr_stmt></while>
}</block></then> <else>else
<expr_stmt><expr>++<name>l</name></expr>;</expr_stmt></else></if>
}</block></while>
<if>if <condition>(<expr><name>l</name> == 2 &amp;&amp; <name><name>name</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr>1</expr>]</index></name> == '.'</expr>)</condition><then>
<expr_stmt><expr><name><name>name</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>l</name> &gt; 2 &amp;&amp; <name><name>name</name><index>[<expr><name>l</name> - 1</expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr><name>l</name> - 2</expr>]</index></name> == '.'
&amp;&amp; <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> - 3</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>l</name> = <name>l</name> - 4</expr>;</expr_stmt>
<if>if <condition>(<expr><name>l</name> &gt;= 0</expr>)</condition><then> <block>{
<while>while <condition>(<expr><name>l</name> &gt;= 0 &amp;&amp; !<call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>l</name>--</expr>;</expr_stmt></while>
<expr_stmt><expr><name>l</name>++</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>l</name> = 0</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then></if></else></if>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_no2slash</name><argument_list>(<argument>char *name</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> = <name>d</name> = <name>name</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_UNC_PATHS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>s</name><index>[<expr>1</expr>]</index></name> == '/'</expr>)</condition><then>
<expr_stmt><expr>*<name>d</name>++ = *<name>s</name>++</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr>*<name>s</name></expr>)</condition> <block>{
<if>if <condition>(<expr>(*<name>d</name>++ = *<name>s</name>) == '/'</expr>)</condition><then> <block>{
<do>do <block>{
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block> while <condition>(<expr>*<name>s</name> == '/'</expr>)</condition>;</do>
}</block></then> <else>else <block>{
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_make_dirstr_prefix</name><argument_list>(<argument>char *d</argument>, <argument>const char *s</argument>, <argument>int n</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>n</name> &lt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>d</name> = '/'</expr>;</expr_stmt>
<expr_stmt><expr>*++<name>d</name> = '\0'</expr>;</expr_stmt>
<return>return <expr>(<name>d</name>)</expr>;</return>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr>*<name>s</name> == '\0' || (*<name>s</name> == '/' &amp;&amp; (--<name>n</name>) == 0)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>d</name> = '/'</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr>*<name>d</name>++ = *<name>s</name>++</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>*++<name>d</name> = 0</expr>;</expr_stmt>
<return>return <expr>(<name>d</name>)</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_make_dirstr_parent</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *s</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_slash</name> <init>= <expr><call><name>ap_strrchr_c</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>last_slash</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>l</name> = (<name>last_slash</name> - <name>s</name>) + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>d</name>)</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_count_dirs</name><argument_list>(<argument>const char *path</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<for>for (<init><expr><name>x</name> = 0</expr>, <expr><name>n</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>path</name><index>[<expr><name>x</name></expr>]</index></name> == '/'</expr>)</condition><then>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if></for>
<return>return <expr><name>n</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nc</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>char **line</argument>, <argument>char stop</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_getword</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>const char **line</argument>, <argument>char stop</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name> <init>= <expr>*<name>line</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>
<while>while <condition>(<expr>(*<name>pos</name> != <name>stop</name>) &amp;&amp; *<name>pos</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>len</name> = <name>pos</name> - *<name>line</name></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stop</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr>*<name>pos</name> == <name>stop</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<expr_stmt><expr>*<name>line</name> = <name>pos</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_white_nc</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>char **line</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_getword_white</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_white</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>const char **line</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name> <init>= <expr>*<name>line</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>
<while>while <condition>(<expr>!<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>pos</name></expr></argument>)</argument_list></call> &amp;&amp; *<name>pos</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>len</name> = <name>pos</name> - *<name>line</name></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>pos</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>line</name> = <name>pos</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nulls_nc</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>char **line</argument>,
<argument>char stop</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_getword_nulls</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nulls</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>const char **line</argument>,
<argument>char stop</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>pos</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr>*<name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>line</name> += <name>len</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>pos</name> - *<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>line</name> = <name>pos</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>substring_conf</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>,
<param><decl><type><name>char</name></type> <name>quote</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>resp</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name><name>start</name><index>[<expr><name>i</name></expr>]</index></name> == '\\' &amp;&amp; (<name><name>start</name><index>[<expr><name>i</name> + 1</expr>]</index></name> == '\\'
|| (<name>quote</name> &amp;&amp; <name><name>start</name><index>[<expr><name>i</name> + 1</expr>]</index></name> == <name>quote</name>))</expr>)</condition><then>
<expr_stmt><expr>*<name>resp</name>++ = <name><name>start</name><index>[<expr>++<name>i</name></expr>]</index></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>resp</name>++ = <name><name>start</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></else></if>
}</block></for>
<expr_stmt><expr>*<name>resp</name>++ = '\0'</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RESOLVE_ENV_PER_TOKEN</name></expr></cpp:if>
<return>return <expr>(<name>char</name> *)<call><name>ap_resolve_env</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>result</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_conf_nc</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **line</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_getword_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_conf</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **line</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr>*<name>line</name></expr></init>, *<name>strend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></while>
<if>if <condition>(<expr>!*<name>str</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>line</name> = <name>str</name></expr>;</expr_stmt>
<return>return <expr>""</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>quote</name> = *<name>str</name>) == '"' || <name>quote</name> == '\''</expr>)</condition><then> <block>{
<expr_stmt><expr><name>strend</name> = <name>str</name> + 1</expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>strend</name> &amp;&amp; *<name>strend</name> != <name>quote</name></expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>strend</name> == '\\' &amp;&amp; <name><name>strend</name><index>[<expr>1</expr>]</index></name> &amp;&amp;
(<name><name>strend</name><index>[<expr>1</expr>]</index></name> == <name>quote</name> || <name><name>strend</name><index>[<expr>1</expr>]</index></name> == '\\')</expr>)</condition><then> <block>{
<expr_stmt><expr><name>strend</name> += 2</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<expr_stmt><expr><name>res</name> = <call><name>substring_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name> + 1</expr></argument>, <argument><expr><name>strend</name> - <name>str</name> - 1</expr></argument>, <argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>strend</name> == <name>quote</name></expr>)</condition><then>
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>strend</name> = <name>str</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>strend</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>strend</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>res</name> = <call><name>substring_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>strend</name> - <name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>strend</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></while>
<expr_stmt><expr>*<name>line</name> = <name>strend</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_conf2_nc</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **line</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_getword_conf2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_conf2</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **line</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr>*<name>line</name></expr></init>, *<name>strend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></while>
<if>if <condition>(<expr>!*<name>str</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>line</name> = <name>str</name></expr>;</expr_stmt>
<return>return <expr>""</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>quote</name> = *<name>str</name>) == '"' || <name>quote</name> == '\''</expr>)</condition><then>
<return>return <expr><call><name>ap_getword_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>quote</name> == '{'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>strend</name> = <name>str</name> + 1</expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>strend</name></expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>strend</name> == '}' &amp;&amp; !--<name>count</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>*<name>strend</name> == '{'</expr>)</condition><then>
<expr_stmt><expr>++<name>count</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>strend</name> == '\\' &amp;&amp; <name><name>strend</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name><name>strend</name><index>[<expr>1</expr>]</index></name> == '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>res</name> = <call><name>substring_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name> + 1</expr></argument>, <argument><expr><name>strend</name> - <name>str</name> - 1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>strend</name> == '}'</expr>)</condition><then>
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>strend</name> = <name>str</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>strend</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>strend</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>res</name> = <call><name>substring_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>strend</name> - <name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>strend</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></while>
<expr_stmt><expr>*<name>line</name> = <name>strend</name></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_cfg_closefile</name><argument_list>(<argument>ap_configfile_t *cfp</argument>)</argument_list></macro> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00551</expr></argument>)</argument_list></call>
"Done with config file %s"</expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>(<name><name>cfp</name>-&gt;<name>close</name></name> == <name>NULL</name>) ? 0 : <call><name><name>cfp</name>-&gt;<name>close</name></name><argument_list>(<argument><expr><name><name>cfp</name>-&gt;<name>param</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cfg_close</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cfg_getch</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>ch</name></decl></param>, <param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_file_getc</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cfg_getstr</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bufsiz</name></decl></param>, <param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>apr_file_gets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsiz</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pcfg_openfile</name><argument_list>(<argument>ap_configfile_t **ret_cfg</argument>,
<argument>apr_pool_t *p</argument>, <argument>const char *name</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>ap_configfile_t</name> *</type><name>new_cfg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>120</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00552</expr></argument>)</argument_list></call>
"Internal error: pcfg_openfile() called with NULL filename"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_EBADF</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>status</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
<argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00553</expr></argument>)</argument_list></call>
"Opening config file %s (%s)"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>status</name> != <name>APR_SUCCESS</name>) ?
<call><name>apr_strerror</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> : "successful"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>status</name></expr>;</return></then></if>
<expr_stmt><expr><name>status</name> = <call><name>apr_file_info_get</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>status</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name> != <name>APR_REG</name> &amp;&amp;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>NETWARE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<call><name>strcasecmp</name><argument_list>(<argument><expr><call><name>apr_filepath_name_get</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"nul"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"/dev/null"</expr></argument>)</argument_list></call> != 0</expr></expr_stmt>)</block> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00554</expr></argument>)</argument_list></call>
"Access to file %s denied by server: not a regular file"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_EBADF</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>status</name> = <call><name>apr_file_read</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>status</name> != <name>APR_SUCCESS</name>) || (<name>len</name> &lt; 3)
|| <call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"\xEF\xBB\xBF"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>zero</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_file_seek</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>new_cfg</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_cfg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>param</name></name> = <name>file</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>getch</name></name> = <name>cfg_getch</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>getstr</name></name> = <name>cfg_getstr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>close</name></name> = <name>cfg_close</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>line_number</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr>*<name>ret_cfg</name> = <name>new_cfg</name></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_configfile_t *</argument>)</argument_list></macro> <macro><name>ap_pcfg_open_custom</name><argument_list>(
<argument>apr_pool_t *p</argument>, <argument>const char *descr</argument>, <argument>void *param</argument>,
<argument>apr_status_t (*getc_func) (char *ch, void *param)</argument>,
<argument>apr_status_t (*gets_func) (void *buf, apr_size_t bufsize, void *param)</argument>,
<argument>apr_status_t (*close_func) (void *param)</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>ap_configfile_t</name> *</type><name>new_cfg</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_cfg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>param</name></name> = <name>param</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>name</name></name> = <name>descr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>getch</name></name> = <name>getc_func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>getstr</name></name> = <name>gets_func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>close</name></name> = <name>close_func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>line_number</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>new_cfg</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_cfg_getc</name><argument_list>(<argument>char *ch</argument>, <argument>ap_configfile_t *cfp</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><call><name><name>cfp</name>-&gt;<name>getch</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>param</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name> &amp;&amp; *<name>ch</name> == <name>LF</name></expr>)</condition><then>
<expr_stmt><expr>++<name><name>cfp</name>-&gt;<name>line_number</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_pcfg_strerror</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>ap_configfile_t *cfp</argument>,
<argument>apr_status_t rc</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>rc</name> == <name>APR_ENOSPC</name></expr>)</condition><then>
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"Error reading %s at line %d: Line too long"</expr></argument>,
<argument><expr><name><name>cfp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>line_number</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"Error reading %s at line %d: %pm"</expr></argument>,
<argument><expr><name><name>cfp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>line_number</name></name></expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ap_cfg_getline_core</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bufsize</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>offset</name></decl></param>, <param><decl><type><name>ap_configfile_t</name> *</type><name>cfp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>cfp</name>-&gt;<name>getstr</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cbuf</name> <init>= <expr><name>buf</name> + <name>offset</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>cbufsize</name> <init>= <expr><name>bufsize</name> - <name>offset</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<expr_stmt><expr>++<name><name>cfp</name>-&gt;<name>line_number</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name><name>cfp</name>-&gt;<name>getstr</name></name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>cbufsize</name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>APR_EOF</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>cbuf</name> != <name>buf</name> + <name>offset</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>cbuf</name> = '\0'</expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <block>{
<return>return <expr><name>APR_EOF</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<return>return <expr><name>rc</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>cp</name> = <name>cbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cp</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cp</name> &gt; <name>buf</name> &amp;&amp; <name><name>cp</name><index>[<expr>-1</expr>]</index></name> == <name>LF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cp</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name>cp</name> &gt; <name>buf</name> &amp;&amp; <name><name>cp</name><index>[<expr>-1</expr>]</index></name> == <name>CR</name></expr>)</condition><then>
<expr_stmt><expr><name>cp</name>--</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>cp</name> &gt; <name>buf</name> &amp;&amp; <name><name>cp</name><index>[<expr>-1</expr>]</index></name> == '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>cp</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>cbufsize</name> -= (<name>cp</name>-<name>cbuf</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>cbuf</name> = <name>cp</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>cp</name> - <name>buf</name> &gt;= <name>bufsize</name> - 1</expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOSPC</name></expr>;</return>
}</block></then></if></else></if>
<break>break;</break>
}</block></while>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>bufsize</name> &lt; 2</expr>)</condition><then> <block>{
<return>return <expr><name>APR_EINVAL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = <call><name><name>cfp</name>-&gt;<name>getch</name></name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>APR_EOF</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>i</name> &gt; <name>offset</name></expr>)</condition><then>
<break>break;</break></then>
<else>else
<return>return <expr><name>APR_EOF</name></expr>;</return></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>rc</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>c</name> == <name>LF</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name><name>cfp</name>-&gt;<name>line_number</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name><name>buf</name><index>[<expr><name>i</name>-1</expr>]</index></name> == '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then> <else>else <block>{
<break>break;</break>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &gt;= <name>bufsize</name> - 1</expr>)</condition><then> <block>{
<return>return <expr><name>APR_ENOSPC</name></expr>;</return>
}</block></then></if>
}</block></while>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cfg_trim_line</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<expr_stmt><expr><name>start</name> = <name>buf</name></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>start</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>start</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>end</name> = &amp;<name><name>start</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>end</name> &gt;= <name>start</name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>*<name>end</name> = '\0'</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>start</name> != <name>buf</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> - <name>start</name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_CFG_LINES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00555</expr></argument>)</argument_list></call> "Read config: '%s'"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>end</name> - <name>start</name> + 1</expr>;</return>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_cfg_getline</name><argument_list>(<argument>char *buf</argument>, <argument>apr_size_t bufsize</argument>,
<argument>ap_configfile_t *cfp</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><call><name>ap_cfg_getline_core</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
<expr_stmt><expr><call><name>cfg_trim_line</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_varbuf_cfg_getline</name><argument_list>(<argument>struct ap_varbuf *vb</argument>,
<argument>ap_configfile_t *cfp</argument>,
<argument>apr_size_t max_len</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>new_len</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr>*<name><name>vb</name>-&gt;<name>buf</name></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name></expr>)</condition><then>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>avail</name></name> - <name><name>vb</name>-&gt;<name>strlen</name></name> &lt; 3</expr>)</condition><then> <block>{
<expr_stmt><expr><name>new_len</name> = <name><name>vb</name>-&gt;<name>avail</name></name> * 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_len</name> &gt; <name>max_len</name></expr>)</condition><then>
<expr_stmt><expr><name>new_len</name> = <name>max_len</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>new_len</name> &lt; 3</expr>)</condition><then>
<expr_stmt><expr><name>new_len</name> = 3</expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>rc</name> = <call><name>ap_cfg_getline_core</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>avail</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>APR_ENOSPC</name> || <name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> += <call><name>strlen</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name> + <name><name>vb</name>-&gt;<name>strlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>rc</name> != <name>APR_ENOSPC</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>avail</name></name> &gt;= <name>max_len</name></expr>)</condition><then>
<return>return <expr><name>APR_ENOSPC</name></expr>;</return></then></if>
<expr_stmt><expr><name>new_len</name> = <name><name>vb</name>-&gt;<name>avail</name></name> * 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_len</name> &gt; <name>max_len</name></expr>)</condition><then>
<expr_stmt><expr><name>new_len</name> = <name>max_len</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name><name>cfp</name>-&gt;<name>line_number</name></name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>strlen</name></name> &gt; <name>max_len</name></expr>)</condition><then>
<return>return <expr><name>APR_ENOSPC</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <call><name>cfg_trim_line</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_size_list_item</name><argument_list>(<argument>const char **field</argument>, <argument>int *len</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>ptr</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)*<name>field</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_qpair</name></decl>, <decl><type ref="prev"/><name>in_qstr</name></decl>, <decl><type ref="prev"/><name>in_com</name></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>ptr</name> == ',' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>token</name> = <name>ptr</name></expr>;</expr_stmt>
<for>for (<init><expr><name>in_qpair</name> = <name>in_qstr</name> = <name>in_com</name> = 0</expr>;</init>
<condition><expr>*<name>ptr</name> &amp;&amp; (<name>in_qpair</name> || <name>in_qstr</name> || <name>in_com</name> || *<name>ptr</name> != ',')</expr>;</condition>
<incr><expr>++<name>ptr</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>in_qpair</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>in_qpair</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<switch>switch <condition>(<expr>*<name>ptr</name></expr>)</condition> <block>{
<case>case <expr>'\\'</expr>:
<expr_stmt><expr><name>in_qpair</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'"'</expr> :
<if>if <condition>(<expr>!<name>in_com</name></expr>)</condition><then>
<expr_stmt><expr><name>in_qstr</name> = !<name>in_qstr</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'('</expr> :
<if>if <condition>(<expr>!<name>in_qstr</name></expr>)</condition><then>
<expr_stmt><expr>++<name>in_com</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>')'</expr> :
<if>if <condition>(<expr><name>in_com</name></expr>)</condition><then>
<expr_stmt><expr>--<name>in_com</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><default>default :
<break>break;</break>
</default>}</block></switch>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr>(*<name>len</name> = (<name>ptr</name> - <name>token</name>)) == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>field</name> = (const <name>char</name> *)<name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>*<name>ptr</name> == ',' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt></while>
<expr_stmt><expr>*<name>field</name> = (const <name>char</name> *)<name>ptr</name></expr>;</expr_stmt>
<return>return <expr>(const <name>char</name> *)<name>token</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_get_list_item</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **field</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tok_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>addspace</name> <init>= <expr>0</expr></init>, <name>in_qpair</name> <init>= <expr>0</expr></init>, <name>in_qstr</name> <init>= <expr>0</expr></init>, <name>in_com</name> <init>= <expr>0</expr></init>, <name>tok_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>tok_start</name> = <call><name>ap_size_list_item</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr>&amp;<name>tok_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>token</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tok_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>ptr</name> = (const <name>unsigned</name> <name>char</name> *)<name>tok_start</name></expr>, <expr><name>pos</name> = (<name>unsigned</name> <name>char</name> *)<name>token</name></expr>;</init>
<condition><expr>*<name>ptr</name> &amp;&amp; (<name>in_qpair</name> || <name>in_qstr</name> || <name>in_com</name> || *<name>ptr</name> != ',')</expr>;</condition>
<incr><expr>++<name>ptr</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>in_qpair</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>in_qpair</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<switch>switch <condition>(<expr>*<name>ptr</name></expr>)</condition> <block>{
<case>case <expr>'\\'</expr>:
<expr_stmt><expr><name>in_qpair</name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
<expr_stmt><expr>*<name>pos</name>++ = ' '</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'"'</expr> :
<if>if <condition>(<expr>!<name>in_com</name></expr>)</condition><then>
<expr_stmt><expr><name>in_qstr</name> = !<name>in_qstr</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
<expr_stmt><expr>*<name>pos</name>++ = ' '</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'('</expr> :
<if>if <condition>(<expr>!<name>in_qstr</name></expr>)</condition><then>
<expr_stmt><expr>++<name>in_com</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
<expr_stmt><expr>*<name>pos</name>++ = ' '</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>')'</expr> :
<if>if <condition>(<expr><name>in_com</name></expr>)</condition><then>
<expr_stmt><expr>--<name>in_com</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>' '</expr> :
</case><case>case <expr>'\t'</expr>:
<if>if <condition>(<expr><name>addspace</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>in_com</name> || <name>in_qstr</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>addspace</name> = 1</expr>;</expr_stmt></else></if>
<break>break;</break>
</case><case>case <expr>'='</expr> :
</case><case>case <expr>'/'</expr> :
</case><case>case <expr>';'</expr> :
<if>if <condition>(<expr>!(<name>in_com</name> || <name>in_qstr</name>)</expr>)</condition><then>
<expr_stmt><expr><name>addspace</name> = -1</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default :
<if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
<expr_stmt><expr>*<name>pos</name>++ = ' '</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pos</name>++ = (<name>in_com</name> || <name>in_qstr</name>) ? *<name>ptr</name>
: <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></else></if>
}</block></for>
<expr_stmt><expr>*<name>pos</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>token</name></expr>;</return>
}</block>
<typedef>typedef <type><enum>enum <name>ap_etag_e</name> <block>{
<decl><name>AP_ETAG_NONE</name></decl>,
<decl><name>AP_ETAG_WEAK</name></decl>,
<decl><name>AP_ETAG_STRONG</name></decl>
}</block></enum></type> <name>ap_etag_e</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>find_list_item</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>line</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tok</name></decl></param>, <param><decl><type><name>ap_etag_e</name></type> <name>type</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>ptr</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>line</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>good</name> <init>= <expr>0</expr></init>, <name>addspace</name> <init>= <expr>0</expr></init>, <name>in_qpair</name> <init>= <expr>0</expr></init>, <name>in_qstr</name> <init>= <expr>0</expr></init>, <name>in_com</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>line</name> || !<name>tok</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>type</name> == <name>AP_ETAG_STRONG</name> &amp;&amp; *<name>tok</name> != '\"'</expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>type</name> == <name>AP_ETAG_WEAK</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>tok</name> == 'W' &amp;&amp; (*(<name>tok</name>+1)) == '/' &amp;&amp; (*(<name>tok</name>+2)) == '\"'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>tok</name> += 2</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>tok</name> != '\"'</expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if></else></if>
}</block></then></if>
<do>do <block>{
<while>while <condition>(<expr>*<name>ptr</name> == ',' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>type</name> == <name>AP_ETAG_STRONG</name> &amp;&amp; *<name>ptr</name> != '\"'</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>type</name> == <name>AP_ETAG_WEAK</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>ptr</name> == 'W' &amp;&amp; (*(<name>ptr</name>+1)) == '/' &amp;&amp; (*(<name>ptr</name>+2)) == '\"'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptr</name> += 2</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>ptr</name> != '\"'</expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if></else></if>
}</block></then></if>
<if>if <condition>(<expr>*<name>ptr</name></expr>)</condition><then>
<expr_stmt><expr><name>good</name> = 1</expr>;</expr_stmt></then>
<else>else
<break>break;</break></else></if>
<for>for (<init><expr><name>pos</name> = (const <name>unsigned</name> <name>char</name> *)<name>tok</name></expr>;</init>
<condition><expr>*<name>ptr</name> &amp;&amp; (<name>in_qpair</name> || <name>in_qstr</name> || <name>in_com</name> || *<name>ptr</name> != ',')</expr>;</condition>
<incr><expr>++<name>ptr</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>in_qpair</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>in_qpair</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name></expr>)</condition><then>
<expr_stmt><expr><name>good</name> = (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<switch>switch <condition>(<expr>*<name>ptr</name></expr>)</condition> <block>{
<case>case <expr>'\\'</expr>:
<expr_stmt><expr><name>in_qpair</name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == ' ')</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'"'</expr> :
<if>if <condition>(<expr>!<name>in_com</name></expr>)</condition><then>
<expr_stmt><expr><name>in_qstr</name> = !<name>in_qstr</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == ' ')</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'('</expr> :
<if>if <condition>(<expr>!<name>in_qstr</name></expr>)</condition><then>
<expr_stmt><expr>++<name>in_com</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == ' ')</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>')'</expr> :
<if>if <condition>(<expr><name>in_com</name></expr>)</condition><then>
<expr_stmt><expr>--<name>in_com</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>' '</expr> :
</case><case>case <expr>'\t'</expr>:
<if>if <condition>(<expr><name>addspace</name> || !<name>good</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>in_com</name> || <name>in_qstr</name></expr>)</condition><then>
<expr_stmt><expr><name>good</name> = (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>addspace</name> = 1</expr>;</expr_stmt></else></if>
<break>break;</break>
</case><case>case <expr>'='</expr> :
</case><case>case <expr>'/'</expr> :
</case><case>case <expr>';'</expr> :
<if>if <condition>(<expr>!(<name>in_com</name> || <name>in_qstr</name>)</expr>)</condition><then>
<expr_stmt><expr><name>addspace</name> = -1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
<break>break;</break>
</case><default>default :
<if>if <condition>(<expr>!<name>good</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
<expr_stmt><expr><name>good</name> = (*<name>pos</name>++ == ' ')</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>in_com</name> || <name>in_qstr</name></expr>)</condition><then>
<expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>good</name> = <name>good</name>
&amp;&amp; (<call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>pos</name>++</expr></argument>)</argument_list></call> == <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name>good</name> &amp;&amp; *<name>pos</name></expr>)</condition><then>
<expr_stmt><expr><name>good</name> = 0</expr>;</expr_stmt></then></if>
}</block> while <condition>(<expr>*<name>ptr</name> &amp;&amp; !<name>good</name></expr>)</condition>;</do>
<return>return <expr><name>good</name></expr>;</return>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_list_item</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>,
<argument>const char *tok</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>find_list_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>AP_ETAG_NONE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_etag_strong</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>,
<argument>const char *tok</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>find_list_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>AP_ETAG_STRONG</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_etag_weak</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>,
<argument>const char *tok</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>find_list_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>AP_ETAG_WEAK</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_parse_token_list_strict</name><argument_list>(<argument>apr_pool_t *p</argument>,
<argument>const char *str_in</argument>,
<argument>apr_array_header_t **tokens</argument>,
<argument>int skip_invalid</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>in_leading_space</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>in_trailing_space</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>string_end</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tok_begin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cur</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>str_in</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>tok_begin</name> = <name>cur</name> = <name>str_in</name></expr>;</expr_stmt>
<while>while <condition>(<expr>!<name>string_end</name></expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr>(<name>unsigned</name> <name>char</name>)*<name>cur</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>TEST_CHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_HTTP_TOKEN_STOP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>in_leading_space</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>in_trailing_space</name></expr>)</condition><then> <block>{
<return>return <expr>"Encountered illegal whitespace in token"</expr>;</return>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == ' ' || <name>c</name> == '\t'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>in_leading_space</name></expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>tok_begin</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>++<name>in_trailing_space</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == ',' || <name>c</name> == '\0'</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>in_leading_space</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>tokens</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>tokens</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>tokens</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call> =
<call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>(*<name>tokens</name>)-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>tok_begin</name></expr></argument>,
<argument><expr>(<name>cur</name> - <name>tok_begin</name>) - <name>in_trailing_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>tok_begin</name> = <name>cur</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>in_leading_space</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>in_trailing_space</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>string_end</name> = (<name>c</name> == '\0')</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>skip_invalid</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>temp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>temp</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if<condition>(<expr>!<name>temp</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>temp</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>cur</name> = <name>temp</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>in_leading_space</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>in_trailing_space</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"Encountered illegal separator "
"'\\x%.2x'"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>int</name>)<name>c</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></else></if></else></if></else></if>
<expr_stmt><expr>++<name>cur</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_scan_http_field_content</name><argument_list>(<argument>const char *ptr</argument>)</argument_list></macro> <block>{
<for>for ( <init>;</init> <condition><expr>!<call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>, <argument><expr><name>T_HTTP_CTRLS</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>ptr</name></expr></incr>) <empty_stmt>;</empty_stmt></for>
<return>return <expr><name>ptr</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_scan_http_token</name><argument_list>(<argument>const char *ptr</argument>)</argument_list></macro> <block>{
<for>for ( <init>;</init> <condition><expr>!<call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>, <argument><expr><name>T_HTTP_TOKEN_STOP</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>ptr</name></expr></incr>) <empty_stmt>;</empty_stmt></for>
<return>return <expr><name>ptr</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_scan_vchar_obstext</name><argument_list>(<argument>const char *ptr</argument>)</argument_list></macro> <block>{
<for>for ( <init>;</init> <condition><expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>, <argument><expr><name>T_VCHAR_OBSTEXT</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>ptr</name></expr></incr>) <empty_stmt>;</empty_stmt></for>
<return>return <expr><name>ptr</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_get_token</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **accept_line</argument>,
<argument>int accept_white</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name> <init>= <expr>*<name>accept_line</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tok_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>tok_start</name> = <name>ptr</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>ptr</name> &amp;&amp; (<name>accept_white</name> || !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call>)
&amp;&amp; *<name>ptr</name> != ';' &amp;&amp; *<name>ptr</name> != ','</expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>ptr</name>++ == '"'</expr>)</condition><then>
<while>while <condition>(<expr>*<name>ptr</name></expr>)</condition>
<if>if <condition>(<expr>*<name>ptr</name>++ == '"'</expr>)</condition><then>
<break>break;</break></then></if></while></then></if>
}</block></while>
<expr_stmt><expr><name>token</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tok_start</name></expr></argument>, <argument><expr><name>ptr</name> - <name>tok_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt></while>
<expr_stmt><expr>*<name>accept_line</name> = <name>ptr</name></expr>;</expr_stmt>
<return>return <expr><name>token</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_token</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>, <argument>const char *tok</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>start_token</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>line</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>line</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_HTTP_TOKEN_STOP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr>!*<name>s</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>start_token</name> = <name>s</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; !<call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_HTTP_TOKEN_STOP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>start_token</name></expr></argument>, <argument><expr>(const <name>char</name> *)<name>tok</name></expr></argument>,
<argument><expr><name>s</name> - <name>start_token</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!*<name>s</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></for>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_last_token</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>,
<argument>const char *tok</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>llen</name></decl>, <decl><type ref="prev"/><name>tlen</name></decl>, <decl><type ref="prev"/><name>lidx</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>line</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>llen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lidx</name> = <name>llen</name> - <name>tlen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lidx</name> &lt; 0 ||
(<name>lidx</name> &gt; 0 &amp;&amp; !(<call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>line</name><index>[<expr><name>lidx</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call> || <name><name>line</name><index>[<expr><name>lidx</name> - 1</expr>]</index></name> == ','))</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>(<call><name>strncasecmp</name><argument_list>(<argument><expr>&amp;<name><name>line</name><index>[<expr><name>lidx</name></expr>]</index></name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call> == 0)</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_shell_cmd</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *str</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>cmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><name>cmd</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2 * <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = (<name>unsigned</name> <name>char</name> *)<name>cmd</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>str</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>*<name>s</name> == '\r' || *<name>s</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>d</name>++ = ' '</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_ESCAPE_SHELL_CMD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>d</name>++ = '\\'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>cmd</name></expr>;</return>
}</block>
<function><type><specifier>static</specifier> <name>char</name></type> <name>x2c</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>what</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>digit</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<expr_stmt><expr><name>digit</name> = ((<name><name>what</name><index>[<expr>0</expr>]</index></name> &gt;= 'A') ? ((<name><name>what</name><index>[<expr>0</expr>]</index></name> &amp; 0xdf) - 'A') + 10
: (<name><name>what</name><index>[<expr>0</expr>]</index></name> - '0'))</expr>;</expr_stmt>
<expr_stmt><expr><name>digit</name> *= 16</expr>;</expr_stmt>
<expr_stmt><expr><name>digit</name> += (<name><name>what</name><index>[<expr>1</expr>]</index></name> &gt;= 'A' ? ((<name><name>what</name><index>[<expr>1</expr>]</index></name> &amp; 0xdf) - 'A') + 10
: (<name><name>what</name><index>[<expr>1</expr>]</index></name> - '0'))</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>char</name></type> <name><name>xstr</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>xstr</name><index>[<expr>0</expr>]</index></name>='0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>xstr</name><index>[<expr>1</expr>]</index></name>='x'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>xstr</name><index>[<expr>2</expr>]</index></name>=<name><name>what</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>xstr</name><index>[<expr>3</expr>]</index></name>=<name><name>what</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>xstr</name><index>[<expr>4</expr>]</index></name>='\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>digit</name> = <call><name>apr_xlate_conv_byte</name><argument_list>(<argument><expr><name>ap_hdrs_from_ascii</name></expr></argument>,
<argument><expr>0xFF &amp; <call><name>strtol</name><argument_list>(<argument><expr><name>xstr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>(<name>digit</name>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>unescape_url</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>url</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>forbid</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reserved</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>badesc</name></decl>, <decl><type ref="prev"/><name>badpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>x</name></decl>, *<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><name>badesc</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>badpath</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr>'%'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>y</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>OK</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>x</name> = <name>y</name></expr>;</init> <condition><expr>*<name>y</name></expr>;</condition> <incr><expr>++<name>x</name></expr>, <expr>++<name>y</name></expr></incr>) <block>{
<if>if <condition>(<expr>*<name>y</name> != '%'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>x</name> = *<name>y</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<call><name>apr_isxdigit</name><argument_list>(<argument><expr>*(<name>y</name> + 1)</expr></argument>)</argument_list></call> || !<call><name>apr_isxdigit</name><argument_list>(<argument><expr>*(<name>y</name> + 2)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>badesc</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>x</name> = '%'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name></type> <name>decoded</name></decl>;</decl_stmt>
<expr_stmt><expr><name>decoded</name> = <call><name>x2c</name><argument_list>(<argument><expr><name>y</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>decoded</name> == '\0')
|| (<name>forbid</name> &amp;&amp; <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>forbid</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>badpath</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>x</name> = <name>decoded</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> += 2</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>reserved</name> &amp;&amp; <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>reserved</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>x</name>++ = *<name>y</name>++</expr>;</expr_stmt>
<expr_stmt><expr>*<name>x</name>++ = *<name>y</name>++</expr>;</expr_stmt>
<expr_stmt><expr>*<name>x</name> = *<name>y</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>x</name> = <name>decoded</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> += 2</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></else></if>
}</block></else></if>
}</block></for>
<expr_stmt><expr>*<name>x</name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>badesc</name></expr>)</condition><then> <block>{
<return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>badpath</name></expr>)</condition><then> <block>{
<return>return <expr><name>HTTP_NOT_FOUND</name></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><name>OK</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url</name><argument_list>(<argument>char *url</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>SLASHES</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url_keep2f</name><argument_list>(<argument>char *url</argument>, <argument>int decode_slashes</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>decode_slashes</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SLASHES</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEW_APIS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url_proxy</name><argument_list>(<argument>char *url</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"/;?"</expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url_reserved</name><argument_list>(<argument>char *url</argument>, <argument>const char *reserved</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_urlencoded</name><argument_list>(<argument>char *query</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>slider</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>query</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>slider</name> = <name>query</name></expr>;</init> <condition><expr>*<name>slider</name></expr>;</condition> <incr><expr><name>slider</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>slider</name> == '+'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>slider</name> = ' '</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
}</block></then></if>
<return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_construct_server</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *hostname</argument>,
<argument>apr_port_t port</argument>, <argument>const request_rec *r</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><call><name>ap_is_default_port</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"%s:%u"</expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_all</name><argument_list>(<argument>char *url</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>c2x_table</name><index>[]</index></name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>unsigned</name> <name>char</name> *</type><name>c2x</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>what</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name></type> <name>prefix</name></decl></param>,
<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>where</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<expr_stmt><expr><name>what</name> = <call><name>apr_xlate_conv_byte</name><argument_list>(<argument><expr><name>ap_hdrs_to_ascii</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr>*<name>where</name>++ = <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>where</name>++ = <name><name>c2x_table</name><index>[<expr><name>what</name> &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>where</name>++ = <name><name>c2x_table</name><index>[<expr><name>what</name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><name>where</name></expr>;</return>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_path_segment_buffer</name><argument_list>(<argument>char *copy</argument>, <argument>const char *segment</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>segment</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *)<name>copy</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>c</name> = *<name>s</name>)</expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_ESCAPE_PATH_SEGMENT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>d</name> = <call><name>c2x</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>'%'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>d</name>++ = <name>c</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>copy</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_path_segment</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *segment</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_escape_path_segment_buffer</name><argument_list>(<argument><expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>3 * <call><name>strlen</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_os_escape_path</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *path</argument>, <argument>int partial</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>copy</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>3 * <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>path</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *)<name>copy</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>partial</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>colon</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>slash</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>colon</name> &amp;&amp; (!<name>slash</name> || <name>colon</name> &lt; <name>slash</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>d</name>++ = '.'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>d</name>++ = '/'</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<while>while <condition>(<expr>(<name>c</name> = *<name>s</name>)</expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_OS_ESCAPE_PATH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>d</name> = <call><name>c2x</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>'%'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>d</name>++ = <name>c</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>copy</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_urlencoded_buffer</name><argument_list>(<argument>char *copy</argument>, <argument>const char *buffer</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *)<name>copy</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>c</name> = *<name>s</name>)</expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_ESCAPE_URLENCODED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>d</name> = <call><name>c2x</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>'%'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == ' '</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>d</name>++ = '+'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>d</name>++ = <name>c</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>copy</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_urlencoded</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *buffer</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>ap_escape_urlencoded_buffer</name><argument_list>(<argument><expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>3 * <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_html2</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *s</argument>, <argument>int toasc</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>x</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != '\0'</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&lt;' || <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&gt;'</expr>)</condition><then>
<expr_stmt><expr><name>j</name> += 3</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&amp;'</expr>)</condition><then>
<expr_stmt><expr><name>j</name> += 4</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '"'</expr>)</condition><then>
<expr_stmt><expr><name>j</name> += 5</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>toasc</name> &amp;&amp; !<call><name>apr_isascii</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>j</name> += 5</expr>;</expr_stmt></then></if></else></if></else></if></else></if></for>
<if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name> + <name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != '\0'</expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&lt;'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>"&amp;lt;"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += 3</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&gt;'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>"&amp;gt;"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += 3</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&amp;'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>"&amp;amp;"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += 4</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '"'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>"&amp;quot;"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += 5</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>toasc</name> &amp;&amp; !<call><name>apr_isascii</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>esc</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"&amp;#%3.3d;"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>esc</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += 5</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></for>
<expr_stmt><expr><name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_logitem</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *str</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>escapes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>str</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_ESCAPE_LOGITEM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>escapes</name>++</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>length</name> = <name>s</name> - (const <name>unsigned</name> <name>char</name> *)<name>str</name> + 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>escapes</name> == 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>length</name> + 3 * <name>escapes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> = (<name>unsigned</name> <name>char</name> *)<name>ret</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>str</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_ESCAPE_LOGITEM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>d</name>++ = '\\'</expr>;</expr_stmt>
<switch>switch<condition>(<expr>*<name>s</name></expr>)</condition> <block>{
<case>case <expr>'\b'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 'b'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\n'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 'n'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\r'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 'r'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\t'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 't'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\v'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 'v'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\\'</expr>:
</case><case>case <expr>'"'</expr>:
<expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>c2x</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr>'x'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> += 3</expr>;</expr_stmt>
</default>}</block></switch>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
}</block></else></if>
}</block></for>
<expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_size_t</argument>)</argument_list></macro> <macro><name>ap_escape_errorlog_item</name><argument_list>(<argument>char *dest</argument>, <argument>const char *source</argument>,
<argument>apr_size_t buflen</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>ep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>source</name> || !<name>buflen</name></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>d</name> = (<name>unsigned</name> <name>char</name> *)<name>dest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>source</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ep</name> = <name>d</name> + <name>buflen</name> - 1</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>d</name> &lt; <name>ep</name> &amp;&amp; *<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{
<if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_ESCAPE_LOGITEM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>d</name>++ = '\\'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>d</name> &gt;= <name>ep</name></expr>)</condition><then> <block>{
<expr_stmt><expr>--<name>d</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<switch>switch<condition>(<expr>*<name>s</name></expr>)</condition> <block>{
<case>case <expr>'\b'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 'b'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\n'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 'n'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\r'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 'r'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\t'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 't'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\v'</expr>:
<expr_stmt><expr>*<name>d</name>++ = 'v'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\\'</expr>:
<expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'"'</expr>:
<expr_stmt><expr><name><name>d</name><index>[<expr>-1</expr>]</index></name> = *<name>s</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><name>d</name> &gt;= <name>ep</name> - 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ep</name> = --<name>d</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>c2x</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr>'x'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>d</name> += 3</expr>;</expr_stmt>
</default>}</block></switch>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
}</block></else></if>
}</block></for>
<expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
<return>return <expr>(<name>d</name> - (<name>unsigned</name> <name>char</name> *)<name>dest</name>)</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_bin2hex</name><argument_list>(<argument>const void *src</argument>, <argument>apr_size_t srclen</argument>, <argument>char *dest</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>in</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>srclen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr>*<name>dest</name>++ = <name><name>c2x_table</name><index>[<expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>dest</name>++ = <name><name>c2x_table</name><index>[<expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>*<name>dest</name> = '\0'</expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_directory</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *path</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>(<name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name>)</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_rdirectory</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *path</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_LINK</name> | <name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>(<name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name>)</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_make_full_path</name><argument_list>(<argument>apr_pool_t *a</argument>, <argument>const char *src1</argument>,
<argument>const char *src2</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len2</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> = (<name>char</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>len1</name> + <name>len2</name> + 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len1</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>path</name> = '/'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> + 1</expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>len2</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> = <name>path</name> + <name>len1</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>next</name><index>[<expr>-1</expr>]</index></name> != '/'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>next</name>++ = '/'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>len2</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>path</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_url</name><argument_list>(<argument>const char *u</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
<for>for (<init><expr><name>x</name> = 0</expr>;</init> <condition><expr><name><name>u</name><index>[<expr><name>x</name></expr>]</index></name> != ':'</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>(!<name><name>u</name><index>[<expr><name>x</name></expr>]</index></name>) ||
((!<call><name>apr_isalnum</name><argument_list>(<argument><expr><name><name>u</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call>) &amp;&amp;
(<name><name>u</name><index>[<expr><name>x</name></expr>]</index></name> != '+') &amp;&amp; (<name><name>u</name><index>[<expr><name>x</name></expr>]</index></name> != '-') &amp;&amp; (<name><name>u</name><index>[<expr><name>x</name></expr>]</index></name> != '.'))</expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>(<name>x</name> ? 1 : 0)</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_ind</name><argument_list>(<argument>const char *s</argument>, <argument>char c</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><name>p</name> - <name>s</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rind</name><argument_list>(<argument>const char *s</argument>, <argument>char c</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>ap_strrchr_c</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><name>p</name> - <name>s</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_str_tolower</name><argument_list>(<argument>char *str</argument>)</argument_list></macro> <block>{
<while>while <condition>(<expr>*<name>str</name></expr>)</condition> <block>{
<expr_stmt><expr>*<name>str</name> = <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
}</block></while>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_str_toupper</name><argument_list>(<argument>char *str</argument>)</argument_list></macro> <block>{
<while>while <condition>(<expr>*<name>str</name></expr>)</condition> <block>{
<expr_stmt><expr>*<name>str</name> = <call><name>apr_toupper</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
}</block></while>
}</block>
<function><type><name>char</name> *</type><name>ap_get_local_host</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>a</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>MAXHOSTNAMELEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXHOSTNAMELEN</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><name>MAXHOSTNAMELEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>server_hostname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>sockaddr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>hostname</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_gethostname</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> - 1</expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name> | <name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00556</expr></argument>)</argument_list></call>
"%s: apr_gethostname() failed to determine ServerName"</expr></argument>,
<argument><expr><name>ap_server_argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>str</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>apr_sockaddr_info_get</name><argument_list>(<argument><expr>&amp;<name>sockaddr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>APR_UNSPEC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<if>if <condition>( <expr>(<call><name>apr_getnameinfo</name><argument_list>(<argument><expr>&amp;<name>hostname</name></expr></argument>, <argument><expr><name>sockaddr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>) &amp;&amp;
(<call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call>)</expr> )</condition><then> <block>{
<expr_stmt><expr><name>server_hostname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>server_hostname</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>server_hostname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>apr_sockaddr_ip_get</name><argument_list>(<argument><expr>&amp;<name>hostname</name></expr></argument>, <argument><expr><name>sockaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>server_hostname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name> | <name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00557</expr></argument>)</argument_list></call>
"%s: apr_sockaddr_info_get() failed for %s"</expr></argument>,
<argument><expr><name>ap_server_argv0</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<if>if <condition>(<expr>!<name>server_hostname</name></expr>)</condition><then>
<expr_stmt><expr><name>server_hostname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>"127.0.0.1"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name>|<name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00558</expr></argument>)</argument_list></call>
"%s: Could not reliably determine the server's fully qualified "
"domain name, using %s. Set the 'ServerName' directive globally "
"to suppress this message"</expr></argument>,
<argument><expr><name>ap_server_argv0</name></expr></argument>, <argument><expr><name>server_hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>server_hostname</name></expr>;</return>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_pbase64decode</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *bufcoded</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>decoded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<expr_stmt><expr><name>decoded</name> = (<name>char</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1 + <call><name>apr_base64_decode_len</name><argument_list>(<argument><expr><name>bufcoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> = <call><name>apr_base64_decode</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>bufcoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>decoded</name><index>[<expr><name>l</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>decoded</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_pbase64encode</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char *string</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>encoded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>encoded</name> = (<name>char</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1 + <call><name>apr_base64_encode_len</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> = <call><name>apr_base64_encode</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>encoded</name><index>[<expr><name>l</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>encoded</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_content_type_tolower</name><argument_list>(<argument>char *str</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>semi</name></decl>;</decl_stmt>
<expr_stmt><expr><name>semi</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>semi</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>semi</name> = '\0'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>semi</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>semi</name> = ';'</expr>;</expr_stmt>
}</block></then></if>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_quotes</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *instring</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>newlen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>inchr</name> <init>= <expr><name>instring</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>outchr</name></decl>, *<decl><type ref="prev"/><name>outstring</name></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>inchr</name> != '\0'</expr>)</condition> <block>{
<expr_stmt><expr><name>newlen</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>inchr</name> == '"'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>newlen</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(*<name>inchr</name> == '\\') &amp;&amp; (<name><name>inchr</name><index>[<expr>1</expr>]</index></name> != '\0')</expr>)</condition><then> <block>{
<expr_stmt><expr><name>inchr</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>newlen</name>++</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>inchr</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>outstring</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>newlen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>inchr</name> = <name>instring</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outchr</name> = <name>outstring</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>inchr</name> != '\0'</expr>)</condition> <block>{
<if>if <condition>(<expr>(*<name>inchr</name> == '\\') &amp;&amp; (<name><name>inchr</name><index>[<expr>1</expr>]</index></name> != '\0')</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>outchr</name>++ = *<name>inchr</name>++</expr>;</expr_stmt>
<expr_stmt><expr>*<name>outchr</name>++ = *<name>inchr</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>*<name>inchr</name> == '"'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>outchr</name>++ = '\\'</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>*<name>inchr</name> != '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>outchr</name>++ = *<name>inchr</name>++</expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<expr_stmt><expr>*<name>outchr</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>outstring</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_append_pid</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *string</argument>,
<argument>const char *delim</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"%s%s%" <name>APR_PID_T_FMT</name></expr></argument>, <argument><expr><name>string</name></expr></argument>,
<argument><expr><name>delim</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_timeout_parameter_parse</name><argument_list>(
<argument>const char *timeout_parameter</argument>,
<argument>apr_interval_time_t *timeout</argument>,
<argument>const char *default_time_unit</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>endp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>time_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>tout</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tout</name> = <call><name>apr_strtoi64</name><argument_list>(<argument><expr><name>timeout_parameter</name></expr></argument>, <argument><expr>&amp;<name>endp</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name></expr>)</condition><then> <block>{
<return>return <expr><name>errno</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>endp</name> || !*<name>endp</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>time_str</name> = <name>default_time_unit</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>time_str</name> = <name>endp</name></expr>;</expr_stmt>
}</block></else></if>
<switch>switch <condition>(<expr>*<name>time_str</name></expr>)</condition> <block>{
<case>case <expr>'s'</expr>:
<expr_stmt><expr>*<name>timeout</name> = (<name>apr_interval_time_t</name>) <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>tout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'h'</expr>:
<expr_stmt><expr>*<name>timeout</name> = (<name>apr_interval_time_t</name>) <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>tout</name> * 3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'m'</expr>:
<switch>switch <condition>(<expr>*(++<name>time_str</name>)</expr>)</condition> <block>{
<case>case <expr>'s'</expr>:
<expr_stmt><expr>*<name>timeout</name> = (<name>apr_interval_time_t</name>) <name>tout</name> * 1000</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'i'</expr>:
<expr_stmt><expr>*<name>timeout</name> = (<name>apr_interval_time_t</name>) <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>tout</name> * 60</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr><name>APR_EGENERAL</name></expr>;</return>
</default>}</block></switch>
<break>break;</break>
</case><default>default:
<return>return <expr><name>APR_EGENERAL</name></expr>;</return>
</default>}</block></switch>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_request_has_body</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>cl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>estr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cls</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_body</name></decl>;</decl_stmt>
<expr_stmt><expr><name>has_body</name> = (!<name><name>r</name>-&gt;<name>header_only</name></name>
&amp;&amp; (<name><name>r</name>-&gt;<name>kept_body</name></name>
|| <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>)</argument_list></call>
|| ( (<name>cls</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call>)
&amp;&amp; (<call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>cl</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>, <argument><expr>&amp;<name>estr</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>)
&amp;&amp; (!*<name>estr</name>)
&amp;&amp; (<name>cl</name> &gt; 0) )
)
)</expr>;</expr_stmt>
<return>return <expr><name>has_body</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pool_cleanup_set_null</name><argument_list>(<argument>void *data_</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>void</name> **</type><name>ptr</name> <init>= <expr>(<name>void</name> **)<name>data_</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>ptr</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_str2_alnum</name><argument_list>(<argument>const char *src</argument>, <argument>char *dest</argument>)</argument_list></macro> <block>{
<for>for ( <init>;</init> <condition><expr>*<name>src</name></expr>;</condition> <incr><expr><name>src</name>++</expr>, <expr><name>dest</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>apr_isprint</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>dest</name> = 'x'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>apr_isalnum</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>dest</name> = '_'</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>dest</name> = (<name>char</name>)*<name>src</name></expr>;</expr_stmt></else></if></else></if>
}</block></for>
<expr_stmt><expr>*<name>dest</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pstr2_alnum</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *src</argument>,
<argument>const char **dest</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>new</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>new</name></expr>)</condition><then>
<return>return <expr><name>APR_ENOMEM</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>dest</name> = <name>new</name></expr>;</expr_stmt>
<return>return <expr><call><name>ap_str2_alnum</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<typedef>typedef <type><enum>enum <block>{
<decl><name>FORM_NORMAL</name></decl>,
<decl><name>FORM_AMP</name></decl>,
<decl><name>FORM_NAME</name></decl>,
<decl><name>FORM_VALUE</name></decl>,
<decl><name>FORM_PERCENTA</name></decl>,
<decl><name>FORM_PERCENTB</name></decl>,
<decl><name>FORM_ABORT</name></decl>
}</block></enum></type> <name>ap_form_type_t</name>;</typedef>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_parse_form_data</name><argument_list>(<argument>request_rec *r</argument>, <argument>ap_filter_t *f</argument>,
<argument>apr_array_header_t **ptr</argument>,
<argument>apr_size_t num</argument>, <argument>apr_size_t usize</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>seen_eos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>HUGE_STRING_LEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ct</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_form_type_t</name></type> <name>state</name> <init>= <expr><name>FORM_NAME</name></expr></init>, <name>percent</name> <init>= <expr><name>FORM_NORMAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_form_pair_t</name> *</type><name>pair</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>pairs</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ap_form_pair_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>escaped_char</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>ptr</name> = <name>pairs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ct</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ct</name> || <call><name>strncasecmp</name><argument_list>(<argument><expr>"application/x-www-form-urlencoded"</expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr>33</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>ap_discard_request_body</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>usize</name> &gt; <name>APR_SIZE_MAX</name> &gt;&gt; 1</expr>)</condition><then>
<expr_stmt><expr><name>size</name> = <name>APR_SIZE_MAX</name> &gt;&gt; 1</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>size</name> = <name>usize</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>!<name>f</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>f</name> = <name><name>r</name>-&gt;<name>input_filters</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name> <init>= <expr><name>NULL</name></expr></init>, *<name>last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>ap_get_brigade</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>AP_MODE_READBYTES</name></expr></argument>,
<argument><expr><name>APR_BLOCK_READ</name></expr></argument>, <argument><expr><name>HUGE_STRING_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>ap_map_http_request_error</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>bucket</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>bucket</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>last</name> = <name>bucket</name></expr>, <expr><name>bucket</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>slide</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>last</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>seen_eos</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name><name>bucket</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>slide</name> = <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>state</name> != <name>FORM_ABORT</name> &amp;&amp; <name>slide</name>-- &gt; 0 &amp;&amp; <name>size</name> &gt;= 0 &amp;&amp; <name>num</name> != 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*<name>data</name>++</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>'+' == <name>c</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>c</name> = ' '</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>'&amp;' == <name>c</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>FORM_AMP</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<if>if <condition>(<expr>'%' == <name>c</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>percent</name> = <name>FORM_PERCENTA</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><name>FORM_PERCENTA</name> == <name>percent</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>escaped_char</name><index>[<expr>0</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>percent</name> = <name>FORM_PERCENTB</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><name>FORM_PERCENTB</name> == <name>percent</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>escaped_char</name><index>[<expr>1</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>x2c</name><argument_list>(<argument><expr><name>escaped_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>percent</name> = <name>FORM_NORMAL</name></expr>;</expr_stmt>
}</block></then></if>
<switch>switch <condition>(<expr><name>state</name></expr>)</condition> <block>{
<case>case <expr><name>FORM_AMP</name></expr>:
<if>if <condition>(<expr><name>pair</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>pair</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>state</name> = <name>FORM_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pair</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>num</name>--</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>FORM_NAME</name></expr>:
<if>if <condition>(<expr><name>offset</name> &lt; <name>HUGE_STRING_LEN</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>'=' == <name>c</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>pair</name> = (<name>ap_form_pair_t</name> *) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pair</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pair</name>-&gt;<name>value</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>state</name> = <name>FORM_VALUE</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>state</name> = <name>FORM_ABORT</name></expr>;</expr_stmt>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>FORM_VALUE</name></expr>:
<if>if <condition>(<expr><name>offset</name> &gt;= <name>HUGE_STRING_LEN</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>pair</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<break>break;</break>
</default>}</block></switch>
}</block></while>
}</block></for>
<expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr>!<name>seen_eos</name></expr>)</condition>;</do>
<if>if <condition>(<expr><name>FORM_ABORT</name> == <name>state</name> || <name>size</name> &lt; 0 || <name>num</name> == 0</expr>)</condition><then> <block>{
<return>return <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>FORM_VALUE</name> == <name>state</name> &amp;&amp; <name>pair</name> &amp;&amp; <name>offset</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>pair</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<return>return <expr><name>OK</name></expr>;</return>
}</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARBUF_SMALL_SIZE</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARBUF_MAX_SIZE</name></cpp:macro> <cpp:value>(APR_SIZE_MAX - 1 - APR_ALIGN_DEFAULT(sizeof(struct ap_varbuf_info)))</cpp:value></cpp:define>
<struct>struct <name>ap_varbuf_info</name> <block>{
<decl_stmt><decl><type>struct <name>apr_memnode_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>varbuf_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>info_</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>ap_varbuf_info</name> *</type><name>info</name> <init>= <expr><name>info_</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>info</name>-&gt;<name>node</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_allocator_free</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>allocator</name></name></expr></argument>, <argument><expr><name><name>info</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>nul</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> * <specifier>const</specifier></type> <name>varbuf_empty</name> <init>= <expr>(<name>char</name> *)&amp;<name>nul</name></expr></init></decl>;</decl_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_init</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>struct ap_varbuf *vb</argument>,
<argument>apr_size_t init_size</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name></name> = <name>varbuf_empty</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>avail</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <name>AP_VARBUF_UNKNOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>pool</name></name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>info</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>init_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_grow</name><argument_list>(<argument>struct ap_varbuf *vb</argument>, <argument>apr_size_t new_len</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_memnode_t</name> *</type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>ap_varbuf_info</name> *</type><name>new_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>new</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name> || <name><name>vb</name>-&gt;<name>avail</name></name> &gt;= <name><name>vb</name>-&gt;<name>strlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_len</name> &lt;= <name><name>vb</name>-&gt;<name>avail</name></name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>new_len</name> &lt; 2 * <name><name>vb</name>-&gt;<name>avail</name></name> &amp;&amp; <name><name>vb</name>-&gt;<name>avail</name></name> &lt; <name>VARBUF_MAX_SIZE</name>/2</expr>)</condition><then> <block>{
<expr_stmt><expr><name>new_len</name> = 2 * <name><name>vb</name>-&gt;<name>avail</name></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>new_len</name> &gt; <name>VARBUF_MAX_SIZE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_abortfunc_t</name></type> <name>abort_fn</name> <init>= <expr><call><name>apr_pool_abort_get</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>abort_fn</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>abort_fn</name><argument_list>(<argument><expr><name>APR_ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if></else></if>
<expr_stmt><expr><name>new_len</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_len</name> &lt;= <name>VARBUF_SMALL_SIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>new_len</name> = <call><name>APR_ALIGN_DEFAULT</name><argument_list>(<argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>avail</name></name> &amp;&amp; <name><name>vb</name>-&gt;<name>strlen</name></name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name> != <name>varbuf_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new</name> == <name><name>vb</name>-&gt;<name>buf</name></name> + <name><name>vb</name>-&gt;<name>avail</name></name> + 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>vb</name>-&gt;<name>avail</name></name> += <name>new_len</name></expr>;</expr_stmt>
<return>return;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name> ?
<name><name>vb</name>-&gt;<name>avail</name></name> + 1 : <name><name>vb</name>-&gt;<name>strlen</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>new</name> = '\0'</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>avail</name></name> = <name>new_len</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name></name> = <name>new</name></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><name>allocator</name> = <call><name>apr_pool_allocator_get</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_len</name> &lt;= <name>VARBUF_MAX_SIZE</name></expr>)</condition><then>
<expr_stmt><expr><name>new_node</name> = <call><name>apr_allocator_alloc</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>,
<argument><expr><name>new_len</name> + <call><name>APR_ALIGN_DEFAULT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<name>new_node</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_abortfunc_t</name></type> <name>abort_fn</name> <init>= <expr><call><name>apr_pool_abort_get</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>abort_fn</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>abort_fn</name><argument_list>(<argument><expr><name>APR_ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><name>new_info</name> = (struct <name>ap_varbuf_info</name> *)<name><name>new_node</name>-&gt;<name>first_avail</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_node</name>-&gt;<name>first_avail</name></name> += <call><name>APR_ALIGN_DEFAULT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_info</name>-&gt;<name>node</name></name> = <name>new_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_info</name>-&gt;<name>allocator</name></name> = <name>allocator</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new</name> = <name><name>new_node</name>-&gt;<name>first_avail</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>new_node</name>-&gt;<name>endp</name></name> - <name><name>new_node</name>-&gt;<name>first_avail</name></name> &gt;= <name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_len</name> = <name><name>new_node</name>-&gt;<name>endp</name></name> - <name><name>new_node</name>-&gt;<name>first_avail</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>avail</name></name> &amp;&amp; <name><name>vb</name>-&gt;<name>strlen</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name> ?
<name><name>vb</name>-&gt;<name>avail</name></name> + 1 : <name><name>vb</name>-&gt;<name>strlen</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>new</name> = '\0'</expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>info</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>apr_pool_cleanup_run</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>info</name></name></expr></argument>, <argument><expr><name>varbuf_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>new_info</name></expr></argument>, <argument><expr><name>varbuf_cleanup</name></expr></argument>,
<argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>info</name></name> = <name>new_info</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name></name> = <name>new</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>avail</name></name> = <name>new_len</name> - 1</expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_strmemcat</name><argument_list>(<argument>struct ap_varbuf *vb</argument>, <argument>const char *str</argument>,
<argument>int len</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr>!<name><name>vb</name>-&gt;<name>avail</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <name>len</name></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name></expr>)</condition><then>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> + <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name> + <name><name>vb</name>-&gt;<name>strlen</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name><index>[<expr><name><name>vb</name>-&gt;<name>strlen</name></name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_free</name><argument_list>(<argument>struct ap_varbuf *vb</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name><name>vb</name>-&gt;<name>info</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_pool_cleanup_run</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>info</name></name></expr></argument>, <argument><expr><name>varbuf_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>info</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_varbuf_pdup</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>struct ap_varbuf *buf</argument>,
<argument>const char *prepend</argument>, <argument>apr_size_t prepend_len</argument>,
<argument>const char *append</argument>, <argument>apr_size_t append_len</argument>,
<argument>apr_size_t *new_len</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>iovec</name></type> <name><name>vec</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>prepend</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name>prepend</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <name>prepend_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>buf</name>-&gt;<name>avail</name></name> &amp;&amp; <name><name>buf</name>-&gt;<name>strlen</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>buf</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name></expr>)</condition><then>
<expr_stmt><expr><name><name>buf</name>-&gt;<name>strlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>buf</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name><name>buf</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <name><name>buf</name>-&gt;<name>strlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>append</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name>append</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <name>append_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>i</name></expr>)</condition><then>
<return>return <expr><call><name>apr_pstrcatv</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>new_len</name></expr>)</condition><then>
<expr_stmt><expr>*<name>new_len</name> = 0</expr>;</expr_stmt></then></if>
<return>return <expr>""</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_varbuf_regsub</name><argument_list>(<argument>struct ap_varbuf *vb</argument>,
<argument>const char *input</argument>,
<argument>const char *source</argument>,
<argument>apr_size_t nmatch</argument>,
<argument>ap_regmatch_t pmatch[]</argument>,
<argument>apr_size_t maxlen</argument>)</argument_list></macro> <block>{
<return>return <expr><call><name>regsub_core</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vb</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name>oom_message</name> <init>= <expr>"[crit] Memory allocation failed, "
"aborting process." <name>APR_EOL_STR</name></expr></init></decl>;</decl_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_abort_on_oom</name><argument_list>()</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>written</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>oom_message</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name> <init>= <expr><name>oom_message</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>written</name> = <call><name>write</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>written</name> == <name>count</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>written</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf</name> += <name>written</name></expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> -= <name>written</name></expr>;</expr_stmt>
}</block></then></if>
}</block> while <condition>(<expr><name>written</name> &gt;= 0 || <name>errno</name> == <name>EINTR</name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_malloc</name><argument_list>(<argument>size_t size</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name> &amp;&amp; <name>size</name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>ap_abort_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>p</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_calloc</name><argument_list>(<argument>size_t nelem</argument>, <argument>size_t size</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><name>nelem</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name> &amp;&amp; <name>nelem</name> != 0 &amp;&amp; <name>size</name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>ap_abort_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>p</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_realloc</name><argument_list>(<argument>void *ptr</argument>, <argument>size_t size</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name> &amp;&amp; <name>size</name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>ap_abort_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>p</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_get_sload</name><argument_list>(<argument>ap_sload_t *ld</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>server_limit</name></decl>, <decl><type ref="prev"/><name>thread_limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ready</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>busy</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>total</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ap_generation_t</name></type> <name>mpm_generation</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>ld</name>-&gt;<name>idle</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ld</name>-&gt;<name>busy</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ld</name>-&gt;<name>bytes_served</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ld</name>-&gt;<name>access_count</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_mpm_query</name><argument_list>(<argument><expr><name>AP_MPMQ_GENERATION</name></expr></argument>, <argument><expr>&amp;<name>mpm_generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_mpm_query</name><argument_list>(<argument><expr><name>AP_MPMQ_HARD_LIMIT_THREADS</name></expr></argument>, <argument><expr>&amp;<name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ap_mpm_query</name><argument_list>(<argument><expr><name>AP_MPMQ_HARD_LIMIT_DAEMONS</name></expr></argument>, <argument><expr>&amp;<name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>server_limit</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>process_score</name> *</type><name>ps</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ps</name> = <call><name>ap_get_scoreboard_process</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>thread_limit</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>worker_score</name> *</type><name>ws</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ws</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <name><name>ws</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>ps</name>-&gt;<name>quiescing</name></name> &amp;&amp; <name><name>ps</name>-&gt;<name>pid</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>res</name> == <name>SERVER_READY</name> &amp;&amp; <name><name>ps</name>-&gt;<name>generation</name></name> == <name>mpm_generation</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ready</name>++</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>res</name> != <name>SERVER_DEAD</name> &amp;&amp;
<name>res</name> != <name>SERVER_STARTING</name> &amp;&amp; <name>res</name> != <name>SERVER_IDLE_KILL</name> &amp;&amp;
<name><name>ps</name>-&gt;<name>generation</name></name> == <name>mpm_generation</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>busy</name>++</expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>ap_extended_status</name> &amp;&amp; !<name><name>ps</name>-&gt;<name>quiescing</name></name> &amp;&amp; <name><name>ps</name>-&gt;<name>pid</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>ws</name>-&gt;<name>access_count</name></name> != 0
|| (<name>res</name> != <name>SERVER_READY</name> &amp;&amp; <name>res</name> != <name>SERVER_DEAD</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ld</name>-&gt;<name>access_count</name></name> += <name><name>ws</name>-&gt;<name>access_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ld</name>-&gt;<name>bytes_served</name></name> += <name><name>ws</name>-&gt;<name>bytes_served</name></name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></for>
}</block></for>
<expr_stmt><expr><name>total</name> = <name>busy</name> + <name>ready</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>total</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ld</name>-&gt;<name>idle</name></name> = <name>ready</name> * 100 / <name>total</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ld</name>-&gt;<name>busy</name></name> = <name>busy</name> * 100 / <name>total</name></expr>;</expr_stmt>
}</block></then></if>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_get_loadavg</name><argument_list>(<argument>ap_loadavg_t *ld</argument>)</argument_list></macro> <block>{
<expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg</name></name> = -1.0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg5</name></name> = -1.0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg15</name></name> = -1.0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_GETLOADAVG</name></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>double</name></type> <name><name>la</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
<expr_stmt><expr><name>num</name> = <call><name>getloadavg</name><argument_list>(<argument><expr><name>la</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>num</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg</name></name> = (<name>float</name>)<name><name>la</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>num</name> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg5</name></name> = (<name>float</name>)<name><name>la</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>num</name> &gt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg15</name></name> = (<name>float</name>)<name><name>la</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
}</block></then></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_get_exec_line</name><argument_list>(<argument>apr_pool_t *p</argument>,
<argument>const char *cmd</argument>,
<argument>const char * const * argv</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_procattr_t</name> *</type><name>procattr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_proc_t</name> *</type><name>proc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>nbytes</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>apr_procattr_create</name><argument_list>(<argument><expr>&amp;<name>procattr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>apr_procattr_io_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>,
<argument><expr><name>APR_FULL_BLOCK</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>apr_procattr_dir_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>,
<argument><expr><call><name>ap_make_dirstr_parent</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>apr_procattr_cmdtype_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>APR_PROGRAM</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>proc</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>apr_proc_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>apr_proc_create</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>fp</name> = <name><name>proc</name>-&gt;<name>out</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><call><name>apr_file_read</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>nbytes</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
&amp;&amp; <name>nbytes</name> == 1 &amp;&amp; (<name>k</name> &lt; <name>MAX_STRING_LEN</name>-1)</expr> ;</condition> <incr/>) <block>{
<if>if <condition>(<expr><name>c</name> == '\n' || <name>c</name> == '\r'</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_array_str_index</name><argument_list>(<argument>const apr_array_header_t *array</argument>,
<argument>const char *s</argument>,
<argument>int start</argument>)</argument_list></macro> <block>{
<if>if <condition>(<expr><name>start</name> &gt;= 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>start</name></expr>;</init> <condition><expr><name>i</name> &lt; <name><name>array</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>i</name></expr>;</return>
}</block></then></if>
}</block></for>
}</block></then></if>
<return>return <expr>-1</expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_array_str_contains</name><argument_list>(<argument>const apr_array_header_t *array</argument>,
<argument>const char *s</argument>)</argument_list></macro> <block>{
<return>return <expr>(<call><name>ap_array_str_index</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &gt;= 0)</expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>short</name></type> <name><name>ucharmap</name><index>[]</index></name> <init>= <expr><block>{
<expr>0x0</expr>, <expr>0x1</expr>, <expr>0x2</expr>, <expr>0x3</expr>, <expr>0x4</expr>, <expr>0x5</expr>, <expr>0x6</expr>, <expr>0x7</expr>,
<expr>0x8</expr>, <expr>0x9</expr>, <expr>0xa</expr>, <expr>0xb</expr>, <expr>0xc</expr>, <expr>0xd</expr>, <expr>0xe</expr>, <expr>0xf</expr>,
<expr>0x10</expr>, <expr>0x11</expr>, <expr>0x12</expr>, <expr>0x13</expr>, <expr>0x14</expr>, <expr>0x15</expr>, <expr>0x16</expr>, <expr>0x17</expr>,
<expr>0x18</expr>, <expr>0x19</expr>, <expr>0x1a</expr>, <expr>0x1b</expr>, <expr>0x1c</expr>, <expr>0x1d</expr>, <expr>0x1e</expr>, <expr>0x1f</expr>,
<expr>0x20</expr>, <expr>0x21</expr>, <expr>0x22</expr>, <expr>0x23</expr>, <expr>0x24</expr>, <expr>0x25</expr>, <expr>0x26</expr>, <expr>0x27</expr>,
<expr>0x28</expr>, <expr>0x29</expr>, <expr>0x2a</expr>, <expr>0x2b</expr>, <expr>0x2c</expr>, <expr>0x2d</expr>, <expr>0x2e</expr>, <expr>0x2f</expr>,
<expr>0x30</expr>, <expr>0x31</expr>, <expr>0x32</expr>, <expr>0x33</expr>, <expr>0x34</expr>, <expr>0x35</expr>, <expr>0x36</expr>, <expr>0x37</expr>,
<expr>0x38</expr>, <expr>0x39</expr>, <expr>0x3a</expr>, <expr>0x3b</expr>, <expr>0x3c</expr>, <expr>0x3d</expr>, <expr>0x3e</expr>, <expr>0x3f</expr>,
<expr>0x40</expr>, <expr>'a'</expr>, <expr>'b'</expr>, <expr>'c'</expr>, <expr>'d'</expr>, <expr>'e'</expr>, <expr>'f'</expr>, <expr>'g'</expr>,
<expr>'h'</expr>, <expr>'i'</expr>, <expr>'j'</expr>, <expr>'k'</expr>, <expr>'l'</expr>, <expr>'m'</expr>, <expr>'n'</expr>, <expr>'o'</expr>,
<expr>'p'</expr>, <expr>'q'</expr>, <expr>'r'</expr>, <expr>'s'</expr>, <expr>'t'</expr>, <expr>'u'</expr>, <expr>'v'</expr>, <expr>'w'</expr>,
<expr>'x'</expr>, <expr>'y'</expr>, <expr>'z'</expr>, <expr>0x5b</expr>, <expr>0x5c</expr>, <expr>0x5d</expr>, <expr>0x5e</expr>, <expr>0x5f</expr>,
<expr>0x60</expr>, <expr>'a'</expr>, <expr>'b'</expr>, <expr>'c'</expr>, <expr>'d'</expr>, <expr>'e'</expr>, <expr>'f'</expr>, <expr>'g'</expr>,
<expr>'h'</expr>, <expr>'i'</expr>, <expr>'j'</expr>, <expr>'k'</expr>, <expr>'l'</expr>, <expr>'m'</expr>, <expr>'n'</expr>, <expr>'o'</expr>,
<expr>'p'</expr>, <expr>'q'</expr>, <expr>'r'</expr>, <expr>'s'</expr>, <expr>'t'</expr>, <expr>'u'</expr>, <expr>'v'</expr>, <expr>'w'</expr>,
<expr>'x'</expr>, <expr>'y'</expr>, <expr>'z'</expr>, <expr>0x7b</expr>, <expr>0x7c</expr>, <expr>0x7d</expr>, <expr>0x7e</expr>, <expr>0x7f</expr>,
<expr>0x80</expr>, <expr>0x81</expr>, <expr>0x82</expr>, <expr>0x83</expr>, <expr>0x84</expr>, <expr>0x85</expr>, <expr>0x86</expr>, <expr>0x87</expr>,
<expr>0x88</expr>, <expr>0x89</expr>, <expr>0x8a</expr>, <expr>0x8b</expr>, <expr>0x8c</expr>, <expr>0x8d</expr>, <expr>0x8e</expr>, <expr>0x8f</expr>,
<expr>0x90</expr>, <expr>0x91</expr>, <expr>0x92</expr>, <expr>0x93</expr>, <expr>0x94</expr>, <expr>0x95</expr>, <expr>0x96</expr>, <expr>0x97</expr>,
<expr>0x98</expr>, <expr>0x99</expr>, <expr>0x9a</expr>, <expr>0x9b</expr>, <expr>0x9c</expr>, <expr>0x9d</expr>, <expr>0x9e</expr>, <expr>0x9f</expr>,
<expr>0xa0</expr>, <expr>0xa1</expr>, <expr>0xa2</expr>, <expr>0xa3</expr>, <expr>0xa4</expr>, <expr>0xa5</expr>, <expr>0xa6</expr>, <expr>0xa7</expr>,
<expr>0xa8</expr>, <expr>0xa9</expr>, <expr>0xaa</expr>, <expr>0xab</expr>, <expr>0xac</expr>, <expr>0xad</expr>, <expr>0xae</expr>, <expr>0xaf</expr>,
<expr>0xb0</expr>, <expr>0xb1</expr>, <expr>0xb2</expr>, <expr>0xb3</expr>, <expr>0xb4</expr>, <expr>0xb5</expr>, <expr>0xb6</expr>, <expr>0xb7</expr>,
<expr>0xb8</expr>, <expr>0xb9</expr>, <expr>0xba</expr>, <expr>0xbb</expr>, <expr>0xbc</expr>, <expr>0xbd</expr>, <expr>0xbe</expr>, <expr>0xbf</expr>,
<expr>0xc0</expr>, <expr>0xc1</expr>, <expr>0xc2</expr>, <expr>0xc3</expr>, <expr>0xc4</expr>, <expr>0xc5</expr>, <expr>0xc6</expr>, <expr>0xc7</expr>,
<expr>0xc8</expr>, <expr>0xc9</expr>, <expr>0xca</expr>, <expr>0xcb</expr>, <expr>0xcc</expr>, <expr>0xcd</expr>, <expr>0xce</expr>, <expr>0xcf</expr>,
<expr>0xd0</expr>, <expr>0xd1</expr>, <expr>0xd2</expr>, <expr>0xd3</expr>, <expr>0xd4</expr>, <expr>0xd5</expr>, <expr>0xd6</expr>, <expr>0xd7</expr>,
<expr>0xd8</expr>, <expr>0xd9</expr>, <expr>0xda</expr>, <expr>0xdb</expr>, <expr>0xdc</expr>, <expr>0xdd</expr>, <expr>0xde</expr>, <expr>0xdf</expr>,
<expr>0xe0</expr>, <expr>0xe1</expr>, <expr>0xe2</expr>, <expr>0xe3</expr>, <expr>0xe4</expr>, <expr>0xe5</expr>, <expr>0xe6</expr>, <expr>0xe7</expr>,
<expr>0xe8</expr>, <expr>0xe9</expr>, <expr>0xea</expr>, <expr>0xeb</expr>, <expr>0xec</expr>, <expr>0xed</expr>, <expr>0xee</expr>, <expr>0xef</expr>,
<expr>0xf0</expr>, <expr>0xf1</expr>, <expr>0xf2</expr>, <expr>0xf3</expr>, <expr>0xf4</expr>, <expr>0xf5</expr>, <expr>0xf6</expr>, <expr>0xf7</expr>,
<expr>0xf8</expr>, <expr>0xf9</expr>, <expr>0xfa</expr>, <expr>0xfb</expr>, <expr>0xfc</expr>, <expr>0xfd</expr>, <expr>0xfe</expr>, <expr>0xff</expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>short</name></type> <name><name>ucharmap</name><index>[]</index></name> <init>= <expr><block>{
<expr>0x00</expr>, <expr>0x01</expr>, <expr>0x02</expr>, <expr>0x03</expr>, <expr>0x9C</expr>, <expr>0x09</expr>, <expr>0x86</expr>, <expr>0x7F</expr>,
<expr>0x97</expr>, <expr>0x8D</expr>, <expr>0x8E</expr>, <expr>0x0B</expr>, <expr>0x0C</expr>, <expr>0x0D</expr>, <expr>0x0E</expr>, <expr>0x0F</expr>,
<expr>0x10</expr>, <expr>0x11</expr>, <expr>0x12</expr>, <expr>0x13</expr>, <expr>0x9D</expr>, <expr>0x85</expr>, <expr>0x08</expr>, <expr>0x87</expr>,
<expr>0x18</expr>, <expr>0x19</expr>, <expr>0x92</expr>, <expr>0x8F</expr>, <expr>0x1C</expr>, <expr>0x1D</expr>, <expr>0x1E</expr>, <expr>0x1F</expr>,
<expr>0x80</expr>, <expr>0x81</expr>, <expr>0x82</expr>, <expr>0x83</expr>, <expr>0x84</expr>, <expr>0x0A</expr>, <expr>0x17</expr>, <expr>0x1B</expr>,
<expr>0x88</expr>, <expr>0x89</expr>, <expr>0x8A</expr>, <expr>0x8B</expr>, <expr>0x8C</expr>, <expr>0x05</expr>, <expr>0x06</expr>, <expr>0x07</expr>,
<expr>0x90</expr>, <expr>0x91</expr>, <expr>0x16</expr>, <expr>0x93</expr>, <expr>0x94</expr>, <expr>0x95</expr>, <expr>0x96</expr>, <expr>0x04</expr>,
<expr>0x98</expr>, <expr>0x99</expr>, <expr>0x9A</expr>, <expr>0x9B</expr>, <expr>0x14</expr>, <expr>0x15</expr>, <expr>0x9E</expr>, <expr>0x1A</expr>,
<expr>0x20</expr>, <expr>0xA0</expr>, <expr>0xE2</expr>, <expr>0xE4</expr>, <expr>0xE0</expr>, <expr>0xE1</expr>, <expr>0xE3</expr>, <expr>0xE5</expr>,
<expr>0xE7</expr>, <expr>0xF1</expr>, <expr>0xA2</expr>, <expr>0x2E</expr>, <expr>0x3C</expr>, <expr>0x28</expr>, <expr>0x2B</expr>, <expr>0x7C</expr>,
<expr>0x26</expr>, <expr>0xE9</expr>, <expr>0xEA</expr>, <expr>0xEB</expr>, <expr>0xE8</expr>, <expr>0xED</expr>, <expr>0xEE</expr>, <expr>0xEF</expr>,
<expr>0xEC</expr>, <expr>0xDF</expr>, <expr>0x21</expr>, <expr>0x24</expr>, <expr>0x2A</expr>, <expr>0x29</expr>, <expr>0x3B</expr>, <expr>0xAC</expr>,
<expr>0x2D</expr>, <expr>0x2F</expr>, <expr>0xC2</expr>, <expr>0xC4</expr>, <expr>0xC0</expr>, <expr>0xC1</expr>, <expr>0xC3</expr>, <expr>0xC5</expr>,
<expr>0xC7</expr>, <expr>0xD1</expr>, <expr>0xA6</expr>, <expr>0x2C</expr>, <expr>0x25</expr>, <expr>0x5F</expr>, <expr>0x3E</expr>, <expr>0x3F</expr>,
<expr>0xF8</expr>, <expr>0xC9</expr>, <expr>0xCA</expr>, <expr>0xCB</expr>, <expr>0xC8</expr>, <expr>0xCD</expr>, <expr>0xCE</expr>, <expr>0xCF</expr>,
<expr>0xCC</expr>, <expr>0x60</expr>, <expr>0x3A</expr>, <expr>0x23</expr>, <expr>0x40</expr>, <expr>0x27</expr>, <expr>0x3D</expr>, <expr>0x22</expr>,
<expr>0xD8</expr>, <expr>0x61</expr>, <expr>0x62</expr>, <expr>0x63</expr>, <expr>0x64</expr>, <expr>0x65</expr>, <expr>0x66</expr>, <expr>0x67</expr>,
<expr>0x68</expr>, <expr>0x69</expr>, <expr>0xAB</expr>, <expr>0xBB</expr>, <expr>0xF0</expr>, <expr>0xFD</expr>, <expr>0xFE</expr>, <expr>0xB1</expr>,
<expr>0xB0</expr>, <expr>0x6A</expr>, <expr>0x6B</expr>, <expr>0x6C</expr>, <expr>0x6D</expr>, <expr>0x6E</expr>, <expr>0x6F</expr>, <expr>0x70</expr>,
<expr>0x71</expr>, <expr>0x72</expr>, <expr>0xAA</expr>, <expr>0xBA</expr>, <expr>0xE6</expr>, <expr>0xB8</expr>, <expr>0xC6</expr>, <expr>0xA4</expr>,
<expr>0xB5</expr>, <expr>0x7E</expr>, <expr>0x73</expr>, <expr>0x74</expr>, <expr>0x75</expr>, <expr>0x76</expr>, <expr>0x77</expr>, <expr>0x78</expr>,
<expr>0x79</expr>, <expr>0x7A</expr>, <expr>0xA1</expr>, <expr>0xBF</expr>, <expr>0xD0</expr>, <expr>0xDD</expr>, <expr>0xDE</expr>, <expr>0xAE</expr>,
<expr>0x5E</expr>, <expr>0xA3</expr>, <expr>0xA5</expr>, <expr>0xB7</expr>, <expr>0xA9</expr>, <expr>0xA7</expr>, <expr>0xB6</expr>, <expr>0xBC</expr>,
<expr>0xBD</expr>, <expr>0xBE</expr>, <expr>0x5B</expr>, <expr>0x5D</expr>, <expr>0xAF</expr>, <expr>0xA8</expr>, <expr>0xB4</expr>, <expr>0xD7</expr>,
<expr>0x7B</expr>, <expr>0x61</expr>, <expr>0x62</expr>, <expr>0x63</expr>, <expr>0x64</expr>, <expr>0x65</expr>, <expr>0x66</expr>, <expr>0x67</expr>,
<expr>0x68</expr>, <expr>0x69</expr>, <expr>0xAD</expr>, <expr>0xF4</expr>, <expr>0xF6</expr>, <expr>0xF2</expr>, <expr>0xF3</expr>, <expr>0xF5</expr>,
<expr>0x7D</expr>, <expr>0x6A</expr>, <expr>0x6B</expr>, <expr>0x6C</expr>, <expr>0x6D</expr>, <expr>0x6E</expr>, <expr>0x6F</expr>, <expr>0x70</expr>,
<expr>0x71</expr>, <expr>0x72</expr>, <expr>0xB9</expr>, <expr>0xFB</expr>, <expr>0xFC</expr>, <expr>0xF9</expr>, <expr>0xFA</expr>, <expr>0xFF</expr>,
<expr>0x5C</expr>, <expr>0xF7</expr>, <expr>0x73</expr>, <expr>0x74</expr>, <expr>0x75</expr>, <expr>0x76</expr>, <expr>0x77</expr>, <expr>0x78</expr>,
<expr>0x79</expr>, <expr>0x7A</expr>, <expr>0xB2</expr>, <expr>0xD4</expr>, <expr>0xD6</expr>, <expr>0xD2</expr>, <expr>0xD3</expr>, <expr>0xD5</expr>,
<expr>0x30</expr>, <expr>0x31</expr>, <expr>0x32</expr>, <expr>0x33</expr>, <expr>0x34</expr>, <expr>0x35</expr>, <expr>0x36</expr>, <expr>0x37</expr>,
<expr>0x38</expr>, <expr>0x39</expr>, <expr>0xB3</expr>, <expr>0xDB</expr>, <expr>0xDC</expr>, <expr>0xD9</expr>, <expr>0xDA</expr>, <expr>0x9F</expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_cstr_casecmp</name><argument_list>(<argument>const char *s1</argument>, <argument>const char *s2</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>str1</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>s1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>str2</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>s2</name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c1</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr>*<name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c2</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr>*<name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmp</name> <init>= <expr><name><name>ucharmap</name><index>[<expr><name>c1</name></expr>]</index></name> - <name><name>ucharmap</name><index>[<expr><name>c2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cmp</name> || !<name>c1</name></expr>)</condition><then>
<return>return <expr><name>cmp</name></expr>;</return></then></if>
<expr_stmt><expr><name>str1</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>str2</name>++</expr>;</expr_stmt>
}</block></for>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_cstr_casecmpn</name><argument_list>(<argument>const char *s1</argument>, <argument>const char *s2</argument>, <argument>apr_size_t n</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>str1</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>s1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>str2</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>s2</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>n</name>--</expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c1</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr>*<name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c2</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr>*<name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmp</name> <init>= <expr><name><name>ucharmap</name><index>[<expr><name>c1</name></expr>]</index></name> - <name><name>ucharmap</name><index>[<expr><name>c2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cmp</name> || !<name>c1</name></expr>)</condition><then>
<return>return <expr><name>cmp</name></expr>;</return></then></if>
<expr_stmt><expr><name>str1</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>str2</name>++</expr>;</expr_stmt>
}</block></while>
<return>return <expr>0</expr>;</return>
}</block>
</unit>
