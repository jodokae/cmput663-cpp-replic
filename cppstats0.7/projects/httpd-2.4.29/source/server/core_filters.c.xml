<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/core_filters.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file  core_filters.c
 * @brief Core input/output network filters.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_fnmatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>    <comment type="block">/* for RLIMIT stuff */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_IOVEC</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_MEMFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include> <comment type="block">/* For index_of_response().  Grump. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>     <comment type="block">/* For the default_handler below... */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ebcdic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_listen.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_so.h"</cpp:file></cpp:include> <comment type="block">/* for ap_find_loaded_module_symbol */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MIN_SENDFILE_BYTES</name></cpp:macro>           <cpp:value>(256)</cpp:value></cpp:define>

<comment type="block">/**
 * Remove all zero length buckets from the brigade.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BRIGADE_NORMALIZE</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>do { \
    apr_bucket *e = APR_BRIGADE_FIRST(b); \
    do {  \
        if (e-&gt;length == 0 &amp;&amp; !APR_BUCKET_IS_METADATA(e)) { \
            apr_bucket *d; \
            d = APR_BUCKET_NEXT(e); \
            apr_bucket_delete(e); \
            e = d; \
        } \
        else { \
            e = APR_BUCKET_NEXT(e); \
        } \
    } while (!APR_BRIGADE_EMPTY(b) &amp;&amp; (e != APR_BRIGADE_SENTINEL(b))); \
} while (0)</cpp:value></cpp:define>

<comment type="block">/* we know core's module_index is 0 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APLOG_MODULE_INDEX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro> <cpp:value>AP_CORE_MODULE_INDEX</cpp:value></cpp:define>

<struct>struct <name>core_output_filter_ctx</name> <block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>buffered_bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmp_flush_bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>deferred_write_pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_written</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>core_filter_ctx</name> <block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmpbb</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><name>apr_status_t</name></type> <name>ap_core_input_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl></param>,
                                  <param><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                  <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_net_rec</name> *</type><name>net</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>net</name>-&gt;<name>in_ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_INIT</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * this mode is for filters that might need to 'initialize'
         * a connection before reading request data from a client.
         * NNTP over SSL for example needs to handshake before the
         * server sends the welcome message.
         * such filters would have changed the mode before this point
         * is reached.  however, protocol modules such as NNTP should
         * not need to know anything about SSL.  given the example, if
         * SSL is not in the filter chain, AP_MODE_INIT is a noop.
         */</comment>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><name><name>net</name>-&gt;<name>in_ctx</name></name> = <name>ctx</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>b</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* seed the brigade with the client socket. */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>ap_run_insert_network_bucket</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr><name><name>net</name>-&gt;<name>client_socket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
            <return>return <expr><name>rv</name></expr>;</return></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_EOF</name></expr>;</return>
    }</block></then></if></else></if>

    <comment type="block">/* ### This is bad. */</comment>
    <expr_stmt><expr><call><name>BRIGADE_NORMALIZE</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* check for empty brigade again *AFTER* BRIGADE_NORMALIZE()
     * If we have lost our socket bucket (see above), we are EOF.
     *
     * Ideally, this should be returning SUCCESS with EOS bucket, but
     * some higher-up APIs (spec. read_request_line via ap_rgetline)
     * want an error code. */</comment>
    <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_EOF</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_GETLINE</name></expr>)</condition><then> <block>{
        <comment type="block">/* we are reading a single LF line, e.g. the HTTP headers */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_brigade_split_line</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>HUGE_STRING_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* We should treat EAGAIN here the same as we do for EOF (brigade is
         * empty).  We do this by returning whatever we have read.  This may
         * or may not be bogus, but is consistent (for now) with EOF logic.
         */</comment>
        <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>block</name> == <name>APR_NONBLOCK_READ</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* ### AP_MODE_PEEK is a horrific name for this mode because we also
     * eat any CRLFs that we see.  That's not the obvious intention of
     * this mode.  Determine whether anyone actually uses this or not. */</comment>
    <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_EATCRLF</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>c</name></decl>;</decl_stmt>

        <comment type="block">/* The purpose of this loop is to ignore any CRLF (or LF) at the end
         * of a request.  Many browsers send extra lines at the end of POST
         * requests.  We use the PEEK method to determine if there is more
         * data on the socket, so that we know if we should delay sending the
         * end of one request until we have served the second request in a
         * pipelined situation.  We don't want to actually delay sending a
         * response if the server finds a CRLF (or LF), becuause that doesn't
         * mean that there is another request, just a blank line.
         */</comment>
        <while>while <condition>(<expr>1</expr>)</condition> <block>{
            <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr><name>APR_EOF</name></expr>;</return></then></if>

            <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_NONBLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
                <return>return <expr><name>rv</name></expr>;</return></then></if>

            <expr_stmt><expr><name>c</name> = <name>str</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>c</name> &lt; <name>str</name> + <name>len</name></expr>)</condition> <block>{
                <if>if <condition>(<expr>*<name>c</name> == <name>APR_ASCII_LF</name></expr>)</condition><then>
                    <expr_stmt><expr><name>c</name>++</expr>;</expr_stmt></then>
                <else>else <if>if <condition>(<expr>*<name>c</name> == <name>APR_ASCII_CR</name> &amp;&amp; *(<name>c</name> + 1) == <name>APR_ASCII_LF</name></expr>)</condition><then>
                    <expr_stmt><expr><name>c</name> += 2</expr>;</expr_stmt></then>
                <else>else
                    <return>return <expr><name>APR_SUCCESS</name></expr>;</return></else></if></else></if>
            }</block></while>

            <comment type="block">/* If we reach here, we were a bucket just full of CRLFs, so
             * just toss the bucket. */</comment>
            <comment type="block">/* FIXME: Is this the right thing to do in the core? */</comment>
            <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If mode is EXHAUSTIVE, we want to just read everything until the end
     * of the brigade, which in this case means the end of the socket.
     * To do this, we attach the brigade that has currently been setaside to
     * the brigade that was passed down, and send that brigade back.
     *
     * NOTE:  This is VERY dangerous to use, and should only be done with
     * extreme caution.  FWLIW, this would be needed by an MPM like Perchild;
     * such an MPM can easily request the socket and all data that has been
     * read, which means that it can pass it to the correct child process.
     */</comment>
    <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_EXHAUSTIVE</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>

        <comment type="block">/* Tack on any buckets that were set aside. */</comment>
        <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Since we've just added all potential buckets (which will most
         * likely simply be the socket bucket) we know this is the end,
         * so tack on an EOS too. */</comment>
        <comment type="block">/* We have read until the brigade was empty, so we know that we
         * must be EOS. */</comment>
        <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* read up to the amount they specified. */</comment>
    <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_READBYTES</name> || <name>mode</name> == <name>AP_MODE_SPECULATIVE</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>readbytes</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call> &amp;&amp; <name>block</name> == <name>APR_NONBLOCK_READ</name></expr>)</condition><then> <block>{
            <comment type="block">/* getting EAGAIN for a blocking read is an error; for a
             * non-blocking read, return an empty brigade. */</comment>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>block</name> == <name>APR_BLOCK_READ</name> &amp;&amp; <name>len</name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* We wanted to read some bytes in blocking mode.  We read
             * 0 bytes.  Hence, we now assume we are EOS.
             *
             * When we are in normal mode, return an EOS bucket to the
             * caller.
             * When we are in speculative mode, leave ctx-&gt;b empty, so
             * that the next call returns an EOS bucket.
             */</comment>
            <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_READBYTES</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if></else></if></else></if>

        <comment type="block">/* Have we read as much data as we wanted (be greedy)? */</comment>
        <if>if <condition>(<expr><name>len</name> &lt; <name>readbytes</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bucket_len</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
            <comment type="block">/* We already registered the data in e in len */</comment>
            <expr_stmt><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr>(<name>len</name> &lt; <name>readbytes</name>) &amp;&amp; (<name>rv</name> == <name>APR_SUCCESS</name>)
                   &amp;&amp; (<name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
                <comment type="block">/* Check for the availability of buckets with known length */</comment>
                <if>if <condition>(<expr><name><name>e</name>-&gt;<name>length</name></name> != -1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>len</name> += <name><name>e</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <comment type="block">/*
                     * Read from bucket, but non blocking. If there isn't any
                     * more data, well than this is fine as well, we will
                     * not wait for more since we already got some and we are
                     * only checking if there isn't more.
                     */</comment>
                    <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>bucket_len</name></expr></argument>,
                                         <argument><expr><name>APR_NONBLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>len</name> += <name>bucket_len</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></while>
        }</block></then></if>

        <comment type="block">/* We can only return at most what we read. */</comment>
        <if>if <condition>(<expr><name>len</name> &lt; <name>readbytes</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>readbytes</name> = <name>len</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name>apr_brigade_partition</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Must do move before CONCAT */</comment>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name> = <call><name>apr_brigade_split_ex</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_READBYTES</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_SPECULATIVE</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>copy_bucket</name></decl>;</decl_stmt>

            <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>;</init>
                 <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>)</argument_list></call></expr>;</condition>
                 <incr><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_copy</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>copy_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>rv</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>copy_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if></else></if>

        <comment type="block">/* Take what was originally there and place it back on ctx-&gt;b */</comment>
        <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>b</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setaside_remaining_output</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                      <param><decl><type><name>core_output_filter_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                      <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                      <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_brigade_nonblocking</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>,
                                             <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                             <param><decl><type><name>apr_size_t</name> *</type><name>bytes_written</name></decl></param>,
                                             <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_empty_buckets</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_brigade_blocking</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>,
                                          <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                          <param><decl><type><name>apr_size_t</name> *</type><name>bytes_written</name></decl></param>,
                                          <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>writev_nonblocking</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>,
                                       <param><decl><type>struct <name>iovec</name> *</type><name>vec</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nvec</name></decl></param>,
                                       <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                       <param><decl><type><name>apr_size_t</name> *</type><name>cumulative_bytes_written</name></decl></param>,
                                       <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SENDFILE</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>sendfile_nonblocking</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>,
                                         <param><decl><type><name>apr_bucket</name> *</type><name>bucket</name></decl></param>,
                                         <param><decl><type><name>apr_size_t</name> *</type><name>cumulative_bytes_written</name></decl></param>,
                                         <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* XXX: Should these be configurable parameters? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THRESHOLD_MIN_WRITE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>THRESHOLD_MAX_BUFFER</name></cpp:macro> <cpp:value>65536</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REQUESTS_IN_PIPELINE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/* Optional function coming from mod_logio, used for logging of output
 * traffic
 */</comment>
<extern>extern APR_OPTIONAL_FN_TYPE(ap_logio_add_bytes_out</extern>) <expr_stmt><expr>*<name>ap__logio_add_bytes_out</name></expr>;</expr_stmt>

<function><type><name>apr_status_t</name></type> <name>ap_core_output_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>new_bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>f</name>-&gt;<name>c</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_net_rec</name> *</type><name>net</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_output_filter_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>net</name>-&gt;<name>out_ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>flush_upto</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_in_brigade</name></decl>, <decl><type ref="prev"/><name>non_file_bytes_in_brigade</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eor_buckets_in_brigade</name></decl>, <decl><type ref="prev"/><name>morphing_bucket_in_brigade</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="block">/* Fail quickly if the connection has already been aborted. */</comment>
    <if>if <condition>(<expr><name><name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>new_bb</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>new_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>ctx</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ctx</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>net</name>-&gt;<name>out_ctx</name></name> = (<name>core_output_filter_ctx_t</name> *)<name>ctx</name></expr>;</expr_stmt>
        <comment type="block">/*
         * Need to create tmp brigade with correct lifetime. Passing
         * NULL to apr_brigade_split_ex would result in a brigade
         * allocated from bb-&gt;pool which might be wrong.
         */</comment>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>tmp_flush_bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* same for buffered_bb and ap_save_brigade */</comment>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>buffered_bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>new_bb</name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>bb</name> = <name>new_bb</name></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>(<name><name>ctx</name>-&gt;<name>buffered_bb</name></name> != <name>NULL</name>) &amp;&amp;
        !<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>buffered_bb</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>new_bb</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>APR_BRIGADE_PREPEND</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>buffered_bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>bb</name> = <name><name>ctx</name>-&gt;<name>buffered_bb</name></name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name><name>c</name>-&gt;<name>data_in_output_filters</name></name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>new_bb</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if></else></if>

    <comment type="block">/* Scan through the brigade and decide whether to attempt a write,
     * and how much to write, based on the following rules:
     *
     *  1) The new_bb is null: Do a nonblocking write of as much as
     *     possible: do a nonblocking write of as much data as possible,
     *     then save the rest in ctx-&gt;buffered_bb.  (If new_bb == NULL,
     *     it probably means that the MPM is doing asynchronous write
     *     completion and has just determined that this connection
     *     is writable.)
     *
     *  2) Determine if and up to which bucket we need to do a blocking
     *     write:
     *
     *  a) The brigade contains a flush bucket: Do a blocking write
     *     of everything up that point.
     *
     *  b) The request is in CONN_STATE_HANDLER state, and the brigade
     *     contains at least THRESHOLD_MAX_BUFFER bytes in non-file
     *     buckets: Do blocking writes until the amount of data in the
     *     buffer is less than THRESHOLD_MAX_BUFFER.  (The point of this
     *     rule is to provide flow control, in case a handler is
     *     streaming out lots of data faster than the data can be
     *     sent to the client.)
     *
     *  c) The request is in CONN_STATE_HANDLER state, and the brigade
     *     contains at least MAX_REQUESTS_IN_PIPELINE EOR buckets:
     *     Do blocking writes until less than MAX_REQUESTS_IN_PIPELINE EOR
     *     buckets are left. (The point of this rule is to prevent too many
     *     FDs being kept open by pipelined requests, possibly allowing a
     *     DoS).
     *
     *  d) The brigade contains a morphing bucket: If there was no other
     *     reason to do a blocking write yet, try reading the bucket. If its
     *     contents fit into memory before THRESHOLD_MAX_BUFFER is reached,
     *     everything is fine. Otherwise we need to do a blocking write the
     *     up to and including the morphing bucket, because ap_save_brigade()
     *     would read the whole bucket into memory later on.
     *
     *  3) Actually do the blocking write up to the last bucket determined
     *     by rules 2a-d. The point of doing only one flush is to make as
     *     few calls to writev() as possible.
     *
     *  4) If the brigade contains at least THRESHOLD_MIN_WRITE
     *     bytes: Do a nonblocking write of as much data as possible,
     *     then save the rest in ctx-&gt;buffered_bb.
     */</comment>

    <if>if <condition>(<expr><name>new_bb</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>send_brigade_nonblocking</name><argument_list>(<argument><expr><name><name>net</name>-&gt;<name>client_socket</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>,
                                      <argument><expr>&amp;(<name><name>ctx</name>-&gt;<name>bytes_written</name></name>)</expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name> &amp;&amp; !<call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* The client has aborted the connection */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>c</name></expr></argument>,
                          <argument><expr>"core_output_filter: writing data to the network"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>setaside_remaining_output</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>bytes_in_brigade</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>non_file_bytes_in_brigade</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>eor_buckets_in_brigade</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>morphing_bucket_in_brigade</name> = 0</expr>;</expr_stmt>

    <for>for (<init><expr><name>bucket</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>bucket</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>bucket</name> = <name>next</name></expr></incr>) <block>{
        <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>bucket</name>-&gt;<name>length</name></name> == (<name>apr_size_t</name>)-1</expr>)</condition><then> <block>{
                <comment type="block">/*
                 * A setaside of morphing buckets would read everything into
                 * memory. Instead, we will flush everything up to and
                 * including this bucket.
                 */</comment>
                <expr_stmt><expr><name>morphing_bucket_in_brigade</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>bytes_in_brigade</name> += <name><name>bucket</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <expr_stmt><expr><name>non_file_bytes_in_brigade</name> += <name><name>bucket</name>-&gt;<name>length</name></name></expr>;</expr_stmt></then></if>
            }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>AP_BUCKET_IS_EOR</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>eor_buckets_in_brigade</name>++</expr>;</expr_stmt>
        }</block></then></if></else></if>

        <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FLUSH</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call>
            || <name>non_file_bytes_in_brigade</name> &gt;= <name>THRESHOLD_MAX_BUFFER</name>
            || <name>morphing_bucket_in_brigade</name>
            || <name>eor_buckets_in_brigade</name> &gt; <name>MAX_REQUESTS_IN_PIPELINE</name></expr>)</condition><then> <block>{
            <comment type="block">/* this segment of the brigade MUST be sent before returning. */</comment>

            <if>if <condition>(<expr><call><name>APLOGctrace6</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>reason</name> <init>= <expr><call><name>APR_BUCKET_IS_FLUSH</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call> ?
                               "FLUSH bucket" :
                               (<name>non_file_bytes_in_brigade</name> &gt;= <name>THRESHOLD_MAX_BUFFER</name>) ?
                               "THRESHOLD_MAX_BUFFER" :
                               <name>morphing_bucket_in_brigade</name> ? "morphing bucket" :
                               "MAX_REQUESTS_IN_PIPELINE"</expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE6</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                              <argument><expr>"core_output_filter: flushing because of %s"</expr></argument>,
                              <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <comment type="block">/*
             * Defer the actual blocking write to avoid doing many writes.
             */</comment>
            <expr_stmt><expr><name>flush_upto</name> = <name>next</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>bytes_in_brigade</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>non_file_bytes_in_brigade</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>eor_buckets_in_brigade</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>morphing_bucket_in_brigade</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>flush_upto</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>tmp_flush_bb</name></name> = <call><name>apr_brigade_split_ex</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>flush_upto</name></expr></argument>,
                                                 <argument><expr><name><name>ctx</name>-&gt;<name>tmp_flush_bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>send_brigade_blocking</name><argument_list>(<argument><expr><name><name>net</name>-&gt;<name>client_socket</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>,
                                   <argument><expr>&amp;(<name><name>ctx</name>-&gt;<name>bytes_written</name></name>)</expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="block">/* The client has aborted the connection */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>c</name></expr></argument>,
                          <argument><expr>"core_output_filter: writing data to the network"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmp_flush_bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>bytes_in_brigade</name> &gt;= <name>THRESHOLD_MIN_WRITE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>send_brigade_nonblocking</name><argument_list>(<argument><expr><name><name>net</name>-&gt;<name>client_socket</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>,
                                      <argument><expr>&amp;(<name><name>ctx</name>-&gt;<name>bytes_written</name></name>)</expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>rv</name> != <name>APR_SUCCESS</name>) &amp;&amp; (!<call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <comment type="block">/* The client has aborted the connection */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>c</name></expr></argument>,
                          <argument><expr>"core_output_filter: writing data to the network"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>c</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>setaside_remaining_output</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This function assumes that either ctx-&gt;buffered_bb == NULL, or
 * ctx-&gt;buffered_bb is empty, or ctx-&gt;buffered_bb == bb
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setaside_remaining_output</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                      <param><decl><type><name>core_output_filter_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                      <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                      <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>bb</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>remove_empty_buckets</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>c</name>-&gt;<name>data_in_output_filters</name></name> = 1</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>bb</name> != <name><name>ctx</name>-&gt;<name>buffered_bb</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>deferred_write_pool</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name><name>ctx</name>-&gt;<name>deferred_write_pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_pool_tag</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>deferred_write_pool</name></name></expr></argument>, <argument><expr>"deferred_write"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>ap_save_brigade</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>&amp;(<name><name>ctx</name>-&gt;<name>buffered_bb</name></name>)</expr></argument>, <argument><expr>&amp;<name>bb</name></expr></argument>,
                            <argument><expr><name><name>ctx</name>-&gt;<name>deferred_write_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>deferred_write_pool</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * There are no more requests in the pipeline. We can just clear the
         * pool.
         */</comment>
        <expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>deferred_write_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APR_MAX_IOVEC_SIZE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_IOVEC_TO_WRITE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_MAX_IOVEC_SIZE</name> &gt; 16</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_IOVEC_TO_WRITE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_IOVEC_TO_WRITE</name></cpp:macro> <cpp:value>APR_MAX_IOVEC_SIZE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_brigade_nonblocking</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>,
                                             <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                             <param><decl><type><name>apr_size_t</name> *</type><name>bytes_written</name></decl></param>,
                                             <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>iovec</name></type> <name><name>vec</name><index>[<expr><name>MAX_IOVEC_TO_WRITE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nvec</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>remove_empty_buckets</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>bucket</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>bucket</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>bucket</name> = <name>next</name></expr></incr>) <block>{
        <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SENDFILE</name></expr></cpp:if>
        <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_bucket_file</name> *</type><name>file_bucket</name> <init>= <expr><call>(<name>apr_bucket_file</name> *)<argument_list>(<argument><expr><name><name>bucket</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name> <init>= <expr><name><name>file_bucket</name>-&gt;<name>fd</name></name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* Use sendfile to send this file unless:
             *   - the platform doesn't support sendfile,
             *   - the file is too small for sendfile to be useful, or
             *   - sendfile is disabled in the httpd config via "EnableSendfile off"
             */</comment>

            <if>if <condition>(<expr>(<call><name>apr_file_flags_get</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> &amp; <name>APR_SENDFILE_ENABLED</name>) &amp;&amp;
                (<name><name>bucket</name>-&gt;<name>length</name></name> &gt;= <name>AP_MIN_SENDFILE_BYTES</name>)</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>nvec</name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr>(<name>void</name>)<call><name>apr_socket_opt_set</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>APR_TCP_NOPUSH</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rv</name> = <call><name>writev_nonblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>nvec</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr>(<name>void</name>)<call><name>apr_socket_opt_set</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>APR_TCP_NOPUSH</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><name>rv</name></expr>;</return>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>rv</name> = <call><name>sendfile_nonblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>nvec</name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr>(<name>void</name>)<call><name>apr_socket_opt_set</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>APR_TCP_NOPUSH</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>nvec</name> = 0</expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>rv</name></expr>;</return>
                }</block></then></if>
                <break>break;</break>
            }</block></then></if>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* APR_HAS_SENDFILE */</comment>
        <comment type="block">/* didn't sendfile */</comment>
        <if>if <condition>(<expr>!<call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>length</name></decl>;</decl_stmt>
            
            <comment type="block">/* Non-blocking read first, in case this is a morphing
             * bucket type. */</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>, <argument><expr><name>APR_NONBLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* Read would block; flush any pending data and retry. */</comment>
                <if>if <condition>(<expr><name>nvec</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>rv</name> = <call><name>writev_nonblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>nvec</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
                        <return>return <expr><name>rv</name></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name>nvec</name> = 0</expr>;</expr_stmt>
                }</block></then></if>
                
                <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>length</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* reading may have split the bucket, so recompute next: */</comment>
            <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vec</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_base</name> = (<name>char</name> *)<name>data</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>vec</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_len</name> = <name>length</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>nvec</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>nvec</name> == <name>MAX_IOVEC_TO_WRITE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>writev_nonblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>nvec</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>nvec</name> = 0</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>rv</name></expr>;</return>
                }</block></then></if>
                <break>break;</break>
            }</block></then></if>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>nvec</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>writev_nonblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>nvec</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>remove_empty_buckets</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>remove_empty_buckets</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name></decl>;</decl_stmt>
    <while>while <condition>(<expr>((<name>bucket</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>) != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>) &amp;&amp;
           (<call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call> || (<name><name>bucket</name>-&gt;<name>length</name></name> == 0))</expr>)</condition> <block>{
        <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_brigade_blocking</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>,
                                          <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                          <param><decl><type><name>apr_size_t</name> *</type><name>bytes_written</name></decl></param>,
                                          <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    <while>while <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>send_brigade_nonblocking</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* Wait until we can send more data */</comment>
                <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>nsds</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_pollfd_t</name></type> <name>pollset</name></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>pollset</name>.<name>p</name></name> = <name><name>c</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pollset</name>.<name>desc_type</name></name> = <name>APR_POLL_SOCKET</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pollset</name>.<name>reqevents</name></name> = <name>APR_POLLOUT</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>pollset</name>.<name>desc</name>.<name>s</name></name> = <name>s</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_socket_timeout_get</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <do>do <block>{
                    <expr_stmt><expr><name>rv</name> = <call><name>apr_poll</name><argument_list>(<argument><expr>&amp;<name>pollset</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>nsds</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block> while <condition>(<expr><call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
            }</block></then>
            <else>else <block>{
                <break>break;</break>
            }</block></else></if>
        }</block></then></if>
    }</block></while>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>writev_nonblocking</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>,
                                       <param><decl><type>struct <name>iovec</name> *</type><name>vec</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nvec</name></decl></param>,
                                       <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                       <param><decl><type><name>apr_size_t</name> *</type><name>cumulative_bytes_written</name></decl></param>,
                                       <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init>, <name>arv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_written</name> <init>= <expr>0</expr></init>, <name>bytes_to_write</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>old_timeout</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>arv</name> = <call><name>apr_socket_timeout_get</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>old_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>arv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>arv</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>arv</name> = <call><name>apr_socket_timeout_set</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>arv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>arv</name></expr>;</return>
    }</block></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nvec</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>bytes_to_write</name> += <name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
    <while>while <condition>(<expr><name>bytes_written</name> &lt; <name>bytes_to_write</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_socket_sendv</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>vec</name> + <name>offset</name></expr></argument>, <argument><expr><name>nvec</name> - <name>offset</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>bytes_written</name> += <name>n</name></expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = <name>offset</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>nvec</name></expr>;</condition> <incr/>) <block>{
                <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name> <init>= <expr><call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>n</name> &gt;= <name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>offset</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>n</name> -= <name><name>vec</name><index>[<expr><name>i</name>++</expr>]</index></name>.<name>iov_len</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> -= <name>n</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>char</name> *) <name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> + <name>n</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></else></if></else></if>
            }</block></for>
        }</block></then></if>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
    }</block></while>
    <if>if <condition>(<expr>(<name>ap__logio_add_bytes_out</name> != <name>NULL</name>) &amp;&amp; (<name>bytes_written</name> &gt; 0)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap__logio_add_bytes_out</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>cumulative_bytes_written</name> += <name>bytes_written</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>arv</name> = <call><name>apr_socket_timeout_set</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>old_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>arv</name> != <name>APR_SUCCESS</name>) &amp;&amp; (<name>rv</name> == <name>APR_SUCCESS</name>)</expr>)</condition><then> <block>{
        <return>return <expr><name>arv</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></else></if>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_SENDFILE</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>sendfile_nonblocking</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>,
                                         <param><decl><type><name>apr_bucket</name> *</type><name>bucket</name></decl></param>,
                                         <param><decl><type><name>apr_size_t</name> *</type><name>cumulative_bytes_written</name></decl></param>,
                                         <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_file</name> *</type><name>file_bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>file_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>file_offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_written</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>base_server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00006</expr></argument>)</argument_list></call>
                     "core_filter: sendfile_nonblocking: "
                     "this should never happen"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>file_bucket</name> = <call>(<name>apr_bucket_file</name> *)<argument_list>(<argument><expr><name><name>bucket</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>fd</name> = <name><name>file_bucket</name>-&gt;<name>fd</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>file_length</name> = <name><name>bucket</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>file_offset</name> = <name><name>bucket</name>-&gt;<name>start</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>bytes_written</name> &lt; <name>file_length</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>n</name> <init>= <expr><name>file_length</name> - <name>bytes_written</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>arv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>old_timeout</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>arv</name> = <call><name>apr_socket_timeout_get</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>old_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>arv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>arv</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>arv</name> = <call><name>apr_socket_timeout_set</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>arv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>arv</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_socket_sendfile</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>file_offset</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>bytes_written</name> += <name>n</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>file_offset</name> += <name>n</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>arv</name> = <call><name>apr_socket_timeout_set</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>old_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>arv</name> != <name>APR_SUCCESS</name>) &amp;&amp; (<name>rv</name> == <name>APR_SUCCESS</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>arv</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>ap__logio_add_bytes_out</name> != <name>NULL</name>) &amp;&amp; (<name>bytes_written</name> &gt; 0)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap__logio_add_bytes_out</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>cumulative_bytes_written</name> += <name>bytes_written</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>bytes_written</name> &lt; <name>file_length</name>) &amp;&amp; (<name>bytes_written</name> &gt; 0)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>bytes_written</name> == <name>file_length</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
