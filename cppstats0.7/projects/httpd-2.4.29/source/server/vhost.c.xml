<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/vhost.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file  vhost.c
 * @brief functions pertaining to virtual host addresses
 *        (configuration and run-time)
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_ARPA_INET_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* we know core's module_index is 0 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APLOG_MODULE_INDEX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro> <cpp:value>AP_CORE_MODULE_INDEX</cpp:value></cpp:define>

<comment type="block">/*
 * After all the definitions there's an explanation of how it's all put
 * together.
 */</comment>

<comment type="block">/* meta-list of name-vhosts.  Each server_rec can be in possibly multiple
 * lists of name-vhosts.
 */</comment>
<typedef>typedef <type>struct <name>name_chain</name></type> <name>name_chain</name>;</typedef>
<struct>struct <name>name_chain</name> <block>{
    <decl_stmt><decl><type><name>name_chain</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl>;</decl_stmt>       <comment type="block">/* the record causing it to be in
                                 * this chain (needed for port comparisons) */</comment>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>server</name></decl>;</decl_stmt>         <comment type="block">/* the server to use on a match */</comment>
}</block>;</struct>

<comment type="block">/* meta-list of ip addresses.  Each server_rec can be in possibly multiple
 * hash chains since it can have multiple ips.
 */</comment>
<typedef>typedef <type>struct <name>ipaddr_chain</name></type> <name>ipaddr_chain</name>;</typedef>
<struct>struct <name>ipaddr_chain</name> <block>{
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl>;</decl_stmt>       <comment type="block">/* the record causing it to be in
                                 * this chain (need for both ip addr and port
                                 * comparisons) */</comment>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>server</name></decl>;</decl_stmt>         <comment type="block">/* the server to use if this matches */</comment>
    <decl_stmt><decl><type><name>name_chain</name> *</type><name>names</name></decl>;</decl_stmt>          <comment type="block">/* if non-NULL then a list of name-vhosts
                                 * sharing this address */</comment>
    <decl_stmt><decl><type><name>name_chain</name> *</type><name>initialnames</name></decl>;</decl_stmt>   <comment type="block">/* no runtime use, temporary storage of first
                                 * NVH'es names */</comment>
}</block>;</struct>

<comment type="block">/* This defines the size of the hash table used for hashing ip addresses
 * of virtual hosts.  It must be a power of two.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>IPHASH_TABLE_SIZE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IPHASH_TABLE_SIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* A (n) bucket hash table, each entry has a pointer to a server rec and
 * a pointer to the other entries in that bucket.  Each individual address,
 * even for virtualhosts with multiple addresses, has an entry in this hash
 * table.  There are extra buckets for _default_, and name-vhost entries.
 *
 * Note that after config time this is constant, so it is thread-safe.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ipaddr_chain</name> *</type><name><name>iphash_table</name><index>[<expr><name>IPHASH_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* dump out statistics about the hash function */</comment>
<comment type="block">/* #define IPHASH_STATISTICS */</comment>

<comment type="block">/* list of the _default_ servers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ipaddr_chain</name> *</type><name>default_list</name></decl>;</decl_stmt>

<comment type="block">/* whether a config error was seen */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>config_error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/* config check function */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>vhost_check_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * How it's used:
 *
 * The ip address determines which chain in iphash_table is interesting, then
 * a comparison is done down that chain to find the first ipaddr_chain whose
 * sar matches the address:port pair.
 *
 * If that ipaddr_chain has names == NULL then you're done, it's an ip-vhost.
 *
 * Otherwise it's a name-vhost list, and the default is the server in the
 * ipaddr_chain record.  We tuck away the ipaddr_chain record in the
 * conn_rec field vhost_lookup_data.  Later on after the headers we get a
 * second chance, and we use the name_chain to figure out what name-vhost
 * matches the headers.
 *
 * If there was no ip address match in the iphash_table then do a lookup
 * in the default_list.
 *
 * How it's put together ... well you should be able to figure that out
 * from how it's used.  Or something like that.
 */</comment>


<comment type="block">/* called at the beginning of the config */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_init_vhost_config</name><argument_list>(<argument>apr_pool_t *p</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>iphash_table</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>iphash_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>default_list</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_check_config</name><argument_list>(<argument><expr><name>vhost_check_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>


<comment type="block">/*
 * Parses a host of the form &lt;address&gt;[:port]
 * paddr is used to create a list in the order of input
 * **paddr is the -&gt;next pointer of the last entry (or s-&gt;addrs)
 * *paddr is the variable used to keep track of **paddr between calls
 * port is the default port to assume
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>get_addresses</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>w_</name></decl></param>,
                                 <param><decl><type><name>server_addr_rec</name> ***</type><name>paddr</name></decl></param>,
                                 <param><decl><type><name>apr_port_t</name></type> <name>default_port</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>my_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>w</name></decl>, *<decl><type ref="prev"/><name>host</name></decl>, *<decl><type ref="prev"/><name>scope_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>wild_port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>wlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>w_</name> == '\0'</expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>wlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>w_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                   <comment type="block">/* wlen must be &gt; 0 at this point */</comment>
    <expr_stmt><expr><name>w</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>w_</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* apr_parse_addr_port() doesn't understand ":*" so handle that first. */</comment>
    <expr_stmt><expr><name>wild_port</name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>w</name><index>[<expr><name>wlen</name> - 1</expr>]</index></name> == '*'</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>wlen</name> &lt; 2</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>wild_port</name> = 1</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>w</name><index>[<expr><name>wlen</name> - 2</expr>]</index></name> == ':'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>w</name><index>[<expr><name>wlen</name> - 2</expr>]</index></name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><name>wild_port</name> = 1</expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then></if>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_parse_addr_port</name><argument_list>(<argument><expr>&amp;<name>host</name></expr></argument>, <argument><expr>&amp;<name>scope_id</name></expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* If the string is "80", apr_parse_addr_port() will be happy and set
     * host to NULL and port to 80, so watch out for that.
     */</comment>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>"The address or port is invalid"</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>host</name></expr>)</condition><then> <block>{
        <return>return <expr>"Missing address for VirtualHost"</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>scope_id</name></expr>)</condition><then> <block>{
        <return>return <expr>"Scope ids are not supported"</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>port</name> &amp;&amp; !<name>wild_port</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>port</name> = <name>default_port</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call> == 0 || <call><name>strcasecmp</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>"_default_"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_sockaddr_info_get</name><argument_list>(<argument><expr>&amp;<name>my_addr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_UNSPEC</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
            <return>return <expr>"Could not determine a wildcard address ('0.0.0.0') -- "
                "check resolver configuration."</expr>;</return>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_sockaddr_info_get</name><argument_list>(<argument><expr>&amp;<name>my_addr</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>APR_UNSPEC</name></expr></argument>, <argument><expr><name>port</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00547</expr></argument>)</argument_list></call>
                "Could not resolve host name %s -- ignoring!"</expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></else></if>

    <comment type="block">/* Remember all addresses for the host */</comment>

    <do>do <block>{
        <expr_stmt><expr><name>sar</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>server_addr_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>**<name>paddr</name> = <name>sar</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>paddr</name> = &amp;<name><name>sar</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sar</name>-&gt;<name>host_addr</name></name> = <name>my_addr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sar</name>-&gt;<name>host_port</name></name> = <name>port</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sar</name>-&gt;<name>virthost</name></name> = <name>host</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>my_addr</name> = <name><name>my_addr</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>my_addr</name></expr>)</condition>;</do>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/* parse the &lt;VirtualHost&gt; addresses */</comment>
<function><type><specifier>const</specifier> <name>char</name> *</type><name>ap_parse_vhost_addrs</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hostname</name></decl></param>,
                                 <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>server_addr_rec</name> **</type><name>addrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name></decl>;</decl_stmt>

    <comment type="block">/* start the list of addresses */</comment>
    <expr_stmt><expr><name>addrs</name> = &amp;<name><name>s</name>-&gt;<name>addrs</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>hostname</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
        <expr_stmt><expr><name>err</name> = <call><name>get_addresses</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>ap_getword_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>hostname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>addrs</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>addrs</name> = <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>
    }</block></while>
    <comment type="block">/* terminate the list */</comment>
    <expr_stmt><expr>*<name>addrs</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>s</name>-&gt;<name>addrs</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>addrs</name>-&gt;<name>host_port</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* override the default port which is inherited from main_server */</comment>
            <expr_stmt><expr><name><name>s</name>-&gt;<name>port</name></name> = <name><name>s</name>-&gt;<name>addrs</name>-&gt;<name>host_port</name></name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro><macro><name>ap_set_name_virtual_host</name><argument_list>(<argument>cmd_parms *cmd</argument>,
                                                        <argument>void *dummy</argument>,
                                                        <argument>const char *arg</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>warnonce</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>++<name>warnonce</name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name>|<name>APLOG_STARTUP</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00548</expr></argument>)</argument_list></call>
                     "NameVirtualHost has no effect and will be removed in the "
                     "next release %s:%d"</expr></argument>,
                     <argument><expr><name><name>cmd</name>-&gt;<name>directive</name>-&gt;<name>filename</name></name></expr></argument>,
                     <argument><expr><name><name>cmd</name>-&gt;<name>directive</name>-&gt;<name>line_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block>


<comment type="block">/* hash table statistics, keep this in here for the beta period so
 * we can find out if the hash function is ok
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPHASH_STATISTICS</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>iphash_compare</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(*(const <name>int</name> *) <name>b</name> - *(const <name>int</name> *) <name>a</name>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_iphash_statistics</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>main_s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name><name>count</name><index>[<expr><name>IPHASH_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>src</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>total</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>HUGE_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>total</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>IPHASH_TABLE_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name><name>count</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <for>for (<init><expr><name>src</name> = <name><name>iphash_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>src</name></expr>;</condition> <incr><expr><name>src</name> = <name><name>src</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <expr_stmt><expr>++<name><name>count</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>i</name> &lt; <name>IPHASH_TABLE_SIZE</name></expr>)</condition><then> <block>{
                <comment type="block">/* don't count the slop buckets in the total */</comment>
                <expr_stmt><expr>++<name>total</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></for>
    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>IPHASH_TABLE_SIZE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>count</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>iphash_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <name>buf</name> + <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                           <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03235</expr></argument>)</argument_list></call> "iphash: total hashed = %u, avg chain = %u, "
                           "chain lengths (count x len):"</expr></argument>,
                           <argument><expr><name>total</name></expr></argument>, <argument><expr><name>total</name> / <name>IPHASH_TABLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>total</name> = 1</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>IPHASH_TABLE_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>count</name><index>[<expr><name>i</name> - 1</expr>]</index></name> != <name><name>count</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>p</name> += <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - (<name>p</name> - <name>buf</name>)</expr></argument>, <argument><expr>" %ux%u"</expr></argument>,
                              <argument><expr><name>total</name></expr></argument>, <argument><expr><name><name>count</name><index>[<expr><name>i</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>total</name> = 1</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>total</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr><name>p</name> += <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - (<name>p</name> - <name>buf</name>)</expr></argument>, <argument><expr>" %ux%u"</expr></argument>,
                      <argument><expr><name>total</name></expr></argument>, <argument><expr><name><name>count</name><index>[<expr><name>IPHASH_TABLE_SIZE</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Intentional no APLOGNO */</comment>
    <comment type="block">/* buf provides APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>main_s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* This hashing function is designed to get good distribution in the cases
 * where the server is handling entire "networks" of servers.  i.e. a
 * whack of /24s.  This is probably the most common configuration for
 * ISPs with large virtual servers.
 *
 * NOTE: This function is symmetric (i.e. collapses all 4 octets
 * into one), so machine byte order (big/little endianness) does not matter.
 *
 * Hash function provided by David Hankins.
 */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>unsigned</name></type> <name>hash_inaddr</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>key</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>key</name> ^= (<name>key</name> &gt;&gt; 16)</expr>;</expr_stmt>
    <return>return <expr>((<name>key</name> &gt;&gt; 8) ^ <name>key</name>) % <name>IPHASH_TABLE_SIZE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>unsigned</name></type> <name>hash_addr</name><parameter_list>(<param><decl><type>struct <name>apr_sockaddr_t</name> *</type><name>sa</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>key</name></decl>;</decl_stmt>

    <comment type="block">/* The key is the last four bytes of the IP address.
     * For IPv4, this is the entire address, as always.
     * For IPv6, this is usually part of the MAC address.
     */</comment>
    <expr_stmt><expr><name>key</name> = *<call>(<name>unsigned</name> *)<argument_list>(<argument><expr>(<name>char</name> *)<name><name>sa</name>-&gt;<name>ipaddr_ptr</name></name> + <name><name>sa</name>-&gt;<name>ipaddr_len</name></name> - 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>hash_inaddr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ipaddr_chain</name> *</type><name>new_ipaddr_chain</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                      <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>new</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>new</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>names</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>initialnames</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>server</name></name> = <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>sar</name></name> = <name>sar</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>new</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>name_chain</name> *</type><name>new_name_chain</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                  <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>name_chain</name> *</type><name>new</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>new</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>server</name></name> = <name>s</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>sar</name></name> = <name>sar</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>new</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>ipaddr_chain</name> *</type><name>find_ipaddr</name><parameter_list>(<param><decl><type><name>apr_sockaddr_t</name> *</type><name>sa</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>trav</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>wild_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* scan the hash table for an exact match first */</comment>
    <expr_stmt><expr><name>bucket</name> = <call><name>hash_addr</name><argument_list>(<argument><expr><name>sa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>trav</name> = <name><name>iphash_table</name><index>[<expr><name>bucket</name></expr>]</index></name></expr>;</init> <condition><expr><name>trav</name></expr>;</condition> <incr><expr><name>trav</name> = <name><name>trav</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name> <init>= <expr><name><name>trav</name>-&gt;<name>sar</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>cur</name> <init>= <expr><name><name>sar</name>-&gt;<name>host_addr</name></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>cur</name>-&gt;<name>port</name></name> == <name><name>sa</name>-&gt;<name>port</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>apr_sockaddr_equal</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>sa</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>trav</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>wild_match</name> == <name>NULL</name> &amp;&amp; (<name><name>cur</name>-&gt;<name>port</name></name> == 0 || <name><name>sa</name>-&gt;<name>port</name></name> == 0)</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>apr_sockaddr_equal</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name>sa</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* don't break, continue looking for an exact match */</comment>
                <expr_stmt><expr><name>wild_match</name> = <name>trav</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></for>
    <return>return <expr><name>wild_match</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>ipaddr_chain</name> *</type><name>find_default_server</name><parameter_list>(<param><decl><type><name>apr_port_t</name></type> <name>port</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>trav</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>wild_match</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>trav</name> = <name>default_list</name></expr>;</init> <condition><expr><name>trav</name></expr>;</condition> <incr><expr><name>trav</name> = <name><name>trav</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <expr_stmt><expr><name>sar</name> = <name><name>trav</name>-&gt;<name>sar</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>sar</name>-&gt;<name>host_port</name></name> == <name>port</name></expr>)</condition><then> <block>{
            <comment type="block">/* match! */</comment>
            <return>return <expr><name>trav</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>wild_match</name> == <name>NULL</name> &amp;&amp; <name><name>sar</name>-&gt;<name>host_port</name></name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* don't break, continue looking for an exact match */</comment>
            <expr_stmt><expr><name>wild_match</name> = <name>trav</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
    <return>return <expr><name>wild_match</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_IPV6</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_IN6_ANYADDR</name><parameter_list>(<param><type><name>ad</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((ad)-&gt;family == APR_INET6                   \
                            &amp;&amp; IN6_IS_ADDR_UNSPECIFIED(&amp;(ad)-&gt;sa.sin6.sin6_addr))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_IN6_ANYADDR</name><parameter_list>(<param><type><name>ad</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_a_vhost</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>ipaddr_chain</name> *</type><name>ic</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>name_chain</name> *</type><name>nc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>ha</name> <init>= <expr><name><name>ic</name>-&gt;<name>sar</name>-&gt;<name>host_addr</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name><name>ha</name>-&gt;<name>family</name></name> == <name>APR_INET</name> &amp;&amp; <name><name>ha</name>-&gt;<name>sa</name>.<name>sin</name>.<name>sin_addr</name>.<name>s_addr</name></name> == <name>INADDR_ANY</name>)
        || <call><name>IS_IN6_ANYADDR</name><argument_list>(<argument><expr><name>ha</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>len</name> = <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"*:%u"</expr></argument>,
                           <argument><expr><name><name>ic</name>-&gt;<name>sar</name>-&gt;<name>host_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>len</name> = <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%pI"</expr></argument>, <argument><expr><name>ha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr><name><name>ic</name>-&gt;<name>sar</name>-&gt;<name>host_port</name></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>-1</expr>]</index></name> = '*'</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>ic</name>-&gt;<name>names</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"%-22s %s (%s:%u)\n"</expr></argument>, <argument><expr><name>buf</name></expr></argument>,
                        <argument><expr><name><name>ic</name>-&gt;<name>server</name>-&gt;<name>server_hostname</name></name></expr></argument>,
                        <argument><expr><name><name>ic</name>-&gt;<name>server</name>-&gt;<name>defn_name</name></name></expr></argument>, <argument><expr><name><name>ic</name>-&gt;<name>server</name>-&gt;<name>defn_line_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"%-22s is a NameVirtualHost\n"
                    "%8s default server %s (%s:%u)\n"</expr></argument>,
                    <argument><expr><name>buf</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name><name>ic</name>-&gt;<name>server</name>-&gt;<name>server_hostname</name></name></expr></argument>,
                    <argument><expr><name><name>ic</name>-&gt;<name>server</name>-&gt;<name>defn_name</name></name></expr></argument>, <argument><expr><name><name>ic</name>-&gt;<name>server</name>-&gt;<name>defn_line_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>nc</name> = <name><name>ic</name>-&gt;<name>names</name></name></expr>;</init> <condition><expr><name>nc</name></expr>;</condition> <incr><expr><name>nc</name> = <name><name>nc</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>nc</name>-&gt;<name>sar</name>-&gt;<name>host_port</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"%8s port %u "</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name><name>nc</name>-&gt;<name>sar</name>-&gt;<name>host_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"%8s port * "</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"namevhost %s (%s:%u)\n"</expr></argument>,
                        <argument><expr><name><name>nc</name>-&gt;<name>server</name>-&gt;<name>server_hostname</name></name></expr></argument>,
                        <argument><expr><name><name>nc</name>-&gt;<name>server</name>-&gt;<name>defn_name</name></name></expr></argument>, <argument><expr><name><name>nc</name>-&gt;<name>server</name>-&gt;<name>defn_line_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>nc</name>-&gt;<name>server</name>-&gt;<name>names</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>names</name> <init>= <expr><name><name>nc</name>-&gt;<name>server</name>-&gt;<name>names</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> **</type><name>name</name> <init>= <expr>(<name>char</name> **)<name><name>names</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>names</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"%16s alias %s\n"</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>nc</name>-&gt;<name>server</name>-&gt;<name>wild_names</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>names</name> <init>= <expr><name><name>nc</name>-&gt;<name>server</name>-&gt;<name>wild_names</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> **</type><name>name</name> <init>= <expr>(<name>char</name> **)<name><name>names</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>names</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <if>if <condition>(<expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"%16s wild alias %s\n"</expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dump_vhost_config</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>ic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"VirtualHost configuration:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* non-wildcard servers */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>IPHASH_TABLE_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <for>for (<init><expr><name>ic</name> = <name><name>iphash_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</init> <condition><expr><name>ic</name></expr>;</condition> <incr><expr><name>ic</name> = <name><name>ic</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>dump_a_vhost</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></for>

    <comment type="block">/* wildcard servers */</comment>
    <for>for (<init><expr><name>ic</name> = <name>default_list</name></expr>;</init> <condition><expr><name>ic</name></expr>;</condition> <incr><expr><name>ic</name> = <name><name>ic</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>dump_a_vhost</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>


<comment type="block">/*
 * When a second or later virtual host maps to the same IP chain,
 * add the relevant server names to the chain.  Special care is taken
 * to avoid adding ic-&gt;names until we're sure there are multiple VH'es.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_name_vhost_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>main_s</name></decl></param>,
                                 <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl></param>,
                                 <param><decl><type><name>ipaddr_chain</name> *</type><name>ic</name></decl></param>)</parameter_list>
<block>{

   <decl_stmt><decl><type><name>name_chain</name> *</type><name>nc</name> <init>= <expr><call><name>new_name_chain</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name><name>nc</name>-&gt;<name>next</name></name> = <name><name>ic</name>-&gt;<name>names</name></name></expr>;</expr_stmt>

   <comment type="block">/* iterating backwards, so each one we see becomes the current default server */</comment>
   <expr_stmt><expr><name><name>ic</name>-&gt;<name>server</name></name> = <name>s</name></expr>;</expr_stmt>

   <if>if <condition>(<expr><name><name>ic</name>-&gt;<name>names</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
       <if>if <condition>(<expr><name><name>ic</name>-&gt;<name>initialnames</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
           <comment type="block">/* first pass, set these names aside in case we see another VH.
            * Until then, this looks like an IP-based VH to runtime.
            */</comment>
           <expr_stmt><expr><name><name>ic</name>-&gt;<name>initialnames</name></name> = <name>nc</name></expr>;</expr_stmt>
       }</block></then>
       <else>else <block>{
           <comment type="block">/* second pass through this chain -- this really is an NVH, and we
            * have two sets of names to link in.
            */</comment>
           <expr_stmt><expr><name><name>nc</name>-&gt;<name>next</name></name> = <name><name>ic</name>-&gt;<name>initialnames</name></name></expr>;</expr_stmt>
           <expr_stmt><expr><name><name>ic</name>-&gt;<name>names</name></name> = <name>nc</name></expr>;</expr_stmt>
           <expr_stmt><expr><name><name>ic</name>-&gt;<name>initialnames</name></name> = <name>NULL</name></expr>;</expr_stmt>
       }</block></else></if>
   }</block></then>
   <else>else <block>{
       <comment type="block">/* 3rd or more -- just keep stacking the names */</comment>
       <expr_stmt><expr><name><name>ic</name>-&gt;<name>names</name></name> = <name>nc</name></expr>;</expr_stmt>
   }</block></else></if>
}</block></function>

<comment type="block">/* compile the tables and such we need to do the run-time vhost lookups */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_fini_vhost_config</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>server_rec *main_s</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>has_default_vhost_addr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ipaddr_chain</name> **</type><name><name>iphash_table_tail</name><index>[<expr><name>IPHASH_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Main host first */</comment>
    <expr_stmt><expr><name>s</name> = <name>main_s</name></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>s</name>-&gt;<name>server_hostname</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>s</name>-&gt;<name>server_hostname</name></name> = <call><name>ap_get_local_host</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* initialize the tails */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>IPHASH_TABLE_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name><name>iphash_table_tail</name><index>[<expr><name>i</name></expr>]</index></name> = &amp;<name><name>iphash_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* The next things to go into the hash table are the virtual hosts
     * themselves.  They're listed off of main_s-&gt;next in the reverse
     * order they occurred in the config file, so we insert them at
     * the iphash_table_tail but don't advance the tail.
     */</comment>

    <for>for (<init><expr><name>s</name> = <name><name>main_s</name>-&gt;<name>next</name></name></expr>;</init> <condition><expr><name>s</name></expr>;</condition> <incr><expr><name>s</name> = <name><name>s</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar_prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>has_default_vhost_addr</name> = 0</expr>;</expr_stmt>
        <for>for (<init><expr><name>sar</name> = <name><name>s</name>-&gt;<name>addrs</name></name></expr>;</init> <condition><expr><name>sar</name></expr>;</condition> <incr><expr><name>sar</name> = <name><name>sar</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>ic</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name><name>inaddr_any</name><index>[<expr>16</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* big enough to handle IPv4 or IPv6 */</comment>
            <comment type="block">/* XXX: this treats 0.0.0.0 as a "default" server which matches no-exact-match for IPv6 */</comment>
            <if>if <condition>(<expr>!<call><name>memcmp</name><argument_list>(<argument><expr><name><name>sar</name>-&gt;<name>host_addr</name>-&gt;<name>ipaddr_ptr</name></name></expr></argument>, <argument><expr><name>inaddr_any</name></expr></argument>, <argument><expr><name><name>sar</name>-&gt;<name>host_addr</name>-&gt;<name>ipaddr_len</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>ic</name> = <call><name>find_default_server</name><argument_list>(<argument><expr><name><name>sar</name>-&gt;<name>host_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>ic</name> &amp;&amp; <name><name>sar</name>-&gt;<name>host_port</name></name> == <name><name>ic</name>-&gt;<name>sar</name>-&gt;<name>host_port</name></name></expr>)</condition><then> <block>{ <comment type="block">/* we're a match for an existing "default server"  */</comment>
                    <if>if <condition>(<expr>!<name>sar_prev</name> || <call><name>memcmp</name><argument_list>(<argument><expr><name><name>sar_prev</name>-&gt;<name>host_addr</name>-&gt;<name>ipaddr_ptr</name></name></expr></argument>, <argument><expr><name>inaddr_any</name></expr></argument>, <argument><expr><name><name>sar_prev</name>-&gt;<name>host_addr</name>-&gt;<name>ipaddr_len</name></name></expr></argument>)</argument_list></call>
                                  || <name><name>sar_prev</name>-&gt;<name>host_port</name></name> != <name><name>sar</name>-&gt;<name>host_port</name></name></expr>)</condition><then> <block>{ 
                        <expr_stmt><expr><call><name>add_name_vhost_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>main_s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sar</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then>
                <else>else <block>{ 
                    <comment type="block">/* No default server, or we found a default server but
                    ** exactly one of us is a wildcard port, which means we want
                    ** two ip-based vhosts not an NVH with two names
                    */</comment>
                    <expr_stmt><expr><name>ic</name> = <call><name>new_ipaddr_chain</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ic</name>-&gt;<name>next</name></name> = <name>default_list</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>default_list</name> = <name>ic</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>add_name_vhost_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>main_s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sar</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
                <expr_stmt><expr><name>has_default_vhost_addr</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* see if it matches something we've already got */</comment>
                <expr_stmt><expr><name>ic</name> = <call><name>find_ipaddr</name><argument_list>(<argument><expr><name><name>sar</name>-&gt;<name>host_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr>!<name>ic</name> || <name><name>sar</name>-&gt;<name>host_port</name></name> != <name><name>ic</name>-&gt;<name>sar</name>-&gt;<name>host_port</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/* No matching server, or we found a matching server but
                    ** exactly one of us is a wildcard port, which means we want
                    ** two ip-based vhosts not an NVH with two names
                    */</comment>
                    <decl_stmt><decl><type><name>unsigned</name></type> <name>bucket</name> <init>= <expr><call><name>hash_addr</name><argument_list>(<argument><expr><name><name>sar</name>-&gt;<name>host_addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>ic</name> = <call><name>new_ipaddr_chain</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ic</name>-&gt;<name>next</name></name> = *<name><name>iphash_table_tail</name><index>[<expr><name>bucket</name></expr>]</index></name></expr>;</expr_stmt>
                    <expr_stmt><expr>*<name><name>iphash_table_tail</name><index>[<expr><name>bucket</name></expr>]</index></name> = <name>ic</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>add_name_vhost_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>main_s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>sar</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>sar_prev</name> = <name>sar</name></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/* Ok now we want to set up a server_hostname if the user was
         * silly enough to forget one.
         * XXX: This is silly we should just crash and burn.
         */</comment>
        <if>if <condition>(<expr>!<name><name>s</name>-&gt;<name>server_hostname</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>has_default_vhost_addr</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>s</name>-&gt;<name>server_hostname</name></name> = <name><name>main_s</name>-&gt;<name>server_hostname</name></name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<name><name>s</name>-&gt;<name>addrs</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* what else can we do?  at this point this vhost has
                    no configured name, probably because they used
                    DNS in the VirtualHost statement.  It's disabled
                    anyhow by the host matching code.  -djg */</comment>
                <expr_stmt><expr><name><name>s</name>-&gt;<name>server_hostname</name></name> =
                    <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"bogus_host_without_forward_dns"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> *</type><name>hostname</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rv</name> = <call><name>apr_getnameinfo</name><argument_list>(<argument><expr>&amp;<name>hostname</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>addrs</name>-&gt;<name>host_addr</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>s</name>-&gt;<name>server_hostname</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <comment type="block">/* again, what can we do?  They didn't specify a
                       ServerName, and their DNS isn't working. -djg */</comment>
                    <decl_stmt><decl><type><name>char</name> *</type><name>ipaddr_str</name></decl>;</decl_stmt>

                    <expr_stmt><expr><call><name>apr_sockaddr_ip_get</name><argument_list>(<argument><expr>&amp;<name>ipaddr_str</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>addrs</name>-&gt;<name>host_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>main_s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00549</expr></argument>)</argument_list></call>
                                 "Failed to resolve server name "
                                 "for %s (check DNS) -- or specify an explicit "
                                 "ServerName"</expr></argument>,
                                 <argument><expr><name>ipaddr_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>s</name>-&gt;<name>server_hostname</name></name> =
                        <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"bogus_host_without_reverse_dns"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if></else></if>
        }</block></then></if>
    }</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IPHASH_STATISTICS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>dump_iphash_statistics</name><argument_list>(<argument><expr><name>main_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"DUMP_VHOSTS"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>thefile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>apr_file_open_stdout</name><argument_list>(<argument><expr>&amp;<name>thefile</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dump_vhost_config</name><argument_list>(<argument><expr><name>thefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vhost_check_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>config_error</name> ? !<name>OK</name> : <name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*****************************************************************************
 * run-time vhost matching functions
 */</comment>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fix_hostname_v6_literal</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>host</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>dst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>double_colon</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>dst</name> = <name>host</name></expr>;</init> <condition><expr>*<name>dst</name></expr>;</condition> <incr><expr><name>dst</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>apr_isxdigit</name><argument_list>(<argument><expr>*<name>dst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>apr_isupper</name><argument_list>(<argument><expr>*<name>dst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>dst</name> = <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>dst</name> == ':'</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>*(<name>dst</name> + 1) == ':'</expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>double_colon</name></expr>)</condition><then>
                    <return>return <expr><name>APR_EINVAL</name></expr>;</return></then></if>
                <expr_stmt><expr><name>double_colon</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>*(<name>dst</name> + 1) == '.'</expr>)</condition><then> <block>{
                <return>return <expr><name>APR_EINVAL</name></expr>;</return>
            }</block></then></if></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>dst</name> == '.'</expr>)</condition><then> <block>{
            <comment type="block">/* For IPv4-mapped IPv6 addresses like ::FFFF:129.144.52.38 */</comment>
            <if>if <condition>(<expr>*(<name>dst</name> + 1) == ':' || *(<name>dst</name> + 1) == '.'</expr>)</condition><then>
                <return>return <expr><name>APR_EINVAL</name></expr>;</return></then></if>
        }</block></then>
        <else>else <block>{
            <return>return <expr><name>APR_EINVAL</name></expr>;</return>
        }</block></else></if></else></if></else></if>
    }</block></for>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>fix_hostname_non_v6</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>host</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>dst</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>dst</name> = <name>host</name></expr>;</init> <condition><expr>*<name>dst</name></expr>;</condition> <incr><expr><name>dst</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>apr_islower</name><argument_list>(<argument><expr>*<name>dst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* leave char unchanged */</comment>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>dst</name> == '.'</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>*(<name>dst</name> + 1) == '.'</expr>)</condition><then> <block>{
                <return>return <expr><name>APR_EINVAL</name></expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>apr_isupper</name><argument_list>(<argument><expr>*<name>dst</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>dst</name> = <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>dst</name> == '/' || *<name>dst</name> == '\\'</expr>)</condition><then> <block>{
            <return>return <expr><name>APR_EINVAL</name></expr>;</return>
        }</block></then></if></else></if></else></if></else></if>
    }</block></for>
    <comment type="block">/* strip trailing gubbins */</comment>
    <if>if <condition>(<expr><name>dst</name> &gt; <name>host</name> &amp;&amp; <name><name>dst</name><index>[<expr>-1</expr>]</index></name> == '.'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>dst</name><index>[<expr>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * If strict mode ever becomes the default, this should be folded into
 * fix_hostname_non_v6()
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>strict_hostname_check</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>host</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>ch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_dotted_decimal</name> <init>= <expr>1</expr></init>, <name>leading_zeroes</name> <init>= <expr>0</expr></init>, <name>dots</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>ch</name> = <name>host</name></expr>;</init> <condition><expr>*<name>ch</name></expr>;</condition> <incr><expr><name>ch</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>apr_isalpha</name><argument_list>(<argument><expr>*<name>ch</name></expr></argument>)</argument_list></call> || *<name>ch</name> == '-'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>is_dotted_decimal</name> = 0</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>ch</name><index>[<expr>0</expr>]</index></name> == '.'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>dots</name>++</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>ch</name><index>[<expr>1</expr>]</index></name> == '0' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>ch</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>leading_zeroes</name> = 1</expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
           <comment type="block">/* also takes care of multiple Host headers by denying commas */</comment>
            <goto>goto <name>bad</name>;</goto>
        }</block></then></if></else></if></else></if>
    }</block></for>
    <if>if <condition>(<expr><name>is_dotted_decimal</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>host</name><index>[<expr>0</expr>]</index></name> == '.' || (<name><name>host</name><index>[<expr>0</expr>]</index></name> == '0' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>host</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <expr_stmt><expr><name>leading_zeroes</name> = 1</expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>leading_zeroes</name> || <name>dots</name> != 3</expr>)</condition><then> <block>{
            <comment type="block">/* RFC 3986 7.4 */</comment>
            <goto>goto <name>bad</name>;</goto>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* The top-level domain must start with a letter (RFC 1123 2.1) */</comment>
        <while>while <condition>(<expr><name>ch</name> &gt; <name>host</name> &amp;&amp; *<name>ch</name> != '.'</expr>)</condition>
            <expr_stmt><expr><name>ch</name>--</expr>;</expr_stmt></while>
        <if>if <condition>(<expr><name><name>ch</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <name><name>ch</name><index>[<expr>1</expr>]</index></name> != '\0' &amp;&amp; !<call><name>apr_isalpha</name><argument_list>(<argument><expr><name><name>ch</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <goto>goto <name>bad</name>;</goto></then></if>
    }</block></else></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>

<label><name>bad</name>:</label>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02415</expr></argument>)</argument_list></call>
                  "[strict] Invalid host name '%s'%s%.6s"</expr></argument>,
                  <argument><expr><name>host</name></expr></argument>, <argument><expr>*<name>ch</name> ? ", problem near: " : ""</expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>APR_EINVAL</name></expr>;</return>
}</block></function>

<comment type="block">/* Lowercase and remove any trailing dot and/or :port from the hostname,
 * and check that it is sane.
 *
 * In most configurations the exact syntax of the hostname isn't
 * important so strict sanity checking isn't necessary. However, in
 * mass hosting setups (using mod_vhost_alias or mod_rewrite) where
 * the hostname is interpolated into the filename, we need to be sure
 * that the interpolation doesn't expose parts of the filesystem.
 * We don't do strict RFC 952 / RFC 1123 syntax checking in order
 * to support iDNS and people who erroneously use underscores.
 * Instead we just check for filesystem metacharacters: directory
 * separators / and \ and sequences of more than one dot.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fix_hostname</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host_header</name></decl></param>,
                        <param><decl><type><name>unsigned</name></type> <name>http_conformance</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>host</name></decl>, *<decl><type ref="prev"/><name>scope_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_v6literal</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>strict</name> <init>= <expr>(<name>http_conformance</name> != <name>AP_HTTP_CONFORMANCE_UNSAFE</name>)</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>src</name> = <name>host_header</name> ? <name>host_header</name> : <name><name>r</name>-&gt;<name>hostname</name></name></expr>;</expr_stmt>

    <comment type="block">/* According to RFC 2616, Host header field CAN be blank */</comment>
    <if>if <condition>(<expr>!*<name>src</name></expr>)</condition><then> <block>{
        <return>return <expr><name>is_v6literal</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* apr_parse_addr_port will interpret a bare integer as a port
     * which is incorrect in this context.  So treat it separately.
     */</comment>
    <for>for (<init><expr><name>c</name> = <name>src</name></expr>;</init> <condition><expr><call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>c</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>c</name></expr></incr>)<empty_stmt>;</empty_stmt></for>
    <if>if <condition>(<expr>!*<name>c</name></expr>)</condition><then> <block>{
        <comment type="block">/* pure integer */</comment>
        <if>if <condition>(<expr><name>strict</name></expr>)</condition><then> <block>{
            <comment type="block">/* RFC 3986 7.4 */</comment>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02416</expr></argument>)</argument_list></call>
                         "[strict] purely numeric host names not allowed: %s"</expr></argument>,
                         <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>bad_nolog</name>;</goto>
        }</block></then></if>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>hostname</name></name> = <name>src</name></expr>;</expr_stmt>
        <return>return <expr><name>is_v6literal</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>host_header</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_parse_addr_port</name><argument_list>(<argument><expr>&amp;<name>host</name></expr></argument>, <argument><expr>&amp;<name>scope_id</name></expr></argument>, <argument><expr>&amp;<name>port</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name> || <name>scope_id</name></expr>)</condition><then>
            <goto>goto <name>bad</name>;</goto></then></if>
        <if>if <condition>(<expr><name>port</name></expr>)</condition><then> <block>{
            <comment type="block">/* Don't throw the Host: header's port number away:
               save it in parsed_uri -- ap_get_server_port() needs it! */</comment>
            <comment type="block">/* @@@ XXX there should be a better way to pass the port.
             *         Like r-&gt;hostname, there should be a r-&gt;portno
             */</comment>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>parsed_uri</name>.<name>port</name></name> = <name>port</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>parsed_uri</name>.<name>port_str</name></name> = <call><name>apr_itoa</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>(<name>int</name>)<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>host_header</name><index>[<expr>0</expr>]</index></name> == '['</expr>)</condition><then>
            <expr_stmt><expr><name>is_v6literal</name> = 1</expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <block>{
        <comment type="block">/*
         * Already parsed, surrounding [ ] (if IPv6 literal) and :port have
         * already been removed.
         */</comment>
        <expr_stmt><expr><name>host</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>hostname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>ap_strchr</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name>is_v6literal</name> = 1</expr>;</expr_stmt></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><name>is_v6literal</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>fix_hostname_v6_literal</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>fix_hostname_non_v6</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>strict</name> &amp;&amp; <name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
            <expr_stmt><expr><name>rv</name> = <call><name>strict_hostname_check</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <goto>goto <name>bad</name>;</goto></then></if>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>hostname</name></name> = <name>host</name></expr>;</expr_stmt>
    <return>return <expr><name>is_v6literal</name></expr>;</return>

<label><name>bad</name>:</label>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00550</expr></argument>)</argument_list></call>
                  "Client sent malformed Host header: %s"</expr></argument>,
                  <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>bad_nolog</name>:</label>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
    <return>return <expr><name>is_v6literal</name></expr>;</return>
}</block></function>

<comment type="block">/* return 1 if host matches ServerName or ServerAliases */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>matches_aliases</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>names</name></decl>;</decl_stmt>

    <comment type="block">/* match ServerName */</comment>
    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>server_hostname</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* search all the aliases from ServerAlias directive */</comment>
    <expr_stmt><expr><name>names</name> = <name><name>s</name>-&gt;<name>names</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>names</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> **</type><name>name</name> <init>= <expr>(<name>char</name> **) <name><name>names</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>names</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <continue>continue;</continue></then></if>
            <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>1</expr>;</return></then></if>
        }</block></for>
    }</block></then></if>
    <expr_stmt><expr><name>names</name> = <name><name>s</name>-&gt;<name>wild_names</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>names</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> **</type><name>name</name> <init>= <expr>(<name>char</name> **) <name><name>names</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>names</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <continue>continue;</continue></then></if>
            <if>if <condition>(<expr>!<call><name>ap_strcasecmp_match</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <return>return <expr>1</expr>;</return></then></if>
        }</block></for>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Suppose a request came in on the same socket as this r, and included
 * a header "Host: host:port", would it map to r-&gt;server?  It's more
 * than just that though.  When we do the normal matches for each request
 * we don't even bother considering Host: etc on non-namevirtualhosts,
 * we just call it a match.  But here we require the host:port to match
 * the ServerName and/or ServerAliases.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_matches_request_vhost</name><argument_list>(<argument>request_rec *r</argument>, <argument>const char *host</argument>,
                                         <argument>apr_port_t port</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = <name><name>r</name>-&gt;<name>server</name></name></expr>;</expr_stmt>

    <comment type="block">/* search all the &lt;VirtualHost&gt; values */</comment>
    <comment type="block">/* XXX: If this is a NameVirtualHost then we may not be doing the Right Thing
     * consider:
     *
     *     NameVirtualHost 10.1.1.1
     *     &lt;VirtualHost 10.1.1.1&gt;
     *     ServerName v1
     *     &lt;/VirtualHost&gt;
     *     &lt;VirtualHost 10.1.1.1&gt;
     *     ServerName v2
     *     &lt;/VirtualHost&gt;
     *
     * Suppose r-&gt;server is v2, and we're asked to match "10.1.1.1".  We'll say
     * "yup it's v2", when really it isn't... if a request came in for 10.1.1.1
     * it would really go to v1.
     */</comment>
    <for>for (<init><expr><name>sar</name> = <name><name>s</name>-&gt;<name>addrs</name></name></expr>;</init> <condition><expr><name>sar</name></expr>;</condition> <incr><expr><name>sar</name> = <name><name>sar</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr>(<name><name>sar</name>-&gt;<name>host_port</name></name> == 0 || <name>port</name> == <name><name>sar</name>-&gt;<name>host_port</name></name>)
            &amp;&amp; !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name><name>sar</name>-&gt;<name>virthost</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* the Port has to match now, because the rest don't have ports associated
     * with them. */</comment>
    <if>if <condition>(<expr><name>port</name> != <name><name>s</name>-&gt;<name>port</name></name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>matches_aliases</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<function><type><specifier>static</specifier> <name>void</name></type> <name>check_hostalias</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Even if the request has a Host: header containing a port we ignore
     * that port.  We always use the physical port of the socket.  There
     * are a few reasons for this:
     *
     * - the default of 80 or 443 for SSL is easier to handle this way
     * - there is less of a possibility of a security problem
     * - it simplifies the data structure
     * - the client may have no idea that a proxy somewhere along the way
     *   translated the request to another ip:port
     * - except for the addresses from the VirtualHost line, none of the other
     *   names we'll match have ports associated with them
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host</name> <init>= <expr><name><name>r</name>-&gt;<name>hostname</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>virthost_s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>last_s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>name_chain</name> *</type><name>src</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>virthost_s</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>last_s</name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>port</name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>local_addr</name>-&gt;<name>port</name></name></expr>;</expr_stmt>

    <comment type="block">/* Recall that the name_chain is a list of server_addr_recs, some of
     * whose ports may not match.  Also each server may appear more than
     * once in the chain -- specifically, it will appear once for each
     * address from its VirtualHost line which matched.  We only want to
     * do the full ServerName/ServerAlias comparisons once for each
     * server, fortunately we know that all the VirtualHost addresses for
     * a single server are adjacent to each other.
     */</comment>

    <for>for (<init><expr><name>src</name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>vhost_lookup_data</name></name></expr>;</init> <condition><expr><name>src</name></expr>;</condition> <incr><expr><name>src</name> = <name><name>src</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl>;</decl_stmt>

        <comment type="block">/* We only consider addresses on the name_chain which have a matching
         * port
         */</comment>
        <expr_stmt><expr><name>sar</name> = <name><name>src</name>-&gt;<name>sar</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>sar</name>-&gt;<name>host_port</name></name> != 0 &amp;&amp; <name>port</name> != <name><name>sar</name>-&gt;<name>host_port</name></name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><name>s</name> = <name><name>src</name>-&gt;<name>server</name></name></expr>;</expr_stmt>

        <comment type="block">/* If we still need to do ServerName and ServerAlias checks for this
         * server, do them now.
         */</comment>
        <if>if <condition>(<expr><name>s</name> != <name>last_s</name></expr>)</condition><then> <block>{
            <comment type="block">/* does it match any ServerName or ServerAlias directive? */</comment>
            <if>if <condition>(<expr><call><name>matches_aliases</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <goto>goto <name>found</name>;</goto>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>last_s</name> = <name>s</name></expr>;</expr_stmt>

        <comment type="block">/* Fallback: does it match the virthost from the sar? */</comment>
        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>host</name></expr></argument>, <argument><expr><name><name>sar</name>-&gt;<name>virthost</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* only the first match is used */</comment>
            <if>if <condition>(<expr><name>virthost_s</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>virthost_s</name> = <name>s</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* If ServerName and ServerAlias check failed, we end up here.  If it
     * matches a VirtualHost, virthost_s is set. Use that as fallback
     */</comment>
    <if>if <condition>(<expr><name>virthost_s</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>s</name> = <name>virthost_s</name></expr>;</expr_stmt>
        <goto>goto <name>found</name>;</goto>
    }</block></then></if>

    <return>return;</return>

<label><name>found</name>:</label>
    <comment type="block">/* s is the first matching server, we're done */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>server</name></name> = <name>s</name></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>check_serverpath</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>last_s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>name_chain</name> *</type><name>src</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>port</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>port</name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>local_addr</name>-&gt;<name>port</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * This is in conjunction with the ServerPath code in http_core, so we
     * get the right host attached to a non- Host-sending request.
     *
     * See the comment in check_hostalias about how each vhost can be
     * listed multiple times.
     */</comment>

    <expr_stmt><expr><name>last_s</name> = <name>NULL</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>src</name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>vhost_lookup_data</name></name></expr>;</init> <condition><expr><name>src</name></expr>;</condition> <incr><expr><name>src</name> = <name><name>src</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <comment type="block">/* We only consider addresses on the name_chain which have a matching
         * port
         */</comment>
        <if>if <condition>(<expr><name><name>src</name>-&gt;<name>sar</name>-&gt;<name>host_port</name></name> != 0 &amp;&amp; <name>port</name> != <name><name>src</name>-&gt;<name>sar</name>-&gt;<name>host_port</name></name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><name>s</name> = <name><name>src</name>-&gt;<name>server</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>s</name> == <name>last_s</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>
        <expr_stmt><expr><name>last_s</name> = <name>s</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>path</name></name> &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>pathlen</name></name></expr></argument>)</argument_list></call> &amp;&amp;
            (<name><name>s</name>-&gt;<name>path</name><index>[<expr><name><name>s</name>-&gt;<name>pathlen</name></name> - 1</expr>]</index></name> == '/' ||
             <name><name>r</name>-&gt;<name>uri</name><index>[<expr><name><name>s</name>-&gt;<name>pathlen</name></name></expr>]</index></name> == '/' ||
             <name><name>r</name>-&gt;<name>uri</name><index>[<expr><name><name>s</name>-&gt;<name>pathlen</name></name></expr>]</index></name> == '\0')</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>server</name></name> = <name>s</name></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type><name>construct_host_header</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                                    <param><decl><type><name>int</name></type> <name>is_v6literal</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>iovec</name></type> <name><name>iov</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nvec</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <comment type="block">/*
     * We cannot use ap_get_server_name/port here, because we must
     * ignore UseCanonicalName/Port.
     */</comment>
    <if>if <condition>(<expr><name>is_v6literal</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_base</name> = "["</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_len</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>nvec</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name><name>r</name>-&gt;<name>hostname</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>hostname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nvec</name>++</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>is_v6literal</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_base</name> = "]"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_len</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>nvec</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>parsed_uri</name>.<name>port_str</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_base</name> = ":"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_len</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>nvec</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_base</name> = <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>port_str</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>iov</name><index>[<expr><name>nvec</name></expr>]</index></name>.<name>iov_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>parsed_uri</name>.<name>port_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>nvec</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><call><name>apr_pstrcatv</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>iov</name></expr></argument>, <argument><expr><name>nvec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_update_vhost_from_headers</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>host_header</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Host"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_v6literal</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>have_hostname_from_url</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>hostname</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If there was a host part in the Request-URI, ignore the 'Host'
         * header.
         */</comment>
        <expr_stmt><expr><name>have_hostname_from_url</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>is_v6literal</name> = <call><name>fix_hostname</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>http_conformance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>host_header</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>is_v6literal</name> = <call><name>fix_hostname</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>host_header</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>http_conformance</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>status</name></name> != <name>HTTP_OK</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>http_conformance</name></name> != <name>AP_HTTP_CONFORMANCE_UNSAFE</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If we have both hostname from an absoluteURI and a Host header,
         * we must ignore the Host header (RFC 2616 5.2).
         * To enforce this, we reset the Host header to the value from the
         * request line.
         */</comment>
        <if>if <condition>(<expr><name>have_hostname_from_url</name> &amp;&amp; <name>host_header</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repl</name> <init>= <expr><call><name>construct_host_header</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>is_v6literal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Host"</expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02417</expr></argument>)</argument_list></call>
                          "Replacing host header '%s' with host '%s' given "
                          "in the request uri"</expr></argument>, <argument><expr><name>host_header</name></expr></argument>, <argument><expr><name>repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* check if we tucked away a name_chain */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>vhost_lookup_data</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>hostname</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>check_hostalias</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>check_serverpath</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
}</block>

<comment type="block">/**
 * For every virtual host on this connection, call func_cb.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_vhost_iterate_given_conn</name><argument_list>(<argument>conn_rec *conn</argument>,
                                            <argument>ap_vhost_iterate_conn_cb func_cb</argument>,
                                            <argument>void* baton</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>last_s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>name_chain</name> *</type><name>src</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>conn</name>-&gt;<name>vhost_lookup_data</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>last_s</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>port</name> = <name><name>conn</name>-&gt;<name>local_addr</name>-&gt;<name>port</name></name></expr>;</expr_stmt>

        <for>for (<init><expr><name>src</name> = <name><name>conn</name>-&gt;<name>vhost_lookup_data</name></name></expr>;</init> <condition><expr><name>src</name></expr>;</condition> <incr><expr><name>src</name> = <name><name>src</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>server_addr_rec</name> *</type><name>sar</name></decl>;</decl_stmt>

            <comment type="block">/* We only consider addresses on the name_chain which have a
             * matching port.
             */</comment>
            <expr_stmt><expr><name>sar</name> = <name><name>src</name>-&gt;<name>sar</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>sar</name>-&gt;<name>host_port</name></name> != 0 &amp;&amp; <name>port</name> != <name><name>sar</name>-&gt;<name>host_port</name></name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name>s</name> = <name><name>src</name>-&gt;<name>server</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>s</name> == <name>last_s</name></expr>)</condition><then> <block>{
                <comment type="block">/* we've already done a callback for this vhost. */</comment>
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name>last_s</name> = <name>s</name></expr>;</expr_stmt>

            <expr_stmt><expr><name>rv</name> = <call><name>func_cb</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>rv</name> != 0</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
        }</block></for>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>func_cb</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>base_server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block>

<comment type="block">/* Called for a new connection which has a known local_addr.  Note that the
 * new connection is assumed to have conn-&gt;server == main server.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_update_vhost_given_ip</name><argument_list>(<argument>conn_rec *conn</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>ipaddr_chain</name> *</type><name>trav</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>port</name></decl>;</decl_stmt>

    <comment type="block">/* scan the hash table for an exact match first */</comment>
    <expr_stmt><expr><name>trav</name> = <call><name>find_ipaddr</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>local_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>trav</name></expr>)</condition><then> <block>{
        <comment type="block">/* save the name_chain for later in case this is a name-vhost */</comment>
        <expr_stmt><expr><name><name>conn</name>-&gt;<name>vhost_lookup_data</name></name> = <name><name>trav</name>-&gt;<name>names</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name>-&gt;<name>base_server</name></name> = <name><name>trav</name>-&gt;<name>server</name></name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* maybe there's a default server or wildcard name-based vhost
     * matching this port
     */</comment>
    <expr_stmt><expr><name>port</name> = <name><name>conn</name>-&gt;<name>local_addr</name>-&gt;<name>port</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>trav</name> = <call><name>find_default_server</name><argument_list>(<argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>trav</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>conn</name>-&gt;<name>vhost_lookup_data</name></name> = <name><name>trav</name>-&gt;<name>names</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conn</name>-&gt;<name>base_server</name></name> = <name><name>trav</name>-&gt;<name>server</name></name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* otherwise we're stuck with just the main server
     * and no name-based vhosts
     */</comment>
    <expr_stmt><expr><name><name>conn</name>-&gt;<name>vhost_lookup_data</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block>
</unit>
