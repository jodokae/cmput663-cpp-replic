<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/util_expr_private.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__AP_EXPR_PRIVATE_H__</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__AP_EXPR_PRIVATE_H__</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_expr.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_NULL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NULL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MIN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<param><type><name>a</name></type></param>,<param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((a)&lt;(b))?(a):(b))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NO_UNISTD_H</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<comment type="block">/* Avoid some warnings with Visual Studio (likely due to a bug in bison) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYMALLOC</name></cpp:macro> <cpp:value>malloc</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYFREE</name></cpp:macro>   <cpp:value>free</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YYDEBUG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYDEBUG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** The operations in a parse tree node */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>op_NOP</name></decl>,
    <decl><name>op_True</name></decl>, <decl><name>op_False</name></decl>,
    <decl><name>op_Not</name></decl>, <decl><name>op_Or</name></decl>, <decl><name>op_And</name></decl>,
    <decl><name>op_Comp</name></decl>,
    <decl><name>op_EQ</name></decl>, <decl><name>op_NE</name></decl>, <decl><name>op_LT</name></decl>, <decl><name>op_LE</name></decl>, <decl><name>op_GT</name></decl>, <decl><name>op_GE</name></decl>, <decl><name>op_IN</name></decl>,
    <decl><name>op_REG</name></decl>, <decl><name>op_NRE</name></decl>,
    <decl><name>op_STR_EQ</name></decl>, <decl><name>op_STR_NE</name></decl>, <decl><name>op_STR_LT</name></decl>, <decl><name>op_STR_LE</name></decl>, <decl><name>op_STR_GT</name></decl>, <decl><name>op_STR_GE</name></decl>,
    <decl><name>op_Concat</name></decl>,
    <decl><name>op_Digit</name></decl>, <decl><name>op_String</name></decl>, <decl><name>op_Regex</name></decl>, <decl><name>op_RegexBackref</name></decl>,
    <decl><name>op_Var</name></decl>,
    <decl><name>op_ListElement</name></decl>,
    <comment type="block">/*
     * call external functions/operators.
     * The info node contains the function pointer and some function specific
     * info.
     * For Binary operators, the Call node links to the Info node and the
     * Args node, which in turn links to the left and right operand.
     * For all other variants, the Call node links to the Info node and the
     * argument.
     */</comment>
    <decl><name>op_UnaryOpCall</name></decl>, <decl><name>op_UnaryOpInfo</name></decl>,
    <decl><name>op_BinaryOpCall</name></decl>, <decl><name>op_BinaryOpInfo</name></decl>, <decl><name>op_BinaryOpArgs</name></decl>,
    <decl><name>op_StringFuncCall</name></decl>, <decl><name>op_StringFuncInfo</name></decl>,
    <decl><name>op_ListFuncCall</name></decl>, <decl><name>op_ListFuncInfo</name></decl>
}</block></enum></type> <name>ap_expr_node_op_e</name>;</typedef>

<comment type="block">/** The basic parse tree node */</comment>
<struct>struct <name>ap_expr_node</name> <block>{
    <decl_stmt><decl><type><name>ap_expr_node_op_e</name></type> <name>node_op</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>node_arg1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>node_arg2</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/** The context used by scanner and parser */</comment>
<typedef>typedef <type><struct>struct <block>{
    <comment type="block">/* internal state of the scanner */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>        *</type><name>inputbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>inputlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>        *</type><name>inputptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>              *</type><name>scanner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>              *</type><name>scan_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>               <name><name>scan_buf</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>               <name>scan_del</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>                <name>at_start</name></decl>;</decl_stmt>

    <comment type="block">/* pools for result and temporary usage */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name>        *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name>        *</type><name>ptemp</name></decl>;</decl_stmt>

    <comment type="block">/* The created parse tree */</comment>
    <decl_stmt><decl><type><name>ap_expr_t</name>         *</type><name>expr</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>        *</type><name>error</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>        *</type><name>error2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type>           <name>flags</name></decl>;</decl_stmt>

    <comment type="block">/*
     * The function to use to lookup provider functions for variables
     * and funtctions
     */</comment>
    <decl_stmt><decl><type><name>ap_expr_lookup_fn_t</name> *</type><name>lookup_fn</name></decl>;</decl_stmt>
}</block></struct></type> <name>ap_expr_parse_ctx_t</name>;</typedef>

<comment type="block">/* flex/bison functions */</comment>
<function_decl><type><name>int</name></type>  <name>ap_expr_yyparse</name><parameter_list>(<param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>context</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyerror</name><parameter_list>(<param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>context</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>  <name>ap_expr_yylex_init</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>scanner</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type>  <name>ap_expr_yylex_destroy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>scanner</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyset_extra</name><parameter_list>(<param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>context</name></decl></param>, <param><decl><type><name>void</name> *</type><name>scanner</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* create a parse tree node */</comment>
<function_decl><type><name>ap_expr_t</name> *</type><name>ap_expr_make</name><parameter_list>(<param><decl><type><name>ap_expr_node_op_e</name></type> <name>op</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>arg1</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>arg2</name></decl></param>, <param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/* create parse tree node for the string-returning function 'name' */</comment>
<function_decl><type><name>ap_expr_t</name> *</type><name>ap_expr_str_func_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>,
                               <param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/* create parse tree node for the list-returning function 'name' */</comment>
<function_decl><type><name>ap_expr_t</name> *</type><name>ap_expr_list_func_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>,
                                <param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/* create parse tree node for the variable 'name' */</comment>
<function_decl><type><name>ap_expr_t</name> *</type><name>ap_expr_var_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/* create parse tree node for the unary operator 'name' */</comment>
<function_decl><type><name>ap_expr_t</name> *</type><name>ap_expr_unary_op_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg</name></decl></param>,
                               <param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/* create parse tree node for the binary operator 'name' */</comment>
<function_decl><type><name>ap_expr_t</name> *</type><name>ap_expr_binary_op_make</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg1</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>ap_expr_t</name> *</type><name>arg2</name></decl></param>,
                                  <param><decl><type><name>ap_expr_parse_ctx_t</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __AP_EXPR_PRIVATE_H__ */</comment>
<comment type="block">/** @} */</comment>

</unit>
