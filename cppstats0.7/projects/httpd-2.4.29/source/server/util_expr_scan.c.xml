<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/util_expr_scan.c"><cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>2</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>

<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>4</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>

<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>YY_INT_ALIGNED</name></cpp:macro> <cpp:value>short int</cpp:value></cpp:define>

<comment type="block">/* A lexical scanner generated by flex */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_SCANNER</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FLEX_MAJOR_VERSION</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FLEX_MINOR_VERSION</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FLEX_SUBMINOR_VERSION</name></cpp:macro> <cpp:value>35</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>YY_FLEX_SUBMINOR_VERSION</name> &gt; 0</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEX_BETA</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* First, we deal with  platform-specific or compiler-specific issues. */</comment>

<comment type="block">/* begin standard C headers. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<comment type="block">/* end standard C headers. */</comment>

<comment type="block">/* flex integer type definitions */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FLEXINT_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLEXINT_H</name></cpp:macro></cpp:define>

<comment type="block">/* C99 systems have &lt;inttypes.h&gt;. Non-C99 systems may or may not. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> &amp;&amp; <name>__STDC_VERSION__</name> &gt;= 199901L</expr></cpp:if>

<comment type="block">/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types. 
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__STDC_LIMIT_MACROS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__STDC_LIMIT_MACROS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<typedef>typedef <type><name>int8_t</name></type> <name>flex_int8_t</name>;</typedef>
<typedef>typedef <type><name>uint8_t</name></type> <name>flex_uint8_t</name>;</typedef>
<typedef>typedef <type><name>int16_t</name></type> <name>flex_int16_t</name>;</typedef>
<typedef>typedef <type><name>uint16_t</name></type> <name>flex_uint16_t</name>;</typedef>
<typedef>typedef <type><name>int32_t</name></type> <name>flex_int32_t</name>;</typedef>
<typedef>typedef <type><name>uint32_t</name></type> <name>flex_uint32_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>signed</name> <name>char</name></type> <name>flex_int8_t</name>;</typedef>
<typedef>typedef <type><name>short</name> <name>int</name></type> <name>flex_int16_t</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>flex_int32_t</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>flex_uint8_t</name>;</typedef> 
<typedef>typedef <type><name>unsigned</name> <name>short</name> <name>int</name></type> <name>flex_uint16_t</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>int</name></type> <name>flex_uint32_t</name>;</typedef>

<comment type="block">/* Limits of integral types. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INT8_MIN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT8_MIN</name></cpp:macro>               <cpp:value>(-128)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INT16_MIN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT16_MIN</name></cpp:macro>              <cpp:value>(-32767-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INT32_MIN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32_MIN</name></cpp:macro>              <cpp:value>(-2147483647-1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INT8_MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT8_MAX</name></cpp:macro>               <cpp:value>(127)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INT16_MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT16_MAX</name></cpp:macro>              <cpp:value>(32767)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>INT32_MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32_MAX</name></cpp:macro>              <cpp:value>(2147483647)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UINT8_MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT8_MAX</name></cpp:macro>              <cpp:value>(255U)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UINT16_MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT16_MAX</name></cpp:macro>             <cpp:value>(65535U)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>UINT32_MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT32_MAX</name></cpp:macro>             <cpp:value>(4294967295U)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ! C99 */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ! FLEXINT_H */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>

<comment type="block">/* The "const" storage-class-modifier is valid. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_USE_CONST</name></cpp:macro></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* ! __cplusplus */</comment>

<comment type="block">/* C99 requires __STDC__ to be defined as 1. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>__STDC__</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_USE_CONST</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* defined (__STDC__) */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* ! __cplusplus */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YY_USE_CONST</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyconst</name></cpp:macro> <cpp:value>const</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyconst</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Returned upon end-of-file. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NULL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_SC_TO_UI</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((unsigned int) (unsigned char) c)</cpp:value></cpp:define>

<comment type="block">/* An opaque pointer. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_TYPEDEF_YY_SCANNER_T</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_TYPEDEF_YY_SCANNER_T</name></cpp:macro></cpp:define>
<typedef>typedef <type><name>void</name>*</type> <name>yyscan_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* For convenience, these vars (plus the bison vars far below)
   are macros in the reentrant scanner. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyin</name></cpp:macro> <cpp:value>yyg-&gt;yyin_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyout</name></cpp:macro> <cpp:value>yyg-&gt;yyout_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyextra</name></cpp:macro> <cpp:value>yyg-&gt;yyextra_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyleng</name></cpp:macro> <cpp:value>yyg-&gt;yyleng_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yytext</name></cpp:macro> <cpp:value>yyg-&gt;yytext_r</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yylineno</name></cpp:macro> <cpp:value>(YY_CURRENT_BUFFER_LVALUE-&gt;yy_bs_lineno)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yycolumn</name></cpp:macro> <cpp:value>(YY_CURRENT_BUFFER_LVALUE-&gt;yy_bs_column)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yy_flex_debug</name></cpp:macro> <cpp:value>yyg-&gt;yy_flex_debug_r</cpp:value></cpp:define>

<comment type="block">/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEGIN</name></cpp:macro> <cpp:value>yyg-&gt;yy_start = 1 + 2 *</cpp:value></cpp:define>

<comment type="block">/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_START</name></cpp:macro> <cpp:value>((yyg-&gt;yy_start - 1) / 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYSTATE</name></cpp:macro> <cpp:value>YY_START</cpp:value></cpp:define>

<comment type="block">/* Action number for EOF rule of a given start state. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STATE_EOF</name><parameter_list>(<param><type><name>state</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(YY_END_OF_BUFFER + state + 1)</cpp:value></cpp:define>

<comment type="block">/* Special action meaning "start processing a new file". */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NEW_FILE</name></cpp:macro> <cpp:value>ap_expr_yyrestart(yyin ,yyscanner )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_END_OF_BUFFER_CHAR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* Size of default input buffer. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_BUF_SIZE</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ia64__</name></cpp:ifdef>
<comment type="block">/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUF_SIZE</name></cpp:macro> <cpp:value>32768</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUF_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __ia64__ */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The state buf must be large enough to hold one state per character in the main buffer.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STATE_BUF_SIZE</name></cpp:macro>   <cpp:value>((YY_BUF_SIZE + 2) * sizeof(yy_state_type))</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_TYPEDEF_YY_BUFFER_STATE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_TYPEDEF_YY_BUFFER_STATE</name></cpp:macro></cpp:define>
<typedef>typedef <type>struct <name>yy_buffer_state</name> *</type><name>YY_BUFFER_STATE</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_ACT_CONTINUE_SCAN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_ACT_END_OF_FILE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EOB_ACT_LAST_MATCH</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_LESS_LINENO</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro></cpp:define>
    
<comment type="block">/* Return all but the first "n" matched characters back to the input stream. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyless</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>do \
		{ \
		<comment type="block">/* Undo effects of setting up yytext. */</comment> \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		*yy_cp = yyg-&gt;yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yyg-&gt;yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; <comment type="block">/* set up yytext again */</comment> \
		} \
	while ( 0 )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unput</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>yyunput( c, yyg-&gt;yytext_ptr , yyscanner )</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_TYPEDEF_YY_SIZE_T</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_TYPEDEF_YY_SIZE_T</name></cpp:macro></cpp:define>
<typedef>typedef <type><name>size_t</name></type> <name>yy_size_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_STRUCT_YY_BUFFER_STATE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_STRUCT_YY_BUFFER_STATE</name></cpp:macro></cpp:define>
<struct>struct <name>yy_buffer_state</name>
	<block>{
	<decl_stmt><decl><type><name>FILE</name> *</type><name>yy_input_file</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> *</type><name>yy_ch_buf</name></decl>;</decl_stmt>		<comment type="block">/* input buffer */</comment>
	<decl_stmt><decl><type><name>char</name> *</type><name>yy_buf_pos</name></decl>;</decl_stmt>		<comment type="block">/* current position in input buffer */</comment>

	<comment type="block">/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */</comment>
	<decl_stmt><decl><type><name>yy_size_t</name></type> <name>yy_buf_size</name></decl>;</decl_stmt>

	<comment type="block">/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>yy_n_chars</name></decl>;</decl_stmt>

	<comment type="block">/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>yy_is_our_buffer</name></decl>;</decl_stmt>

	<comment type="block">/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>yy_is_interactive</name></decl>;</decl_stmt>

	<comment type="block">/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>yy_at_bol</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>yy_bs_lineno</name></decl>;</decl_stmt> <comment type="block">/**&lt; The line count. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_bs_column</name></decl>;</decl_stmt> <comment type="block">/**&lt; The column count. */</comment>
    
	<comment type="block">/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>yy_fill_buffer</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>yy_buffer_status</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUFFER_NEW</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUFFER_NORMAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
	<comment type="block">/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via ap_expr_yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BUFFER_EOF_PENDING</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

	}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !YY_STRUCT_YY_BUFFER_STATE */</comment>

<comment type="block">/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_CURRENT_BUFFER</name></cpp:macro> <cpp:value>( yyg-&gt;yy_buffer_stack \
                          ? yyg-&gt;yy_buffer_stack[yyg-&gt;yy_buffer_stack_top] \
                          : NULL)</cpp:value></cpp:define>

<comment type="block">/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_CURRENT_BUFFER_LVALUE</name></cpp:macro> <cpp:value>yyg-&gt;yy_buffer_stack[yyg-&gt;yy_buffer_stack_top]</cpp:value></cpp:define>

<function_decl><type><name>void</name></type> <name>ap_expr_yyrestart</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type><name>input_file</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yy_switch_to_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>new_buffer</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_create_buffer</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param>,<param><decl><type><name>int</name></type> <name>size</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yy_delete_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yy_flush_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yypush_buffer_state</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>new_buffer</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yypop_buffer_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yyensure_buffer_stack</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yy_load_buffer_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yy_init_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl></param>,<param><decl><type><name>FILE</name> *</type><name>file</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FLUSH_BUFFER</name></cpp:macro> <cpp:value>ap_expr_yy_flush_buffer(YY_CURRENT_BUFFER ,yyscanner)</cpp:value></cpp:define>

<function_decl><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_buffer</name> <parameter_list>(<param><decl><type><name>char</name> *</type><name>base</name></decl></param>,<param><decl><type><name>yy_size_t</name></type> <name>size</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_string</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type><name>yy_str</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_bytes</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type><name>bytes</name></decl></param>,<param><decl><type><name>int</name></type> <name>len</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name> *</type><name>ap_expr_yyalloc</name> <parameter_list>(<param><decl><type><name>yy_size_t</name></type></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name> *</type><name>ap_expr_yyrealloc</name> <parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>,<param><decl><type><name>yy_size_t</name></type></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_expr_yyfree</name> <parameter_list>(<param><decl><type><name>void</name> *</type></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yy_new_buffer</name></cpp:macro> <cpp:value>ap_expr_yy_create_buffer</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yy_set_interactive</name><parameter_list>(<param><type><name>is_interactive</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>{ \
	if ( ! YY_CURRENT_BUFFER ){ \
        ap_expr_yyensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
            ap_expr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
	} \
	YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive = is_interactive; \
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yy_set_bol</name><parameter_list>(<param><type><name>at_bol</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>{ \
	if ( ! YY_CURRENT_BUFFER ){\
        ap_expr_yyensure_buffer_stack (yyscanner); \
		YY_CURRENT_BUFFER_LVALUE =    \
            ap_expr_yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
	} \
	YY_CURRENT_BUFFER_LVALUE-&gt;yy_at_bol = at_bol; \
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_AT_BOL</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>(YY_CURRENT_BUFFER_LVALUE-&gt;yy_at_bol)</cpp:value></cpp:define>

<comment type="block">/* Begin user sect3 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_expr_yywrap</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_SKIP_YYWRAP</name></cpp:macro></cpp:define>

<typedef>typedef <type><name>unsigned</name> <name>char</name></type> <name>YY_CHAR</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>yy_state_type</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yytext_ptr</name></cpp:macro> <cpp:value>yytext_r</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>yy_state_type</name></type> <name>yy_get_previous_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>yy_state_type</name></type> <name>yy_try_NUL_trans</name> <parameter_list>(<param><decl><type><name>yy_state_type</name></type> <name>current_state</name></decl></param>  ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yy_get_next_buffer</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_fatal_error</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name></type> <name><name>msg</name><index>[]</index></name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<comment type="block">/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_DO_BEFORE_ACTION</name></cpp:macro> \
	<cpp:value>yyg-&gt;yytext_ptr = yy_bp; \
	yyleng = (size_t) (yy_cp - yy_bp); \
	yyg-&gt;yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yyg-&gt;yy_c_buf_p = yy_cp;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NUM_RULES</name></cpp:macro> <cpp:value>67</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_END_OF_BUFFER</name></cpp:macro> <cpp:value>68</cpp:value></cpp:define>
<comment type="block">/* This struct is not used in this scanner,
   but its presence is necessary. */</comment>
<struct>struct <name>yy_trans_info</name>
	<block>{
	<decl_stmt><decl><type><name>flex_int32_t</name></type> <name>yy_verify</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>flex_int32_t</name></type> <name>yy_nxt</name></decl>;</decl_stmt>
	}</block>;</struct>
<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_accept</name><index>[<expr>124</expr>]</index></name> <init>=
    <expr><block>{   <expr>0</expr>,
        <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,
        <expr>0</expr>,    <expr>0</expr>,   <expr>68</expr>,   <expr>66</expr>,    <expr>1</expr>,   <expr>43</expr>,    <expr>2</expr>,   <expr>66</expr>,   <expr>66</expr>,   <expr>66</expr>,
       <expr>65</expr>,   <expr>66</expr>,   <expr>44</expr>,   <expr>26</expr>,   <expr>63</expr>,   <expr>32</expr>,   <expr>30</expr>,   <expr>34</expr>,   <expr>64</expr>,   <expr>64</expr>,
       <expr>64</expr>,   <expr>64</expr>,   <expr>64</expr>,   <expr>64</expr>,   <expr>64</expr>,   <expr>64</expr>,   <expr>64</expr>,   <expr>64</expr>,   <expr>64</expr>,   <expr>66</expr>,
       <expr>14</expr>,    <expr>4</expr>,    <expr>3</expr>,   <expr>17</expr>,   <expr>17</expr>,   <expr>67</expr>,   <expr>17</expr>,   <expr>23</expr>,    <expr>4</expr>,   <expr>22</expr>,
       <expr>20</expr>,   <expr>21</expr>,   <expr>67</expr>,   <expr>16</expr>,   <expr>16</expr>,   <expr>24</expr>,   <expr>27</expr>,   <expr>29</expr>,   <expr>28</expr>,    <expr>1</expr>,
       <expr>31</expr>,   <expr>37</expr>,   <expr>19</expr>,   <expr>18</expr>,   <expr>39</expr>,   <expr>63</expr>,   <expr>59</expr>,   <expr>59</expr>,   <expr>59</expr>,   <expr>59</expr>,
       <expr>59</expr>,   <expr>59</expr>,   <expr>33</expr>,   <expr>30</expr>,   <expr>36</expr>,   <expr>35</expr>,   <expr>64</expr>,   <expr>64</expr>,   <expr>57</expr>,   <expr>64</expr>,
       <expr>55</expr>,   <expr>54</expr>,   <expr>58</expr>,   <expr>53</expr>,   <expr>52</expr>,   <expr>25</expr>,   <expr>25</expr>,   <expr>56</expr>,   <expr>64</expr>,   <expr>40</expr>,
       <expr>64</expr>,   <expr>41</expr>,   <expr>14</expr>,   <expr>13</expr>,   <expr>15</expr>,   <expr>12</expr>,    <expr>5</expr>,    <expr>6</expr>,   <expr>10</expr>,   <expr>11</expr>,

        <expr>7</expr>,    <expr>8</expr>,    <expr>9</expr>,   <expr>20</expr>,   <expr>60</expr>,   <expr>46</expr>,   <expr>48</expr>,   <expr>50</expr>,   <expr>45</expr>,   <expr>49</expr>,
       <expr>51</expr>,   <expr>47</expr>,   <expr>38</expr>,   <expr>64</expr>,   <expr>42</expr>,   <expr>64</expr>,    <expr>5</expr>,    <expr>6</expr>,   <expr>64</expr>,   <expr>61</expr>,
        <expr>5</expr>,   <expr>62</expr>,    <expr>0</expr>
    }</block></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int32_t</name></type> <name><name>yy_ec</name><index>[<expr>256</expr>]</index></name> <init>=
    <expr><block>{   <expr>0</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>2</expr>,    <expr>3</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>2</expr>,    <expr>4</expr>,    <expr>5</expr>,    <expr>6</expr>,    <expr>7</expr>,    <expr>8</expr>,    <expr>9</expr>,    <expr>5</expr>,   <expr>10</expr>,
       <expr>10</expr>,    <expr>1</expr>,    <expr>1</expr>,   <expr>11</expr>,   <expr>12</expr>,   <expr>13</expr>,   <expr>14</expr>,   <expr>15</expr>,   <expr>15</expr>,   <expr>15</expr>,
       <expr>15</expr>,   <expr>15</expr>,   <expr>15</expr>,   <expr>15</expr>,   <expr>15</expr>,   <expr>16</expr>,   <expr>16</expr>,   <expr>17</expr>,    <expr>6</expr>,   <expr>18</expr>,
       <expr>19</expr>,   <expr>20</expr>,    <expr>6</expr>,    <expr>1</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,
       <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,
       <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,
        <expr>1</expr>,   <expr>22</expr>,    <expr>1</expr>,    <expr>6</expr>,   <expr>23</expr>,    <expr>1</expr>,   <expr>24</expr>,   <expr>25</expr>,   <expr>21</expr>,   <expr>26</expr>,

       <expr>27</expr>,   <expr>28</expr>,   <expr>29</expr>,   <expr>21</expr>,   <expr>30</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>31</expr>,   <expr>32</expr>,   <expr>33</expr>,
       <expr>34</expr>,   <expr>21</expr>,   <expr>35</expr>,   <expr>36</expr>,   <expr>37</expr>,   <expr>38</expr>,   <expr>39</expr>,   <expr>21</expr>,   <expr>21</expr>,   <expr>21</expr>,
       <expr>21</expr>,   <expr>21</expr>,   <expr>40</expr>,   <expr>41</expr>,   <expr>42</expr>,   <expr>43</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,

        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>
    }</block></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int32_t</name></type> <name><name>yy_meta</name><index>[<expr>44</expr>]</index></name> <init>=
    <expr><block>{   <expr>0</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>2</expr>,    <expr>1</expr>,    <expr>2</expr>,    <expr>1</expr>,    <expr>2</expr>,    <expr>2</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>3</expr>,    <expr>2</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,
        <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>2</expr>,    <expr>1</expr>
    }</block></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_base</name><index>[<expr>133</expr>]</index></name> <init>=
    <expr><block>{   <expr>0</expr>,
        <expr>0</expr>,    <expr>0</expr>,   <expr>41</expr>,   <expr>47</expr>,   <expr>89</expr>,    <expr>0</expr>,  <expr>130</expr>,  <expr>136</expr>,    <expr>0</expr>,    <expr>0</expr>,
      <expr>147</expr>,  <expr>146</expr>,  <expr>175</expr>,  <expr>275</expr>,   <expr>54</expr>,   <expr>28</expr>,  <expr>275</expr>,   <expr>43</expr>,  <expr>134</expr>,  <expr>164</expr>,
      <expr>275</expr>,  <expr>164</expr>,  <expr>275</expr>,  <expr>275</expr>,   <expr>45</expr>,  <expr>152</expr>,   <expr>32</expr>,  <expr>151</expr>,    <expr>0</expr>,  <expr>136</expr>,
      <expr>133</expr>,  <expr>143</expr>,   <expr>26</expr>,  <expr>133</expr>,   <expr>35</expr>,  <expr>194</expr>,   <expr>38</expr>,  <expr>129</expr>,  <expr>128</expr>,  <expr>122</expr>,
        <expr>0</expr>,  <expr>275</expr>,  <expr>275</expr>,   <expr>51</expr>,  <expr>122</expr>,  <expr>221</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,
        <expr>0</expr>,  <expr>275</expr>,  <expr>275</expr>,   <expr>61</expr>,  <expr>121</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,   <expr>76</expr>,
      <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,   <expr>65</expr>,    <expr>0</expr>,  <expr>125</expr>,   <expr>47</expr>,  <expr>126</expr>,
      <expr>107</expr>,  <expr>130</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,    <expr>0</expr>,  <expr>130</expr>,    <expr>0</expr>,  <expr>124</expr>,
        <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,  <expr>275</expr>,    <expr>0</expr>,    <expr>0</expr>,  <expr>104</expr>,    <expr>0</expr>,
      <expr>101</expr>,  <expr>275</expr>,    <expr>0</expr>,  <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,   <expr>71</expr>,  <expr>131</expr>,  <expr>275</expr>,  <expr>275</expr>,

      <expr>275</expr>,  <expr>275</expr>,  <expr>275</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,
        <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,   <expr>99</expr>,    <expr>0</expr>,   <expr>61</expr>,  <expr>133</expr>,  <expr>135</expr>,   <expr>57</expr>,    <expr>0</expr>,
      <expr>138</expr>,    <expr>0</expr>,  <expr>275</expr>,  <expr>259</expr>,  <expr>262</expr>,  <expr>265</expr>,   <expr>79</expr>,   <expr>67</expr>,  <expr>268</expr>,  <expr>271</expr>,
       <expr>65</expr>,   <expr>42</expr>
    }</block></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_def</name><index>[<expr>133</expr>]</index></name> <init>=
    <expr><block>{   <expr>0</expr>,
      <expr>123</expr>,    <expr>1</expr>,  <expr>124</expr>,  <expr>124</expr>,  <expr>123</expr>,    <expr>5</expr>,  <expr>124</expr>,  <expr>124</expr>,  <expr>125</expr>,  <expr>125</expr>,
      <expr>126</expr>,  <expr>126</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>127</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>128</expr>,  <expr>128</expr>,
      <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>123</expr>,
      <expr>129</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>130</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>131</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>132</expr>,  <expr>132</expr>,  <expr>132</expr>,  <expr>132</expr>,
      <expr>132</expr>,  <expr>132</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,
      <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>123</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,
      <expr>128</expr>,  <expr>123</expr>,  <expr>129</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,

      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>131</expr>,  <expr>132</expr>,  <expr>132</expr>,  <expr>132</expr>,  <expr>132</expr>,  <expr>132</expr>,  <expr>132</expr>,
      <expr>132</expr>,  <expr>132</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>128</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>128</expr>,  <expr>128</expr>,
      <expr>123</expr>,  <expr>128</expr>,    <expr>0</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>
    }</block></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_nxt</name><index>[<expr>319</expr>]</index></name> <init>=
    <expr><block>{   <expr>0</expr>,
       <expr>14</expr>,   <expr>15</expr>,   <expr>15</expr>,   <expr>16</expr>,   <expr>17</expr>,   <expr>14</expr>,   <expr>18</expr>,   <expr>19</expr>,   <expr>20</expr>,   <expr>21</expr>,
       <expr>21</expr>,   <expr>22</expr>,   <expr>23</expr>,   <expr>24</expr>,   <expr>25</expr>,   <expr>25</expr>,   <expr>21</expr>,   <expr>26</expr>,   <expr>27</expr>,   <expr>28</expr>,
       <expr>29</expr>,   <expr>14</expr>,   <expr>14</expr>,   <expr>30</expr>,   <expr>29</expr>,   <expr>29</expr>,   <expr>31</expr>,   <expr>32</expr>,   <expr>33</expr>,   <expr>34</expr>,
       <expr>35</expr>,   <expr>36</expr>,   <expr>37</expr>,   <expr>38</expr>,   <expr>29</expr>,   <expr>29</expr>,   <expr>29</expr>,   <expr>39</expr>,   <expr>29</expr>,   <expr>21</expr>,
       <expr>40</expr>,   <expr>21</expr>,   <expr>14</expr>,   <expr>42</expr>,  <expr>105</expr>,   <expr>43</expr>,   <expr>61</expr>,   <expr>44</expr>,   <expr>45</expr>,   <expr>42</expr>,
       <expr>74</expr>,   <expr>43</expr>,   <expr>81</expr>,   <expr>44</expr>,   <expr>45</expr>,   <expr>60</expr>,   <expr>60</expr>,   <expr>63</expr>,   <expr>63</expr>,   <expr>66</expr>,
       <expr>66</expr>,   <expr>84</expr>,   <expr>46</expr>,   <expr>82</expr>,   <expr>88</expr>,   <expr>94</expr>,   <expr>94</expr>,  <expr>104</expr>,   <expr>46</expr>,   <expr>77</expr>,
       <expr>62</expr>,   <expr>89</expr>,   <expr>85</expr>,  <expr>107</expr>,   <expr>75</expr>,   <expr>94</expr>,   <expr>94</expr>,   <expr>60</expr>,   <expr>60</expr>,   <expr>66</expr>,
       <expr>66</expr>,   <expr>67</expr>,   <expr>47</expr>,  <expr>122</expr>,  <expr>108</expr>,  <expr>117</expr>,  <expr>118</expr>,  <expr>120</expr>,   <expr>47</expr>,   <expr>48</expr>,
       <expr>48</expr>,   <expr>49</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,

       <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>50</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>48</expr>,   <expr>51</expr>,
       <expr>48</expr>,   <expr>48</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,
       <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>51</expr>,   <expr>48</expr>,   <expr>48</expr>,
       <expr>52</expr>,   <expr>48</expr>,   <expr>42</expr>,  <expr>110</expr>,   <expr>53</expr>,  <expr>119</expr>,   <expr>54</expr>,   <expr>55</expr>,   <expr>42</expr>,  <expr>116</expr>,
       <expr>53</expr>,  <expr>115</expr>,   <expr>54</expr>,   <expr>55</expr>,  <expr>111</expr>,  <expr>118</expr>,  <expr>118</expr>,  <expr>121</expr>,  <expr>118</expr>,  <expr>118</expr>,
      <expr>118</expr>,   <expr>46</expr>,  <expr>118</expr>,  <expr>118</expr>,  <expr>114</expr>,  <expr>113</expr>,  <expr>112</expr>,   <expr>46</expr>,  <expr>109</expr>,  <expr>106</expr>,
       <expr>95</expr>,   <expr>95</expr>,   <expr>92</expr>,   <expr>91</expr>,   <expr>90</expr>,   <expr>83</expr>,   <expr>80</expr>,   <expr>79</expr>,   <expr>78</expr>,   <expr>76</expr>,
       <expr>73</expr>,   <expr>56</expr>,   <expr>65</expr>,   <expr>64</expr>,  <expr>123</expr>,   <expr>59</expr>,   <expr>59</expr>,   <expr>56</expr>,   <expr>66</expr>,   <expr>66</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
       <expr>68</expr>,  <expr>123</expr>,   <expr>69</expr>,   <expr>70</expr>,   <expr>71</expr>,  <expr>123</expr>,   <expr>72</expr>,   <expr>86</expr>,   <expr>86</expr>,   <expr>86</expr>,

       <expr>86</expr>,   <expr>86</expr>,  <expr>123</expr>,  <expr>123</expr>,   <expr>86</expr>,   <expr>86</expr>,   <expr>86</expr>,   <expr>86</expr>,  <expr>123</expr>,  <expr>123</expr>,
       <expr>86</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,   <expr>87</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,   <expr>86</expr>,   <expr>97</expr>,   <expr>98</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,   <expr>99</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>100</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>101</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>102</expr>,  <expr>123</expr>,  <expr>103</expr>,   <expr>41</expr>,
       <expr>41</expr>,   <expr>41</expr>,   <expr>57</expr>,   <expr>57</expr>,   <expr>57</expr>,   <expr>58</expr>,   <expr>58</expr>,   <expr>58</expr>,   <expr>93</expr>,  <expr>123</expr>,
       <expr>93</expr>,   <expr>96</expr>,   <expr>96</expr>,   <expr>96</expr>,   <expr>13</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,

      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>
    }</block></expr></init></decl> ;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>yyconst</name> <name>flex_int16_t</name></type> <name><name>yy_chk</name><index>[<expr>319</expr>]</index></name> <init>=
    <expr><block>{   <expr>0</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,
        <expr>1</expr>,    <expr>1</expr>,    <expr>1</expr>,    <expr>3</expr>,  <expr>132</expr>,    <expr>3</expr>,   <expr>16</expr>,    <expr>3</expr>,    <expr>3</expr>,    <expr>4</expr>,
       <expr>27</expr>,    <expr>4</expr>,   <expr>33</expr>,    <expr>4</expr>,    <expr>4</expr>,   <expr>15</expr>,   <expr>15</expr>,   <expr>18</expr>,   <expr>18</expr>,   <expr>25</expr>,
       <expr>25</expr>,   <expr>35</expr>,    <expr>3</expr>,   <expr>33</expr>,   <expr>37</expr>,   <expr>44</expr>,   <expr>44</expr>,  <expr>131</expr>,    <expr>4</expr>,  <expr>128</expr>,
       <expr>16</expr>,   <expr>37</expr>,   <expr>35</expr>,   <expr>69</expr>,   <expr>27</expr>,   <expr>54</expr>,   <expr>54</expr>,   <expr>60</expr>,   <expr>60</expr>,   <expr>66</expr>,
       <expr>66</expr>,  <expr>127</expr>,    <expr>3</expr>,  <expr>119</expr>,   <expr>69</expr>,   <expr>97</expr>,   <expr>97</expr>,  <expr>116</expr>,    <expr>4</expr>,    <expr>5</expr>,
        <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,

        <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,
        <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,
        <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,    <expr>5</expr>,
        <expr>5</expr>,    <expr>5</expr>,    <expr>7</expr>,   <expr>71</expr>,    <expr>7</expr>,  <expr>114</expr>,    <expr>7</expr>,    <expr>7</expr>,    <expr>8</expr>,   <expr>91</expr>,
        <expr>8</expr>,   <expr>89</expr>,    <expr>8</expr>,    <expr>8</expr>,   <expr>71</expr>,   <expr>98</expr>,   <expr>98</expr>,  <expr>117</expr>,  <expr>117</expr>,  <expr>118</expr>,
      <expr>118</expr>,    <expr>7</expr>,  <expr>121</expr>,  <expr>121</expr>,   <expr>80</expr>,   <expr>78</expr>,   <expr>72</expr>,    <expr>8</expr>,   <expr>70</expr>,   <expr>68</expr>,
       <expr>55</expr>,   <expr>45</expr>,   <expr>40</expr>,   <expr>39</expr>,   <expr>38</expr>,   <expr>34</expr>,   <expr>32</expr>,   <expr>31</expr>,   <expr>30</expr>,   <expr>28</expr>,
       <expr>26</expr>,    <expr>7</expr>,   <expr>20</expr>,   <expr>19</expr>,   <expr>13</expr>,   <expr>12</expr>,   <expr>11</expr>,    <expr>8</expr>,   <expr>22</expr>,   <expr>22</expr>,
        <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,
       <expr>22</expr>,    <expr>0</expr>,   <expr>22</expr>,   <expr>22</expr>,   <expr>22</expr>,    <expr>0</expr>,   <expr>22</expr>,   <expr>36</expr>,   <expr>36</expr>,   <expr>36</expr>,

       <expr>36</expr>,   <expr>36</expr>,    <expr>0</expr>,    <expr>0</expr>,   <expr>36</expr>,   <expr>36</expr>,   <expr>36</expr>,   <expr>36</expr>,    <expr>0</expr>,    <expr>0</expr>,
       <expr>36</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,   <expr>36</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,
        <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,
        <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,   <expr>36</expr>,   <expr>46</expr>,   <expr>46</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,
        <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,   <expr>46</expr>,    <expr>0</expr>,    <expr>0</expr>,   <expr>46</expr>,    <expr>0</expr>,
        <expr>0</expr>,    <expr>0</expr>,    <expr>0</expr>,   <expr>46</expr>,    <expr>0</expr>,    <expr>0</expr>,   <expr>46</expr>,    <expr>0</expr>,   <expr>46</expr>,  <expr>124</expr>,
      <expr>124</expr>,  <expr>124</expr>,  <expr>125</expr>,  <expr>125</expr>,  <expr>125</expr>,  <expr>126</expr>,  <expr>126</expr>,  <expr>126</expr>,  <expr>129</expr>,    <expr>0</expr>,
      <expr>129</expr>,  <expr>130</expr>,  <expr>130</expr>,  <expr>130</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,

      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,
      <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>,  <expr>123</expr>
    }</block></expr></init></decl> ;</decl_stmt>

<comment type="block">/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REJECT</name></cpp:macro> <cpp:value>reject_used_but_not_detected</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yymore</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>yymore_used_but_not_detected</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_MORE_ADJ</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_RESTORE_YY_MORE_OFFSET</name></cpp:macro></cpp:define>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>
<comment type="block">/*
 *  ap_expr_scan.l, based on ssl_expr_scan.l from mod_ssl
 */</comment>
<comment type="block">/*  _________________________________________________________________
**
**  Expression Scanner
**  _________________________________________________________________
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_NO_INPUT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>




<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>43</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_expr_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_expr_parse.h"</cpp:file></cpp:include>

<cpp:undef>#<cpp:directive>undef</cpp:directive>  <name>YY_INPUT</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_INPUT</name><parameter_list>(<param><type><name>buf</name></type></param>,<param><type><name>result</name></type></param>,<param><type><name>max_size</name></type></param>)</parameter_list></cpp:macro>                       \
<cpp:value>{                                                           \
    if ((result = MIN(max_size, yyextra-&gt;inputbuf           \
                              + yyextra-&gt;inputlen           \
                              - yyextra-&gt;inputptr)) &lt;= 0)   \
    {                                                       \
        result = YY_NULL;                                   \
    }                                                       \
    else {                                                  \
        memcpy(buf, yyextra-&gt;inputptr, result);             \
        yyextra-&gt;inputptr += result;                        \
    }                                                       \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_EXTRA_TYPE</name></cpp:macro> <cpp:value>ap_expr_parse_ctx_t*</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PERROR</name><parameter_list>(<param><type><name>msg</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { yyextra-&gt;error2 = msg ; return T_ERROR; } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str_ptr</name></cpp:macro>     <cpp:value>(yyextra-&gt;scan_ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str_buf</name></cpp:macro>     <cpp:value>(yyextra-&gt;scan_buf)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str_del</name></cpp:macro>     <cpp:value>(yyextra-&gt;scan_del)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_APPEND</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {                          \
        *str_ptr++ = (c);                           \
        if (str_ptr &gt;= str_buf + sizeof(str_buf))   \
            PERROR("String too long");              \
    } while (0)</cpp:value></cpp:define>

<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>615</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITIAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>var</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vararg</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>regex</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>regex_flags</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_NO_UNISTD_H</name></cpp:ifndef>
<comment type="block">/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_EXTRA_TYPE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_EXTRA_TYPE</name></cpp:macro> <cpp:value>void *</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Holds the entire state of the reentrant scanner. */</comment>
<struct>struct <name>yyguts_t</name>
    <block>{

    <comment type="block">/* User-defined. Not touched by flex. */</comment>
    <decl_stmt><decl><type><name>YY_EXTRA_TYPE</name></type> <name>yyextra_r</name></decl>;</decl_stmt>

    <comment type="block">/* The rest are the same as the globals declared in the non-reentrant scanner. */</comment>
    <decl_stmt><decl><type><name>FILE</name> *</type><name>yyin_r</name></decl>, *<decl><type ref="prev"/><name>yyout_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>yy_buffer_stack_top</name></decl>;</decl_stmt> <comment type="block">/**&lt; index of top of stack. */</comment>
    <decl_stmt><decl><type><name>size_t</name></type> <name>yy_buffer_stack_max</name></decl>;</decl_stmt> <comment type="block">/**&lt; capacity of stack. */</comment>
    <decl_stmt><decl><type><name>YY_BUFFER_STATE</name> *</type> <name>yy_buffer_stack</name></decl>;</decl_stmt> <comment type="block">/**&lt; Stack as an array. */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>yy_hold_char</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_n_chars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yyleng_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>yy_c_buf_p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_init</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_did_buffer_switch_on_eof</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_start_stack_ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_start_stack_depth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> *</type><name>yy_start_stack</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>yy_state_type</name></type> <name>yy_last_accepting_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>*</type> <name>yy_last_accepting_cpos</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>yylineno_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_flex_debug_r</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> *</type><name>yytext_r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_more_flag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>yy_more_len</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>YYSTYPE</name> *</type> <name>yylval_r</name></decl>;</decl_stmt>

    }</block>;</struct> <comment type="block">/* end struct yyguts_t */</comment>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yy_init_globals</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

    <comment type="block">/* This must go here because YYSTYPE and YYLTYPE are included
     * from bison output in section 1.*/</comment>
    <cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>yylval</name></cpp:macro> <cpp:value>yyg-&gt;yylval_r</cpp:value></cpp:define>
    
<function_decl><type><name>int</name></type> <name>ap_expr_yylex_init</name> <parameter_list>(<param><decl><type><name>yyscan_t</name>*</type> <name>scanner</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ap_expr_yylex_init_extra</name> <parameter_list>(<param><decl><type><name>YY_EXTRA_TYPE</name></type> <name>user_defined</name></decl></param>,<param><decl><type><name>yyscan_t</name>*</type> <name>scanner</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */</comment>

<function_decl><type><name>int</name></type> <name>ap_expr_yylex_destroy</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ap_expr_yyget_debug</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ap_expr_yyset_debug</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>debug_flag</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>YY_EXTRA_TYPE</name></type> <name>ap_expr_yyget_extra</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ap_expr_yyset_extra</name> <parameter_list>(<param><decl><type><name>YY_EXTRA_TYPE</name></type> <name>user_defined</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>FILE</name> *</type><name>ap_expr_yyget_in</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ap_expr_yyset_in</name>  <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>in_str</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>FILE</name> *</type><name>ap_expr_yyget_out</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ap_expr_yyset_out</name>  <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>out_str</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ap_expr_yyget_leng</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>char</name> *</type><name>ap_expr_yyget_text</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>ap_expr_yyget_lineno</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ap_expr_yyset_lineno</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>line_number</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>YYSTYPE</name> *</type> <name>ap_expr_yyget_lval</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>ap_expr_yyset_lval</name> <parameter_list>(<param><decl><type><name>YYSTYPE</name> *</type> <name>yylval_param</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>

<comment type="block">/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_SKIP_YYWRAP</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <function_decl><type><name>int</name></type> <name>ap_expr_yywrap</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl></extern>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>ap_expr_yywrap</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>yytext_ptr</name></cpp:ifndef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_flex_strncpy</name> <parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>,<param><decl><type><name>yyconst</name></type> <name>char</name> *</decl></param>,<param><decl><type><name>int</name></type></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YY_NEED_STRLEN</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yy_flex_strlen</name> <parameter_list>(<param><decl><type><name>yyconst</name></type> <name>char</name> *</decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_NO_INPUT</name></cpp:ifndef>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>yyinput</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>input</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_push_state</name> <parameter_list>(<param><decl><type><name>int</name></type> <name>new_state</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>
    
    <function_decl><type><specifier>static</specifier> <name>void</name></type> <name>yy_pop_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param> )</parameter_list>;</function_decl>
    
<comment type="block">/* Amount of stuff to slurp up with each read. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_READ_BUF_SIZE</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__ia64__</name></cpp:ifdef>
<comment type="block">/* On IA-64, the buffer size is 16k, not 8k */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_READ_BUF_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_READ_BUF_SIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __ia64__ */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Copy whatever the last rule matched to the standard output. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ECHO</name></cpp:ifndef>
<comment type="block">/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ECHO</name></cpp:macro> <cpp:value>do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_INPUT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_INPUT</name><parameter_list>(<param><type><name>buf</name></type></param>,<param><type><name>result</name></type></param>,<param><type><name>max_size</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>if ( YY_CURRENT_BUFFER_LVALUE-&gt;yy_is_interactive ) \
		{ \
		int c = '*'; \
		size_t n; \
		for ( n = 0; n &lt; max_size &amp;&amp; \
			     (c = getc( yyin )) != EOF &amp;&amp; c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF &amp;&amp; ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else \
		{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 &amp;&amp; ferror(yyin)) \
			{ \
			if( errno != EINTR) \
				{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
				} \
			errno=0; \
			clearerr(yyin); \
			} \
		}\
\

#endif</cpp:value></cpp:define>

<comment type="block">/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>yyterminate</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyterminate</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>return YY_NULL</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Number of entries by which start-condition stack grows. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_START_STACK_INCR</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_START_STACK_INCR</name></cpp:macro> <cpp:value>25</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Report a fatal error. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_FATAL_ERROR</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_FATAL_ERROR</name><parameter_list>(<param><type><name>msg</name></type></param>)</parameter_list></cpp:macro> <cpp:value>yy_fatal_error( msg , yyscanner)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* end tables serialization structures and prototypes */</comment>

<comment type="block">/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_DECL</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_DECL_IS_OURS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>ap_expr_yylex</name> \
               <parameter_list>(<param><decl><type><name>YYSTYPE</name> *</type> <name>yylval_param</name></decl></param> ,<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_DECL</name></cpp:macro> <cpp:value>int ap_expr_yylex \
               (YYSTYPE * yylval_param , yyscan_t yyscanner)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !YY_DECL */</comment>

<comment type="block">/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_USER_ACTION</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_USER_ACTION</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Code executed at the end of each rule. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_BREAK</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_BREAK</name></cpp:macro> <cpp:value>break;</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_RULE_SETUP</name></cpp:macro> \
	<cpp:value>YY_USER_ACTION</cpp:value></cpp:define>

<comment type="block">/** The main scanner function which does all the work.
 */</comment>
<macro><name>YY_DECL</name></macro>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>yy_state_type</name></type> <name>yy_current_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>yy_cp</name></decl>, *<decl><type ref="prev"/><name>yy_bp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>yy_act</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>78</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>


  <decl_stmt><decl><type><name>char</name></type>  <name><name>regex_buf</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>regex_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>  <name>regex_del</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>


 <comment type="block">/*
  * Set initial state for string expressions
  */</comment>
  <if>if <condition>(<expr><name><name>yyextra</name>-&gt;<name>at_start</name></name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>yyextra</name>-&gt;<name>at_start</name></name> = 0</expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>yyextra</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_STRING_RESULT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>T_EXPR_STRING</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <return>return <expr><name>T_EXPR_BOOL</name></expr>;</return>
    }</block></else></if>
  }</block></then></if>


 <comment type="block">/*
  * Whitespaces
  */</comment>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>886</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>

    <expr_stmt><expr><name>yylval</name> = <name>yylval_param</name></expr>;</expr_stmt>

	<if>if <condition>( <expr>!<name><name>yyg</name>-&gt;<name>yy_init</name></name></expr> )</condition><then>
		<block>{
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_init</name></name> = 1</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YY_USER_INIT</name></cpp:ifdef>
		<expr_stmt><expr><name>YY_USER_INIT</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_start</name></name></expr> )</condition><then>
			<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start</name></name> = 1</expr>;</expr_stmt></then></if>	<comment type="block">/* first start state */</comment>

		<if>if <condition>( <expr>! <name>yyin</name></expr> )</condition><then>
			<expr_stmt><expr><name>yyin</name> = <name>stdin</name></expr>;</expr_stmt></then></if>

		<if>if <condition>( <expr>! <name>yyout</name></expr> )</condition><then>
			<expr_stmt><expr><name>yyout</name> = <name>stdout</name></expr>;</expr_stmt></then></if>

		<if>if <condition>( <expr>! <name>YY_CURRENT_BUFFER</name></expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>ap_expr_yyensure_buffer_stack</name> <argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> =
				<call><name>ap_expr_yy_create_buffer</name><argument_list>(<argument><expr><name>yyin</name></expr></argument>,<argument><expr><name>YY_BUF_SIZE</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

	<while>while <condition>( <expr>1</expr> )</condition>		<comment type="block">/* loops until end-of-file is reached */</comment>
		<block>{
		<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>

		<comment type="block">/* Support of yytext. */</comment>
		<expr_stmt><expr>*<name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>

		<comment type="block">/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */</comment>
		<expr_stmt><expr><name>yy_bp</name> = <name>yy_cp</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_start</name></name></expr>;</expr_stmt>
<label><name>yy_match</name>:</label>
		<do>do
			<block>{
			<decl_stmt><decl><type><name>register</name> <name>YY_CHAR</name></type> <name>yy_c</name> <init>= <expr><name><name>yy_ec</name><index>[<expr><call><name>YY_SC_TO_UI</name><argument_list>(<argument><expr>*<name>yy_cp</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if>if <condition>( <expr><name><name>yy_accept</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr> )</condition><then>
				<block>{
				<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name> = <name>yy_current_state</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name> = <name>yy_cp</name></expr>;</expr_stmt>
				}</block></then></if>
			<while>while <condition>( <expr><name><name>yy_chk</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + <name>yy_c</name></expr>]</index></name> != <name>yy_current_state</name></expr> )</condition>
				<block>{
				<expr_stmt><expr><name>yy_current_state</name> = (<name>int</name>) <name><name>yy_def</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr>;</expr_stmt>
				<if>if <condition>( <expr><name>yy_current_state</name> &gt;= 124</expr> )</condition><then>
					<expr_stmt><expr><name>yy_c</name> = <name><name>yy_meta</name><index>[<expr>(<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt></then></if>
				}</block></while>
			<expr_stmt><expr><name>yy_current_state</name> = <name><name>yy_nxt</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + (<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr>++<name>yy_cp</name></expr>;</expr_stmt>
			}</block>
		while <condition>( <expr><name>yy_current_state</name> != 123</expr> )</condition>;</do>
		<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name></expr>;</expr_stmt>

<label><name>yy_find_action</name>:</label>
		<expr_stmt><expr><name>yy_act</name> = <name><name>yy_accept</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>YY_DO_BEFORE_ACTION</name></expr>;</expr_stmt>

<label><name>do_action</name>:</label>	<comment type="block">/* This label is used only to access EOF actions. */</comment>

		<switch>switch <condition>( <expr><name>yy_act</name></expr> )</condition>
	<block>{ <comment type="block">/* beginning of action switch */</comment>
			<case>case <expr>0</expr>: <comment type="block">/* must back up */</comment>
			<comment type="block">/* undo the effects of YY_DO_BEFORE_ACTION */</comment>
			<expr_stmt><expr>*<name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name></expr>;</expr_stmt>
			<goto>goto <name>yy_find_action</name>;</goto>

</case><case>case <expr>1</expr>:
<comment type="block">/* rule 1 can match eol */</comment>
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>103</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ 
    <comment type="block">/* NOP */</comment>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * strings ("..." and '...')
  */</comment>
</case><case>case <expr>2</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>110</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>str_del</name> = <name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_STR_BEGIN</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>3</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>116</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <if>if <condition>(<expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name> == <name>str_del</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>YY_START</name> == <name>var</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Unterminated variable in string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>str_ptr</name> == <name>str_buf</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>T_STR_END</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* return what we have so far and scan delimiter again */</comment>
            <expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
            <return>return <expr><name>T_STRING</name></expr>;</return>
        }</block></else></if></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>4</expr>:
<comment type="block">/* rule 4 can match eol */</comment>
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>138</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Unterminated string or variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>:
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>vararg</name></expr></argument>)</argument_list></call></expr>:
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>141</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Unterminated string or variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>:
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>144</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <if>if <condition>(<expr>!(<name><name>yyextra</name>-&gt;<name>flags</name></name> &amp; <name>AP_EXPR_FLAG_STRING_RESULT</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Unterminated string or variable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>T_STRING</name></expr>;</return>
    }</block></else></if>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>5</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>157</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr>(<name>void</name>)<call><name>sscanf</name><argument_list>(<argument><expr><name>yytext</name>+1</expr></argument>, <argument><expr>"%o"</expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>result</name> &gt; 0xff</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Escape sequence out of bound"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>6</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>168</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Bad escape sequence"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>7</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>171</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>8</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>172</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\r'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>9</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>173</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\t'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>10</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>174</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\b'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>11</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>175</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>'\f'</expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>12</expr>:
<comment type="block">/* rule 12 can match eol */</comment>
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>176</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name><name>yytext</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/* regexp backref inside string/arg */</comment>
</case><case>case <expr>13</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>179</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <if>if <condition>(<expr><name>str_ptr</name> != <name>str_buf</name></expr>)</condition><then> <block>{
        <comment type="block">/* return what we have so far and scan '$x' again */</comment>
        <expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>T_STRING</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>yylval</name>-&gt;<name>num</name></name> = <name><name>yytext</name><index>[<expr>1</expr>]</index></name> - '0'</expr>;</expr_stmt>
        <return>return <expr><name>T_REGEX_BACKREF</name></expr>;</return>
    }</block></else></if>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>14</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>194</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>cp</name> <init>= <expr><name>yytext</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr>*<name>cp</name> != '\0'</expr>)</condition> <block>{
        <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cp</name>++</expr>;</expr_stmt>
    }</block></while>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/* variable inside string/arg */</comment>
</case><case>case <expr>15</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>203</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <if>if <condition>(<expr><name>str_ptr</name> != <name>str_buf</name></expr>)</condition><then> <block>{
        <comment type="block">/* return what we have so far and scan '%{' again */</comment>
        <expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
        <return>return <expr><name>T_STRING</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>yy_push_state</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>T_VAR_BEGIN</name></expr>;</return>
    }</block></else></if>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>16</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>218</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
     <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>17</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>222</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
     <expr_stmt><expr><call><name>STR_APPEND</name><argument_list>(<argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>18</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>226</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><call><name>yy_push_state</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_VAR_BEGIN</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>19</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>231</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>num</name></name> = <name><name>yytext</name><index>[<expr>1</expr>]</index></name> - '0'</expr>;</expr_stmt>
    <return>return <expr><name>T_REGEX_BACKREF</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * fixed name variable expansion %{XXX} and function call in %{func:arg} syntax
  */</comment>
</case><case>case <expr>20</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>239</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_ID</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>21</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>244</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><call><name>yy_pop_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_VAR_END</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>22</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>249</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>vararg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>23</expr>:
<comment type="block">/* rule 23 can match eol */</comment>
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>254</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>msg</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>,
                             <argument><expr>"Invalid character in variable name '%c'"</expr></argument>, <argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>24</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>260</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <if>if <condition>(<expr><name>str_ptr</name> != <name>str_buf</name></expr>)</condition><then> <block>{
        <comment type="block">/* return what we have so far and scan '}' again */</comment>
        <expr_stmt><expr>*<name>str_ptr</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>str_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>str_ptr</name> = <name>str_buf</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>T_STRING</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>yy_pop_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>T_VAR_END</name></expr>;</return>
    }</block></else></if>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * Regular Expression
  */</comment>
</case><case>case <expr>25</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>278</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name>regex_del</name> = <name><name>yytext</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>regex_ptr</name> = <name>regex_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>26</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>283</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name>regex_del</name> = <name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>regex_ptr</name> = <name>regex_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>27</expr>:
<comment type="block">/* rule 27 can match eol */</comment>
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>288</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <if>if <condition>(<expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name> == <name>regex_del</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>regex_ptr</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>regex_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr>*<name>regex_ptr</name>++ = <name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>regex_ptr</name> &gt;= <name>regex_buf</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>regex_buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
            <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr>"Regexp too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>28</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>299</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>regex_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_REGEX_I</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>29</expr>:
<comment type="block">/* rule 29 can match eol */</comment>
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>304</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>regex_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>yyless</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_REGEX</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>regex_flags</name></expr></argument>)</argument_list></call></expr>:
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>310</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>regex_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_REGEX</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * Operators
  */</comment>
</case><case>case <expr>30</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>319</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_EQ</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>31</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>320</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_NE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>32</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>321</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_LT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>33</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>322</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_LE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>34</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>323</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_GT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>35</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>324</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_STR_GE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>36</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>325</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_REG</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>37</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>326</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NRE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>38</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>327</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_AND</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>39</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>328</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_AND</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>40</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>329</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_OR</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>41</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>330</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_OR</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>42</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>331</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NOT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>43</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>332</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NOT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>44</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>333</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_CONCAT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>45</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>334</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_IN</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>46</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>335</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_EQ</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>47</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>336</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>48</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>337</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_GE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>49</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>338</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_LE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>50</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>339</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_GT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>51</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>340</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_LT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/* for compatibility with ssl_expr */</comment>
</case><case>case <expr>52</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>343</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_LT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>53</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>344</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_LE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>54</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>345</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_GT</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>55</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>346</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_GE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>56</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>347</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_NE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>57</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>348</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_EQ</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>58</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>349</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_OP_IN</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>59</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>351</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_OP_UNARY</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>60</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>356</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_OP_BINARY</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * Specials
  */</comment>
</case><case>case <expr>61</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>364</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_TRUE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>62</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>365</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{ <return>return <expr><name>T_FALSE</name></expr>;</return> }</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * Digits
  */</comment>
</case><case>case <expr>63</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>370</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_DIGIT</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * Identifiers
  */</comment>
</case><case>case <expr>64</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>378</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <expr_stmt><expr><name><name>yylval</name>-&gt;<name>cpVal</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>T_ID</name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * These are parts of the grammar and are returned as is
  */</comment>
</case><case>case <expr>65</expr>:
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>386</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <return>return <expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr>;</return>
}</block>
	<macro><name>YY_BREAK</name></macro>
<comment type="block">/*
  * Anything else is an error
  */</comment>
</case><case>case <expr>66</expr>:
<comment type="block">/* rule 66 can match eol */</comment>
<macro><name>YY_RULE_SETUP</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>393</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>msg</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>yyextra</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Parse error near '%c'"</expr></argument>, <argument><expr><name><name>yytext</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>PERROR</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
	<macro><name>YY_BREAK</name></macro>
</case><case>case <expr>67</expr>:
<decl_stmt><decl><type><name>YY_RULE_SETUP</name></type>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>398</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>
<name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"flex scanner jammed"</expr></argument> )</argument_list></decl>;</decl_stmt>
	<macro><name>YY_BREAK</name></macro>
<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>1523</cpp:number> <cpp:file>"util_expr_scan.c"</cpp:file></cpp:line>
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>INITIAL</name></expr></argument>)</argument_list></call></expr>:
</case><case>case <expr><call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>:
	<expr_stmt><expr><call><name>yyterminate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	</case><case>case <expr><name>YY_END_OF_BUFFER</name></expr>:
		<block>{
		<comment type="block">/* Amount of text matched not including the EOB char. */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>yy_amount_of_matched_text</name> <init>= <expr><call>(<name>int</name>) <argument_list>(<argument><expr><name>yy_cp</name> - <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name></expr></argument>)</argument_list></call> - 1</expr></init></decl>;</decl_stmt>

		<comment type="block">/* Undo the effects of YY_DO_BEFORE_ACTION. */</comment>
		<expr_stmt><expr>*<name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
		<macro><name>YY_RESTORE_YY_MORE_OFFSET</name></macro>

		<if>if <condition>( <expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buffer_status</name></name> == <name>YY_BUFFER_NEW</name></expr> )</condition><then>
			<block>{
			<comment type="block">/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * ap_expr_yylex().  If so, then we have to assure
			 * consistency between YY_CURRENT_BUFFER and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */</comment>
			<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_input_file</name></name> = <name>yyin</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buffer_status</name></name> = <name>YY_BUFFER_NORMAL</name></expr>;</expr_stmt>
			}</block></then></if>

		<comment type="block">/* Note that here we test for yy_c_buf_p "&lt;=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */</comment>
		<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> &lt;= &amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>]</index></name></expr> )</condition><then>
			<block>{ <comment type="block">/* This was really a NUL. */</comment>
			<decl_stmt><decl><type><name>yy_state_type</name></type> <name>yy_next_state</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>yy_amount_of_matched_text</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>yy_current_state</name> = <call><name>yy_get_previous_state</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */</comment>

			<expr_stmt><expr><name>yy_next_state</name> = <call><name>yy_try_NUL_trans</name><argument_list>( <argument><expr><name>yy_current_state</name></expr></argument> , <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>yy_bp</name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</expr_stmt>

			<if>if <condition>( <expr><name>yy_next_state</name></expr> )</condition><then>
				<block>{
				<comment type="block">/* Consume the NUL. */</comment>
				<expr_stmt><expr><name>yy_cp</name> = ++<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>yy_current_state</name> = <name>yy_next_state</name></expr>;</expr_stmt>
				<goto>goto <name>yy_match</name>;</goto>
				}</block></then>

			<else>else
				<block>{
				<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name></expr>;</expr_stmt>
				<goto>goto <name>yy_find_action</name>;</goto>
				}</block></else></if>
			}</block></then>

		<else>else <switch>switch <condition>( <expr><call><name>yy_get_next_buffer</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr> )</condition>
			<block>{
			<case>case <expr><name>EOB_ACT_END_OF_FILE</name></expr>:
				<block>{
				<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name> = 0</expr>;</expr_stmt>

				<if>if <condition>( <expr><call><name>ap_expr_yywrap</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr> )</condition><then>
					<block>{
					<comment type="block">/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */</comment>
					<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>yy_act</name> = <call><name>YY_STATE_EOF</name><argument_list>(<argument><expr><name>YY_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<goto>goto <name>do_action</name>;</goto>
					}</block></then>

				<else>else
					<block>{
					<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name></expr> )</condition><then>
						<expr_stmt><expr><name>YY_NEW_FILE</name></expr>;</expr_stmt></then></if>
					}</block></else></if>
				<break>break;</break>
				}</block>

			</case><case>case <expr><name>EOB_ACT_CONTINUE_SCAN</name></expr>:
				<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> =
					<name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>yy_amount_of_matched_text</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>yy_current_state</name> = <call><name>yy_get_previous_state</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>yy_bp</name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</expr_stmt>
				<goto>goto <name>yy_match</name>;</goto>

			</case><case>case <expr><name>EOB_ACT_LAST_MATCH</name></expr>:
				<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> =
				&amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>]</index></name></expr>;</expr_stmt>

				<expr_stmt><expr><name>yy_current_state</name> = <call><name>yy_get_previous_state</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>yy_bp</name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</expr_stmt>
				<goto>goto <name>yy_find_action</name>;</goto>
			</case>}</block></switch></else></if>
		<break>break;</break>
		}</block>

	</case><default>default:
		<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>(
			<argument><expr>"fatal flex scanner internal error--no action found"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
	</default>}</block></switch> <comment type="block">/* end of action switch */</comment>
		}</block></while> <comment type="block">/* end of scanning one token */</comment>
}</block> <comment type="block">/* end of ap_expr_yylex */</comment>

<comment type="block">/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_get_next_buffer</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>dest</name> <init>= <expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>source</name> <init>= <expr><name><name>yyg</name>-&gt;<name>yytext_ptr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>number_to_move</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ret_val</name></decl>;</decl_stmt>

	<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> &gt; &amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> + 1</expr>]</index></name></expr> )</condition><then>
		<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>(
		<argument><expr>"fatal flex scanner internal error--end of buffer missed"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

	<if>if <condition>( <expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_fill_buffer</name></name> == 0</expr> )</condition><then>
		<block>{ <comment type="block">/* Don't try to fill the buffer, so this is an EOF. */</comment>
		<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> - <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> - <name>YY_MORE_ADJ</name> == 1</expr> )</condition><then>
			<block>{
			<comment type="block">/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */</comment>
			<return>return <expr><name>EOB_ACT_END_OF_FILE</name></expr>;</return>
			}</block></then>

		<else>else
			<block>{
			<comment type="block">/* We matched some text prior to the EOB, first
			 * process it.
			 */</comment>
			<return>return <expr><name>EOB_ACT_LAST_MATCH</name></expr>;</return>
			}</block></else></if>
		}</block></then></if>

	<comment type="block">/* Try to read more data. */</comment>

	<comment type="block">/* First move last chars to start of buffer. */</comment>
	<expr_stmt><expr><name>number_to_move</name> = <call>(<name>int</name>) <argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> - <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>

	<for>for ( <init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>number_to_move</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr> )
		<expr_stmt><expr>*(<name>dest</name>++) = *(<name>source</name>++)</expr>;</expr_stmt></for>

	<if>if <condition>( <expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buffer_status</name></name> == <name>YY_BUFFER_EOF_PENDING</name></expr> )</condition><then>
		<comment type="block">/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */</comment>
		<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name> = <name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> = 0</expr>;</expr_stmt></then>

	<else>else
		<block>{
			<decl_stmt><decl><type><name>int</name></type> <name>num_to_read</name> <init>=
			<expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_size</name></name> - <name>number_to_move</name> - 1</expr></init></decl>;</decl_stmt>

		<while>while <condition>( <expr><name>num_to_read</name> &lt;= 0</expr> )</condition>
			<block>{ <comment type="block">/* Not enough room in the buffer - grow it. */</comment>

			<comment type="block">/* just a shorter name for the current buffer */</comment>
			<decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name> <init>= <expr><name>YY_CURRENT_BUFFER</name></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name>int</name></type> <name>yy_c_buf_p_offset</name> <init>=
				<expr><call>(<name>int</name>) <argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> - <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if>if <condition>( <expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name></expr> )</condition><then>
				<block>{
				<decl_stmt><decl><type><name>int</name></type> <name>new_size</name> <init>= <expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> * 2</expr></init></decl>;</decl_stmt>

				<if>if <condition>( <expr><name>new_size</name> &lt;= 0</expr> )</condition><then>
					<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> += <name><name>b</name>-&gt;<name>yy_buf_size</name></name> / 8</expr>;</expr_stmt></then>
				<else>else
					<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> *= 2</expr>;</expr_stmt></else></if>

				<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name></name> = (<name>char</name> *)
					<comment type="block">/* Include room in for 2 EOB chars. */</comment>
					<call><name>ap_expr_yyrealloc</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr></argument>,<argument><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> + 2</expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
				}</block></then>
			<else>else
				<comment type="block">/* Can't grow it, we don't own it. */</comment>
				<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name></name> = 0</expr>;</expr_stmt></else></if>

			<if>if <condition>( <expr>! <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr> )</condition><then>
				<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>(
				<argument><expr>"fatal error - scanner input buffer overflow"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

			<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = &amp;<name><name>b</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name>yy_c_buf_p_offset</name></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><name>num_to_read</name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_size</name></name> -
						<name>number_to_move</name> - 1</expr>;</expr_stmt>

			}</block></while>

		<if>if <condition>( <expr><name>num_to_read</name> &gt; <name>YY_READ_BUF_SIZE</name></expr> )</condition><then>
			<expr_stmt><expr><name>num_to_read</name> = <name>YY_READ_BUF_SIZE</name></expr>;</expr_stmt></then></if>

		<comment type="block">/* Read in more data. */</comment>
		<expr_stmt><expr><call><name>YY_INPUT</name><argument_list>( <argument><expr>(&amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name>number_to_move</name></expr>]</index></name>)</expr></argument>,
			<argument><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr></argument>, <argument><expr>(<name>size_t</name>) <name>num_to_read</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name> = <name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
		}</block></else></if>

	<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> == 0</expr> )</condition><then>
		<block>{
		<if>if <condition>( <expr><name>number_to_move</name> == <name>YY_MORE_ADJ</name></expr> )</condition><then>
			<block>{
			<expr_stmt><expr><name>ret_val</name> = <name>EOB_ACT_END_OF_FILE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ap_expr_yyrestart</name><argument_list>(<argument><expr><name>yyin</name></expr></argument>  ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then>

		<else>else
			<block>{
			<expr_stmt><expr><name>ret_val</name> = <name>EOB_ACT_LAST_MATCH</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buffer_status</name></name> =
				<name>YY_BUFFER_EOF_PENDING</name></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then>

	<else>else
		<expr_stmt><expr><name>ret_val</name> = <name>EOB_ACT_CONTINUE_SCAN</name></expr>;</expr_stmt></else></if>

	<if>if <condition>(<expr><call>(<name>yy_size_t</name>) <argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> + <name>number_to_move</name></expr></argument>)</argument_list></call> &gt; <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_size</name></name></expr>)</condition><then> <block>{
		<comment type="block">/* Extend the array by 50%, plus the number we really need. */</comment>
		<decl_stmt><decl><type><name>yy_size_t</name></type> <name>new_size</name> <init>= <expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> + <name>number_to_move</name> + (<name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> &gt;&gt; 1)</expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name></name> = (<name>char</name> *) <call><name>ap_expr_yyrealloc</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name></name></expr></argument>,<argument><expr><name>new_size</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>( <expr>! <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name></name></expr> )</condition><then>
			<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in yy_get_next_buffer()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
	}</block></then></if>

	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> += <name>number_to_move</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> + 1</expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> = &amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><name>ret_val</name></expr>;</return>
}</block></function>

<comment type="block">/* yy_get_previous_state - get the state just before the EOB char was reached */</comment>

    <function><type><specifier>static</specifier> <name>yy_state_type</name></type> <name>yy_get_previous_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>yy_state_type</name></type> <name>yy_current_state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>yy_cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>yy_current_state</name> = <name><name>yyg</name>-&gt;<name>yy_start</name></name></expr>;</expr_stmt>

	<for>for ( <init><expr><name>yy_cp</name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>YY_MORE_ADJ</name></expr>;</init> <condition><expr><name>yy_cp</name> &lt; <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</condition> <incr><expr>++<name>yy_cp</name></expr></incr> )
		<block>{
		<decl_stmt><decl><type><name>register</name> <name>YY_CHAR</name></type> <name>yy_c</name> <init>= <expr>(*<name>yy_cp</name> ? <name><name>yy_ec</name><index>[<expr><call><name>YY_SC_TO_UI</name><argument_list>(<argument><expr>*<name>yy_cp</name></expr></argument>)</argument_list></call></expr>]</index></name> : 1)</expr></init></decl>;</decl_stmt>
		<if>if <condition>( <expr><name><name>yy_accept</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr> )</condition><then>
			<block>{
			<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name> = <name>yy_current_state</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name> = <name>yy_cp</name></expr>;</expr_stmt>
			}</block></then></if>
		<while>while <condition>( <expr><name><name>yy_chk</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + <name>yy_c</name></expr>]</index></name> != <name>yy_current_state</name></expr> )</condition>
			<block>{
			<expr_stmt><expr><name>yy_current_state</name> = (<name>int</name>) <name><name>yy_def</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr>;</expr_stmt>
			<if>if <condition>( <expr><name>yy_current_state</name> &gt;= 124</expr> )</condition><then>
				<expr_stmt><expr><name>yy_c</name> = <name><name>yy_meta</name><index>[<expr>(<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt></then></if>
			}</block></while>
		<expr_stmt><expr><name>yy_current_state</name> = <name><name>yy_nxt</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + (<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></for>

	<return>return <expr><name>yy_current_state</name></expr>;</return>
}</block></function>

<comment type="block">/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */</comment>
    <function><type><specifier>static</specifier> <name>yy_state_type</name></type> <name>yy_try_NUL_trans</name>  <parameter_list>(<param><decl><type><name>yy_state_type</name></type> <name>yy_current_state</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>yy_is_jam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt> <comment type="block">/* This var may be unused depending upon options. */</comment>
	<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>yy_cp</name> <init>= <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>register</name> <name>YY_CHAR</name></type> <name>yy_c</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
	<if>if <condition>( <expr><name><name>yy_accept</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr> )</condition><then>
		<block>{
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_state</name></name> = <name>yy_current_state</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_last_accepting_cpos</name></name> = <name>yy_cp</name></expr>;</expr_stmt>
		}</block></then></if>
	<while>while <condition>( <expr><name><name>yy_chk</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + <name>yy_c</name></expr>]</index></name> != <name>yy_current_state</name></expr> )</condition>
		<block>{
		<expr_stmt><expr><name>yy_current_state</name> = (<name>int</name>) <name><name>yy_def</name><index>[<expr><name>yy_current_state</name></expr>]</index></name></expr>;</expr_stmt>
		<if>if <condition>( <expr><name>yy_current_state</name> &gt;= 124</expr> )</condition><then>
			<expr_stmt><expr><name>yy_c</name> = <name><name>yy_meta</name><index>[<expr>(<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt></then></if>
		}</block></while>
	<expr_stmt><expr><name>yy_current_state</name> = <name><name>yy_nxt</name><index>[<expr><name><name>yy_base</name><index>[<expr><name>yy_current_state</name></expr>]</index></name> + (<name>unsigned</name> <name>int</name>) <name>yy_c</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>yy_is_jam</name> = (<name>yy_current_state</name> == 123)</expr>;</expr_stmt>

	<return>return <expr><name>yy_is_jam</name> ? 0 : <name>yy_current_state</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_NO_INPUT</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
    <function><type><specifier>static</specifier> <name>int</name></type> <name>yyinput</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    static int input  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>

	<if>if <condition>( <expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> == <name>YY_END_OF_BUFFER_CHAR</name></expr> )</condition><then>
		<block>{
		<comment type="block">/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */</comment>
		<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> &lt; &amp;<name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_ch_buf</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>]</index></name></expr> )</condition><then>
			<comment type="block">/* This was really a NUL. */</comment>
			<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = '\0'</expr>;</expr_stmt></then>

		<else>else
			<block>{ <comment type="block">/* need more input */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> - <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr>++<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>

			<switch>switch <condition>( <expr><call><name>yy_get_next_buffer</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr> )</condition>
				<block>{
				<case>case <expr><name>EOB_ACT_LAST_MATCH</name></expr>:
					<comment type="block">/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */</comment>

					<comment type="block">/* Reset buffer status. */</comment>
					<expr_stmt><expr><call><name>ap_expr_yyrestart</name><argument_list>(<argument><expr><name>yyin</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*FALLTHROUGH*/</comment>

				</case><case>case <expr><name>EOB_ACT_END_OF_FILE</name></expr>:
					<block>{
					<if>if <condition>( <expr><call><name>ap_expr_yywrap</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr> )</condition><then>
						<return>return <expr><name>EOF</name></expr>;</return></then></if>

					<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name></expr> )</condition><then>
						<expr_stmt><expr><name>YY_NEW_FILE</name></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
					<return>return <expr><call><name>yyinput</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
					<return>return <expr><call><name>input</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					}</block>

				</case><case>case <expr><name>EOB_ACT_CONTINUE_SCAN</name></expr>:
					<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> + <name>offset</name></expr>;</expr_stmt>
					<break>break;</break>
				</case>}</block></switch>
			}</block></else></if>
		}</block></then></if>

	<expr_stmt><expr><name>c</name> = *(<name>unsigned</name> <name>char</name> *) <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>	<comment type="block">/* cast for 8-bit char's */</comment>
	<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = '\0'</expr>;</expr_stmt>	<comment type="block">/* preserve yytext */</comment>
	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_hold_char</name></name> = *++<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>

	<return>return <expr><name>c</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* ifndef YY_NO_INPUT */</comment>

<comment type="block">/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 * @param yyscanner The scanner object.
 * @note This function does not reset the start condition to @c INITIAL .
 */</comment>
    <function><type><name>void</name></type> <name>ap_expr_yyrestart</name>  <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>input_file</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>( <expr>! <name>YY_CURRENT_BUFFER</name></expr> )</condition><then><block>{
        <expr_stmt><expr><call><name>ap_expr_yyensure_buffer_stack</name> <argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> =
            <call><name>ap_expr_yy_create_buffer</name><argument_list>(<argument><expr><name>yyin</name></expr></argument>,<argument><expr><name>YY_BUF_SIZE</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<expr_stmt><expr><call><name>ap_expr_yy_init_buffer</name><argument_list>(<argument><expr><name>YY_CURRENT_BUFFER</name></expr></argument>,<argument><expr><name>input_file</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 * @param yyscanner The scanner object.
 */</comment>
    <function><type><name>void</name></type> <name>ap_expr_yy_switch_to_buffer</name>  <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type>  <name>new_buffer</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* TODO. We should be able to replace this entire function body
	 * with
	 *		ap_expr_yypop_buffer_state();
	 *		ap_expr_yypush_buffer_state(new_buffer);
     */</comment>
	<expr_stmt><expr><call><name>ap_expr_yyensure_buffer_stack</name> <argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>( <expr><name>YY_CURRENT_BUFFER</name> == <name>new_buffer</name></expr> )</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>( <expr><name>YY_CURRENT_BUFFER</name></expr> )</condition><then>
		<block>{
		<comment type="block">/* Flush out information for old buffer. */</comment>
		<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_pos</name></name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name> = <name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
		}</block></then></if>

	<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = <name>new_buffer</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We don't actually know whether we did this switch during
	 * EOF (ap_expr_yywrap()) processing, but the only time this flag
	 * is looked at is after ap_expr_yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */</comment>
	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name> = 1</expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yy_load_buffer_state</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_n_chars</name></name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yytext_ptr</name></name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_pos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>yyin</name> = <name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_input_file</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_hold_char</name></name> = *<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 * @param yyscanner The scanner object.
 * @return the allocated buffer state.
 */</comment>
    <function><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_create_buffer</name>  <parameter_list>(<param><decl><type><name>FILE</name> *</type> <name>file</name></decl></param>, <param><decl><type><name>int</name></type>  <name>size</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl>;</decl_stmt>
    
	<expr_stmt><expr><name>b</name> = (<name>YY_BUFFER_STATE</name>) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>( <argument>struct <expr><name>yy_buffer_state</name></expr></argument> )</argument_list></sizeof></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
		<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yy_create_buffer()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> = <name>size</name></expr>;</expr_stmt>

	<comment type="block">/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */</comment>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name></name> = (<name>char</name> *) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> + 2</expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>( <expr>! <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr> )</condition><then>
		<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yy_create_buffer()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name> = 1</expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ap_expr_yy_init_buffer</name><argument_list>(<argument><expr><name>b</name></expr></argument>,<argument><expr><name>file</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>b</name></expr>;</return>
}</block></function>

<comment type="block">/** Destroy the buffer.
 * @param b a buffer created with ap_expr_yy_create_buffer()
 * @param yyscanner The scanner object.
 */</comment>
    <function><type><name>void</name></type> <name>ap_expr_yy_delete_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type>  <name>b</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
		<return>return;</return></then></if>

	<if>if <condition>( <expr><name>b</name> == <name>YY_CURRENT_BUFFER</name></expr> )</condition><then> <comment type="block">/* Not sure if we should pop here. */</comment>
		<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = (<name>YY_BUFFER_STATE</name>) 0</expr>;</expr_stmt></then></if>

	<if>if <condition>( <expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name></expr> )</condition><then>
		<expr_stmt><expr><call><name>ap_expr_yyfree</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>b</name>-&gt;<name>yy_ch_buf</name></name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>ap_expr_yyfree</name><argument_list>(<argument><expr>(<name>void</name> *) <name>b</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a ap_expr_yyrestart() or at EOF.
 */</comment>
    <function><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yy_init_buffer</name>  <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type>  <name>b</name></decl></param>, <param><decl><type><name>FILE</name> *</type> <name>file</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>

<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>oerrno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ap_expr_yy_flush_buffer</name><argument_list>(<argument><expr><name>b</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_input_file</name></name> = <name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_fill_buffer</name></name> = 1</expr>;</expr_stmt>

    <comment type="block">/* If b is the current buffer, then ap_expr_yy_init_buffer was _probably_
     * called from ap_expr_yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */</comment>
    <if>if <condition>(<expr><name>b</name> != <name>YY_CURRENT_BUFFER</name></expr>)</condition><then><block>{
        <expr_stmt><expr><name><name>b</name>-&gt;<name>yy_bs_lineno</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>b</name>-&gt;<name>yy_bs_column</name></name> = 0</expr>;</expr_stmt>
    }</block></then></if>

        <expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_interactive</name></name> = 0</expr>;</expr_stmt>
    
	<expr_stmt><expr><name>errno</name> = <name>oerrno</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 * @param yyscanner The scanner object.
 */</comment>
    <function><type><name>void</name></type> <name>ap_expr_yy_flush_buffer</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type>  <name>b</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_n_chars</name></name> = 0</expr>;</expr_stmt>

	<comment type="block">/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */</comment>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name><index>[<expr>0</expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_ch_buf</name><index>[<expr>1</expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_pos</name></name> = &amp;<name><name>b</name>-&gt;<name>yy_ch_buf</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_at_bol</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buffer_status</name></name> = <name>YY_BUFFER_NEW</name></expr>;</expr_stmt>

	<if>if <condition>( <expr><name>b</name> == <name>YY_CURRENT_BUFFER</name></expr> )</condition><then>
		<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>

<comment type="block">/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *  @param yyscanner The scanner object.
 */</comment>
<function><type><name>void</name></type> <name>ap_expr_yypush_buffer_state</name> <parameter_list>(<param><decl><type><name>YY_BUFFER_STATE</name></type> <name>new_buffer</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr><name>new_buffer</name> == <name>NULL</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><call><name>ap_expr_yyensure_buffer_stack</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This block is copied from ap_expr_yy_switch_to_buffer. */</comment>
	<if>if <condition>( <expr><name>YY_CURRENT_BUFFER</name></expr> )</condition><then>
		<block>{
		<comment type="block">/* Flush out information for old buffer. */</comment>
		<expr_stmt><expr>*<name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = <name><name>yyg</name>-&gt;<name>yy_hold_char</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_buf_pos</name></name> = <name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>YY_CURRENT_BUFFER_LVALUE</name>-&gt;<name>yy_n_chars</name></name> = <name><name>yyg</name>-&gt;<name>yy_n_chars</name></name></expr>;</expr_stmt>
		}</block></then></if>

	<comment type="block">/* Only push if top exists. Otherwise, replace top. */</comment>
	<if>if <condition>(<expr><name>YY_CURRENT_BUFFER</name></expr>)</condition><then>
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name>++</expr>;</expr_stmt></then></if>
	<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = <name>new_buffer</name></expr>;</expr_stmt>

	<comment type="block">/* copied from ap_expr_yy_switch_to_buffer. */</comment>
	<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *  @param yyscanner The scanner object.
 */</comment>
<function><type><name>void</name></type> <name>ap_expr_yypop_buffer_state</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>(<expr>!<name>YY_CURRENT_BUFFER</name></expr>)</condition><then>
		<return>return;</return></then></if>

	<expr_stmt><expr><call><name>ap_expr_yy_delete_buffer</name><argument_list>(<argument><expr><name>YY_CURRENT_BUFFER</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = <name>NULL</name></expr>;</expr_stmt>
	<if>if <condition>(<expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name> &gt; 0</expr>)</condition><then>
		<expr_stmt><expr>--<name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name></expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><name>YY_CURRENT_BUFFER</name></expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>ap_expr_yy_load_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_did_buffer_switch_on_eof</name></name> = 1</expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<comment type="block">/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ap_expr_yyensure_buffer_stack</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>int</name></type> <name>num_to_alloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

	<if>if <condition>(<expr>!<name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr>)</condition><then> <block>{

		<comment type="block">/* First allocation is just for 2 elements, since we don't know if this
		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
		 * immediate realloc on the next call.
         */</comment>
		<expr_stmt><expr><name>num_to_alloc</name> = 1</expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> = (struct <name>yy_buffer_state</name>**)<call><name>ap_expr_yyalloc</name>
								<argument_list>(<argument><expr><name>num_to_alloc</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>yy_buffer_state</name>*</expr></argument>)</argument_list></sizeof></expr></argument>
								, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr> )</condition><then>
			<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yyensure_buffer_stack()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
								  
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>num_to_alloc</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>yy_buffer_state</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name> = <name>num_to_alloc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name> = 0</expr>;</expr_stmt>
		<return>return;</return>
	}</block></then></if>

	<if>if <condition>(<expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name> &gt;= (<name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name>) - 1</expr>)</condition><then><block>{

		<comment type="block">/* Increase the buffer to prepare for a possible push. */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>grow_size</name> <init>= <expr>8</expr></init></decl> <comment type="block">/* arbitrary grow size */</comment>;</decl_stmt>

		<expr_stmt><expr><name>num_to_alloc</name> = <name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name> + <name>grow_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> = (struct <name>yy_buffer_state</name>**)<call><name>ap_expr_yyrealloc</name>
								<argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr></argument>,
								<argument><expr><name>num_to_alloc</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>yy_buffer_state</name>*</expr></argument>)</argument_list></sizeof></expr></argument>
								, <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr> )</condition><then>
			<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yyensure_buffer_stack()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

		<comment type="block">/* zero only the new slots.*/</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> + <name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>grow_size</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>yy_buffer_state</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name> = <name>num_to_alloc</name></expr>;</expr_stmt>
	}</block></then></if>
}</block></function>

<comment type="block">/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object. 
 */</comment>
<function><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_buffer</name>  <parameter_list>(<param><decl><type><name>char</name> *</type> <name>base</name></decl></param>, <param><decl><type><name>yy_size_t</name></type>  <name>size</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl>;</decl_stmt>
    
	<if>if <condition>( <expr><name>size</name> &lt; 2 ||
	     <name><name>base</name><index>[<expr><name>size</name>-2</expr>]</index></name> != <name>YY_END_OF_BUFFER_CHAR</name> ||
	     <name><name>base</name><index>[<expr><name>size</name>-1</expr>]</index></name> != <name>YY_END_OF_BUFFER_CHAR</name></expr> )</condition><then>
		<comment type="block">/* They forgot to leave room for the EOB's. */</comment>
		<return>return <expr>0</expr>;</return></then></if>

	<expr_stmt><expr><name>b</name> = (<name>YY_BUFFER_STATE</name>) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>( <argument>struct <expr><name>yy_buffer_state</name></expr></argument> )</argument_list></sizeof></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
		<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yy_scan_buffer()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_size</name></name> = <name>size</name> - 2</expr>;</expr_stmt>	<comment type="block">/* "- 2" to take care of EOB's */</comment>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buf_pos</name></name> = <name><name>b</name>-&gt;<name>yy_ch_buf</name></name> = <name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_input_file</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_n_chars</name></name> = <name><name>b</name>-&gt;<name>yy_buf_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_interactive</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_at_bol</name></name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_fill_buffer</name></name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_buffer_status</name></name> = <name>YY_BUFFER_NEW</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ap_expr_yy_switch_to_buffer</name><argument_list>(<argument><expr><name>b</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>b</name></expr>;</return>
}</block></function>

<comment type="block">/** Setup the input buffer state to scan a string. The next call to ap_expr_yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       ap_expr_yy_scan_bytes() instead.
 */</comment>
<function><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_string</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type> <name>yystr</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    
	<return>return <expr><call><name>ap_expr_yy_scan_bytes</name><argument_list>(<argument><expr><name>yystr</name></expr></argument>,<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>yystr</name></expr></argument>)</argument_list></call></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/** Setup the input buffer state to scan the given bytes. The next call to ap_expr_yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 * @param yyscanner The scanner object.
 * @return the newly allocated buffer state object.
 */</comment>
<function><type><name>YY_BUFFER_STATE</name></type> <name>ap_expr_yy_scan_bytes</name>  <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type> <name>yybytes</name></decl></param>, <param><decl><type><name>int</name></type>  <name>_yybytes_len</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>YY_BUFFER_STATE</name></type> <name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>yy_size_t</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    
	<comment type="block">/* Get memory for full buffer, including space for trailing EOB's. */</comment>
	<expr_stmt><expr><name>n</name> = <name>_yybytes_len</name> + 2</expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> = (<name>char</name> *) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><name>n</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>( <expr>! <name>buf</name></expr> )</condition><then>
		<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of dynamic memory in ap_expr_yy_scan_bytes()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

	<for>for ( <init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>_yybytes_len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr> )
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>yybytes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>

	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>_yybytes_len</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>_yybytes_len</name>+1</expr>]</index></name> = <name>YY_END_OF_BUFFER_CHAR</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>b</name> = <call><name>ap_expr_yy_scan_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><name>n</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if>if <condition>( <expr>! <name>b</name></expr> )</condition><then>
		<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"bad buffer in ap_expr_yy_scan_bytes()"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

	<comment type="block">/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */</comment>
	<expr_stmt><expr><name><name>b</name>-&gt;<name>yy_is_our_buffer</name></name> = 1</expr>;</expr_stmt>

	<return>return <expr><name>b</name></expr>;</return>
}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type> <name>yy_push_state</name> <parameter_list>(<param><decl><type><name>int</name></type>  <name>new_state</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>( <expr><name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name> &gt;= <name><name>yyg</name>-&gt;<name>yy_start_stack_depth</name></name></expr> )</condition><then>
		<block>{
		<decl_stmt><decl><type><name>yy_size_t</name></type> <name>new_size</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack_depth</name></name> += <name>YY_START_STACK_INCR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_size</name> = <name><name>yyg</name>-&gt;<name>yy_start_stack_depth</name></name> * <sizeof>sizeof<argument_list>( <argument><expr><name>int</name></expr></argument> )</argument_list></sizeof></expr>;</expr_stmt>

		<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_start_stack</name></name></expr> )</condition><then>
			<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name> = (<name>int</name> *) <call><name>ap_expr_yyalloc</name><argument_list>(<argument><expr><name>new_size</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></then>

		<else>else
			<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name> = (<name>int</name> *) <call><name>ap_expr_yyrealloc</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>yyg</name>-&gt;<name>yy_start_stack</name></name></expr></argument>,<argument><expr><name>new_size</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt></else></if>

		<if>if <condition>( <expr>! <name><name>yyg</name>-&gt;<name>yy_start_stack</name></name></expr> )</condition><then>
			<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"out of memory expanding start-condition stack"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>
		}</block></then></if>

	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name>++</expr>]</index></name> = <name>YY_START</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name>new_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

    <function><type><specifier>static</specifier> <name>void</name></type> <name>yy_pop_state</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
	<if>if <condition>( <expr>--<name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name> &lt; 0</expr> )</condition><then>
		<expr_stmt><expr><call><name>YY_FATAL_ERROR</name><argument_list>( <argument><expr>"start-condition stack underflow"</expr></argument> )</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>BEGIN</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name><index>[<expr><name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>YY_EXIT_FAILURE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YY_EXIT_FAILURE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_fatal_error</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name>*</type> <name>msg</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    	<expr_stmt><expr>(<name>void</name>) <call><name>fprintf</name><argument_list>( <argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>msg</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exit</name><argument_list>( <argument><expr><name>YY_EXIT_FAILURE</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Redefine yyless() so it works in section 3 code. */</comment>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>yyless</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>yyless</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> \
	<cpp:value>do \
		{ \
		<comment type="block">/* Undo effects of setting up yytext. */</comment> \
        int yyless_macro_arg = (n); \
        YY_LESS_LINENO(yyless_macro_arg);\
		yytext[yyleng] = yyg-&gt;yy_hold_char; \
		yyg-&gt;yy_c_buf_p = yytext + yyless_macro_arg; \
		yyg-&gt;yy_hold_char = *yyg-&gt;yy_c_buf_p; \
		*yyg-&gt;yy_c_buf_p = '\0'; \
		yyleng = yyless_macro_arg; \
		} \
	while ( 0 )</cpp:value></cpp:define>

<comment type="block">/* Accessor  methods (get/set functions) to struct members. */</comment>

<comment type="block">/** Get the user-defined data for this scanner.
 * @param yyscanner The scanner object.
 */</comment>
<function><type><name>YY_EXTRA_TYPE</name></type> <name>ap_expr_yyget_extra</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>yyextra</name></expr>;</return>
}</block></function>

<comment type="block">/** Get the current line number.
 * @param yyscanner The scanner object.
 */</comment>
<function><type><name>int</name></type> <name>ap_expr_yyget_lineno</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    
        <if>if <condition>(<expr>! <name>YY_CURRENT_BUFFER</name></expr>)</condition><then>
            <return>return <expr>0</expr>;</return></then></if>
    
    <return>return <expr><name>yylineno</name></expr>;</return>
}</block></function>

<comment type="block">/** Get the current column number.
 * @param yyscanner The scanner object.
 */</comment>

<comment type="block">/** Get the input stream.
 * @param yyscanner The scanner object.
 */</comment>
<function><type><name>FILE</name> *</type><name>ap_expr_yyget_in</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>yyin</name></expr>;</return>
}</block></function>

<comment type="block">/** Get the output stream.
 * @param yyscanner The scanner object.
 */</comment>
<function><type><name>FILE</name> *</type><name>ap_expr_yyget_out</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>yyout</name></expr>;</return>
}</block></function>

<comment type="block">/** Get the length of the current token.
 * @param yyscanner The scanner object.
 */</comment>
<function><type><name>int</name></type> <name>ap_expr_yyget_leng</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>yyleng</name></expr>;</return>
}</block></function>

<comment type="block">/** Get the current token.
 * @param yyscanner The scanner object.
 */</comment>

<function><type><name>char</name> *</type><name>ap_expr_yyget_text</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>yytext</name></expr>;</return>
}</block></function>

<comment type="block">/** Set the user-defined data. This data is never touched by the scanner.
 * @param user_defined The data to be associated with this scanner.
 * @param yyscanner The scanner object.
 */</comment>
<function><type><name>void</name></type> <name>ap_expr_yyset_extra</name> <parameter_list>(<param><decl><type><name>YY_EXTRA_TYPE</name></type>  <name>user_defined</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>yyextra</name> = <name>user_defined</name></expr> ;</expr_stmt>
}</block></function>

<comment type="block">/** Set the current line number.
 * @param line_number
 * @param yyscanner The scanner object.
 */</comment>
<function><type><name>void</name></type> <name>ap_expr_yyset_lineno</name> <parameter_list>(<param><decl><type><name>int</name></type>  <name>line_number</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* lineno is only valid if an input buffer exists. */</comment>
        <if>if <condition>(<expr>! <name>YY_CURRENT_BUFFER</name></expr> )</condition><then>
           <expr_stmt><expr><call><name>yy_fatal_error</name><argument_list>( <argument><expr>"ap_expr_yyset_lineno called with no buffer"</expr></argument> , <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if> 
    
    <expr_stmt><expr><name>yylineno</name> = <name>line_number</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/** Set the current column.
 * @param line_number
 * @param yyscanner The scanner object.
 */</comment>

<comment type="block">/** Set the input stream. This does not discard the current
 * input buffer.
 * @param in_str A readable stream.
 * @param yyscanner The scanner object.
 * @see ap_expr_yy_switch_to_buffer
 */</comment>
<function><type><name>void</name></type> <name>ap_expr_yyset_in</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type>  <name>in_str</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>yyin</name> = <name>in_str</name></expr> ;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>ap_expr_yyset_out</name> <parameter_list>(<param><decl><type><name>FILE</name> *</type>  <name>out_str</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>yyout</name> = <name>out_str</name></expr> ;</expr_stmt>
}</block></function>

<function><type><name>int</name></type> <name>ap_expr_yyget_debug</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>yy_flex_debug</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>ap_expr_yyset_debug</name> <parameter_list>(<param><decl><type><name>int</name></type>  <name>bdebug</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>yy_flex_debug</name> = <name>bdebug</name></expr> ;</expr_stmt>
}</block></function>

<comment type="block">/* Accessor methods for yylval and yylloc */</comment>

<function><type><name>YYSTYPE</name> *</type> <name>ap_expr_yyget_lval</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>yylval</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>ap_expr_yyset_lval</name> <parameter_list>(<param><decl><type><name>YYSTYPE</name> *</type>  <name>yylval_param</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>yylval</name> = <name>yylval_param</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* User-visible API */</comment>

<comment type="block">/* ap_expr_yylex_init is special because it creates the scanner itself, so it is
 * the ONLY reentrant function that doesn't take the scanner as the last argument.
 * That's why we explicitly handle the declaration, instead of using our macros.
 */</comment>

<function><type><name>int</name></type> <name>ap_expr_yylex_init</name><parameter_list>(<param><decl><type><name>yyscan_t</name>*</type> <name>ptr_yy_globals</name></decl></param>)</parameter_list>

<block>{
    <if>if <condition>(<expr><name>ptr_yy_globals</name> == <name>NULL</name></expr>)</condition><then><block>{
        <expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>ptr_yy_globals</name> = (<name>yyscan_t</name>) <call><name>ap_expr_yyalloc</name> <argument_list>( <argument><expr><sizeof>sizeof<argument_list>( <argument>struct <expr><name>yyguts_t</name></expr></argument> )</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>*<name>ptr_yy_globals</name> == <name>NULL</name></expr>)</condition><then><block>{
        <expr_stmt><expr><name>errno</name> = <name>ENOMEM</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>*<name>ptr_yy_globals</name></expr></argument>,<argument><expr>0x00</expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>yyguts_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>yy_init_globals</name> <argument_list>( <argument><expr>*<name>ptr_yy_globals</name></expr></argument> )</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ap_expr_yylex_init_extra has the same functionality as ap_expr_yylex_init, but follows the
 * convention of taking the scanner as the last argument. Note however, that
 * this is a *pointer* to a scanner, as it will be allocated by this call (and
 * is the reason, too, why this function also must handle its own declaration).
 * The user defined value in the first argument will be available to ap_expr_yyalloc in
 * the yyextra field.
 */</comment>

<function><type><name>int</name></type> <name>ap_expr_yylex_init_extra</name><parameter_list>(<param><decl><type><name>YY_EXTRA_TYPE</name></type> <name>yy_user_defined</name></decl></param>,<param><decl><type><name>yyscan_t</name>*</type> <name>ptr_yy_globals</name></decl></param> )</parameter_list>

<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name></type> <name>dummy_yyguts</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_expr_yyset_extra</name> <argument_list>(<argument><expr><name>yy_user_defined</name></expr></argument>, <argument><expr>&amp;<name>dummy_yyguts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>ptr_yy_globals</name> == <name>NULL</name></expr>)</condition><then><block>{
        <expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
	
    <expr_stmt><expr>*<name>ptr_yy_globals</name> = (<name>yyscan_t</name>) <call><name>ap_expr_yyalloc</name> <argument_list>( <argument><expr><sizeof>sizeof<argument_list>( <argument>struct <expr><name>yyguts_t</name></expr></argument> )</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>dummy_yyguts</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
	
    <if>if <condition>(<expr>*<name>ptr_yy_globals</name> == <name>NULL</name></expr>)</condition><then><block>{
        <expr_stmt><expr><name>errno</name> = <name>ENOMEM</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    
    <comment type="block">/* By setting to 0xAA, we expose bugs in
    yy_init_globals. Leave at 0x00 for releases. */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>*<name>ptr_yy_globals</name></expr></argument>,<argument><expr>0x00</expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>yyguts_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>ap_expr_yyset_extra</name> <argument_list>(<argument><expr><name>yy_user_defined</name></expr></argument>, <argument><expr>*<name>ptr_yy_globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><call><name>yy_init_globals</name> <argument_list>( <argument><expr>*<name>ptr_yy_globals</name></expr></argument> )</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_init_globals</name> <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Initialization is the same as for the non-reentrant scanner.
     * This function is called from ap_expr_yylex_destroy(), so don't allocate here.
     */</comment>

    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_top</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack_max</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_c_buf_p</name></name> = (<name>char</name> *) 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_init</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start</name></name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack_ptr</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack_depth</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name> =  <name>NULL</name></expr>;</expr_stmt>

<comment type="block">/* Defined in main.c */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YY_STDINIT</name></cpp:ifdef>
    <expr_stmt><expr><name>yyin</name> = <name>stdin</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>yyout</name> = <name>stdout</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>yyin</name> = (<name>FILE</name> *) 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>yyout</name> = (<name>FILE</name> *) 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* For future reference: Set errno on error, since we are called by
     * ap_expr_yylex_init()
     */</comment>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* ap_expr_yylex_destroy is for both reentrant and non-reentrant scanners. */</comment>
<function><type><name>int</name></type> <name>ap_expr_yylex_destroy</name>  <parameter_list>(<param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>yyguts_t</name> *</type> <name>yyg</name> <init>= <expr>(struct <name>yyguts_t</name>*)<name>yyscanner</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Pop the buffer stack, destroying each element. */</comment>
	<while>while<condition>(<expr><name>YY_CURRENT_BUFFER</name></expr>)</condition><block>{
		<expr_stmt><expr><call><name>ap_expr_yy_delete_buffer</name><argument_list>(<argument><expr><name>YY_CURRENT_BUFFER</name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>YY_CURRENT_BUFFER_LVALUE</name> = <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ap_expr_yypop_buffer_state</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></while>

	<comment type="block">/* Destroy the stack itself. */</comment>
	<expr_stmt><expr><call><name>ap_expr_yyfree</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_buffer_stack</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Destroy the start condition stack. */</comment>
        <expr_stmt><expr><call><name>ap_expr_yyfree</name><argument_list>(<argument><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name></expr></argument> ,<argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>yyg</name>-&gt;<name>yy_start_stack</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Reset the globals. This is important in a non-reentrant scanner so the next time
     * ap_expr_yylex() is called, initialization will occur. */</comment>
    <expr_stmt><expr><call><name>yy_init_globals</name><argument_list>( <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Destroy the main struct (reentrant only). */</comment>
    <expr_stmt><expr><call><name>ap_expr_yyfree</name> <argument_list>( <argument><expr><name>yyscanner</name></expr></argument> , <argument><expr><name>yyscanner</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>yyscanner</name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * Internal utility routines.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>yytext_ptr</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>yy_flex_strncpy</name> <parameter_list>(<param><decl><type><name>char</name>*</type> <name>s1</name></decl></param>, <param><decl><type><name>yyconst</name> <name>char</name> *</type> <name>s2</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for ( <init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr> )
		<expr_stmt><expr><name><name>s1</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>s2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>YY_NEED_STRLEN</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>yy_flex_strlen</name> <parameter_list>(<param><decl><type><name>yyconst</name> <name>char</name> *</type> <name>s</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>n</name></decl>;</decl_stmt>
	<for>for ( <init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr> )
		<empty_stmt>;</empty_stmt></for>

	<return>return <expr><name>n</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name> *</type><name>ap_expr_yyalloc</name> <parameter_list>(<param><decl><type><name>yy_size_t</name></type>  <name>size</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr>(<name>void</name> *) <call><name>malloc</name><argument_list>( <argument><expr><name>size</name></expr></argument> )</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name> *</type><name>ap_expr_yyrealloc</name>  <parameter_list>(<param><decl><type><name>void</name> *</type> <name>ptr</name></decl></param>, <param><decl><type><name>yy_size_t</name></type>  <name>size</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<comment type="block">/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */</comment>
	<return>return <expr>(<name>void</name> *) <call><name>realloc</name><argument_list>( <argument><expr>(<name>char</name> *) <name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument> )</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>ap_expr_yyfree</name> <parameter_list>(<param><decl><type><name>void</name> *</type> <name>ptr</name></decl></param> , <param><decl><type><name>yyscan_t</name></type> <name>yyscanner</name></decl></param>)</parameter_list>
<block>{
	<expr_stmt><expr><call><name>free</name><argument_list>( <argument><expr>(<name>char</name> *) <name>ptr</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* see ap_expr_yyrealloc() for (char *) cast */</comment>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>YYTABLES_NAME</name></cpp:macro> <cpp:value>"yytables"</cpp:value></cpp:define>

<cpp:line>#<cpp:directive>line</cpp:directive> <cpp:number>398</cpp:number> <cpp:file>"util_expr_scan.l"</cpp:file></cpp:line>





</unit>
