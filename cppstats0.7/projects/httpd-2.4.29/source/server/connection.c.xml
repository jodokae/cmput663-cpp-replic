<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/connection.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>

<macro><name>APR_HOOK_STRUCT</name><argument_list>(
            <argument>APR_HOOK_LINK(create_connection)
            APR_HOOK_LINK(process_connection)
            APR_HOOK_LINK(pre_connection)
            APR_HOOK_LINK(pre_close_connection)</argument>
)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>conn_rec *</argument>,<argument>create_connection</argument>,
                            <argument>(apr_pool_t *p, server_rec *server, apr_socket_t *csd, long conn_id, void *sbh, apr_bucket_alloc_t *alloc)</argument>,
                            <argument>(p, server, csd, conn_id, sbh, alloc)</argument>, <argument>NULL</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>int</argument>,<argument>process_connection</argument>,<argument>(conn_rec *c)</argument>,<argument>(c)</argument>,<argument>DECLINED</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_ALL</name><argument_list>(<argument>int</argument>,<argument>pre_connection</argument>,<argument>(conn_rec *c, void *csd)</argument>,<argument>(c, csd)</argument>,<argument>OK</argument>,<argument>DECLINED</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_ALL</name><argument_list>(<argument>int</argument>,<argument>pre_close_connection</argument>,<argument>(conn_rec *c)</argument>,<argument>(c)</argument>,<argument>OK</argument>,<argument>DECLINED</argument>)</argument_list></macro>

<comment type="block">/*
 * More machine-dependent networking gooo... on some systems,
 * you've got to be *really* sure that all the packets are acknowledged
 * before closing the connection, since the client will not be able
 * to see the last response if their TCP buffer is flushed by a RST
 * packet from us, which is what the server's TCP stack will send
 * if it receives any request data after closing the connection.
 *
 * In an ideal world, this function would be accomplished by simply
 * setting the socket option SO_LINGER and handling it within the
 * server's TCP stack while the process continues on to the next request.
 * Unfortunately, it seems that most (if not all) operating systems
 * block the server process on close() when SO_LINGER is used.
 * For those that don't, see USE_SO_LINGER below.  For the rest,
 * we have created a home-brew lingering_close.
 *
 * Many operating systems tend to block, puke, or otherwise mishandle
 * calls to shutdown only half of the connection.  You should define
 * NO_LINGCLOSE in ap_config.h if such is the case for your system.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX_SECS_TO_LINGER</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SECS_TO_LINGER</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_shutdown_conn</name><argument_list>(<argument>conn_rec *c</argument>, <argument>int flush</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>flush</name></expr>)</condition><then> <block>{
        <comment type="block">/* FLUSH bucket */</comment>
        <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* End Of Connection bucket */</comment>
    <expr_stmt><expr><name>b</name> = <call><name>ap_bucket_eoc_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block>

<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_flush_conn</name><argument_list>(<argument>conn_rec *c</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr>(<name>void</name>)<call><name>ap_shutdown_conn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_prep_lingering_close</name><argument_list>(<argument>conn_rec *c</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* Give protocol handlers one last chance to raise their voice */</comment>
    <expr_stmt><expr><call><name>ap_run_pre_close_connection</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name><name>c</name>-&gt;<name>sbh</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_update_child_status</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>sbh</name></name></expr></argument>, <argument><expr><name>SERVER_CLOSING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block>

<comment type="block">/* we now proceed to read from the client until we get EOF, or until
 * MAX_SECS_TO_LINGER has passed.  The reasons for doing this are
 * documented in a draft:
 *
 * http://tools.ietf.org/html/draft-ietf-http-connection-00.txt
 *
 * in a nutshell -- if we don't make this effort we risk causing
 * TCP RST packets to be sent which can tear down a connection before
 * all the response data has been sent to the client.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECONDS_TO_LINGER</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_start_lingering_close</name><argument_list>(<argument>conn_rec *c</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>csd</name> <init>= <expr><call><name>ap_get_conn_socket</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>csd</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ap_prep_lingering_close</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_LINGCLOSE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ap_flush_conn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* just close it */</comment>
    <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Close the connection, being careful to send out whatever is still
     * in our buffers.  If possible, try to avoid a hard close until the
     * client has ACKed our FIN and/or has stopped sending us data.
     */</comment>

    <comment type="block">/* Send any leftover data to the client, but never try to again */</comment>
    <expr_stmt><expr><call><name>ap_flush_conn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Shut down the socket for write, which will send a FIN
     * to the peer.
     */</comment>
    <if>if <condition>(<expr><call><name>apr_socket_shutdown</name><argument_list>(<argument><expr><name>csd</name></expr></argument>, <argument><expr><name>APR_SHUTDOWN_WRITE</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name>
        || <name><name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_lingering_close</name><argument_list>(<argument>conn_rec *c</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>dummybuf</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>now</name></decl>, <decl><type ref="prev"/><name>timeup</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>csd</name> <init>= <expr><call><name>ap_get_conn_socket</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>ap_start_lingering_close</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* Read available data from the client whilst it continues sending
     * it, for a maximum time of MAX_SECS_TO_LINGER.  If the client
     * does not send any data within 2 seconds (a value pulled from
     * Apache 1.3 which seems to work well), give up.
     */</comment>
    <expr_stmt><expr><call><name>apr_socket_timeout_set</name><argument_list>(<argument><expr><name>csd</name></expr></argument>, <argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>SECONDS_TO_LINGER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_socket_opt_set</name><argument_list>(<argument><expr><name>csd</name></expr></argument>, <argument><expr><name>APR_INCOMPLETE_READ</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The common path here is that the initial apr_socket_recv() call
     * will return 0 bytes read; so that case must avoid the expensive
     * apr_time_now() call and time arithmetic. */</comment>

    <do>do <block>{
        <expr_stmt><expr><name>nbytes</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>dummybuf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>apr_socket_recv</name><argument_list>(<argument><expr><name>csd</name></expr></argument>, <argument><expr><name>dummybuf</name></expr></argument>, <argument><expr>&amp;<name>nbytes</name></expr></argument>)</argument_list></call> || <name>nbytes</name> == 0</expr>)</condition><then>
            <break>break;</break></then></if>

        <expr_stmt><expr><name>now</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>timeup</name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/*
             * First time through;
             * calculate now + 30 seconds (MAX_SECS_TO_LINGER).
             *
             * If some module requested a shortened waiting period, only wait for
             * 2s (SECONDS_TO_LINGER). This is useful for mitigating certain
             * DoS attacks.
             */</comment>
            <if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"short-lingering-close"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>timeup</name> = <name>now</name> + <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>SECONDS_TO_LINGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>timeup</name> = <name>now</name> + <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>MAX_SECS_TO_LINGER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <continue>continue;</continue>
        }</block></then></if>
    }</block> while <condition>(<expr><name>now</name> &lt; <name>timeup</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_process_connection</name><argument_list>(<argument>conn_rec *c</argument>, <argument>void *csd</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ap_update_vhost_given_ip</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> = <call><name>ap_run_pre_connection</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rc</name> != <name>OK</name> &amp;&amp; <name>rc</name> != <name>DONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>c</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_run_process_connection</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block>
</unit>
