<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/util.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * util.c: string utility things
 *
 * 3/21/93 Rob McCool
 * 1995-96 Many changes by the Apache Software Foundation
 *
 */</comment>

<comment type="block">/* Debugging aid:
 * #define DEBUG            to trace all cfg_open*()/cfg_closefile() calls
 * #define DEBUG_CFG_LINES  to trace every line read from the config files
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STDIO</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_PROCESS_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;process.h&gt;</cpp:file></cpp:include>            <comment type="block">/* for getpid() on Win32 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_NETDB_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>              <comment type="block">/* for gethostbyname() */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_base64.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ebcdic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_varbuf.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PWD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GRP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_LOADAVG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/loadavg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>

<comment type="block">/* A bunch of functions in util.c scan strings looking for certain characters.
 * To make that more efficient we encode a lookup table.  The test_char_table
 * is generated automatically by gen_test_char.c.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"test_char.h"</cpp:file></cpp:include>

<comment type="block">/* we assume the folks using this ensure 0 &lt;= c &lt; 256... which means
 * you need a cast to (unsigned char) first, you can't just plug a
 * char in here and get it to work, because if char is signed then it
 * will first be sign extended.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_CHAR</name><parameter_list>(<param><type><name>c</name></type></param>, <param><type><name>f</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>(test_char_table[(unsigned char)(c)] &amp; (f))</cpp:value></cpp:define>

<comment type="block">/* Win32/NetWare/OS2 need to check for both forward and back slashes
 * in ap_getparents() and ap_escape_url.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASE_BLIND_FILESYSTEM</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SLASH</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((s == '/') || (s == '\\'))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLASHES</name></cpp:macro> <cpp:value>"/\\"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SLASH</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(s == '/')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLASHES</name></cpp:macro> <cpp:value>"/"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* we know core's module_index is 0 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APLOG_MODULE_INDEX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro> <cpp:value>AP_CORE_MODULE_INDEX</cpp:value></cpp:define>

<comment type="block">/*
 * Examine a field value (such as a media-/content-type) string and return
 * it sans any parameters; e.g., strip off any ';charset=foo' and the like.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_field_noparam</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *intype</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>semi</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>intype</name> == <name>NULL</name></expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>semi</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>intype</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>semi</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>intype</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
    <else>else <block>{
        <while>while <condition>(<expr>(<name>semi</name> &gt; <name>intype</name>) &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>semi</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><name>semi</name>--</expr>;</expr_stmt>
        }</block></while>
        <return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>intype</name></expr></argument>, <argument><expr><name>semi</name> - <name>intype</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_ht_time</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>apr_time_t t</argument>, <argument>const char *fmt</argument>,
                              <argument>int gmt</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>retcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>ts</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tf</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>xt</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>gmt</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>f</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>strp</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>apr_time_exp_gmt</name><argument_list>(<argument><expr>&amp;<name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Convert %Z to "GMT" and %z to "+0000";
         * on hosts that do not have a time zone string in struct tm,
         * strftime must assume its argument is local time.
         */</comment>
        <for>for(<init><expr><name>strp</name> = <name>tf</name></expr>, <expr><name>f</name> = <name>fmt</name></expr>;</init> <condition><expr><name>strp</name> &lt; <name>tf</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>tf</name></expr></argument>)</argument_list></sizeof> - 6 &amp;&amp; (*<name>strp</name> = *<name>f</name>)</expr>
            ;</condition> <incr><expr><name>f</name>++</expr>, <expr><name>strp</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>f</name> != '%'</expr>)</condition><then> <continue>continue;</continue></then></if>
            <switch>switch <condition>(<expr><name><name>f</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr>'%'</expr>:
                <expr_stmt><expr>*++<name>strp</name> = *++<name>f</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'Z'</expr>:
                <expr_stmt><expr>*<name>strp</name>++ = 'G'</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>strp</name>++ = 'M'</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>strp</name> = 'T'</expr>;</expr_stmt>
                <expr_stmt><expr><name>f</name>++</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'z'</expr>: <comment type="block">/* common extension */</comment>
                <expr_stmt><expr>*<name>strp</name>++ = '+'</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>strp</name>++ = '0'</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>strp</name>++ = '0'</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>strp</name>++ = '0'</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>strp</name> = '0'</expr>;</expr_stmt>
                <expr_stmt><expr><name>f</name>++</expr>;</expr_stmt>
                <break>break;</break>
            </case>}</block></switch>
        }</block></for>
        <expr_stmt><expr>*<name>strp</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name>fmt</name> = <name>tf</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* check return code? */</comment>
    <expr_stmt><expr><call><name>apr_strftime</name><argument_list>(<argument><expr><name>ts</name></expr></argument>, <argument><expr>&amp;<name>retcode</name></expr></argument>, <argument><expr><name>MAX_STRING_LEN</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr>&amp;<name>xt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name><index>[<expr><name>MAX_STRING_LEN</name> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* Roy owes Rob beer. */</comment>
<comment type="block">/* Rob owes Roy dinner. */</comment>

<comment type="block">/* These legacy comments would make a lot more sense if Roy hadn't
 * replaced the old later_than() routine with util_date.c.
 *
 * Well, okay, they still wouldn't make any sense.
 */</comment>

<comment type="block">/* Match = 0, NoMatch = 1, Abort = -1
 * Based loosely on sections of wildmat.c by Rich Salz
 * Hmmm... shouldn't this really go component by component?
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_strcmp_match</name><argument_list>(<argument>const char *str</argument>, <argument>const char *expected</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>x</name> = 0</expr>, <expr><name>y</name> = 0</expr>;</init> <condition><expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr>;</condition> <incr><expr>++<name>y</name></expr>, <expr>++<name>x</name></expr></incr>) <block>{
        <if>if <condition>(<expr>(!<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name>) &amp;&amp; (<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> != '*')</expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> == '*'</expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name><name>expected</name><index>[<expr>++<name>y</name></expr>]</index></name> == '*'</expr>)</condition><empty_stmt>;</empty_stmt></while>
            <if>if <condition>(<expr>!<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr>)</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
            <while>while <condition>(<expr><name><name>str</name><index>[<expr><name>x</name></expr>]</index></name></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
                <if>if <condition>(<expr>(<name>ret</name> = <call><name>ap_strcmp_match</name><argument_list>(<argument><expr>&amp;<name><name>str</name><index>[<expr><name>x</name>++</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr></argument>)</argument_list></call>) != 1</expr>)</condition><then>
                    <return>return <expr><name>ret</name></expr>;</return></then></if>
            }</block></while>
            <return>return <expr>-1</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>(<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> != '?') &amp;&amp; (<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> != <name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name>)</expr>)</condition><then>
            <return>return <expr>1</expr>;</return></then></if></else></if>
    }</block></for>
    <return>return <expr>(<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> != '\0')</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_strcasecmp_match</name><argument_list>(<argument>const char *str</argument>, <argument>const char *expected</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>x</name> = 0</expr>, <expr><name>y</name> = 0</expr>;</init> <condition><expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr>;</condition> <incr><expr>++<name>y</name></expr>, <expr>++<name>x</name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> &amp;&amp; <name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> != '*'</expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>
        <if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> == '*'</expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name><name>expected</name><index>[<expr>++<name>y</name></expr>]</index></name> == '*'</expr>)</condition><empty_stmt>;</empty_stmt></while>
            <if>if <condition>(<expr>!<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr>)</condition><then>
                <return>return <expr>0</expr>;</return></then></if>
            <while>while <condition>(<expr><name><name>str</name><index>[<expr><name>x</name></expr>]</index></name></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
                <if>if <condition>(<expr>(<name>ret</name> = <call><name>ap_strcasecmp_match</name><argument_list>(<argument><expr>&amp;<name><name>str</name><index>[<expr><name>x</name>++</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr></argument>)</argument_list></call>) != 1</expr>)</condition><then>
                    <return>return <expr><name>ret</name></expr>;</return></then></if>
            }</block></while>
            <return>return <expr>-1</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name> != '?'
                 &amp;&amp; <call><name>apr_tolower</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call> != <call><name>apr_tolower</name><argument_list>(<argument><expr><name><name>expected</name><index>[<expr><name>y</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>1</expr>;</return></then></if></else></if>
    }</block></for>
    <return>return <expr>(<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> != '\0')</expr>;</return>
}</block>

<comment type="block">/* We actually compare the canonical root to this root, (but we don't
 * waste time checking the case), since every use of this function in
 * httpd-2.1 tests if the path is 'proper', meaning we've already passed
 * it through apr_filepath_merge, or we haven't.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_os_is_path_absolute</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *dir</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>newpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ourdir</name> <init>= <expr><name>dir</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>apr_filepath_root</name><argument_list>(<argument><expr>&amp;<name>newpath</name></expr></argument>, <argument><expr>&amp;<name>dir</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name>
            || <call><name>strncmp</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>ourdir</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>newpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_matchexp</name><argument_list>(<argument>const char *str</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>x</name> = 0</expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
        <if>if <condition>(<expr>(<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> == '*') || (<name><name>str</name><index>[<expr><name>x</name></expr>]</index></name> == '?')</expr>)</condition><then>
            <return>return <expr>1</expr>;</return></then></if></for>
    <return>return <expr>0</expr>;</return>
}</block>

<comment type="block">/*
 * Here's a pool-based interface to the POSIX-esque ap_regcomp().
 * Note that we return ap_regex_t instead of being passed one.
 * The reason is that if you use an already-used ap_regex_t structure,
 * the memory that you've already allocated gets forgotten, and
 * regfree() doesn't clear it. So we don't allow it.
 */</comment>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>regex_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>preg</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_regfree</name><argument_list>(<argument><expr>(<name>ap_regex_t</name> *) <name>preg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_regex_t *</argument>)</argument_list></macro> <macro><name>ap_pregcomp</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *pattern</argument>,
                                     <argument>int cflags</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>preg</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof *<name>preg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>ap_regcomp</name><argument_list>(<argument><expr><name>preg</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>err</name> == <name>AP_REG_ESPACE</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_abort_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>void</name> *) <name>preg</name></expr></argument>, <argument><expr><name>regex_cleanup</name></expr></argument>,
                              <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>preg</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_pregfree</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>ap_regex_t *reg</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>ap_regfree</name><argument_list>(<argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_cleanup_kill</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>void</name> *) <name>reg</name></expr></argument>, <argument><expr><name>regex_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<comment type="block">/*
 * Similar to standard strstr() but we ignore case in this version.
 * Based on the strstr() implementation further below.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_strcasestr</name><argument_list>(<argument>const char *s1</argument>, <argument>const char *s2</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>p1</name></decl>, *<decl><type ref="prev"/><name>p2</name></decl>;</decl_stmt>
    <if>if <condition>(<expr>*<name>s2</name> == '\0'</expr>)</condition><then> <block>{
        <comment type="block">/* an empty s2 */</comment>
        <return>return<expr>((<name>char</name> *)<name>s1</name>)</expr>;</return>
    }</block></then></if>
    <while>while<condition>(<expr>1</expr>)</condition> <block>{
        <for>for ( <init>;</init> <condition><expr>(*<name>s1</name> != '\0') &amp;&amp; (<call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>s1</name></expr></argument>)</argument_list></call> != <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>s2</name></expr></argument>)</argument_list></call>)</expr>;</condition> <incr><expr><name>s1</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
        <if>if <condition>(<expr>*<name>s1</name> == '\0'</expr>)</condition><then> <block>{
            <return>return<expr>(<name>NULL</name>)</expr>;</return>
        }</block></then></if>
        <comment type="block">/* found first character of s2, see if the rest matches */</comment>
        <expr_stmt><expr><name>p1</name> = (<name>char</name> *)<name>s1</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p2</name> = (<name>char</name> *)<name>s2</name></expr>;</expr_stmt>
        <for>for (<init><expr>++<name>p1</name></expr>, <expr>++<name>p2</name></expr>;</init> <condition><expr><call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>p1</name></expr></argument>)</argument_list></call> == <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>p2</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>p1</name></expr>, <expr>++<name>p2</name></expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>p1</name> == '\0'</expr>)</condition><then> <block>{
                <comment type="block">/* both strings ended together */</comment>
                <return>return<expr>((<name>char</name> *)<name>s1</name>)</expr>;</return>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr>*<name>p2</name> == '\0'</expr>)</condition><then> <block>{
            <comment type="block">/* second string ended, a match */</comment>
            <break>break;</break>
        }</block></then></if>
        <comment type="block">/* didn't find a match here, try starting at next character in s1 */</comment>
        <expr_stmt><expr><name>s1</name>++</expr>;</expr_stmt>
    }</block></while>
    <return>return<expr>((<name>char</name> *)<name>s1</name>)</expr>;</return>
}</block>

<comment type="block">/*
 * Returns an offsetted pointer in bigstring immediately after
 * prefix. Returns bigstring if bigstring doesn't start with
 * prefix or if prefix is longer than bigstring while still matching.
 * NOTE: pointer returned is relative to bigstring, so we
 * can use standard pointer comparisons in the calling function
 * (eg: test if ap_stripprefix(a,b) == a)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_stripprefix</name><argument_list>(<argument>const char *bigstring</argument>,
                                        <argument>const char *prefix</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p1</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name>prefix</name> == '\0'</expr>)</condition><then>
        <return>return <expr><name>bigstring</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p1</name> = <name>bigstring</name></expr>;</expr_stmt>
    <while>while <condition>(<expr>*<name>p1</name> &amp;&amp; *<name>prefix</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>*<name>p1</name>++ != *<name>prefix</name>++</expr>)</condition><then>
            <return>return <expr><name>bigstring</name></expr>;</return></then></if>
    }</block></while>
    <if>if <condition>(<expr>*<name>prefix</name> == '\0'</expr>)</condition><then>
        <return>return <expr><name>p1</name></expr>;</return></then></if>

    <comment type="block">/* hit the end of bigstring! */</comment>
    <return>return <expr><name>bigstring</name></expr>;</return>
}</block>

<comment type="block">/* This function substitutes for $0-$9, filling in regular expression
 * submatches. Pass it the same nmatch and pmatch arguments that you
 * passed ap_regexec(). pmatch should not be greater than the maximum number
 * of subexpressions - i.e. one more than the re_nsub member of ap_regex_t.
 *
 * nmatch must be &lt;=AP_MAX_REG_MATCH (10).
 *
 * input should be the string with the $-expressions, source should be the
 * string that was matched against.
 *
 * It returns the substituted string, or NULL if a vbuf is used.
 * On errors, returns the orig string.
 *
 * Parts of this code are based on Henry Spencer's regsub(), from his
 * AT&amp;T V8 regexp package.
 */</comment>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>regsub_core</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> **</type><name>result</name></decl></param>,
                                <param><decl><type>struct <name>ap_varbuf</name> *</type><name>vb</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nmatch</name></decl></param>,
                                <param><decl><type><name>ap_regmatch_t</name></type> <name><name>pmatch</name><index>[]</index></name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>maxlen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name> <init>= <expr><name>input</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>dst</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>no</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr>(<name>result</name> &amp;&amp; <name>p</name> &amp;&amp; !<name>vb</name>) || (<name>vb</name> &amp;&amp; !<name>p</name> &amp;&amp; !<name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>source</name> || <name>nmatch</name>&gt;<name>AP_MAX_REG_MATCH</name></expr>)</condition><then>
        <return>return <expr><name>APR_EINVAL</name></expr>;</return></then></if>
    <if>if <condition>(<expr>!<name>nmatch</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>maxlen</name> &gt; 0 &amp;&amp; <name>len</name> &gt;= <name>maxlen</name></expr>)</condition><then>
            <return>return <expr><name>APR_ENOMEM</name></expr>;</return></then></if>
        <if>if <condition>(<expr>!<name>vb</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>result</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>ap_varbuf_strmemcat</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></else></if>
    }</block></then></if>

    <comment type="block">/* First pass, find the size */</comment>
    <while>while <condition>(<expr>(<name>c</name> = *<name>src</name>++) != '\0'</expr>)</condition> <block>{
        <if>if <condition>(<expr><name>c</name> == '$' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>no</name> = *<name>src</name>++ - '0'</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>no</name> = <name>AP_MAX_REG_MATCH</name></expr>;</expr_stmt></else></if>

        <if>if <condition>(<expr><name>no</name> &gt;= <name>AP_MAX_REG_MATCH</name></expr>)</condition><then> <block>{  <comment type="block">/* Ordinary character. */</comment>
            <if>if <condition>(<expr><name>c</name> == '\\' &amp;&amp; *<name>src</name></expr>)</condition><then>
                <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>len</name>++</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>no</name> &lt; <name>nmatch</name> &amp;&amp; <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name> &lt; <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>APR_SIZE_MAX</name> - <name>len</name> &lt;= <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name></expr>)</condition><then>
                <return>return <expr><name>APR_ENOMEM</name></expr>;</return></then></if>
            <expr_stmt><expr><name>len</name> += <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name></expr>;</expr_stmt>
        }</block></then></if></else></if>

    }</block></while>

    <if>if <condition>(<expr><name>len</name> &gt;= <name>maxlen</name> &amp;&amp; <name>maxlen</name> &gt; 0</expr>)</condition><then>
        <return>return <expr><name>APR_ENOMEM</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<name>vb</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>result</name> = <name>dst</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> + <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dst</name> = <name><name>vb</name>-&gt;<name>buf</name></name> + <name><name>vb</name>-&gt;<name>strlen</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> += <name>len</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Now actually fill in the string */</comment>

    <expr_stmt><expr><name>src</name> = <name>input</name></expr>;</expr_stmt>

    <while>while <condition>(<expr>(<name>c</name> = *<name>src</name>++) != '\0'</expr>)</condition> <block>{
        <if>if <condition>(<expr><name>c</name> == '$' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>no</name> = *<name>src</name>++ - '0'</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>no</name> = <name>AP_MAX_REG_MATCH</name></expr>;</expr_stmt></else></if>

        <if>if <condition>(<expr><name>no</name> &gt;= <name>AP_MAX_REG_MATCH</name></expr>)</condition><then> <block>{  <comment type="block">/* Ordinary character. */</comment>
            <if>if <condition>(<expr><name>c</name> == '\\' &amp;&amp; *<name>src</name></expr>)</condition><then>
                <expr_stmt><expr><name>c</name> = *<name>src</name>++</expr>;</expr_stmt></then></if>
            <expr_stmt><expr>*<name>dst</name>++ = <name>c</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>no</name> &lt; <name>nmatch</name> &amp;&amp; <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name> &lt; <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>len</name> = <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>source</name> + <name><name>pmatch</name><index>[<expr><name>no</name></expr>]</index></name>.<name>rm_so</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dst</name> += <name>len</name></expr>;</expr_stmt>
        }</block></then></if></else></if>

    }</block></while>
    <expr_stmt><expr>*<name>dst</name> = '\0'</expr>;</expr_stmt>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>AP_PREGSUB_MAXLEN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_PREGSUB_MAXLEN</name></cpp:macro>   <cpp:value>(HUGE_STRING_LEN * 8)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_pregsub</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *input</argument>,
                              <argument>const char *source</argument>, <argument>apr_size_t nmatch</argument>,
                              <argument>ap_regmatch_t pmatch[]</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><call><name>regsub_core</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>,
                                  <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>AP_PREGSUB_MAXLEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>result</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pregsub_ex</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **result</argument>,
                                       <argument>const char *input</argument>, <argument>const char *source</argument>,
                                       <argument>apr_size_t nmatch</argument>, <argument>ap_regmatch_t pmatch[]</argument>,
                                       <argument>apr_size_t maxlen</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><call><name>regsub_core</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>,
                                  <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>result</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>rc</name></expr>;</return>
}</block>

<comment type="block">/*
 * Parse .. so we don't compromise security
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_getparents</name><argument_list>(<argument>char *name</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>first_dot</name></decl>;</decl_stmt>

    <comment type="block">/* Four paseses, as per RFC 1808 */</comment>
    <comment type="block">/* a) remove ./ path segments */</comment>
    <for>for (<init><expr><name>next</name> = <name>name</name></expr>;</init> <condition><expr>*<name>next</name> &amp;&amp; (*<name>next</name> != '.')</expr>;</condition> <incr><expr><name>next</name>++</expr></incr>) <block>{
    }</block></for>

    <expr_stmt><expr><name>l</name> = <name>w</name> = <name>first_dot</name> = <name>next</name> - <name>name</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> != '\0'</expr>)</condition> <block>{
        <if>if <condition>(<expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> == '.' &amp;&amp; <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call>
            &amp;&amp; (<name>l</name> == 0 || <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <expr_stmt><expr><name>l</name> += 2</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>name</name><index>[<expr><name>w</name>++</expr>]</index></name> = <name><name>name</name><index>[<expr><name>l</name>++</expr>]</index></name></expr>;</expr_stmt></else></if>
    }</block></while>

    <comment type="block">/* b) remove trailing . path, segment */</comment>
    <if>if <condition>(<expr><name>w</name> == 1 &amp;&amp; <name><name>name</name><index>[<expr>0</expr>]</index></name> == '.'</expr>)</condition><then>
        <expr_stmt><expr><name>w</name>--</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>w</name> &gt; 1 &amp;&amp; <name><name>name</name><index>[<expr><name>w</name> - 1</expr>]</index></name> == '.' &amp;&amp; <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>w</name> - 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>w</name>--</expr>;</expr_stmt></then></if></else></if>
    <expr_stmt><expr><name><name>name</name><index>[<expr><name>w</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

    <comment type="block">/* c) remove all xx/../ segments. (including leading ../ and /../) */</comment>
    <expr_stmt><expr><name>l</name> = <name>first_dot</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> != '\0'</expr>)</condition> <block>{
        <if>if <condition>(<expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr><name>l</name> + 1</expr>]</index></name> == '.' &amp;&amp; <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> + 2</expr>]</index></name></expr></argument>)</argument_list></call>
            &amp;&amp; (<name>l</name> == 0 || <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><name>l</name> + 3</expr></init>, <name>n</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>l</name> = <name>l</name> - 2</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>l</name> &gt;= 0</expr>)</condition><then> <block>{
                <while>while <condition>(<expr><name>l</name> &gt;= 0 &amp;&amp; !<call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                    <expr_stmt><expr><name>l</name>--</expr>;</expr_stmt></while>
                <expr_stmt><expr><name>l</name>++</expr>;</expr_stmt>
            }</block></then>
            <else>else
                <expr_stmt><expr><name>l</name> = 0</expr>;</expr_stmt></else></if>
            <expr_stmt><expr><name>n</name> = <name>l</name></expr>;</expr_stmt>
            <while>while <condition>(<expr>(<name><name>name</name><index>[<expr><name>n</name></expr>]</index></name> = <name><name>name</name><index>[<expr><name>m</name></expr>]</index></name>)</expr>)</condition>
                <expr_stmt><expr>(++<name>n</name>, ++<name>m</name>)</expr>;</expr_stmt></while>
        }</block></then>
        <else>else
            <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt></else></if>
    }</block></while>

    <comment type="block">/* d) remove trailing xx/.. segment. */</comment>
    <if>if <condition>(<expr><name>l</name> == 2 &amp;&amp; <name><name>name</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr>1</expr>]</index></name> == '.'</expr>)</condition><then>
        <expr_stmt><expr><name><name>name</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></then>
    <else>else <if>if <condition>(<expr><name>l</name> &gt; 2 &amp;&amp; <name><name>name</name><index>[<expr><name>l</name> - 1</expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr><name>l</name> - 2</expr>]</index></name> == '.'
             &amp;&amp; <call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name> - 3</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>l</name> = <name>l</name> - 4</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>l</name> &gt;= 0</expr>)</condition><then> <block>{
            <while>while <condition>(<expr><name>l</name> &gt;= 0 &amp;&amp; !<call><name>IS_SLASH</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
                <expr_stmt><expr><name>l</name>--</expr>;</expr_stmt></while>
            <expr_stmt><expr><name>l</name>++</expr>;</expr_stmt>
        }</block></then>
        <else>else
            <expr_stmt><expr><name>l</name> = 0</expr>;</expr_stmt></else></if>
        <expr_stmt><expr><name><name>name</name><index>[<expr><name>l</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
    }</block></then></if></else></if>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_no2slash</name><argument_list>(<argument>char *name</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = <name>d</name> = <name>name</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNC_PATHS</name></cpp:ifdef>
    <comment type="block">/* Check for UNC names.  Leave leading two slashes. */</comment>
    <if>if <condition>(<expr><name><name>s</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>s</name><index>[<expr>1</expr>]</index></name> == '/'</expr>)</condition><then>
        <expr_stmt><expr>*<name>d</name>++ = *<name>s</name>++</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <while>while <condition>(<expr>*<name>s</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>(*<name>d</name>++ = *<name>s</name>) == '/'</expr>)</condition><then> <block>{
            <do>do <block>{
                <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
            }</block> while <condition>(<expr>*<name>s</name> == '/'</expr>)</condition>;</do>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></while>
    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
}</block>


<comment type="block">/*
 * copy at most n leading directories of s into d
 * d should be at least as large as s plus 1 extra byte
 * assumes n &gt; 0
 * the return value is the ever useful pointer to the trailing \0 of d
 *
 * MODIFIED FOR HAVE_DRIVE_LETTERS and NETWARE environments,
 * so that if n == 0, "/" is returned in d with n == 1
 * and s == "e:/test.html", "e:/" is returned in d
 * *** See also directory_walk in modules/http/http_request.c

 * examples:
 *    /a/b, 0  ==&gt; /  (true for all platforms)
 *    /a/b, 1  ==&gt; /
 *    /a/b, 2  ==&gt; /a/
 *    /a/b, 3  ==&gt; /a/b/
 *    /a/b, 4  ==&gt; /a/b/
 *
 *    c:/a/b 0 ==&gt; /
 *    c:/a/b 1 ==&gt; c:/
 *    c:/a/b 2 ==&gt; c:/a/
 *    c:/a/b 3 ==&gt; c:/a/b
 *    c:/a/b 4 ==&gt; c:/a/b
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_make_dirstr_prefix</name><argument_list>(<argument>char *d</argument>, <argument>const char *s</argument>, <argument>int n</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><name>n</name> &lt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>d</name> = '/'</expr>;</expr_stmt>
        <expr_stmt><expr>*++<name>d</name> = '\0'</expr>;</expr_stmt>
        <return>return <expr>(<name>d</name>)</expr>;</return>
    }</block></then></if>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <if>if <condition>(<expr>*<name>s</name> == '\0' || (*<name>s</name> == '/' &amp;&amp; (--<name>n</name>) == 0)</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>d</name> = '/'</expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr>*<name>d</name>++ = *<name>s</name>++</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr>*++<name>d</name> = 0</expr>;</expr_stmt>
    <return>return <expr>(<name>d</name>)</expr>;</return>
}</block>


<comment type="block">/*
 * return the parent directory name including trailing / of the file s
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_make_dirstr_parent</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *s</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_slash</name> <init>= <expr><call><name>ap_strrchr_c</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>last_slash</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>l</name> = (<name>last_slash</name> - <name>s</name>) + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>(<name>d</name>)</expr>;</return>
}</block>


<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_count_dirs</name><argument_list>(<argument>const char *path</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>x</name> = 0</expr>, <expr><name>n</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
        <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>x</name></expr>]</index></name> == '/'</expr>)</condition><then>
            <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></then></if></for>
    <return>return <expr><name>n</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nc</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>char **line</argument>, <argument>char stop</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>ap_getword</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>const char **line</argument>, <argument>char stop</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name> <init>= <expr>*<name>line</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>(*<name>pos</name> != <name>stop</name>) &amp;&amp; *<name>pos</name></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>len</name> = <name>pos</name> - *<name>line</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>stop</name></expr>)</condition><then> <block>{
        <while>while <condition>(<expr>*<name>pos</name> == <name>stop</name></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
        }</block></while>
    }</block></then></if>
    <expr_stmt><expr>*<name>line</name> = <name>pos</name></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_white_nc</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>char **line</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>ap_getword_white</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_white</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>const char **line</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name> <init>= <expr>*<name>line</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>!<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>pos</name></expr></argument>)</argument_list></call> &amp;&amp; *<name>pos</name></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>len</name> = <name>pos</name> - *<name>line</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>pos</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr>*<name>line</name> = <name>pos</name></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nulls_nc</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>char **line</argument>,
                                       <argument>char stop</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>ap_getword_nulls</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_nulls</name><argument_list>(<argument>apr_pool_t *atrans</argument>, <argument>const char **line</argument>,
                                    <argument>char stop</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>stop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>pos</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr>*<name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>res</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>line</name> += <name>len</name></expr>;</expr_stmt>
        <return>return <expr><name>res</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>res</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>atrans</name></expr></argument>, <argument><expr>*<name>line</name></expr></argument>, <argument><expr><name>pos</name> - *<name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>++<name>pos</name></expr>;</expr_stmt>

    <expr_stmt><expr>*<name>line</name> = <name>pos</name></expr>;</expr_stmt>

    <return>return <expr><name>res</name></expr>;</return>
}</block>

<comment type="block">/* Get a word, (new) config-file style --- quoted strings and backslashes
 * all honored
 */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>substring_conf</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>,
                            <param><decl><type><name>char</name></type> <name>quote</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>resp</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>start</name><index>[<expr><name>i</name></expr>]</index></name> == '\\' &amp;&amp; (<name><name>start</name><index>[<expr><name>i</name> + 1</expr>]</index></name> == '\\'
                                 || (<name>quote</name> &amp;&amp; <name><name>start</name><index>[<expr><name>i</name> + 1</expr>]</index></name> == <name>quote</name>))</expr>)</condition><then>
            <expr_stmt><expr>*<name>resp</name>++ = <name><name>start</name><index>[<expr>++<name>i</name></expr>]</index></name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr>*<name>resp</name>++ = <name><name>start</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></else></if>
    }</block></for>

    <expr_stmt><expr>*<name>resp</name>++ = '\0'</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>RESOLVE_ENV_PER_TOKEN</name></expr></cpp:if>
    <return>return <expr>(<name>char</name> *)<call><name>ap_resolve_env</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><name>result</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_conf_nc</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **line</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>ap_getword_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_conf</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **line</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr>*<name>line</name></expr></init>, *<name>strend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></while>

    <if>if <condition>(<expr>!*<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>line</name> = <name>str</name></expr>;</expr_stmt>
        <return>return <expr>""</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>quote</name> = *<name>str</name>) == '"' || <name>quote</name> == '\''</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>strend</name> = <name>str</name> + 1</expr>;</expr_stmt>
        <while>while <condition>(<expr>*<name>strend</name> &amp;&amp; *<name>strend</name> != <name>quote</name></expr>)</condition> <block>{
            <if>if <condition>(<expr>*<name>strend</name> == '\\' &amp;&amp; <name><name>strend</name><index>[<expr>1</expr>]</index></name> &amp;&amp;
                (<name><name>strend</name><index>[<expr>1</expr>]</index></name> == <name>quote</name> || <name><name>strend</name><index>[<expr>1</expr>]</index></name> == '\\')</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>strend</name> += 2</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></while>
        <expr_stmt><expr><name>res</name> = <call><name>substring_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name> + 1</expr></argument>, <argument><expr><name>strend</name> - <name>str</name> - 1</expr></argument>, <argument><expr><name>quote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>*<name>strend</name> == <name>quote</name></expr>)</condition><then>
            <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>strend</name> = <name>str</name></expr>;</expr_stmt>
        <while>while <condition>(<expr>*<name>strend</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>strend</name></expr></argument>)</argument_list></call></expr>)</condition>
            <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></while>

        <expr_stmt><expr><name>res</name> = <call><name>substring_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>strend</name> - <name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>strend</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></while>
    <expr_stmt><expr>*<name>line</name> = <name>strend</name></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_conf2_nc</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char **line</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>ap_getword_conf2</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(const <name>char</name> **) <name>line</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_getword_conf2</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **line</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr>*<name>line</name></expr></init>, *<name>strend</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></while>

    <if>if <condition>(<expr>!*<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>line</name> = <name>str</name></expr>;</expr_stmt>
        <return>return <expr>""</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>quote</name> = *<name>str</name>) == '"' || <name>quote</name> == '\''</expr>)</condition><then>
        <return>return <expr><call><name>ap_getword_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<expr><name>quote</name> == '{'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>strend</name> = <name>str</name> + 1</expr>;</expr_stmt>
        <while>while <condition>(<expr>*<name>strend</name></expr>)</condition> <block>{
            <if>if <condition>(<expr>*<name>strend</name> == '}' &amp;&amp; !--<name>count</name></expr>)</condition><then>
                <break>break;</break></then></if>
            <if>if <condition>(<expr>*<name>strend</name> == '{'</expr>)</condition><then>
                <expr_stmt><expr>++<name>count</name></expr>;</expr_stmt></then></if>
            <if>if <condition>(<expr>*<name>strend</name> == '\\' &amp;&amp; <name><name>strend</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <name><name>strend</name><index>[<expr>1</expr>]</index></name> == '\\'</expr>)</condition><then> <block>{
                <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name>res</name> = <call><name>substring_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name> + 1</expr></argument>, <argument><expr><name>strend</name> - <name>str</name> - 1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>*<name>strend</name> == '}'</expr>)</condition><then>
            <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>strend</name> = <name>str</name></expr>;</expr_stmt>
        <while>while <condition>(<expr>*<name>strend</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>strend</name></expr></argument>)</argument_list></call></expr>)</condition>
            <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></while>

        <expr_stmt><expr><name>res</name> = <call><name>substring_conf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>strend</name> - <name>str</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>strend</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>strend</name></expr>;</expr_stmt></while>
    <expr_stmt><expr>*<name>line</name> = <name>strend</name></expr>;</expr_stmt>
    <return>return <expr><name>res</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_cfg_closefile</name><argument_list>(<argument>ap_configfile_t *cfp</argument>)</argument_list></macro>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00551</expr></argument>)</argument_list></call>
        "Done with config file %s"</expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>(<name><name>cfp</name>-&gt;<name>close</name></name> == <name>NULL</name>) ? 0 : <call><name><name>cfp</name>-&gt;<name>close</name></name><argument_list>(<argument><expr><name><name>cfp</name>-&gt;<name>param</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* we can't use apr_file_* directly because of linking issues on Windows */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cfg_close</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cfg_getch</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>ch</name></decl></param>, <param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>apr_file_getc</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cfg_getstr</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bufsiz</name></decl></param>, <param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>apr_file_gets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsiz</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Open a ap_configfile_t as FILE, return open ap_configfile_t struct pointer */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pcfg_openfile</name><argument_list>(<argument>ap_configfile_t **ret_cfg</argument>,
                                          <argument>apr_pool_t *p</argument>, <argument>const char *name</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>ap_configfile_t</name> *</type><name>new_cfg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>120</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00552</expr></argument>)</argument_list></call>
               "Internal error: pcfg_openfile() called with NULL filename"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_EBADF</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>status</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00553</expr></argument>)</argument_list></call>
                "Opening config file %s (%s)"</expr></argument>,
                <argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>status</name> != <name>APR_SUCCESS</name>) ?
                <call><name>apr_strerror</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> : "successful"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>status</name></expr>;</return></then></if>

    <expr_stmt><expr><name>status</name> = <call><name>apr_file_info_get</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>status</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name> != <name>APR_REG</name> &amp;&amp;
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>NETWARE</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <call><name>strcasecmp</name><argument_list>(<argument><expr><call><name>apr_filepath_name_get</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"nul"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"/dev/null"</expr></argument>)</argument_list></call> != 0</expr></expr_stmt>)</block> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 || OS2 */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00554</expr></argument>)</argument_list></call>
                     "Access to file %s denied by server: not a regular file"</expr></argument>,
                     <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_EBADF</name></expr>;</return>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
    <comment type="block">/* Some twisted character [no pun intended] at MS decided that a
     * zero width joiner as the lead wide character would be ideal for
     * describing Unicode text files.  This was further convoluted to
     * another MSism that the same character mapped into utf-8, EF BB BF
     * would signify utf-8 text files.
     *
     * Since MS configuration files are all protecting utf-8 encoded
     * Unicode path, file and resource names, we already have the correct
     * WinNT encoding.  But at least eat the stupid three bytes up front.
     */</comment>
    <block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>3</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>status</name> = <call><name>apr_file_read</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>status</name> != <name>APR_SUCCESS</name>) || (<name>len</name> &lt; 3)
              || <call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"\xEF\xBB\xBF"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_off_t</name></type> <name>zero</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>apr_file_seek</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>zero</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>new_cfg</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_cfg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>param</name></name> = <name>file</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>getch</name></name> = <name>cfg_getch</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>getstr</name></name> = <name>cfg_getstr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>close</name></name> = <name>cfg_close</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>line_number</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>ret_cfg</name> = <name>new_cfg</name></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>


<comment type="block">/* Allocate a ap_configfile_t handle with user defined functions and params */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_configfile_t *</argument>)</argument_list></macro> <macro><name>ap_pcfg_open_custom</name><argument_list>(
            <argument>apr_pool_t *p</argument>, <argument>const char *descr</argument>, <argument>void *param</argument>,
            <argument>apr_status_t (*getc_func) (char *ch, void *param)</argument>,
            <argument>apr_status_t (*gets_func) (void *buf, apr_size_t bufsize, void *param)</argument>,
            <argument>apr_status_t (*close_func) (void *param)</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>ap_configfile_t</name> *</type><name>new_cfg</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_cfg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>param</name></name> = <name>param</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>name</name></name> = <name>descr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>getch</name></name> = <name>getc_func</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>getstr</name></name> = <name>gets_func</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>close</name></name> = <name>close_func</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_cfg</name>-&gt;<name>line_number</name></name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>new_cfg</name></expr>;</return>
}</block>

<comment type="block">/* Read one character from a configfile_t */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_cfg_getc</name><argument_list>(<argument>char *ch</argument>, <argument>ap_configfile_t *cfp</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><call><name><name>cfp</name>-&gt;<name>getch</name></name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>param</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name> &amp;&amp; *<name>ch</name> == <name>LF</name></expr>)</condition><then>
        <expr_stmt><expr>++<name><name>cfp</name>-&gt;<name>line_number</name></name></expr>;</expr_stmt></then></if>
    <return>return <expr><name>rc</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_pcfg_strerror</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>ap_configfile_t *cfp</argument>,
                                          <argument>apr_status_t rc</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>rc</name> == <name>APR_ENOSPC</name></expr>)</condition><then>
        <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"Error reading %s at line %d: Line too long"</expr></argument>,
                            <argument><expr><name><name>cfp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>line_number</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"Error reading %s at line %d: %pm"</expr></argument>,
                        <argument><expr><name><name>cfp</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>line_number</name></name></expr></argument>, <argument><expr>&amp;<name>rc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* Read one line from open ap_configfile_t, strip LF, increase line number */</comment>
<comment type="block">/* If custom handler does not define a getstr() function, read char by char */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ap_cfg_getline_core</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bufsize</name></decl></param>,
                                        <param><decl><type><name>apr_size_t</name></type> <name>offset</name></decl></param>, <param><decl><type><name>ap_configfile_t</name> *</type><name>cfp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>
    <comment type="block">/* If a "get string" function is defined, use it */</comment>
    <if>if <condition>(<expr><name><name>cfp</name>-&gt;<name>getstr</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>cbuf</name> <init>= <expr><name>buf</name> + <name>offset</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>cbufsize</name> <init>= <expr><name>bufsize</name> - <name>offset</name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr>1</expr>)</condition> <block>{
            <expr_stmt><expr>++<name><name>cfp</name>-&gt;<name>line_number</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>rc</name> = <call><name><name>cfp</name>-&gt;<name>getstr</name></name><argument_list>(<argument><expr><name>cbuf</name></expr></argument>, <argument><expr><name>cbufsize</name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rc</name> == <name>APR_EOF</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>cbuf</name> != <name>buf</name> + <name>offset</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>cbuf</name> = '\0'</expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then>
                <else>else <block>{
                    <return>return <expr><name>APR_EOF</name></expr>;</return>
                }</block></else></if>
            }</block></then></if>
            <if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>rc</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/*
             *  check for line continuation,
             *  i.e. match [^\\]\\[\r]\n only
             */</comment>
            <expr_stmt><expr><name>cp</name> = <name>cbuf</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>cp</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>cp</name> &gt; <name>buf</name> &amp;&amp; <name><name>cp</name><index>[<expr>-1</expr>]</index></name> == <name>LF</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cp</name>--</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>cp</name> &gt; <name>buf</name> &amp;&amp; <name><name>cp</name><index>[<expr>-1</expr>]</index></name> == <name>CR</name></expr>)</condition><then>
                    <expr_stmt><expr><name>cp</name>--</expr>;</expr_stmt></then></if>
                <if>if <condition>(<expr><name>cp</name> &gt; <name>buf</name> &amp;&amp; <name><name>cp</name><index>[<expr>-1</expr>]</index></name> == '\\'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>cp</name>--</expr>;</expr_stmt>
                    <comment type="block">/*
                     * line continuation requested -
                     * then remove backslash and continue
                     */</comment>
                    <expr_stmt><expr><name>cbufsize</name> -= (<name>cp</name>-<name>cbuf</name>)</expr>;</expr_stmt>
                    <expr_stmt><expr><name>cbuf</name> = <name>cp</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>cp</name> - <name>buf</name> &gt;= <name>bufsize</name> - 1</expr>)</condition><then> <block>{
                <return>return <expr><name>APR_ENOSPC</name></expr>;</return>
            }</block></then></if></else></if>
            <break>break;</break>
        }</block></while>
    }</block></then> <else>else <block>{
        <comment type="block">/* No "get string" function defined; read character by character */</comment>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr><name>offset</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>bufsize</name> &lt; 2</expr>)</condition><then> <block>{
            <comment type="block">/* too small, assume caller is crazy */</comment>
            <return>return <expr><name>APR_EINVAL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>offset</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

        <while>while <condition>(<expr>1</expr>)</condition> <block>{
            <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> = <call><name><name>cfp</name>-&gt;<name>getch</name></name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name><name>cfp</name>-&gt;<name>param</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rc</name> == <name>APR_EOF</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>i</name> &gt; <name>offset</name></expr>)</condition><then>
                    <break>break;</break></then>
                <else>else
                    <return>return <expr><name>APR_EOF</name></expr>;</return></else></if>
            }</block></then></if>
            <if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
                <return>return <expr><name>rc</name></expr>;</return></then></if>
            <if>if <condition>(<expr><name>c</name> == <name>LF</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>++<name><name>cfp</name>-&gt;<name>line_number</name></name></expr>;</expr_stmt>
                <comment type="block">/* check for line continuation */</comment>
                <if>if <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name><name>buf</name><index>[<expr><name>i</name>-1</expr>]</index></name> == '\\'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then>
                <else>else <block>{
                    <break>break;</break>
                }</block></else></if>
            }</block></then></if>
            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>i</name> &gt;= <name>bufsize</name> - 1</expr>)</condition><then> <block>{
                <return>return <expr><name>APR_ENOSPC</name></expr>;</return>
            }</block></then></if>
        }</block></while>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cfg_trim_line</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <comment type="block">/*
     * Leading and trailing white space is eliminated completely
     */</comment>
    <expr_stmt><expr><name>start</name> = <name>buf</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>start</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>start</name></expr>;</expr_stmt></while>
    <comment type="block">/* blast trailing whitespace */</comment>
    <expr_stmt><expr><name>end</name> = &amp;<name><name>start</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
    <while>while <condition>(<expr>--<name>end</name> &gt;= <name>start</name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>*<name>end</name> = '\0'</expr>;</expr_stmt></while>
    <comment type="block">/* Zap leading whitespace by shifting */</comment>
    <if>if <condition>(<expr><name>start</name> != <name>buf</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> - <name>start</name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_CFG_LINES</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00555</expr></argument>)</argument_list></call> "Read config: '%s'"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>end</name> - <name>start</name> + 1</expr>;</return>
}</block></function>

<comment type="block">/* Read one line from open ap_configfile_t, strip LF, increase line number */</comment>
<comment type="block">/* If custom handler does not define a getstr() function, read char by char */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_cfg_getline</name><argument_list>(<argument>char *buf</argument>, <argument>apr_size_t bufsize</argument>,
                                        <argument>ap_configfile_t *cfp</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><call><name>ap_cfg_getline_core</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>cfg_trim_line</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>rc</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_varbuf_cfg_getline</name><argument_list>(<argument>struct ap_varbuf *vb</argument>,
                                               <argument>ap_configfile_t *cfp</argument>,
                                               <argument>apr_size_t max_len</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>new_len</name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr>*<name><name>vb</name>-&gt;<name>buf</name></name> = '\0'</expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>avail</name></name> - <name><name>vb</name>-&gt;<name>strlen</name></name> &lt; 3</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>new_len</name> = <name><name>vb</name>-&gt;<name>avail</name></name> * 2</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_len</name> &gt; <name>max_len</name></expr>)</condition><then>
            <expr_stmt><expr><name>new_len</name> = <name>max_len</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>new_len</name> &lt; 3</expr>)</condition><then>
            <expr_stmt><expr><name>new_len</name> = 3</expr>;</expr_stmt></then></if></else></if>
        <expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><name>rc</name> = <call><name>ap_cfg_getline_core</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>avail</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name></expr></argument>, <argument><expr><name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rc</name> == <name>APR_ENOSPC</name> || <name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> += <call><name>strlen</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name> + <name><name>vb</name>-&gt;<name>strlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>rc</name> != <name>APR_ENOSPC</name></expr>)</condition><then>
            <break>break;</break></then></if>
        <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>avail</name></name> &gt;= <name>max_len</name></expr>)</condition><then>
            <return>return <expr><name>APR_ENOSPC</name></expr>;</return></then></if>
        <expr_stmt><expr><name>new_len</name> = <name><name>vb</name>-&gt;<name>avail</name></name> * 2</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_len</name> &gt; <name>max_len</name></expr>)</condition><then>
            <expr_stmt><expr><name>new_len</name> = <name>max_len</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>--<name><name>cfp</name>-&gt;<name>line_number</name></name></expr>;</expr_stmt>
    }</block></for>
    <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>strlen</name></name> &gt; <name>max_len</name></expr>)</condition><then>
        <return>return <expr><name>APR_ENOSPC</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <call><name>cfg_trim_line</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>rc</name></expr>;</return>
}</block>

<comment type="block">/* Size an HTTP header field list item, as separated by a comma.
 * The return value is a pointer to the beginning of the non-empty list item
 * within the original string (or NULL if there is none) and the address
 * of field is shifted to the next non-comma, non-whitespace character.
 * len is the length of the item excluding any beginning whitespace.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_size_list_item</name><argument_list>(<argument>const char **field</argument>, <argument>int *len</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>ptr</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)*<name>field</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>in_qpair</name></decl>, <decl><type ref="prev"/><name>in_qstr</name></decl>, <decl><type ref="prev"/><name>in_com</name></decl>;</decl_stmt>

    <comment type="block">/* Find first non-comma, non-whitespace byte */</comment>

    <while>while <condition>(<expr>*<name>ptr</name> == ',' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt></while>

    <expr_stmt><expr><name>token</name> = <name>ptr</name></expr>;</expr_stmt>

    <comment type="block">/* Find the end of this item, skipping over dead bits */</comment>

    <for>for (<init><expr><name>in_qpair</name> = <name>in_qstr</name> = <name>in_com</name> = 0</expr>;</init>
         <condition><expr>*<name>ptr</name> &amp;&amp; (<name>in_qpair</name> || <name>in_qstr</name> || <name>in_com</name> || *<name>ptr</name> != ',')</expr>;</condition>
         <incr><expr>++<name>ptr</name></expr></incr>) <block>{

        <if>if <condition>(<expr><name>in_qpair</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>in_qpair</name> = 0</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <switch>switch <condition>(<expr>*<name>ptr</name></expr>)</condition> <block>{
                <case>case <expr>'\\'</expr>: <expr_stmt><expr><name>in_qpair</name> = 1</expr>;</expr_stmt>      <comment type="block">/* quoted-pair         */</comment>
                           <break>break;</break>
                </case><case>case <expr>'"'</expr> : <if>if <condition>(<expr>!<name>in_com</name></expr>)</condition><then>       <comment type="block">/* quoted string delim */</comment>
                               <expr_stmt><expr><name>in_qstr</name> = !<name>in_qstr</name></expr>;</expr_stmt></then></if>
                           <break>break;</break>
                </case><case>case <expr>'('</expr> : <if>if <condition>(<expr>!<name>in_qstr</name></expr>)</condition><then>      <comment type="block">/* comment (may nest)  */</comment>
                               <expr_stmt><expr>++<name>in_com</name></expr>;</expr_stmt></then></if>
                           <break>break;</break>
                </case><case>case <expr>')'</expr> : <if>if <condition>(<expr><name>in_com</name></expr>)</condition><then>        <comment type="block">/* end comment         */</comment>
                               <expr_stmt><expr>--<name>in_com</name></expr>;</expr_stmt></then></if>
                           <break>break;</break>
                </case><default>default  : <break>break;</break>
            </default>}</block></switch>
        }</block></else></if>
    }</block></for>

    <if>if <condition>(<expr>(*<name>len</name> = (<name>ptr</name> - <name>token</name>)) == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>field</name> = (const <name>char</name> *)<name>ptr</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Advance field pointer to the next non-comma, non-white byte */</comment>

    <while>while <condition>(<expr>*<name>ptr</name> == ',' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt></while>

    <expr_stmt><expr>*<name>field</name> = (const <name>char</name> *)<name>ptr</name></expr>;</expr_stmt>
    <return>return <expr>(const <name>char</name> *)<name>token</name></expr>;</return>
}</block>

<comment type="block">/* Retrieve an HTTP header field list item, as separated by a comma,
 * while stripping insignificant whitespace and lowercasing anything not in
 * a quoted string or comment.  The return value is a new string containing
 * the converted list item (or NULL if none) and the address pointed to by
 * field is shifted to the next non-comma, non-whitespace.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_get_list_item</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **field</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tok_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>addspace</name> <init>= <expr>0</expr></init>, <name>in_qpair</name> <init>= <expr>0</expr></init>, <name>in_qstr</name> <init>= <expr>0</expr></init>, <name>in_com</name> <init>= <expr>0</expr></init>, <name>tok_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Find the beginning and maximum length of the list item so that
     * we can allocate a buffer for the new string and reset the field.
     */</comment>
    <if>if <condition>(<expr>(<name>tok_start</name> = <call><name>ap_size_list_item</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr>&amp;<name>tok_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>token</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tok_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Scan the token again, but this time copy only the good bytes.
     * We skip extra whitespace and any whitespace around a '=', '/',
     * or ';' and lowercase normal characters not within a comment,
     * quoted-string or quoted-pair.
     */</comment>
    <for>for (<init><expr><name>ptr</name> = (const <name>unsigned</name> <name>char</name> *)<name>tok_start</name></expr>, <expr><name>pos</name> = (<name>unsigned</name> <name>char</name> *)<name>token</name></expr>;</init>
         <condition><expr>*<name>ptr</name> &amp;&amp; (<name>in_qpair</name> || <name>in_qstr</name> || <name>in_com</name> || *<name>ptr</name> != ',')</expr>;</condition>
         <incr><expr>++<name>ptr</name></expr></incr>) <block>{

        <if>if <condition>(<expr><name>in_qpair</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>in_qpair</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <switch>switch <condition>(<expr>*<name>ptr</name></expr>)</condition> <block>{
                <case>case <expr>'\\'</expr>: <expr_stmt><expr><name>in_qpair</name> = 1</expr>;</expr_stmt>
                           <if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
                               <expr_stmt><expr>*<name>pos</name>++ = ' '</expr>;</expr_stmt></then></if>
                           <expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
                           <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                           <break>break;</break>
                </case><case>case <expr>'"'</expr> : <if>if <condition>(<expr>!<name>in_com</name></expr>)</condition><then>
                               <expr_stmt><expr><name>in_qstr</name> = !<name>in_qstr</name></expr>;</expr_stmt></then></if>
                           <if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
                               <expr_stmt><expr>*<name>pos</name>++ = ' '</expr>;</expr_stmt></then></if>
                           <expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
                           <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                           <break>break;</break>
                </case><case>case <expr>'('</expr> : <if>if <condition>(<expr>!<name>in_qstr</name></expr>)</condition><then>
                               <expr_stmt><expr>++<name>in_com</name></expr>;</expr_stmt></then></if>
                           <if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
                               <expr_stmt><expr>*<name>pos</name>++ = ' '</expr>;</expr_stmt></then></if>
                           <expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
                           <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                           <break>break;</break>
                </case><case>case <expr>')'</expr> : <if>if <condition>(<expr><name>in_com</name></expr>)</condition><then>
                               <expr_stmt><expr>--<name>in_com</name></expr>;</expr_stmt></then></if>
                           <expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
                           <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                           <break>break;</break>
                </case><case>case <expr>' '</expr> :
                </case><case>case <expr>'\t'</expr>: <if>if <condition>(<expr><name>addspace</name></expr>)</condition><then>
                               <break>break;</break></then></if>
                           <if>if <condition>(<expr><name>in_com</name> || <name>in_qstr</name></expr>)</condition><then>
                               <expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt></then>
                           <else>else
                               <expr_stmt><expr><name>addspace</name> = 1</expr>;</expr_stmt></else></if>
                           <break>break;</break>
                </case><case>case <expr>'='</expr> :
                </case><case>case <expr>'/'</expr> :
                </case><case>case <expr>';'</expr> : <if>if <condition>(<expr>!(<name>in_com</name> || <name>in_qstr</name>)</expr>)</condition><then>
                               <expr_stmt><expr><name>addspace</name> = -1</expr>;</expr_stmt></then></if>
                           <expr_stmt><expr>*<name>pos</name>++ = *<name>ptr</name></expr>;</expr_stmt>
                           <break>break;</break>
                </case><default>default  : <if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
                               <expr_stmt><expr>*<name>pos</name>++ = ' '</expr>;</expr_stmt></then></if>
                           <expr_stmt><expr>*<name>pos</name>++ = (<name>in_com</name> || <name>in_qstr</name>) ? *<name>ptr</name>
                                                        : <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                           <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                           <break>break;</break>
            </default>}</block></switch>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr>*<name>pos</name> = '\0'</expr>;</expr_stmt>

    <return>return <expr><name>token</name></expr>;</return>
}</block>

<typedef>typedef <type><enum>enum <name>ap_etag_e</name> <block>{
    <decl><name>AP_ETAG_NONE</name></decl>,
    <decl><name>AP_ETAG_WEAK</name></decl>,
    <decl><name>AP_ETAG_STRONG</name></decl>
}</block></enum></type> <name>ap_etag_e</name>;</typedef>

<comment type="block">/* Find an item in canonical form (lowercase, no extra spaces) within
 * an HTTP field value list.  Returns 1 if found, 0 if not found.
 * This would be much more efficient if we stored header fields as
 * an array of list items as they are received instead of a plain string.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>find_list_item</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>line</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tok</name></decl></param>, <param><decl><type><name>ap_etag_e</name></type> <name>type</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>ptr</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>line</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>good</name> <init>= <expr>0</expr></init>, <name>addspace</name> <init>= <expr>0</expr></init>, <name>in_qpair</name> <init>= <expr>0</expr></init>, <name>in_qstr</name> <init>= <expr>0</expr></init>, <name>in_com</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>line</name> || !<name>tok</name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>type</name> == <name>AP_ETAG_STRONG</name> &amp;&amp; *<name>tok</name> != '\"'</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>type</name> == <name>AP_ETAG_WEAK</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>*<name>tok</name> == 'W' &amp;&amp; (*(<name>tok</name>+1)) == '/' &amp;&amp; (*(<name>tok</name>+2)) == '\"'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>tok</name> += 2</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>tok</name> != '\"'</expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if></else></if>
    }</block></then></if>

    <do>do <block>{  <comment type="block">/* loop for each item in line's list */</comment>

        <comment type="block">/* Find first non-comma, non-whitespace byte */</comment>
        <while>while <condition>(<expr>*<name>ptr</name> == ',' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* Account for strong or weak Etags, depending on our search */</comment>
        <if>if <condition>(<expr><name>type</name> == <name>AP_ETAG_STRONG</name> &amp;&amp; *<name>ptr</name> != '\"'</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <if>if <condition>(<expr><name>type</name> == <name>AP_ETAG_WEAK</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>*<name>ptr</name> == 'W' &amp;&amp; (*(<name>ptr</name>+1)) == '/' &amp;&amp; (*(<name>ptr</name>+2)) == '\"'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>ptr</name> += 2</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>*<name>ptr</name> != '\"'</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if></else></if>
        }</block></then></if>

        <if>if <condition>(<expr>*<name>ptr</name></expr>)</condition><then>
            <expr_stmt><expr><name>good</name> = 1</expr>;</expr_stmt></then>  <comment type="block">/* until proven otherwise for this item */</comment>
        <else>else
            <break>break;</break></else></if>     <comment type="block">/* no items left and nothing good found */</comment>

        <comment type="block">/* We skip extra whitespace and any whitespace around a '=', '/',
         * or ';' and lowercase normal characters not within a comment,
         * quoted-string or quoted-pair.
         */</comment>
        <for>for (<init><expr><name>pos</name> = (const <name>unsigned</name> <name>char</name> *)<name>tok</name></expr>;</init>
             <condition><expr>*<name>ptr</name> &amp;&amp; (<name>in_qpair</name> || <name>in_qstr</name> || <name>in_com</name> || *<name>ptr</name> != ',')</expr>;</condition>
             <incr><expr>++<name>ptr</name></expr></incr>) <block>{

            <if>if <condition>(<expr><name>in_qpair</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>in_qpair</name> = 0</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>good</name></expr>)</condition><then>
                    <expr_stmt><expr><name>good</name> = (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt></then></if>
            }</block></then>
            <else>else <block>{
                <switch>switch <condition>(<expr>*<name>ptr</name></expr>)</condition> <block>{
                    <case>case <expr>'\\'</expr>: <expr_stmt><expr><name>in_qpair</name> = 1</expr>;</expr_stmt>
                               <if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
                                   <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == ' ')</expr>;</expr_stmt></then></if>
                               <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
                               <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                               <break>break;</break>
                    </case><case>case <expr>'"'</expr> : <if>if <condition>(<expr>!<name>in_com</name></expr>)</condition><then>
                                   <expr_stmt><expr><name>in_qstr</name> = !<name>in_qstr</name></expr>;</expr_stmt></then></if>
                               <if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
                                   <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == ' ')</expr>;</expr_stmt></then></if>
                               <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
                               <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                               <break>break;</break>
                    </case><case>case <expr>'('</expr> : <if>if <condition>(<expr>!<name>in_qstr</name></expr>)</condition><then>
                                   <expr_stmt><expr>++<name>in_com</name></expr>;</expr_stmt></then></if>
                               <if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
                                   <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == ' ')</expr>;</expr_stmt></then></if>
                               <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
                               <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                               <break>break;</break>
                    </case><case>case <expr>')'</expr> : <if>if <condition>(<expr><name>in_com</name></expr>)</condition><then>
                                   <expr_stmt><expr>--<name>in_com</name></expr>;</expr_stmt></then></if>
                               <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
                               <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                               <break>break;</break>
                    </case><case>case <expr>' '</expr> :
                    </case><case>case <expr>'\t'</expr>: <if>if <condition>(<expr><name>addspace</name> || !<name>good</name></expr>)</condition><then>
                                   <break>break;</break></then></if>
                               <if>if <condition>(<expr><name>in_com</name> || <name>in_qstr</name></expr>)</condition><then>
                                   <expr_stmt><expr><name>good</name> = (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt></then>
                               <else>else
                                   <expr_stmt><expr><name>addspace</name> = 1</expr>;</expr_stmt></else></if>
                               <break>break;</break>
                    </case><case>case <expr>'='</expr> :
                    </case><case>case <expr>'/'</expr> :
                    </case><case>case <expr>';'</expr> : <if>if <condition>(<expr>!(<name>in_com</name> || <name>in_qstr</name>)</expr>)</condition><then>
                                   <expr_stmt><expr><name>addspace</name> = -1</expr>;</expr_stmt></then></if>
                               <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt>
                               <break>break;</break>
                    </case><default>default  : <if>if <condition>(<expr>!<name>good</name></expr>)</condition><then>
                                   <break>break;</break></then></if>
                               <if>if <condition>(<expr><name>addspace</name> == 1</expr>)</condition><then>
                                   <expr_stmt><expr><name>good</name> = (*<name>pos</name>++ == ' ')</expr>;</expr_stmt></then></if>
                               <if>if <condition>(<expr><name>in_com</name> || <name>in_qstr</name></expr>)</condition><then>
                                   <expr_stmt><expr><name>good</name> = <name>good</name> &amp;&amp; (*<name>pos</name>++ == *<name>ptr</name>)</expr>;</expr_stmt></then>
                               <else>else
                                   <expr_stmt><expr><name>good</name> = <name>good</name>
                                       &amp;&amp; (<call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>pos</name>++</expr></argument>)</argument_list></call> == <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></else></if>
                               <expr_stmt><expr><name>addspace</name> = 0</expr>;</expr_stmt>
                               <break>break;</break>
                </default>}</block></switch>
            }</block></else></if>
        }</block></for>
        <if>if <condition>(<expr><name>good</name> &amp;&amp; *<name>pos</name></expr>)</condition><then>
            <expr_stmt><expr><name>good</name> = 0</expr>;</expr_stmt></then></if>          <comment type="block">/* not good if only a prefix was matched */</comment>

    }</block> while <condition>(<expr>*<name>ptr</name> &amp;&amp; !<name>good</name></expr>)</condition>;</do>

    <return>return <expr><name>good</name></expr>;</return>
}</block></function>

<comment type="block">/* Find an item in canonical form (lowercase, no extra spaces) within
 * an HTTP field value list.  Returns 1 if found, 0 if not found.
 * This would be much more efficient if we stored header fields as
 * an array of list items as they are received instead of a plain string.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_list_item</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>,
                                  <argument>const char *tok</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>find_list_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>AP_ETAG_NONE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* Find a strong Etag in canonical form (lowercase, no extra spaces) within
 * an HTTP field value list.  Returns 1 if found, 0 if not found.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_etag_strong</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>,
                                    <argument>const char *tok</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>find_list_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>AP_ETAG_STRONG</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* Find a weak ETag in canonical form (lowercase, no extra spaces) within
 * an HTTP field value list.  Returns 1 if found, 0 if not found.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_etag_weak</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>,
                                  <argument>const char *tok</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>find_list_item</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>AP_ETAG_WEAK</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* Grab a list of tokens of the format 1#token (from RFC7230) */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_parse_token_list_strict</name><argument_list>(<argument>apr_pool_t *p</argument>,
                                                <argument>const char *str_in</argument>,
                                                <argument>apr_array_header_t **tokens</argument>,
                                                <argument>int skip_invalid</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>in_leading_space</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>in_trailing_space</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>string_end</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tok_begin</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cur</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>str_in</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>tok_begin</name> = <name>cur</name> = <name>str_in</name></expr>;</expr_stmt>

    <while>while <condition>(<expr>!<name>string_end</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr>(<name>unsigned</name> <name>char</name>)*<name>cur</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>TEST_CHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_HTTP_TOKEN_STOP</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Non-separator character; we are finished with leading
             * whitespace. We must never have encountered any trailing
             * whitespace before the delimiter (comma) */</comment>
            <expr_stmt><expr><name>in_leading_space</name> = 0</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>in_trailing_space</name></expr>)</condition><then> <block>{
                <return>return <expr>"Encountered illegal whitespace in token"</expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>c</name> == ' ' || <name>c</name> == '\t'</expr>)</condition><then> <block>{
            <comment type="block">/* "Linear whitespace" only includes ASCII CRLF, space, and tab;
             * we can't get a CRLF since headers are split on them already,
             * so only look for a space or a tab */</comment>
            <if>if <condition>(<expr><name>in_leading_space</name></expr>)</condition><then> <block>{
                <comment type="block">/* We're still in leading whitespace */</comment>
                <expr_stmt><expr>++<name>tok_begin</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* We must be in trailing whitespace */</comment>
                <expr_stmt><expr>++<name>in_trailing_space</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>c</name> == ',' || <name>c</name> == '\0'</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>in_leading_space</name></expr>)</condition><then> <block>{
                <comment type="block">/* If we're out of the leading space, we know we've read some
                 * characters of a token */</comment>
                <if>if <condition>(<expr>*<name>tokens</name> == <name>NULL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>tokens</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>tokens</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call> =
                    <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>(*<name>tokens</name>)-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>tok_begin</name></expr></argument>,
                                   <argument><expr>(<name>cur</name> - <name>tok_begin</name>) - <name>in_trailing_space</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <comment type="block">/* We're allowed to have null elements, just don't add them to the
             * array */</comment>

            <expr_stmt><expr><name>tok_begin</name> = <name>cur</name> + 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>in_leading_space</name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>in_trailing_space</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name>string_end</name> = (<name>c</name> == '\0')</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Encountered illegal separator char */</comment>
            <if>if <condition>(<expr><name>skip_invalid</name></expr>)</condition><then> <block>{
                <comment type="block">/* Skip to the next separator */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>temp</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>temp</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if<condition>(<expr>!<name>temp</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>temp</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/* Act like we haven't seen a token so we reset */</comment>
                <expr_stmt><expr><name>cur</name> = <name>temp</name> - 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>in_leading_space</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>in_trailing_space</name> = 0</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"Encountered illegal separator "
                                    "'\\x%.2x'"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>int</name>)<name>c</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></else></if></else></if></else></if>

        <expr_stmt><expr>++<name>cur</name></expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block>

<comment type="block">/* Scan a string for HTTP VCHAR/obs-text characters including HT and SP
 * (as used in header values, for example, in RFC 7230 section 3.2)
 * returning the pointer to the first non-HT ASCII ctrl character.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_scan_http_field_content</name><argument_list>(<argument>const char *ptr</argument>)</argument_list></macro>
<block>{
    <for>for ( <init>;</init> <condition><expr>!<call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>, <argument><expr><name>T_HTTP_CTRLS</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>ptr</name></expr></incr>) <empty_stmt>;</empty_stmt></for>

    <return>return <expr><name>ptr</name></expr>;</return>
}</block>

<comment type="block">/* Scan a string for HTTP token characters, returning the pointer to
 * the first non-token character.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_scan_http_token</name><argument_list>(<argument>const char *ptr</argument>)</argument_list></macro>
<block>{
    <for>for ( <init>;</init> <condition><expr>!<call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>, <argument><expr><name>T_HTTP_TOKEN_STOP</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>ptr</name></expr></incr>) <empty_stmt>;</empty_stmt></for>

    <return>return <expr><name>ptr</name></expr>;</return>
}</block>

<comment type="block">/* Scan a string for visible ASCII (0x21-0x7E) or obstext (0x80+)
 * and return a pointer to the first ctrl/space character encountered.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_scan_vchar_obstext</name><argument_list>(<argument>const char *ptr</argument>)</argument_list></macro>
<block>{
    <for>for ( <init>;</init> <condition><expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>, <argument><expr><name>T_VCHAR_OBSTEXT</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>ptr</name></expr></incr>) <empty_stmt>;</empty_stmt></for>

    <return>return <expr><name>ptr</name></expr>;</return>
}</block>

<comment type="block">/* Retrieve a token, spacing over it and returning a pointer to
 * the first non-white byte afterwards.  Note that these tokens
 * are delimited by semis and commas; and can also be delimited
 * by whitespace at the caller's option.
 */</comment>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_get_token</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char **accept_line</argument>,
                                <argument>int accept_white</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name> <init>= <expr>*<name>accept_line</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tok_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>

    <comment type="block">/* Find first non-white byte */</comment>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt></while>

    <expr_stmt><expr><name>tok_start</name> = <name>ptr</name></expr>;</expr_stmt>

    <comment type="block">/* find token end, skipping over quoted strings.
     * (comments are already gone).
     */</comment>

    <while>while <condition>(<expr>*<name>ptr</name> &amp;&amp; (<name>accept_white</name> || !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call>)
           &amp;&amp; *<name>ptr</name> != ';' &amp;&amp; *<name>ptr</name> != ','</expr>)</condition> <block>{
        <if>if <condition>(<expr>*<name>ptr</name>++ == '"'</expr>)</condition><then>
            <while>while <condition>(<expr>*<name>ptr</name></expr>)</condition>
                <if>if <condition>(<expr>*<name>ptr</name>++ == '"'</expr>)</condition><then>
                    <break>break;</break></then></if></while></then></if>
    }</block></while>

    <expr_stmt><expr><name>token</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>tok_start</name></expr></argument>, <argument><expr><name>ptr</name> - <name>tok_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Advance accept_line pointer to the next non-white byte */</comment>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>ptr</name></expr>;</expr_stmt></while>

    <expr_stmt><expr>*<name>accept_line</name> = <name>ptr</name></expr>;</expr_stmt>
    <return>return <expr><name>token</name></expr>;</return>
}</block>


<comment type="block">/* find http tokens, see the definition of token from RFC2068 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_token</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>, <argument>const char *tok</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>start_token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>line</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>line</name></expr>;</expr_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <comment type="block">/* find start of token, skip all stop characters */</comment>
        <while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_HTTP_TOKEN_STOP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>!*<name>s</name></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>start_token</name> = <name>s</name></expr>;</expr_stmt>
        <comment type="block">/* find end of the token */</comment>
        <while>while <condition>(<expr>*<name>s</name> &amp;&amp; !<call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_HTTP_TOKEN_STOP</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>start_token</name></expr></argument>, <argument><expr>(const <name>char</name> *)<name>tok</name></expr></argument>,
                         <argument><expr><name>s</name> - <name>start_token</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!*<name>s</name></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
    }</block></for>
}</block>


<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_find_last_token</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *line</argument>,
                                   <argument>const char *tok</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>llen</name></decl>, <decl><type ref="prev"/><name>tlen</name></decl>, <decl><type ref="prev"/><name>lidx</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>line</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><name>llen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>tlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lidx</name> = <name>llen</name> - <name>tlen</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>lidx</name> &lt; 0 ||
        (<name>lidx</name> &gt; 0 &amp;&amp; !(<call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>line</name><index>[<expr><name>lidx</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call> || <name><name>line</name><index>[<expr><name>lidx</name> - 1</expr>]</index></name> == ','))</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <return>return <expr>(<call><name>strncasecmp</name><argument_list>(<argument><expr>&amp;<name><name>line</name><index>[<expr><name>lidx</name></expr>]</index></name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call> == 0)</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_shell_cmd</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *str</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cmd</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2 * <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* Be safe */</comment>
    <expr_stmt><expr><name>d</name> = (<name>unsigned</name> <name>char</name> *)<name>cmd</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>str</name></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <comment type="block">/*
         * Newlines to Win32/OS2 CreateProcess() are ill advised.
         * Convert them to spaces since they are effectively white
         * space to most applications
         */</comment>
        <if>if <condition>(<expr>*<name>s</name> == '\r' || *<name>s</name> == '\n'</expr>)</condition><then> <block>{
             <expr_stmt><expr>*<name>d</name>++ = ' '</expr>;</expr_stmt>
             <continue>continue;</continue>
         }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_ESCAPE_SHELL_CMD</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>d</name>++ = '\\'</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>

    <return>return <expr><name>cmd</name></expr>;</return>
}</block>

<function><type><specifier>static</specifier> <name>char</name></type> <name>x2c</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>what</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name>digit</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
    <expr_stmt><expr><name>digit</name> = ((<name><name>what</name><index>[<expr>0</expr>]</index></name> &gt;= 'A') ? ((<name><name>what</name><index>[<expr>0</expr>]</index></name> &amp; 0xdf) - 'A') + 10
             : (<name><name>what</name><index>[<expr>0</expr>]</index></name> - '0'))</expr>;</expr_stmt>
    <expr_stmt><expr><name>digit</name> *= 16</expr>;</expr_stmt>
    <expr_stmt><expr><name>digit</name> += (<name><name>what</name><index>[<expr>1</expr>]</index></name> &gt;= 'A' ? ((<name><name>what</name><index>[<expr>1</expr>]</index></name> &amp; 0xdf) - 'A') + 10
              : (<name><name>what</name><index>[<expr>1</expr>]</index></name> - '0'))</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/*APR_CHARSET_EBCDIC*/</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>xstr</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>xstr</name><index>[<expr>0</expr>]</index></name>='0'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xstr</name><index>[<expr>1</expr>]</index></name>='x'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xstr</name><index>[<expr>2</expr>]</index></name>=<name><name>what</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xstr</name><index>[<expr>3</expr>]</index></name>=<name><name>what</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xstr</name><index>[<expr>4</expr>]</index></name>='\0'</expr>;</expr_stmt>
    <expr_stmt><expr><name>digit</name> = <call><name>apr_xlate_conv_byte</name><argument_list>(<argument><expr><name>ap_hdrs_from_ascii</name></expr></argument>,
                                <argument><expr>0xFF &amp; <call><name>strtol</name><argument_list>(<argument><expr><name>xstr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*APR_CHARSET_EBCDIC*/</comment>
    <return>return <expr>(<name>digit</name>)</expr>;</return>
}</block></function>

<comment type="block">/*
 * Unescapes a URL, leaving reserved characters intact.
 * Returns 0 on success, non-zero on error
 * Failure is due to
 *   bad % escape       returns HTTP_BAD_REQUEST
 *
 *   decoding %00 or a forbidden character returns HTTP_NOT_FOUND
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>unescape_url</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>url</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>forbid</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reserved</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>badesc</name></decl>, <decl><type ref="prev"/><name>badpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>x</name></decl>, *<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>badesc</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>badpath</name> = 0</expr>;</expr_stmt>
    <comment type="block">/* Initial scan for first '%'. Don't bother writing values before
     * seeing a '%' */</comment>
    <expr_stmt><expr><name>y</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr>'%'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>y</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>
    <for>for (<init><expr><name>x</name> = <name>y</name></expr>;</init> <condition><expr>*<name>y</name></expr>;</condition> <incr><expr>++<name>x</name></expr>, <expr>++<name>y</name></expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>y</name> != '%'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>x</name> = *<name>y</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr>!<call><name>apr_isxdigit</name><argument_list>(<argument><expr>*(<name>y</name> + 1)</expr></argument>)</argument_list></call> || !<call><name>apr_isxdigit</name><argument_list>(<argument><expr>*(<name>y</name> + 2)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>badesc</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr>*<name>x</name> = '%'</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <decl_stmt><decl><type><name>char</name></type> <name>decoded</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>decoded</name> = <call><name>x2c</name><argument_list>(<argument><expr><name>y</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>(<name>decoded</name> == '\0')
                    || (<name>forbid</name> &amp;&amp; <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>forbid</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>badpath</name> = 1</expr>;</expr_stmt>
                    <expr_stmt><expr>*<name>x</name> = <name>decoded</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>y</name> += 2</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>reserved</name> &amp;&amp; <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>reserved</name></expr></argument>, <argument><expr><name>decoded</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>x</name>++ = *<name>y</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr>*<name>x</name>++ = *<name>y</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr>*<name>x</name> = *<name>y</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr>*<name>x</name> = <name>decoded</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>y</name> += 2</expr>;</expr_stmt>
                }</block></else></if></else></if>
            }</block></else></if>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr>*<name>x</name> = '\0'</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>badesc</name></expr>)</condition><then> <block>{
        <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>badpath</name></expr>)</condition><then> <block>{
        <return>return <expr><name>HTTP_NOT_FOUND</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></else></if></else></if>
}</block></function>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url</name><argument_list>(<argument>char *url</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* Traditional */</comment>
    <return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>SLASHES</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url_keep2f</name><argument_list>(<argument>char *url</argument>, <argument>int decode_slashes</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* AllowEncodedSlashes (corrected) */</comment>
    <if>if <condition>(<expr><name>decode_slashes</name></expr>)</condition><then> <block>{
        <comment type="block">/* no chars reserved */</comment>
        <return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then> <else>else <block>{
        <comment type="block">/* reserve (do not decode) encoded slashes */</comment>
        <return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SLASHES</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if>
}</block>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEW_APIS</name></cpp:ifdef>
<comment type="block">/* IFDEF these out until they've been thought through.
 * Just a germ of an API extension for now
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url_proxy</name><argument_list>(<argument>char *url</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* leave RFC1738 reserved characters intact, * so proxied URLs
     * don't get mangled.  Where does that leave encoded '&amp;' ?
     */</comment>
    <return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"/;?"</expr></argument>)</argument_list></call></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_url_reserved</name><argument_list>(<argument>char *url</argument>, <argument>const char *reserved</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>reserved</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_urlencoded</name><argument_list>(<argument>char *query</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>slider</name></decl>;</decl_stmt>

    <comment type="block">/* replace plus with a space */</comment>
    <if>if <condition>(<expr><name>query</name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>slider</name> = <name>query</name></expr>;</init> <condition><expr>*<name>slider</name></expr>;</condition> <incr><expr><name>slider</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>slider</name> == '+'</expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>slider</name> = ' '</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <comment type="block">/* unescape everything else */</comment>
    <return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_construct_server</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *hostname</argument>,
                                       <argument>apr_port_t port</argument>, <argument>const request_rec *r</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><call><name>ap_is_default_port</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
    <else>else <block>{
        <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"%s:%u"</expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unescape_all</name><argument_list>(<argument>char *url</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>unescape_url</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* c2x takes an unsigned, and expects the caller has guaranteed that
 * 0 &lt;= what &lt; 256... which usually means that you have to cast to
 * unsigned char first, because (unsigned)(char)(x) first goes through
 * signed extension to an int before the unsigned cast.
 *
 * The reason for this assumption is to assist gcc code generation --
 * the unsigned char -&gt; unsigned extension is already done earlier in
 * both uses of this code, so there's no need to waste time doing it
 * again.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>c2x_table</name><index>[]</index></name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>unsigned</name> <name>char</name> *</type><name>c2x</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>what</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name></type> <name>prefix</name></decl></param>,
                                     <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>where</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
    <expr_stmt><expr><name>what</name> = <call><name>apr_xlate_conv_byte</name><argument_list>(<argument><expr><name>ap_hdrs_to_ascii</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*APR_CHARSET_EBCDIC*/</comment>
    <expr_stmt><expr>*<name>where</name>++ = <name>prefix</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>where</name>++ = <name><name>c2x_table</name><index>[<expr><name>what</name> &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>where</name>++ = <name><name>c2x_table</name><index>[<expr><name>what</name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name>where</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * escape_path_segment() escapes a path segment, as defined in RFC 1808. This
 * routine is (should be) OS independent.
 *
 * os_escape_path() converts an OS path to a URL, in an OS dependent way. In all
 * cases if a ':' occurs before the first '/' in the URL, the URL should be
 * prefixed with "./" (or the ':' escaped). In the case of Unix, this means
 * leaving '/' alone, but otherwise doing what escape_path_segment() does. For
 * efficiency reasons, we don't use escape_path_segment(), which is provided for
 * reference. Again, RFC 1808 is where this stuff is defined.
 *
 * If partial is set, os_escape_path() assumes that the path will be appended to
 * something with a '/' in it (and thus does not prefix "./").
 */</comment>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_path_segment_buffer</name><argument_list>(<argument>char *copy</argument>, <argument>const char *segment</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>segment</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *)<name>copy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>(<name>c</name> = *<name>s</name>)</expr>)</condition> <block>{
        <if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_ESCAPE_PATH_SEGMENT</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>d</name> = <call><name>c2x</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>'%'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>d</name>++ = <name>c</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><name>copy</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_path_segment</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *segment</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>ap_escape_path_segment_buffer</name><argument_list>(<argument><expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>3 * <call><name>strlen</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_os_escape_path</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *path</argument>, <argument>int partial</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>copy</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>3 * <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>path</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *)<name>copy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>partial</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>colon</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>slash</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>colon</name> &amp;&amp; (!<name>slash</name> || <name>colon</name> &lt; <name>slash</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>d</name>++ = '.'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>d</name>++ = '/'</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <while>while <condition>(<expr>(<name>c</name> = *<name>s</name>)</expr>)</condition> <block>{
        <if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_OS_ESCAPE_PATH</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>d</name> = <call><name>c2x</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>'%'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>d</name>++ = <name>c</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><name>copy</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_urlencoded_buffer</name><argument_list>(<argument>char *copy</argument>, <argument>const char *buffer</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>buffer</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *)<name>copy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>(<name>c</name> = *<name>s</name>)</expr>)</condition> <block>{
        <if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>T_ESCAPE_URLENCODED</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>d</name> = <call><name>c2x</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>'%'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>c</name> == ' '</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>d</name>++ = '+'</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>d</name>++ = <name>c</name></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><name>copy</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_urlencoded</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *buffer</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>ap_escape_urlencoded_buffer</name><argument_list>(<argument><expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>3 * <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* ap_escape_uri is now a macro for os_escape_path */</comment>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_html2</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *s</argument>, <argument>int toasc</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>x</name></decl>;</decl_stmt>

    <comment type="block">/* first, count the number of extra characters */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != '\0'</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&lt;' || <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&gt;'</expr>)</condition><then>
            <expr_stmt><expr><name>j</name> += 3</expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&amp;'</expr>)</condition><then>
            <expr_stmt><expr><name>j</name> += 4</expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '"'</expr>)</condition><then>
            <expr_stmt><expr><name>j</name> += 5</expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>toasc</name> &amp;&amp; !<call><name>apr_isascii</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>j</name> += 5</expr>;</expr_stmt></then></if></else></if></else></if></else></if></for>

    <if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then>
        <return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><name>x</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>i</name> + <name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> != '\0'</expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>)
        <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&lt;'</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>"&amp;lt;"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> += 3</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&gt;'</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>"&amp;gt;"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> += 3</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '&amp;'</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>"&amp;amp;"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> += 4</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == '"'</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr>"&amp;quot;"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> += 5</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>toasc</name> &amp;&amp; !<call><name>apr_isascii</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>esc</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"&amp;#%3.3d;"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>esc</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>j</name> += 5</expr>;</expr_stmt>
        }</block></then>
        <else>else
            <expr_stmt><expr><name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if></for>

    <expr_stmt><expr><name><name>x</name><index>[<expr><name>j</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><name>x</name></expr>;</return>
}</block>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_logitem</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *str</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>ret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>length</name></decl>, <decl><type ref="prev"/><name>escapes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Compute how many characters need to be escaped */</comment>
    <expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>str</name></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_ESCAPE_LOGITEM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>escapes</name>++</expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
    
    <comment type="block">/* Compute the length of the input string, including NULL */</comment>
    <expr_stmt><expr><name>length</name> = <name>s</name> - (const <name>unsigned</name> <name>char</name> *)<name>str</name> + 1</expr>;</expr_stmt>
    
    <comment type="block">/* Fast path: nothing to escape */</comment>
    <if>if <condition>(<expr><name>escapes</name> == 0</expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    
    <comment type="block">/* Each escaped character needs up to 3 extra bytes (0 --&gt; \x00) */</comment>
    <expr_stmt><expr><name>ret</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>length</name> + 3 * <name>escapes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>d</name> = (<name>unsigned</name> <name>char</name> *)<name>ret</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>str</name></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_ESCAPE_LOGITEM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>d</name>++ = '\\'</expr>;</expr_stmt>
            <switch>switch<condition>(<expr>*<name>s</name></expr>)</condition> <block>{
            <case>case <expr>'\b'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 'b'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\n'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 'n'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\r'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 'r'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\t'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 't'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\v'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 'v'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\\'</expr>:
            </case><case>case <expr>'"'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><default>default:
                <expr_stmt><expr><call><name>c2x</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr>'x'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>d</name> += 3</expr>;</expr_stmt>
            </default>}</block></switch>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>

    <return>return <expr><name>ret</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_size_t</argument>)</argument_list></macro> <macro><name>ap_escape_errorlog_item</name><argument_list>(<argument>char *dest</argument>, <argument>const char *source</argument>,
                                               <argument>apr_size_t buflen</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>ep</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>source</name> || !<name>buflen</name></expr>)</condition><then> <block>{ <comment type="block">/* be safe */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>d</name> = (<name>unsigned</name> <name>char</name> *)<name>dest</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> = (const <name>unsigned</name> <name>char</name> *)<name>source</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ep</name> = <name>d</name> + <name>buflen</name> - 1</expr>;</expr_stmt>

    <for>for (<init>;</init> <condition><expr><name>d</name> &lt; <name>ep</name> &amp;&amp; *<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{

        <if>if <condition>(<expr><call><name>TEST_CHAR</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>T_ESCAPE_LOGITEM</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>d</name>++ = '\\'</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>d</name> &gt;= <name>ep</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>--<name>d</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>

            <switch>switch<condition>(<expr>*<name>s</name></expr>)</condition> <block>{
            <case>case <expr>'\b'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 'b'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\n'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 'n'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\r'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 'r'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\t'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 't'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\v'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = 'v'</expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'\\'</expr>:
                <expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'"'</expr>: <comment type="block">/* no need for this in error log */</comment>
                <expr_stmt><expr><name><name>d</name><index>[<expr>-1</expr>]</index></name> = *<name>s</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><default>default:
                <if>if <condition>(<expr><name>d</name> &gt;= <name>ep</name> - 2</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ep</name> = --<name>d</name></expr>;</expr_stmt> <comment type="block">/* break the for loop as well */</comment>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name>c2x</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr>'x'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>d</name> += 3</expr>;</expr_stmt>
            </default>}</block></switch>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>d</name>++ = *<name>s</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>

    <return>return <expr>(<name>d</name> - (<name>unsigned</name> <name>char</name> *)<name>dest</name>)</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_bin2hex</name><argument_list>(<argument>const void *src</argument>, <argument>apr_size_t srclen</argument>, <argument>char *dest</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>in</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>srclen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr>*<name>dest</name>++ = <name><name>c2x_table</name><index>[<expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>dest</name>++ = <name><name>c2x_table</name><index>[<expr><name><name>in</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr>*<name>dest</name> = '\0'</expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_directory</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *path</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>                <comment type="block">/* in error condition, just return no */</comment>

    <return>return <expr>(<name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name>)</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_rdirectory</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *path</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_LINK</name> | <name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>                <comment type="block">/* in error condition, just return no */</comment>

    <return>return <expr>(<name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name>)</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_make_full_path</name><argument_list>(<argument>apr_pool_t *a</argument>, <argument>const char *src1</argument>,
                                  <argument>const char *src2</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>len1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>src1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len2</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>src2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="block">/* allocate +3 for '/' delimiter, trailing NULL and overallocate
      * one extra byte to allow the caller to add a trailing '/'
      */</comment>
    <expr_stmt><expr><name>path</name> = (<name>char</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>len1</name> + <name>len2</name> + 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len1</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>path</name> = '/'</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> + 1</expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>len2</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>next</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>src1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>next</name> = <name>path</name> + <name>len1</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>next</name><index>[<expr>-1</expr>]</index></name> != '/'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>next</name>++ = '/'</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name>src2</name></expr></argument>, <argument><expr><name>len2</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>path</name></expr>;</return>
}</block>

<comment type="block">/*
 * Check for an absoluteURI syntax (see section 3.2 in RFC2068).
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_url</name><argument_list>(<argument>const char *u</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>x</name> = 0</expr>;</init> <condition><expr><name><name>u</name><index>[<expr><name>x</name></expr>]</index></name> != ':'</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr>(!<name><name>u</name><index>[<expr><name>x</name></expr>]</index></name>) ||
            ((!<call><name>apr_isalnum</name><argument_list>(<argument><expr><name><name>u</name><index>[<expr><name>x</name></expr>]</index></name></expr></argument>)</argument_list></call>) &amp;&amp;
             (<name><name>u</name><index>[<expr><name>x</name></expr>]</index></name> != '+') &amp;&amp; (<name><name>u</name><index>[<expr><name>x</name></expr>]</index></name> != '-') &amp;&amp; (<name><name>u</name><index>[<expr><name>x</name></expr>]</index></name> != '.'))</expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
    }</block></for>

    <return>return <expr>(<name>x</name> ? 1 : 0)</expr>;</return>                <comment type="block">/* If the first character is ':', it's broken, too */</comment>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_ind</name><argument_list>(<argument>const char *s</argument>, <argument>char c</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
    <return>return <expr><name>p</name> - <name>s</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rind</name><argument_list>(<argument>const char *s</argument>, <argument>char c</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>ap_strrchr_c</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
    <return>return <expr><name>p</name> - <name>s</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_str_tolower</name><argument_list>(<argument>char *str</argument>)</argument_list></macro>
<block>{
    <while>while <condition>(<expr>*<name>str</name></expr>)</condition> <block>{
        <expr_stmt><expr>*<name>str</name> = <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
    }</block></while>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_str_toupper</name><argument_list>(<argument>char *str</argument>)</argument_list></macro>
<block>{
    <while>while <condition>(<expr>*<name>str</name></expr>)</condition> <block>{
        <expr_stmt><expr>*<name>str</name> = <call><name>apr_toupper</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
    }</block></while>
}</block>

<comment type="block">/*
 * We must return a FQDN
 */</comment>
<function><type><name>char</name> *</type><name>ap_get_local_host</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>a</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAXHOSTNAMELEN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXHOSTNAMELEN</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><name>MAXHOSTNAMELEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>server_hostname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>sockaddr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>hostname</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>apr_gethostname</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> - 1</expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name> | <name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00556</expr></argument>)</argument_list></call>
                     "%s: apr_gethostname() failed to determine ServerName"</expr></argument>,
                     <argument><expr><name>ap_server_argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>str</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>apr_sockaddr_info_get</name><argument_list>(<argument><expr>&amp;<name>sockaddr</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>APR_UNSPEC</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <if>if <condition>( <expr>(<call><name>apr_getnameinfo</name><argument_list>(<argument><expr>&amp;<name>hostname</name></expr></argument>, <argument><expr><name>sockaddr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>) &amp;&amp;
                (<call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call>)</expr> )</condition><then> <block>{
                <expr_stmt><expr><name>server_hostname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>server_hostname</name></expr>;</return>
            }</block></then> <else>else <if>if <condition>(<expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>server_hostname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>apr_sockaddr_ip_get</name><argument_list>(<argument><expr>&amp;<name>hostname</name></expr></argument>, <argument><expr><name>sockaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>server_hostname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name> | <name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00557</expr></argument>)</argument_list></call>
                         "%s: apr_sockaddr_info_get() failed for %s"</expr></argument>,
                         <argument><expr><name>ap_server_argv0</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>

    <if>if <condition>(<expr>!<name>server_hostname</name></expr>)</condition><then>
        <expr_stmt><expr><name>server_hostname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>"127.0.0.1"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name>|<name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00558</expr></argument>)</argument_list></call>
                 "%s: Could not reliably determine the server's fully qualified "
                 "domain name, using %s. Set the 'ServerName' directive globally "
                 "to suppress this message"</expr></argument>,
                 <argument><expr><name>ap_server_argv0</name></expr></argument>, <argument><expr><name>server_hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>server_hostname</name></expr>;</return>
}</block></function>

<comment type="block">/* simple 'pool' alloc()ing glue to apr_base64.c
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_pbase64decode</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *bufcoded</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>decoded</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>decoded</name> = (<name>char</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1 + <call><name>apr_base64_decode_len</name><argument_list>(<argument><expr><name>bufcoded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l</name> = <call><name>apr_base64_decode</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>bufcoded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoded</name><index>[<expr><name>l</name></expr>]</index></name> = '\0'</expr>;</expr_stmt> <comment type="block">/* make binary sequence into string */</comment>

    <return>return <expr><name>decoded</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_pbase64encode</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>char *string</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>encoded</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>encoded</name> = (<name>char</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1 + <call><name>apr_base64_encode_len</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l</name> = <call><name>apr_base64_encode</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoded</name><index>[<expr><name>l</name></expr>]</index></name> = '\0'</expr>;</expr_stmt> <comment type="block">/* make binary sequence into string */</comment>

    <return>return <expr><name>encoded</name></expr>;</return>
}</block>

<comment type="block">/* we want to downcase the type/subtype for comparison purposes
 * but nothing else because ;parameter=foo values are case sensitive.
 * XXX: in truth we want to downcase parameter names... but really,
 * apache has never handled parameters and such correctly.  You
 * also need to compress spaces and such to be able to compare
 * properly. -djg
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_content_type_tolower</name><argument_list>(<argument>char *str</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>semi</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>semi</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>semi</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>semi</name> = '\0'</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>semi</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>semi</name> = ';'</expr>;</expr_stmt>
    }</block></then></if>
}</block>

<comment type="block">/*
 * Given a string, replace any bare " with \" .
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_escape_quotes</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *instring</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>newlen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>inchr</name> <init>= <expr><name>instring</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>outchr</name></decl>, *<decl><type ref="prev"/><name>outstring</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Look through the input string, jogging the length of the output
     * string up by an extra byte each time we find an unescaped ".
     */</comment>
    <while>while <condition>(<expr>*<name>inchr</name> != '\0'</expr>)</condition> <block>{
        <expr_stmt><expr><name>newlen</name>++</expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>inchr</name> == '"'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>newlen</name>++</expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/*
         * If we find a slosh, and it's not the last byte in the string,
         * it's escaping something - advance past both bytes.
         */</comment>
        <if>if <condition>(<expr>(*<name>inchr</name> == '\\') &amp;&amp; (<name><name>inchr</name><index>[<expr>1</expr>]</index></name> != '\0')</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>inchr</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><name>newlen</name>++</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>inchr</name>++</expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name>outstring</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>newlen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>inchr</name> = <name>instring</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>outchr</name> = <name>outstring</name></expr>;</expr_stmt>
    <comment type="block">/*
     * Now copy the input string to the output string, inserting a slosh
     * in front of every " that doesn't already have one.
     */</comment>
    <while>while <condition>(<expr>*<name>inchr</name> != '\0'</expr>)</condition> <block>{
        <if>if <condition>(<expr>(*<name>inchr</name> == '\\') &amp;&amp; (<name><name>inchr</name><index>[<expr>1</expr>]</index></name> != '\0')</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>outchr</name>++ = *<name>inchr</name>++</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>outchr</name>++ = *<name>inchr</name>++</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>*<name>inchr</name> == '"'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>outchr</name>++ = '\\'</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>*<name>inchr</name> != '\0'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>outchr</name>++ = *<name>inchr</name>++</expr>;</expr_stmt>
        }</block></then></if>
    }</block></while>
    <expr_stmt><expr>*<name>outchr</name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><name>outstring</name></expr>;</return>
}</block>

<comment type="block">/*
 * Given a string, append the PID deliminated by delim.
 * Usually used to create a pid-appended filepath name
 * (eg: /a/b/foo -&gt; /a/b/foo.6726). A function, and not
 * a macro, to avoid unistd.h dependency
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_append_pid</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *string</argument>,
                                    <argument>const char *delim</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"%s%s%" <name>APR_PID_T_FMT</name></expr></argument>, <argument><expr><name>string</name></expr></argument>,
                        <argument><expr><name>delim</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

}</block>

<comment type="block">/**
 * Parse a given timeout parameter string into an apr_interval_time_t value.
 * The unit of the time interval is given as postfix string to the numeric
 * string. Currently the following units are understood:
 *
 * ms    : milliseconds
 * s     : seconds
 * mi[n] : minutes
 * h     : hours
 *
 * If no unit is contained in the given timeout parameter the default_time_unit
 * will be used instead.
 * @param timeout_parameter The string containing the timeout parameter.
 * @param timeout The timeout value to be returned.
 * @param default_time_unit The default time unit to use if none is specified
 * in timeout_parameter.
 * @return Status value indicating whether the parsing was successful or not.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_timeout_parameter_parse</name><argument_list>(
                                               <argument>const char *timeout_parameter</argument>,
                                               <argument>apr_interval_time_t *timeout</argument>,
                                               <argument>const char *default_time_unit</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>endp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>time_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>tout</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tout</name> = <call><name>apr_strtoi64</name><argument_list>(<argument><expr><name>timeout_parameter</name></expr></argument>, <argument><expr>&amp;<name>endp</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>errno</name></expr>)</condition><then> <block>{
        <return>return <expr><name>errno</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>endp</name> || !*<name>endp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>time_str</name> = <name>default_time_unit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>time_str</name> = <name>endp</name></expr>;</expr_stmt>
    }</block></else></if>

    <switch>switch <condition>(<expr>*<name>time_str</name></expr>)</condition> <block>{
        <comment type="block">/* Time is in seconds */</comment>
    <case>case <expr>'s'</expr>:
        <expr_stmt><expr>*<name>timeout</name> = (<name>apr_interval_time_t</name>) <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>tout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr>'h'</expr>:
        <comment type="block">/* Time is in hours */</comment>
        <expr_stmt><expr>*<name>timeout</name> = (<name>apr_interval_time_t</name>) <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>tout</name> * 3600</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr>'m'</expr>:
        <switch>switch <condition>(<expr>*(++<name>time_str</name>)</expr>)</condition> <block>{
        <comment type="block">/* Time is in milliseconds */</comment>
        <case>case <expr>'s'</expr>:
            <expr_stmt><expr>*<name>timeout</name> = (<name>apr_interval_time_t</name>) <name>tout</name> * 1000</expr>;</expr_stmt>
            <break>break;</break>
        <comment type="block">/* Time is in minutes */</comment>
        </case><case>case <expr>'i'</expr>:
            <expr_stmt><expr>*<name>timeout</name> = (<name>apr_interval_time_t</name>) <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>tout</name> * 60</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
        </default>}</block></switch>
        <break>break;</break>
    </case><default>default:
        <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
    </default>}</block></switch>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<comment type="block">/**
 * Determine if a request has a request body or not.
 *
 * @param r the request_rec of the request
 * @return truth value
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_request_has_body</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>cl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>estr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cls</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>has_body</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>has_body</name> = (!<name><name>r</name>-&gt;<name>header_only</name></name>
                &amp;&amp; (<name><name>r</name>-&gt;<name>kept_body</name></name>
                    || <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>)</argument_list></call>
                    || ( (<name>cls</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call>)
                        &amp;&amp; (<call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>cl</name></expr></argument>, <argument><expr><name>cls</name></expr></argument>, <argument><expr>&amp;<name>estr</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>)
                        &amp;&amp; (!*<name>estr</name>)
                        &amp;&amp; (<name>cl</name> &gt; 0) )
                    )
                )</expr>;</expr_stmt>
    <return>return <expr><name>has_body</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pool_cleanup_set_null</name><argument_list>(<argument>void *data_</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>void</name> **</type><name>ptr</name> <init>= <expr>(<name>void</name> **)<name>data_</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr>*<name>ptr</name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_str2_alnum</name><argument_list>(<argument>const char *src</argument>, <argument>char *dest</argument>)</argument_list></macro> <block>{

    <for>for ( <init>;</init> <condition><expr>*<name>src</name></expr>;</condition> <incr><expr><name>src</name>++</expr>, <expr><name>dest</name>++</expr></incr>)
    <block>{
        <if>if <condition>(<expr>!<call><name>apr_isprint</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*<name>dest</name> = 'x'</expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr>!<call><name>apr_isalnum</name><argument_list>(<argument><expr>*<name>src</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*<name>dest</name> = '_'</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr>*<name>dest</name> = (<name>char</name>)*<name>src</name></expr>;</expr_stmt></else></if></else></if>
    }</block></for>
    <expr_stmt><expr>*<name>dest</name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>

}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_pstr2_alnum</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *src</argument>,
                                        <argument>const char **dest</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>new</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>new</name></expr>)</condition><then>
        <return>return <expr><name>APR_ENOMEM</name></expr>;</return></then></if>
    <expr_stmt><expr>*<name>dest</name> = <name>new</name></expr>;</expr_stmt>
    <return>return <expr><call><name>ap_str2_alnum</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/**
 * Read the body and parse any form found, which must be of the
 * type application/x-www-form-urlencoded.
 *
 * Name/value pairs are returned in an array, with the names as
 * strings with a maximum length of HUGE_STRING_LEN, and the
 * values as bucket brigades. This allows values to be arbitrarily
 * large.
 *
 * All url-encoding is removed from both the names and the values
 * on the fly. The names are interpreted as strings, while the
 * values are interpreted as blocks of binary data, that may
 * contain the 0 character.
 *
 * In order to ensure that resource limits are not exceeded, a
 * maximum size must be provided. If the sum of the lengths of
 * the names and the values exceed this size, this function
 * will return HTTP_REQUEST_ENTITY_TOO_LARGE.
 *
 * An optional number of parameters can be provided, if the number
 * of parameters provided exceeds this amount, this function will
 * return HTTP_REQUEST_ENTITY_TOO_LARGE. If this value is negative,
 * no limit is imposed, and the number of parameters is in turn
 * constrained by the size parameter above.
 *
 * This function honours any kept_body configuration, and the
 * original raw request body will be saved to the kept_body brigade
 * if so configured, just as ap_discard_request_body does.
 *
 * NOTE: File upload is not yet supported, but can be without change
 * to the function call.
 */</comment>

<comment type="block">/* form parsing stuff */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>FORM_NORMAL</name></decl>,
    <decl><name>FORM_AMP</name></decl>,
    <decl><name>FORM_NAME</name></decl>,
    <decl><name>FORM_VALUE</name></decl>,
    <decl><name>FORM_PERCENTA</name></decl>,
    <decl><name>FORM_PERCENTB</name></decl>,
    <decl><name>FORM_ABORT</name></decl>
}</block></enum></type> <name>ap_form_type_t</name>;</typedef>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_parse_form_data</name><argument_list>(<argument>request_rec *r</argument>, <argument>ap_filter_t *f</argument>,
                                   <argument>apr_array_header_t **ptr</argument>,
                                   <argument>apr_size_t num</argument>, <argument>apr_size_t usize</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>seen_eos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>HUGE_STRING_LEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ct</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_form_type_t</name></type> <name>state</name> <init>= <expr><name>FORM_NAME</name></expr></init>, <name>percent</name> <init>= <expr><name>FORM_NORMAL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_form_pair_t</name> *</type><name>pair</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>pairs</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ap_form_pair_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>escaped_char</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>ptr</name> = <name>pairs</name></expr>;</expr_stmt>

    <comment type="block">/* sanity check - we only support forms for now */</comment>
    <expr_stmt><expr><name>ct</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ct</name> || <call><name>strncasecmp</name><argument_list>(<argument><expr>"application/x-www-form-urlencoded"</expr></argument>, <argument><expr><name>ct</name></expr></argument>, <argument><expr>33</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><call><name>ap_discard_request_body</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>usize</name> &gt; <name>APR_SIZE_MAX</name> &gt;&gt; 1</expr>)</condition><then>
        <expr_stmt><expr><name>size</name> = <name>APR_SIZE_MAX</name> &gt;&gt; 1</expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>size</name> = <name>usize</name></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr>!<name>f</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>f</name> = <name><name>r</name>-&gt;<name>input_filters</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name> <init>= <expr><name>NULL</name></expr></init>, *<name>last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><call><name>ap_get_brigade</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>AP_MODE_READBYTES</name></expr></argument>,
                                <argument><expr><name>APR_BLOCK_READ</name></expr></argument>, <argument><expr><name>HUGE_STRING_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ap_map_http_request_error</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <for>for (<init><expr><name>bucket</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>bucket</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>last</name> = <name>bucket</name></expr>, <expr><name>bucket</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>slide</name></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>last</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>seen_eos</name> = 1</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>bucket</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>slide</name> = <name>len</name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>state</name> != <name>FORM_ABORT</name> &amp;&amp; <name>slide</name>-- &gt; 0 &amp;&amp; <name>size</name> &gt;= 0 &amp;&amp; <name>num</name> != 0</expr>)</condition> <block>{
                <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*<name>data</name>++</expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr>'+' == <name>c</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>c</name> = ' '</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>'&amp;' == <name>c</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>state</name> = <name>FORM_AMP</name></expr>;</expr_stmt>
                }</block></then></if></else></if>
                <if>if <condition>(<expr>'%' == <name>c</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>percent</name> = <name>FORM_PERCENTA</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
                <if>if <condition>(<expr><name>FORM_PERCENTA</name> == <name>percent</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>escaped_char</name><index>[<expr>0</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>percent</name> = <name>FORM_PERCENTB</name></expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then></if>
                <if>if <condition>(<expr><name>FORM_PERCENTB</name> == <name>percent</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>escaped_char</name><index>[<expr>1</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c</name> = <call><name>x2c</name><argument_list>(<argument><expr><name>escaped_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>percent</name> = <name>FORM_NORMAL</name></expr>;</expr_stmt>
                }</block></then></if>
                <switch>switch <condition>(<expr><name>state</name></expr>)</condition> <block>{
                    <case>case <expr><name>FORM_AMP</name></expr>:
                        <if>if <condition>(<expr><name>pair</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>pair</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><name>state</name> = <name>FORM_NAME</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>pair</name> = <name>NULL</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
                        <expr_stmt><expr><name>num</name>--</expr>;</expr_stmt>
                        <break>break;</break>
                    </case><case>case <expr><name>FORM_NAME</name></expr>:
                        <if>if <condition>(<expr><name>offset</name> &lt; <name>HUGE_STRING_LEN</name></expr>)</condition><then> <block>{
                            <if>if <condition>(<expr>'=' == <name>c</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name> = 0</expr>;</expr_stmt>
                                <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
                                <expr_stmt><expr><name>pair</name> = (<name>ap_form_pair_t</name> *) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>pair</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name><name>pair</name>-&gt;<name>value</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                <expr_stmt><expr><name>state</name> = <name>FORM_VALUE</name></expr>;</expr_stmt>
                            }</block></then>
                            <else>else <block>{
                                <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
                                <expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
                            }</block></else></if>
                        }</block></then>
                        <else>else <block>{
                            <expr_stmt><expr><name>state</name> = <name>FORM_ABORT</name></expr>;</expr_stmt>
                        }</block></else></if>
                        <break>break;</break>
                    </case><case>case <expr><name>FORM_VALUE</name></expr>:
                        <if>if <condition>(<expr><name>offset</name> &gt;= <name>HUGE_STRING_LEN</name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>pair</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
                        }</block></then></if>
                        <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>offset</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
                        <break>break;</break>
                    </case><default>default:
                        <break>break;</break>
                </default>}</block></switch>
            }</block></while>

        }</block></for>

        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block> while <condition>(<expr>!<name>seen_eos</name></expr>)</condition>;</do>

    <if>if <condition>(<expr><name>FORM_ABORT</name> == <name>state</name> || <name>size</name> &lt; 0 || <name>num</name> == 0</expr>)</condition><then> <block>{
        <return>return <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>FORM_VALUE</name> == <name>state</name> &amp;&amp; <name>pair</name> &amp;&amp; <name>offset</name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>pair</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <return>return <expr><name>OK</name></expr>;</return>

}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARBUF_SMALL_SIZE</name></cpp:macro> <cpp:value>2048</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARBUF_MAX_SIZE</name></cpp:macro>   <cpp:value>(APR_SIZE_MAX - 1 -                                \
                           APR_ALIGN_DEFAULT(sizeof(struct ap_varbuf_info)))</cpp:value></cpp:define>

<struct>struct <name>ap_varbuf_info</name> <block>{
    <decl_stmt><decl><type>struct <name>apr_memnode_t</name> *</type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>varbuf_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>info_</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>ap_varbuf_info</name> *</type><name>info</name> <init>= <expr><name>info_</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>info</name>-&gt;<name>node</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_allocator_free</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>allocator</name></name></expr></argument>, <argument><expr><name><name>info</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>nul</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> * <specifier>const</specifier></type> <name>varbuf_empty</name> <init>= <expr>(<name>char</name> *)&amp;<name>nul</name></expr></init></decl>;</decl_stmt>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_init</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>struct ap_varbuf *vb</argument>,
                                <argument>apr_size_t init_size</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name></name> = <name>varbuf_empty</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>avail</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <name>AP_VARBUF_UNKNOWN</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>pool</name></name> = <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>info</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>init_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_grow</name><argument_list>(<argument>struct ap_varbuf *vb</argument>, <argument>apr_size_t new_len</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_memnode_t</name> *</type><name>new_node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>ap_varbuf_info</name> *</type><name>new_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>new</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name> || <name><name>vb</name>-&gt;<name>avail</name></name> &gt;= <name><name>vb</name>-&gt;<name>strlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>new_len</name> &lt;= <name><name>vb</name>-&gt;<name>avail</name></name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><name>new_len</name> &lt; 2 * <name><name>vb</name>-&gt;<name>avail</name></name> &amp;&amp; <name><name>vb</name>-&gt;<name>avail</name></name> &lt; <name>VARBUF_MAX_SIZE</name>/2</expr>)</condition><then> <block>{
        <comment type="block">/* at least double the size, to avoid repeated reallocations */</comment>
        <expr_stmt><expr><name>new_len</name> = 2 * <name><name>vb</name>-&gt;<name>avail</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>new_len</name> &gt; <name>VARBUF_MAX_SIZE</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_abortfunc_t</name></type> <name>abort_fn</name> <init>= <expr><call><name>apr_pool_abort_get</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>abort_fn</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>abort_fn</name><argument_list>(<argument><expr><name>APR_ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if></else></if>

    <expr_stmt><expr><name>new_len</name>++</expr>;</expr_stmt>  <comment type="block">/* add space for trailing \0 */</comment>
    <if>if <condition>(<expr><name>new_len</name> &lt;= <name>VARBUF_SMALL_SIZE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>new_len</name> = <call><name>APR_ALIGN_DEFAULT</name><argument_list>(<argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>new</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>avail</name></name> &amp;&amp; <name><name>vb</name>-&gt;<name>strlen</name></name> != 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name> != <name>varbuf_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>new</name> == <name><name>vb</name>-&gt;<name>buf</name></name> + <name><name>vb</name>-&gt;<name>avail</name></name> + 1</expr>)</condition><then> <block>{
                <comment type="block">/* We are lucky: the new memory lies directly after our old
                 * buffer, we can now use both.
                 */</comment>
                <expr_stmt><expr><name><name>vb</name>-&gt;<name>avail</name></name> += <name>new_len</name></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* copy up to vb-&gt;strlen + 1 bytes */</comment>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name> ?
                                     <name><name>vb</name>-&gt;<name>avail</name></name> + 1 : <name><name>vb</name>-&gt;<name>strlen</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>new</name> = '\0'</expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>avail</name></name> = <name>new_len</name> - 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name></name> = <name>new</name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* The required block is rather larger. Use allocator directly so that
     * the memory can be freed independently from the pool. */</comment>
    <expr_stmt><expr><name>allocator</name> = <call><name>apr_pool_allocator_get</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>new_len</name> &lt;= <name>VARBUF_MAX_SIZE</name></expr>)</condition><then>
        <expr_stmt><expr><name>new_node</name> = <call><name>apr_allocator_alloc</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>,
                                       <argument><expr><name>new_len</name> + <call><name>APR_ALIGN_DEFAULT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr>!<name>new_node</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_abortfunc_t</name></type> <name>abort_fn</name> <init>= <expr><call><name>apr_pool_abort_get</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>abort_fn</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>abort_fn</name><argument_list>(<argument><expr><name>APR_ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name>new_info</name> = (struct <name>ap_varbuf_info</name> *)<name><name>new_node</name>-&gt;<name>first_avail</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_node</name>-&gt;<name>first_avail</name></name> += <call><name>APR_ALIGN_DEFAULT</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_info</name>-&gt;<name>node</name></name> = <name>new_node</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_info</name>-&gt;<name>allocator</name></name> = <name>allocator</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>new</name> = <name><name>new_node</name>-&gt;<name>first_avail</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name><name>new_node</name>-&gt;<name>endp</name></name> - <name><name>new_node</name>-&gt;<name>first_avail</name></name> &gt;= <name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>new_len</name> = <name><name>new_node</name>-&gt;<name>endp</name></name> - <name><name>new_node</name>-&gt;<name>first_avail</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>avail</name></name> &amp;&amp; <name><name>vb</name>-&gt;<name>strlen</name></name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name> ?
                             <name><name>vb</name>-&gt;<name>avail</name></name> + 1 : <name><name>vb</name>-&gt;<name>strlen</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr>*<name>new</name> = '\0'</expr>;</expr_stmt></else></if>
    <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>info</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_pool_cleanup_run</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>info</name></name></expr></argument>, <argument><expr><name>varbuf_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>new_info</name></expr></argument>, <argument><expr><name>varbuf_cleanup</name></expr></argument>,
                              <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>info</name></name> = <name>new_info</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name></name> = <name>new</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>avail</name></name> = <name>new_len</name> - 1</expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_strmemcat</name><argument_list>(<argument>struct ap_varbuf *vb</argument>, <argument>const char *str</argument>,
                                     <argument>int len</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
        <return>return;</return></then></if>
    <if>if <condition>(<expr>!<name><name>vb</name>-&gt;<name>avail</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <name>len</name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>ap_varbuf_grow</name><argument_list>(<argument><expr><name>vb</name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>strlen</name></name> + <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>buf</name></name> + <name><name>vb</name>-&gt;<name>strlen</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>strlen</name></name> += <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name><index>[<expr><name><name>vb</name>-&gt;<name>strlen</name></name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_varbuf_free</name><argument_list>(<argument>struct ap_varbuf *vb</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><name><name>vb</name>-&gt;<name>info</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_pool_cleanup_run</name><argument_list>(<argument><expr><name><name>vb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>vb</name>-&gt;<name>info</name></name></expr></argument>, <argument><expr><name>varbuf_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vb</name>-&gt;<name>info</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>vb</name>-&gt;<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_varbuf_pdup</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>struct ap_varbuf *buf</argument>,
                                  <argument>const char *prepend</argument>, <argument>apr_size_t prepend_len</argument>,
                                  <argument>const char *append</argument>, <argument>apr_size_t append_len</argument>,
                                  <argument>apr_size_t *new_len</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>iovec</name></type> <name><name>vec</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>prepend</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name>prepend</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <name>prepend_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>buf</name>-&gt;<name>avail</name></name> &amp;&amp; <name><name>buf</name>-&gt;<name>strlen</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>buf</name>-&gt;<name>strlen</name></name> == <name>AP_VARBUF_UNKNOWN</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>buf</name>-&gt;<name>strlen</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>buf</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name><name>buf</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <name><name>buf</name>-&gt;<name>strlen</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>append</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name>append</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec</name><index>[<expr><name>i</name></expr>]</index></name>.<name>iov_len</name> = <name>append_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>i</name></expr>)</condition><then>
        <return>return <expr><call><name>apr_pstrcatv</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <if>if <condition>(<expr><name>new_len</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>new_len</name> = 0</expr>;</expr_stmt></then></if>
    <return>return <expr>""</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_varbuf_regsub</name><argument_list>(<argument>struct ap_varbuf *vb</argument>,
                                          <argument>const char *input</argument>,
                                          <argument>const char *source</argument>,
                                          <argument>apr_size_t nmatch</argument>,
                                          <argument>ap_regmatch_t pmatch[]</argument>,
                                          <argument>apr_size_t maxlen</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>regsub_core</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vb</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>nmatch</name></expr></argument>, <argument><expr><name>pmatch</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name>oom_message</name> <init>= <expr>"[crit] Memory allocation failed, "
                                        "aborting process." <name>APR_EOL_STR</name></expr></init></decl>;</decl_stmt>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_abort_on_oom</name><argument_list>()</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>written</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>oom_message</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name> <init>= <expr><name>oom_message</name></expr></init></decl>;</decl_stmt>
    <do>do <block>{
        <expr_stmt><expr><name>written</name> = <call><name>write</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>written</name> == <name>count</name></expr>)</condition><then>
            <break>break;</break></then></if>
        <if>if <condition>(<expr><name>written</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>buf</name> += <name>written</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>count</name> -= <name>written</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block> while <condition>(<expr><name>written</name> &gt;= 0 || <name>errno</name> == <name>EINTR</name></expr>)</condition>;</do>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_malloc</name><argument_list>(<argument>size_t size</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name> == <name>NULL</name> &amp;&amp; <name>size</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_abort_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>p</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_calloc</name><argument_list>(<argument>size_t nelem</argument>, <argument>size_t size</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><name>nelem</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name> == <name>NULL</name> &amp;&amp; <name>nelem</name> != 0 &amp;&amp; <name>size</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_abort_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>p</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_realloc</name><argument_list>(<argument>void *ptr</argument>, <argument>size_t size</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>p</name> <init>= <expr><call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>p</name> == <name>NULL</name> &amp;&amp; <name>size</name> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_abort_on_oom</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>p</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_get_sload</name><argument_list>(<argument>ap_sload_t *ld</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>server_limit</name></decl>, <decl><type ref="prev"/><name>thread_limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ready</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>busy</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>total</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_generation_t</name></type> <name>mpm_generation</name></decl>;</decl_stmt>

    <comment type="block">/* preload errored fields, we overwrite */</comment>
    <expr_stmt><expr><name><name>ld</name>-&gt;<name>idle</name></name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ld</name>-&gt;<name>busy</name></name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ld</name>-&gt;<name>bytes_served</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ld</name>-&gt;<name>access_count</name></name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_mpm_query</name><argument_list>(<argument><expr><name>AP_MPMQ_GENERATION</name></expr></argument>, <argument><expr>&amp;<name>mpm_generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_mpm_query</name><argument_list>(<argument><expr><name>AP_MPMQ_HARD_LIMIT_THREADS</name></expr></argument>, <argument><expr>&amp;<name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_mpm_query</name><argument_list>(<argument><expr><name>AP_MPMQ_HARD_LIMIT_DAEMONS</name></expr></argument>, <argument><expr>&amp;<name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>server_limit</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>process_score</name> *</type><name>ps</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>ps</name> = <call><name>ap_get_scoreboard_process</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>thread_limit</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>worker_score</name> *</type><name>ws</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>ws</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>res</name> = <name><name>ws</name>-&gt;<name>status</name></name></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<name><name>ps</name>-&gt;<name>quiescing</name></name> &amp;&amp; <name><name>ps</name>-&gt;<name>pid</name></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>res</name> == <name>SERVER_READY</name> &amp;&amp; <name><name>ps</name>-&gt;<name>generation</name></name> == <name>mpm_generation</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>ready</name>++</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>res</name> != <name>SERVER_DEAD</name> &amp;&amp;
                         <name>res</name> != <name>SERVER_STARTING</name> &amp;&amp; <name>res</name> != <name>SERVER_IDLE_KILL</name> &amp;&amp;
                         <name><name>ps</name>-&gt;<name>generation</name></name> == <name>mpm_generation</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>busy</name>++</expr>;</expr_stmt>
                }</block></then></if></else></if>   
            }</block></then></if>

            <if>if <condition>(<expr><name>ap_extended_status</name> &amp;&amp; !<name><name>ps</name>-&gt;<name>quiescing</name></name> &amp;&amp; <name><name>ps</name>-&gt;<name>pid</name></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>ws</name>-&gt;<name>access_count</name></name> != 0 
                    || (<name>res</name> != <name>SERVER_READY</name> &amp;&amp; <name>res</name> != <name>SERVER_DEAD</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ld</name>-&gt;<name>access_count</name></name> += <name><name>ws</name>-&gt;<name>access_count</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ld</name>-&gt;<name>bytes_served</name></name> += <name><name>ws</name>-&gt;<name>bytes_served</name></name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></for>
    }</block></for>
    <expr_stmt><expr><name>total</name> = <name>busy</name> + <name>ready</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>total</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ld</name>-&gt;<name>idle</name></name> = <name>ready</name> * 100 / <name>total</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ld</name>-&gt;<name>busy</name></name> = <name>busy</name> * 100 / <name>total</name></expr>;</expr_stmt>
    }</block></then></if>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_get_loadavg</name><argument_list>(<argument>ap_loadavg_t *ld</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* preload errored fields, we overwrite */</comment>
    <expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg</name></name> = -1.0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg5</name></name> = -1.0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg15</name></name> = -1.0</expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_GETLOADAVG</name></expr></cpp:if>
    <block>{
        <decl_stmt><decl><type><name>double</name></type> <name><name>la</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>num</name> = <call><name>getloadavg</name><argument_list>(<argument><expr><name>la</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>num</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg</name></name> = (<name>float</name>)<name><name>la</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>num</name> &gt; 1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg5</name></name> = (<name>float</name>)<name><name>la</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>num</name> &gt; 2</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ld</name>-&gt;<name>loadavg15</name></name> = (<name>float</name>)<name><name>la</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_get_exec_line</name><argument_list>(<argument>apr_pool_t *p</argument>,
                                    <argument>const char *cmd</argument>,
                                    <argument>const char * const * argv</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_procattr_t</name> *</type><name>procattr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_proc_t</name> *</type><name>proc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nbytes</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>apr_procattr_create</name><argument_list>(<argument><expr>&amp;<name>procattr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>apr_procattr_io_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>,
                            <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>apr_procattr_dir_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>,
                             <argument><expr><call><name>ap_make_dirstr_parent</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <if>if <condition>(<expr><call><name>apr_procattr_cmdtype_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>APR_PROGRAM</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>proc</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>apr_proc_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>apr_proc_create</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <expr_stmt><expr><name>fp</name> = <name><name>proc</name>-&gt;<name>out</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    <comment type="block">/* XXX: we are reading 1 byte at a time here */</comment>
    <for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><call><name>apr_file_read</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>nbytes</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
                &amp;&amp; <name>nbytes</name> == 1 &amp;&amp; (<name>k</name> &lt; <name>MAX_STRING_LEN</name>-1)</expr>     ;</condition> <incr/>) <block>{
        <if>if <condition>(<expr><name>c</name> == '\n' || <name>c</name> == '\r'</expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>buf</name><index>[<expr><name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_array_str_index</name><argument_list>(<argument>const apr_array_header_t *array</argument>, 
                                   <argument>const char *s</argument>,
                                   <argument>int start</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><name>start</name> &gt;= 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        
        <for>for (<init><expr><name>i</name> = <name>start</name></expr>;</init> <condition><expr><name>i</name> &lt; <name><name>array</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
    }</block></then></if>
    
    <return>return <expr>-1</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_array_str_contains</name><argument_list>(<argument>const apr_array_header_t *array</argument>, 
                                      <argument>const char *s</argument>)</argument_list></macro>
<block>{
    <return>return <expr>(<call><name>ap_array_str_index</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &gt;= 0)</expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<comment type="block">/*
 * Our own known-fast translation table for casecmp by character.
 * Only ASCII alpha characters 41-5A are folded to 61-7A, other
 * octets (such as extended latin alphabetics) are never case-folded.
 * NOTE: Other than Alpha A-Z/a-z, each code point is unique!
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>short</name></type> <name><name>ucharmap</name><index>[]</index></name> <init>= <expr><block>{
    <expr>0x0</expr>,  <expr>0x1</expr>,  <expr>0x2</expr>,  <expr>0x3</expr>,  <expr>0x4</expr>,  <expr>0x5</expr>,  <expr>0x6</expr>,  <expr>0x7</expr>,
    <expr>0x8</expr>,  <expr>0x9</expr>,  <expr>0xa</expr>,  <expr>0xb</expr>,  <expr>0xc</expr>,  <expr>0xd</expr>,  <expr>0xe</expr>,  <expr>0xf</expr>,
    <expr>0x10</expr>, <expr>0x11</expr>, <expr>0x12</expr>, <expr>0x13</expr>, <expr>0x14</expr>, <expr>0x15</expr>, <expr>0x16</expr>, <expr>0x17</expr>,
    <expr>0x18</expr>, <expr>0x19</expr>, <expr>0x1a</expr>, <expr>0x1b</expr>, <expr>0x1c</expr>, <expr>0x1d</expr>, <expr>0x1e</expr>, <expr>0x1f</expr>,
    <expr>0x20</expr>, <expr>0x21</expr>, <expr>0x22</expr>, <expr>0x23</expr>, <expr>0x24</expr>, <expr>0x25</expr>, <expr>0x26</expr>, <expr>0x27</expr>,
    <expr>0x28</expr>, <expr>0x29</expr>, <expr>0x2a</expr>, <expr>0x2b</expr>, <expr>0x2c</expr>, <expr>0x2d</expr>, <expr>0x2e</expr>, <expr>0x2f</expr>,
    <expr>0x30</expr>, <expr>0x31</expr>, <expr>0x32</expr>, <expr>0x33</expr>, <expr>0x34</expr>, <expr>0x35</expr>, <expr>0x36</expr>, <expr>0x37</expr>,
    <expr>0x38</expr>, <expr>0x39</expr>, <expr>0x3a</expr>, <expr>0x3b</expr>, <expr>0x3c</expr>, <expr>0x3d</expr>, <expr>0x3e</expr>, <expr>0x3f</expr>,
    <expr>0x40</expr>,  <expr>'a'</expr>,  <expr>'b'</expr>,  <expr>'c'</expr>,  <expr>'d'</expr>,  <expr>'e'</expr>,  <expr>'f'</expr>,  <expr>'g'</expr>,
     <expr>'h'</expr>,  <expr>'i'</expr>,  <expr>'j'</expr>,  <expr>'k'</expr>,  <expr>'l'</expr>,  <expr>'m'</expr>,  <expr>'n'</expr>,  <expr>'o'</expr>,
     <expr>'p'</expr>,  <expr>'q'</expr>,  <expr>'r'</expr>,  <expr>'s'</expr>,  <expr>'t'</expr>,  <expr>'u'</expr>,  <expr>'v'</expr>,  <expr>'w'</expr>,
     <expr>'x'</expr>,  <expr>'y'</expr>,  <expr>'z'</expr>, <expr>0x5b</expr>, <expr>0x5c</expr>, <expr>0x5d</expr>, <expr>0x5e</expr>, <expr>0x5f</expr>,
    <expr>0x60</expr>,  <expr>'a'</expr>,  <expr>'b'</expr>,  <expr>'c'</expr>,  <expr>'d'</expr>,  <expr>'e'</expr>,  <expr>'f'</expr>,  <expr>'g'</expr>,
     <expr>'h'</expr>,  <expr>'i'</expr>,  <expr>'j'</expr>,  <expr>'k'</expr>,  <expr>'l'</expr>,  <expr>'m'</expr>,  <expr>'n'</expr>,  <expr>'o'</expr>,
     <expr>'p'</expr>,  <expr>'q'</expr>,  <expr>'r'</expr>,  <expr>'s'</expr>,  <expr>'t'</expr>,  <expr>'u'</expr>,  <expr>'v'</expr>,  <expr>'w'</expr>,
     <expr>'x'</expr>,  <expr>'y'</expr>,  <expr>'z'</expr>, <expr>0x7b</expr>, <expr>0x7c</expr>, <expr>0x7d</expr>, <expr>0x7e</expr>, <expr>0x7f</expr>,
    <expr>0x80</expr>, <expr>0x81</expr>, <expr>0x82</expr>, <expr>0x83</expr>, <expr>0x84</expr>, <expr>0x85</expr>, <expr>0x86</expr>, <expr>0x87</expr>,
    <expr>0x88</expr>, <expr>0x89</expr>, <expr>0x8a</expr>, <expr>0x8b</expr>, <expr>0x8c</expr>, <expr>0x8d</expr>, <expr>0x8e</expr>, <expr>0x8f</expr>,
    <expr>0x90</expr>, <expr>0x91</expr>, <expr>0x92</expr>, <expr>0x93</expr>, <expr>0x94</expr>, <expr>0x95</expr>, <expr>0x96</expr>, <expr>0x97</expr>,
    <expr>0x98</expr>, <expr>0x99</expr>, <expr>0x9a</expr>, <expr>0x9b</expr>, <expr>0x9c</expr>, <expr>0x9d</expr>, <expr>0x9e</expr>, <expr>0x9f</expr>,
    <expr>0xa0</expr>, <expr>0xa1</expr>, <expr>0xa2</expr>, <expr>0xa3</expr>, <expr>0xa4</expr>, <expr>0xa5</expr>, <expr>0xa6</expr>, <expr>0xa7</expr>,
    <expr>0xa8</expr>, <expr>0xa9</expr>, <expr>0xaa</expr>, <expr>0xab</expr>, <expr>0xac</expr>, <expr>0xad</expr>, <expr>0xae</expr>, <expr>0xaf</expr>,
    <expr>0xb0</expr>, <expr>0xb1</expr>, <expr>0xb2</expr>, <expr>0xb3</expr>, <expr>0xb4</expr>, <expr>0xb5</expr>, <expr>0xb6</expr>, <expr>0xb7</expr>,
    <expr>0xb8</expr>, <expr>0xb9</expr>, <expr>0xba</expr>, <expr>0xbb</expr>, <expr>0xbc</expr>, <expr>0xbd</expr>, <expr>0xbe</expr>, <expr>0xbf</expr>,
    <expr>0xc0</expr>, <expr>0xc1</expr>, <expr>0xc2</expr>, <expr>0xc3</expr>, <expr>0xc4</expr>, <expr>0xc5</expr>, <expr>0xc6</expr>, <expr>0xc7</expr>,
    <expr>0xc8</expr>, <expr>0xc9</expr>, <expr>0xca</expr>, <expr>0xcb</expr>, <expr>0xcc</expr>, <expr>0xcd</expr>, <expr>0xce</expr>, <expr>0xcf</expr>,
    <expr>0xd0</expr>, <expr>0xd1</expr>, <expr>0xd2</expr>, <expr>0xd3</expr>, <expr>0xd4</expr>, <expr>0xd5</expr>, <expr>0xd6</expr>, <expr>0xd7</expr>,
    <expr>0xd8</expr>, <expr>0xd9</expr>, <expr>0xda</expr>, <expr>0xdb</expr>, <expr>0xdc</expr>, <expr>0xdd</expr>, <expr>0xde</expr>, <expr>0xdf</expr>,
    <expr>0xe0</expr>, <expr>0xe1</expr>, <expr>0xe2</expr>, <expr>0xe3</expr>, <expr>0xe4</expr>, <expr>0xe5</expr>, <expr>0xe6</expr>, <expr>0xe7</expr>,
    <expr>0xe8</expr>, <expr>0xe9</expr>, <expr>0xea</expr>, <expr>0xeb</expr>, <expr>0xec</expr>, <expr>0xed</expr>, <expr>0xee</expr>, <expr>0xef</expr>,
    <expr>0xf0</expr>, <expr>0xf1</expr>, <expr>0xf2</expr>, <expr>0xf3</expr>, <expr>0xf4</expr>, <expr>0xf5</expr>, <expr>0xf6</expr>, <expr>0xf7</expr>,
    <expr>0xf8</expr>, <expr>0xf9</expr>, <expr>0xfa</expr>, <expr>0xfb</expr>, <expr>0xfc</expr>, <expr>0xfd</expr>, <expr>0xfe</expr>, <expr>0xff</expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* APR_CHARSET_EBCDIC */</comment>
<comment type="block">/*
 * Derived from apr-iconv/ccs/cp037.c for EBCDIC case comparison,
 * provides unique identity of every char value (strict ISO-646
 * conformance, arbitrary election of an ISO-8859-1 ordering, and
 * very arbitrary control code assignments into C1 to achieve
 * identity and a reversible mapping of code points),
 * then folding the equivalences of ASCII 41-5A into 61-7A, 
 * presenting comparison results in a somewhat ISO/IEC 10646
 * (ASCII-like) order, depending on the EBCDIC code page in use.
 *
 * NOTE: Other than Alpha A-Z/a-z, each code point is unique!
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>short</name></type> <name><name>ucharmap</name><index>[]</index></name> <init>= <expr><block>{
    <expr>0x00</expr>, <expr>0x01</expr>, <expr>0x02</expr>, <expr>0x03</expr>, <expr>0x9C</expr>, <expr>0x09</expr>, <expr>0x86</expr>, <expr>0x7F</expr>,
    <expr>0x97</expr>, <expr>0x8D</expr>, <expr>0x8E</expr>, <expr>0x0B</expr>, <expr>0x0C</expr>, <expr>0x0D</expr>, <expr>0x0E</expr>, <expr>0x0F</expr>,
    <expr>0x10</expr>, <expr>0x11</expr>, <expr>0x12</expr>, <expr>0x13</expr>, <expr>0x9D</expr>, <expr>0x85</expr>, <expr>0x08</expr>, <expr>0x87</expr>,
    <expr>0x18</expr>, <expr>0x19</expr>, <expr>0x92</expr>, <expr>0x8F</expr>, <expr>0x1C</expr>, <expr>0x1D</expr>, <expr>0x1E</expr>, <expr>0x1F</expr>,
    <expr>0x80</expr>, <expr>0x81</expr>, <expr>0x82</expr>, <expr>0x83</expr>, <expr>0x84</expr>, <expr>0x0A</expr>, <expr>0x17</expr>, <expr>0x1B</expr>,
    <expr>0x88</expr>, <expr>0x89</expr>, <expr>0x8A</expr>, <expr>0x8B</expr>, <expr>0x8C</expr>, <expr>0x05</expr>, <expr>0x06</expr>, <expr>0x07</expr>,
    <expr>0x90</expr>, <expr>0x91</expr>, <expr>0x16</expr>, <expr>0x93</expr>, <expr>0x94</expr>, <expr>0x95</expr>, <expr>0x96</expr>, <expr>0x04</expr>,
    <expr>0x98</expr>, <expr>0x99</expr>, <expr>0x9A</expr>, <expr>0x9B</expr>, <expr>0x14</expr>, <expr>0x15</expr>, <expr>0x9E</expr>, <expr>0x1A</expr>,
    <expr>0x20</expr>, <expr>0xA0</expr>, <expr>0xE2</expr>, <expr>0xE4</expr>, <expr>0xE0</expr>, <expr>0xE1</expr>, <expr>0xE3</expr>, <expr>0xE5</expr>,
    <expr>0xE7</expr>, <expr>0xF1</expr>, <expr>0xA2</expr>, <expr>0x2E</expr>, <expr>0x3C</expr>, <expr>0x28</expr>, <expr>0x2B</expr>, <expr>0x7C</expr>,
    <expr>0x26</expr>, <expr>0xE9</expr>, <expr>0xEA</expr>, <expr>0xEB</expr>, <expr>0xE8</expr>, <expr>0xED</expr>, <expr>0xEE</expr>, <expr>0xEF</expr>,
    <expr>0xEC</expr>, <expr>0xDF</expr>, <expr>0x21</expr>, <expr>0x24</expr>, <expr>0x2A</expr>, <expr>0x29</expr>, <expr>0x3B</expr>, <expr>0xAC</expr>,
    <expr>0x2D</expr>, <expr>0x2F</expr>, <expr>0xC2</expr>, <expr>0xC4</expr>, <expr>0xC0</expr>, <expr>0xC1</expr>, <expr>0xC3</expr>, <expr>0xC5</expr>,
    <expr>0xC7</expr>, <expr>0xD1</expr>, <expr>0xA6</expr>, <expr>0x2C</expr>, <expr>0x25</expr>, <expr>0x5F</expr>, <expr>0x3E</expr>, <expr>0x3F</expr>,
    <expr>0xF8</expr>, <expr>0xC9</expr>, <expr>0xCA</expr>, <expr>0xCB</expr>, <expr>0xC8</expr>, <expr>0xCD</expr>, <expr>0xCE</expr>, <expr>0xCF</expr>,
    <expr>0xCC</expr>, <expr>0x60</expr>, <expr>0x3A</expr>, <expr>0x23</expr>, <expr>0x40</expr>, <expr>0x27</expr>, <expr>0x3D</expr>, <expr>0x22</expr>,
    <expr>0xD8</expr>, <expr>0x61</expr>, <expr>0x62</expr>, <expr>0x63</expr>, <expr>0x64</expr>, <expr>0x65</expr>, <expr>0x66</expr>, <expr>0x67</expr>,
    <expr>0x68</expr>, <expr>0x69</expr>, <expr>0xAB</expr>, <expr>0xBB</expr>, <expr>0xF0</expr>, <expr>0xFD</expr>, <expr>0xFE</expr>, <expr>0xB1</expr>,
    <expr>0xB0</expr>, <expr>0x6A</expr>, <expr>0x6B</expr>, <expr>0x6C</expr>, <expr>0x6D</expr>, <expr>0x6E</expr>, <expr>0x6F</expr>, <expr>0x70</expr>,
    <expr>0x71</expr>, <expr>0x72</expr>, <expr>0xAA</expr>, <expr>0xBA</expr>, <expr>0xE6</expr>, <expr>0xB8</expr>, <expr>0xC6</expr>, <expr>0xA4</expr>,
    <expr>0xB5</expr>, <expr>0x7E</expr>, <expr>0x73</expr>, <expr>0x74</expr>, <expr>0x75</expr>, <expr>0x76</expr>, <expr>0x77</expr>, <expr>0x78</expr>,
    <expr>0x79</expr>, <expr>0x7A</expr>, <expr>0xA1</expr>, <expr>0xBF</expr>, <expr>0xD0</expr>, <expr>0xDD</expr>, <expr>0xDE</expr>, <expr>0xAE</expr>,
    <expr>0x5E</expr>, <expr>0xA3</expr>, <expr>0xA5</expr>, <expr>0xB7</expr>, <expr>0xA9</expr>, <expr>0xA7</expr>, <expr>0xB6</expr>, <expr>0xBC</expr>,
    <expr>0xBD</expr>, <expr>0xBE</expr>, <expr>0x5B</expr>, <expr>0x5D</expr>, <expr>0xAF</expr>, <expr>0xA8</expr>, <expr>0xB4</expr>, <expr>0xD7</expr>,
    <expr>0x7B</expr>, <expr>0x61</expr>, <expr>0x62</expr>, <expr>0x63</expr>, <expr>0x64</expr>, <expr>0x65</expr>, <expr>0x66</expr>, <expr>0x67</expr>,
    <expr>0x68</expr>, <expr>0x69</expr>, <expr>0xAD</expr>, <expr>0xF4</expr>, <expr>0xF6</expr>, <expr>0xF2</expr>, <expr>0xF3</expr>, <expr>0xF5</expr>,
    <expr>0x7D</expr>, <expr>0x6A</expr>, <expr>0x6B</expr>, <expr>0x6C</expr>, <expr>0x6D</expr>, <expr>0x6E</expr>, <expr>0x6F</expr>, <expr>0x70</expr>,
    <expr>0x71</expr>, <expr>0x72</expr>, <expr>0xB9</expr>, <expr>0xFB</expr>, <expr>0xFC</expr>, <expr>0xF9</expr>, <expr>0xFA</expr>, <expr>0xFF</expr>,
    <expr>0x5C</expr>, <expr>0xF7</expr>, <expr>0x73</expr>, <expr>0x74</expr>, <expr>0x75</expr>, <expr>0x76</expr>, <expr>0x77</expr>, <expr>0x78</expr>,
    <expr>0x79</expr>, <expr>0x7A</expr>, <expr>0xB2</expr>, <expr>0xD4</expr>, <expr>0xD6</expr>, <expr>0xD2</expr>, <expr>0xD3</expr>, <expr>0xD5</expr>,
    <expr>0x30</expr>, <expr>0x31</expr>, <expr>0x32</expr>, <expr>0x33</expr>, <expr>0x34</expr>, <expr>0x35</expr>, <expr>0x36</expr>, <expr>0x37</expr>,
    <expr>0x38</expr>, <expr>0x39</expr>, <expr>0xB3</expr>, <expr>0xDB</expr>, <expr>0xDC</expr>, <expr>0xD9</expr>, <expr>0xDA</expr>, <expr>0x9F</expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_cstr_casecmp</name><argument_list>(<argument>const char *s1</argument>, <argument>const char *s2</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>str1</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>s1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>str2</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>s2</name></expr></init></decl>;</decl_stmt>
    <for>for (<init>;</init><condition>;</condition><incr/>)
    <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c1</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr>*<name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c2</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr>*<name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmp</name> <init>= <expr><name><name>ucharmap</name><index>[<expr><name>c1</name></expr>]</index></name> - <name><name>ucharmap</name><index>[<expr><name>c2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Not necessary to test for !c2, this is caught by cmp */</comment>
        <if>if <condition>(<expr><name>cmp</name> || !<name>c1</name></expr>)</condition><then>
            <return>return <expr><name>cmp</name></expr>;</return></then></if>
        <expr_stmt><expr><name>str1</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>str2</name>++</expr>;</expr_stmt>
    }</block></for>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_cstr_casecmpn</name><argument_list>(<argument>const char *s1</argument>, <argument>const char *s2</argument>, <argument>apr_size_t n</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>str1</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>s1</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>str2</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>s2</name></expr></init></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>n</name>--</expr>)</condition>
    <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c1</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr>*<name>str1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>c2</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr>*<name>str2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cmp</name> <init>= <expr><name><name>ucharmap</name><index>[<expr><name>c1</name></expr>]</index></name> - <name><name>ucharmap</name><index>[<expr><name>c2</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* Not necessary to test for !c2, this is caught by cmp */</comment>
        <if>if <condition>(<expr><name>cmp</name> || !<name>c1</name></expr>)</condition><then>
            <return>return <expr><name>cmp</name></expr>;</return></then></if>
        <expr_stmt><expr><name>str1</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>str2</name>++</expr>;</expr_stmt>
    }</block></while>
    <return>return <expr>0</expr>;</return>
}</block>

</unit>
