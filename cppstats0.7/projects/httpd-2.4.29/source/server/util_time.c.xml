<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/util_time.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_time.h"</cpp:file></cpp:include>


<comment type="block">/* Number of characters needed to format the microsecond part of a timestamp.
 * Microseconds have 6 digits plus one separator character makes 7.
 *   */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CTIME_USEC_LENGTH</name></cpp:macro>      <cpp:value>7</cpp:value></cpp:define>

<comment type="block">/* Length of ISO 8601 date/time */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_CTIME_COMPACT_LEN</name></cpp:macro>      <cpp:value>20</cpp:value></cpp:define>


<comment type="block">/* Cache for exploded values of recent timestamps
 */</comment>

<struct>struct <name>exploded_time_cache_element</name> <block>{
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>t</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>xt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>t_validate</name></decl>;</decl_stmt> <comment type="block">/* please see comments in cached_explode() */</comment>
}</block>;</struct>

<comment type="block">/* the "+ 1" is for the current second: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_CACHE_SIZE</name></cpp:macro> <cpp:value>(AP_TIME_RECENT_THRESHOLD + 1)</cpp:value></cpp:define>

<comment type="block">/* Note that AP_TIME_RECENT_THRESHOLD is defined to
 * be a power of two minus one in util_time.h, so that
 * we can replace a modulo operation with a bitwise AND
 * when hashing items into a cache of size
 * AP_TIME_RECENT_THRESHOLD+1
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIME_CACHE_MASK</name></cpp:macro> <cpp:value>(AP_TIME_RECENT_THRESHOLD)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> struct <name>exploded_time_cache_element</name></type> <name><name>exploded_cache_localtime</name><index>[<expr><name>TIME_CACHE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>exploded_time_cache_element</name></type> <name><name>exploded_cache_gmt</name><index>[<expr><name>TIME_CACHE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cached_explode</name><parameter_list>(<param><decl><type><name>apr_time_exp_t</name> *</type><name>xt</name></decl></param>, <param><decl><type><name>apr_time_t</name></type> <name>t</name></decl></param>,
                                   <param><decl><type>struct <name>exploded_time_cache_element</name> *</type><name>cache</name></decl></param>,
                                   <param><decl><type><name>int</name></type> <name>use_gmt</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>seconds</name> <init>= <expr><call><name>apr_time_sec</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>exploded_time_cache_element</name> *</type><name>cache_element</name> <init>=
        <expr>&amp;(<name><name>cache</name><index>[<expr><name>seconds</name> &amp; <name>TIME_CACHE_MASK</name></expr>]</index></name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>exploded_time_cache_element</name></type> <name>cache_element_snapshot</name></decl>;</decl_stmt>

    <comment type="block">/* The cache is implemented as a ring buffer.  Each second,
     * it uses a different element in the buffer.  The timestamp
     * in the element indicates whether the element contains the
     * exploded time for the current second (vs the time
     * 'now - AP_TIME_RECENT_THRESHOLD' seconds ago).  If the
     * cached value is for the current time, we use it.  Otherwise,
     * we compute the apr_time_exp_t and store it in this
     * cache element. Note that the timestamp in the cache
     * element is updated only after the exploded time.  Thus
     * if two threads hit this cache element simultaneously
     * at the start of a new second, they'll both explode the
     * time and store it.  I.e., the writers will collide, but
     * they'll be writing the same value.
     */</comment>
    <if>if <condition>(<expr><name><name>cache_element</name>-&gt;<name>t</name></name> &gt;= <name>seconds</name></expr>)</condition><then> <block>{
        <comment type="block">/* There is an intentional race condition in this design:
         * in a multithreaded app, one thread might be reading
         * from this cache_element to resolve a timestamp from
         * TIME_CACHE_SIZE seconds ago at the same time that
         * another thread is copying the exploded form of the
         * current time into the same cache_element.  (I.e., the
         * first thread might hit this element of the ring buffer
         * just as the element is being recycled.)  This can
         * also happen at the start of a new second, if a
         * reader accesses the cache_element after a writer
         * has updated cache_element.t but before the writer
         * has finished updating the whole cache_element.
         *
         * Rather than trying to prevent this race condition
         * with locks, we allow it to happen and then detect
         * and correct it.  The detection works like this:
         *   Step 1: Take a "snapshot" of the cache element by
         *           copying it into a temporary buffer.
         *   Step 2: Check whether the snapshot contains consistent
         *           data: the timestamps at the start and end of
         *           the cache_element should both match the 'seconds'
         *           value that we computed from the input time.
         *           If these three don't match, then the snapshot
         *           shows the cache_element in the middle of an
         *           update, and its contents are invalid.
         *   Step 3: If the snapshot is valid, use it.  Otherwise,
         *           just give up on the cache and explode the
         *           input time.
         */</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>cache_element_snapshot</name></expr></argument>, <argument><expr><name>cache_element</name></expr></argument>,
               <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>exploded_time_cache_element</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>seconds</name> != <name><name>cache_element_snapshot</name>.<name>t</name></name>) ||
            (<name>seconds</name> != <name><name>cache_element_snapshot</name>.<name>t_validate</name></name>)</expr>)</condition><then> <block>{
            <comment type="block">/* Invalid snapshot */</comment>
            <if>if <condition>(<expr><name>use_gmt</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>apr_time_exp_gmt</name><argument_list>(<argument><expr><name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then>
            <else>else <block>{
                <return>return <expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr><name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Valid snapshot */</comment>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>xt</name></expr></argument>, <argument><expr>&amp;(<name><name>cache_element_snapshot</name>.<name>xt</name></name>)</expr></argument>,
                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>apr_time_exp_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>r</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>use_gmt</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>r</name> = <call><name>apr_time_exp_gmt</name><argument_list>(<argument><expr><name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>r</name> = <call><name>apr_time_exp_lt</name><argument_list>(<argument><expr><name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr><name>r</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>r</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>cache_element</name>-&gt;<name>t</name></name> = <name>seconds</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;(<name><name>cache_element</name>-&gt;<name>xt</name></name>)</expr></argument>, <argument><expr><name>xt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>apr_time_exp_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>cache_element</name>-&gt;<name>t_validate</name></name> = <name>seconds</name></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>xt</name>-&gt;<name>tm_usec</name></name> = (<name>int</name>)<call><name>apr_time_usec</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_explode_recent_localtime</name><argument_list>(<argument>apr_time_exp_t * tm</argument>,
                                                     <argument>apr_time_t t</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>cached_explode</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>exploded_cache_localtime</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_explode_recent_gmt</name><argument_list>(<argument>apr_time_exp_t * tm</argument>,
                                               <argument>apr_time_t t</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>cached_explode</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>exploded_cache_gmt</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_recent_ctime</name><argument_list>(<argument>char *date_str</argument>, <argument>apr_time_t t</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name>APR_CTIME_LEN</name></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>ap_recent_ctime_ex</name><argument_list>(<argument><expr><name>date_str</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>AP_CTIME_OPTION_NONE</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_recent_ctime_ex</name><argument_list>(<argument>char *date_str</argument>, <argument>apr_time_t t</argument>,
                                            <argument>int option</argument>, <argument>int *len</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* ### This code is a clone of apr_ctime(), except that it
     * uses ap_explode_recent_localtime() instead of apr_time_exp_lt().
     */</comment>
    <decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>xt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>real_year</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>needed</name></decl>;</decl_stmt>


    <comment type="block">/* Calculate the needed buffer length */</comment>
    <if>if <condition>(<expr><name>option</name> &amp; <name>AP_CTIME_OPTION_COMPACT</name></expr>)</condition><then>
        <expr_stmt><expr><name>needed</name> = <name>AP_CTIME_COMPACT_LEN</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>needed</name> = <name>APR_CTIME_LEN</name></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr><name>option</name> &amp; <name>AP_CTIME_OPTION_USEC</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>needed</name> += <name>AP_CTIME_USEC_LENGTH</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Check the provided buffer length */</comment>
    <if>if <condition>(<expr><name>len</name> &amp;&amp; *<name>len</name> &gt;= <name>needed</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>len</name> = <name>needed</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr><name>len</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>len</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>APR_ENOMEM</name></expr>;</return>
    }</block></else></if>

    <comment type="block">/* example without options: "Wed Jun 30 21:49:08 1993" */</comment>
    <comment type="block">/*                           123456789012345678901234  */</comment>
    <comment type="block">/* example for compact format: "1993-06-30 21:49:08" */</comment>
    <comment type="block">/*                              1234567890123456789  */</comment>

    <expr_stmt><expr><call><name>ap_explode_recent_localtime</name><argument_list>(<argument><expr>&amp;<name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>real_year</name> = 1900 + <name><name>xt</name>.<name>tm_year</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>option</name> &amp; <name>AP_CTIME_OPTION_COMPACT</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>real_month</name> <init>= <expr><name><name>xt</name>.<name>tm_mon</name></name> + 1</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> / 1000 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 1000 / 100 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 100 / 10 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 10 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = '-'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_month</name> / 10 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_month</name> % 10 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = '-'</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>s</name> = &amp;<name><name>apr_day_snames</name><index>[<expr><name><name>xt</name>.<name>tm_wday</name></name></expr>]</index><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> = &amp;<name><name>apr_month_snames</name><index>[<expr><name><name>xt</name>.<name>tm_mon</name></name></expr>]</index><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_mday</name></name> / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_mday</name></name> % 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_hour</name></name> / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_hour</name></name> % 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ':'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_min</name></name> / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_min</name></name> % 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ':'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_sec</name></name> / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_sec</name></name> % 10 + '0'</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>option</name> &amp; <name>AP_CTIME_OPTION_USEC</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>div</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>usec</name> <init>= <expr>(<name>int</name>)<name><name>xt</name>.<name>tm_usec</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = '.'</expr>;</expr_stmt>
        <for>for (<init><expr><name>div</name>=100000</expr>;</init> <condition><expr><name>div</name>&gt;0</expr>;</condition> <incr><expr><name>div</name>=<name>div</name>/10</expr></incr>) <block>{
            <expr_stmt><expr>*<name>date_str</name>++ = <name>usec</name> / <name>div</name> + '0'</expr>;</expr_stmt>
            <expr_stmt><expr><name>usec</name> = <name>usec</name> % <name>div</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
    <if>if <condition>(<expr>!(<name>option</name> &amp; <name>AP_CTIME_OPTION_COMPACT</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> / 1000 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 1000 / 100 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 100 / 10 + '0'</expr>;</expr_stmt>
        <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 10 + '0'</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>date_str</name>++ = 0</expr>;</expr_stmt>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_recent_rfc822_date</name><argument_list>(<argument>char *date_str</argument>, <argument>apr_time_t t</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* ### This code is a clone of apr_rfc822_date(), except that it
     * uses ap_explode_recent_gmt() instead of apr_time_exp_gmt().
     */</comment>
    <decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>xt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>real_year</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_explode_recent_gmt</name><argument_list>(<argument><expr>&amp;<name>xt</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* example: "Sat, 08 Jan 2000 18:31:41 GMT" */</comment>
    <comment type="block">/*           12345678901234567890123456789  */</comment>

    <expr_stmt><expr><name>s</name> = &amp;<name><name>apr_day_snames</name><index>[<expr><name><name>xt</name>.<name>tm_wday</name></name></expr>]</index><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ','</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_mday</name></name> / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_mday</name></name> % 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> = &amp;<name><name>apr_month_snames</name><index>[<expr><name><name>xt</name>.<name>tm_mon</name></name></expr>]</index><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = *<name>s</name>++</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
    <expr_stmt><expr><name>real_year</name> = 1900 + <name><name>xt</name>.<name>tm_year</name></name></expr>;</expr_stmt>
    <comment type="block">/* This routine isn't y10k ready. */</comment>
    <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> / 1000 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 1000 / 100 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 100 / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name>real_year</name> % 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_hour</name></name> / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_hour</name></name> % 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ':'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_min</name></name> / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_min</name></name> % 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ':'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_sec</name></name> / 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = <name><name>xt</name>.<name>tm_sec</name></name> % 10 + '0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = ' '</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = 'G'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = 'M'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = 'T'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>date_str</name>++ = 0</expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>
</unit>
