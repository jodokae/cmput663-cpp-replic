<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/mpm/winnt/mpm_winnt.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include> <comment type="block">/* for read_config */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>   <comment type="block">/* for get_remote_host */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_portable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_shm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_general.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_listen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_default.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_winnt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;malloc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_atomic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__WATCOMC__</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_environ</name></cpp:macro> <cpp:value>environ</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>STACK_SIZE_PARAM_IS_A_RESERVATION</name></cpp:ifndef> <comment type="block">/* missing on MinGW */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_SIZE_PARAM_IS_A_RESERVATION</name></cpp:macro> <cpp:value>0x00010000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Because ap_setup_listeners() is skipped in the child, any merging
 * of [::]:80 and 0.0.0.0:80 for AP_ENABLE_V4_MAPPED in the parent
 * won't have taken place in the child, so the child will expect to
 * read two sockets for "Listen 80" but the parent will send only
 * one.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_ENABLE_V4_MAPPED</name></cpp:ifdef>
<cpp:error>#<cpp:directive>error</cpp:directive> The WinNT MPM does not currently support AP_ENABLE_V4_MAPPED</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* scoreboard.c does the heavy lifting; all we do is create the child
 * score by moving a handle down the pipe into the child's stdin.
 */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>apr_shm_t</name> *</type><name>ap_scoreboard_shm</name></decl>;</decl_stmt>

<comment type="block">/* my_generation is returned to the scoreboard code */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>ap_generation_t</name></type> <name>my_generation</name><init>=<expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/* Definitions of WINNT MPM specific config globals */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>shutdown_event</name></decl>;</decl_stmt>  <comment type="block">/* used to signal the parent to shutdown */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>restart_event</name></decl>;</decl_stmt>   <comment type="block">/* used to signal the parent to restart */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>one_process</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <specifier>const</specifier>*</type> <name>signal_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OSVERSIONINFO</name></type> <name>osver</name></decl>;</decl_stmt> <comment type="block">/* VER_PLATFORM_WIN32_NT */</comment>

<comment type="block">/* set by child_main to STACK_SIZE_PARAM_IS_A_RESERVATION for NT &gt;= 5.1 (XP/2003) */</comment>
<decl_stmt><decl><type><name>DWORD</name></type> <name>stack_res_flag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>DWORD</name></type> <name>parent_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DWORD</name></type> <name>my_pid</name></decl>;</decl_stmt>

<comment type="block">/* used by parent to signal the child to start and exit */</comment>
<decl_stmt><decl><type><name>apr_proc_mutex_t</name> *</type><name>start_mutex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>exit_event</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ap_threads_per_child</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>thread_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>first_thread_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>winnt_mpm_state</name> <init>= <expr><name>AP_MPMQ_STARTING</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* shared by service.c as global, although
 * perhaps it should be private.
 */</comment>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl>;</decl_stmt>

<comment type="block">/* Only one of these, the pipe from our parent, meant only for
 * one child worker's consumption (not to be inherited!)
 * XXX: decorate this name for the trunk branch, was left simplified
 *      only to make the 2.2 patch trivial to read.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>pipe</name></decl>;</decl_stmt>

<comment type="block">/*
 * Command processors
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_threads_per_child</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ap_threads_per_child</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_thread_limit</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>thread_limit</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>winnt_cmds</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>LISTEN_COMMANDS</name></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ThreadsPerChild"</expr></argument>, <argument><expr><name>set_threads_per_child</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Number of threads each child creates"</expr></argument> )</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ThreadLimit"</expr></argument>, <argument><expr><name>set_thread_limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Maximum worker threads in a server for this run of Apache"</expr></argument>)</argument_list></call></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>winnt_note_child_started</name><parameter_list>(<param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name> = <name>pid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                        <argument><expr><name>my_generation</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MPM_CHILD_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>winnt_note_child_killed</name><parameter_list>(<param><decl><type><name>int</name></type> <name>slot</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>generation</name></expr></argument>,
                        <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MPM_CHILD_EXITED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name> = 0</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Signalling Apache on NT.
 *
 * Under Unix, Apache can be told to shutdown or restart by sending various
 * signals (HUP, USR, TERM). On NT we don't have easy access to signals, so
 * we use "events" instead. The parent apache process goes into a loop
 * where it waits forever for a set of events. Two of those events are
 * called
 *
 *    apPID_shutdown
 *    apPID_restart
 *
 * (where PID is the PID of the apache parent process). When one of these
 * is signalled, the Apache parent performs the appropriate action. The events
 * can become signalled through internal Apache methods (e.g. if the child
 * finds a fatal error and needs to kill its parent), via the service
 * control manager (the control thread will signal the shutdown event when
 * requested to stop the Apache service), from the -k Apache command line,
 * or from any external program which finds the Apache PID from the
 * httpd.pid file.
 *
 * The signal_parent() function, below, is used to signal one of these events.
 * It can be called by any child or parent process, since it does not
 * rely on global variables.
 *
 * On entry, type gives the event to signal. 0 means shutdown, 1 means
 * graceful restart.
 */</comment>
<comment type="block">/*
 * Initialise the signal names, in the global variables signal_name_prefix,
 * signal_restart_name and signal_shutdown_name.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SIGNAL_NAME</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>  <comment type="block">/* Long enough for apPID_shutdown, where PID is an int */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>signal_name_prefix</name><index>[<expr><name>MAX_SIGNAL_NAME</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>signal_restart_name</name><index>[<expr><name>MAX_SIGNAL_NAME</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>signal_shutdown_name</name><index>[<expr><name>MAX_SIGNAL_NAME</name></expr>]</index></name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>setup_signal_names</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>prefix</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>signal_name_prefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>signal_name_prefix</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>signal_shutdown_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>signal_shutdown_name</name></expr></argument>)</argument_list></sizeof></expr></argument>,
        <argument><expr>"%s_shutdown"</expr></argument>, <argument><expr><name>signal_name_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>signal_restart_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>signal_restart_name</name></expr></argument>)</argument_list></sizeof></expr></argument>,
        <argument><expr>"%s_restart"</expr></argument>, <argument><expr><name>signal_name_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_signal_parent</name><argument_list>(<argument>ap_signal_parent_e type</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>signal_name</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>parent_pid</name> == <name>my_pid</name></expr>)</condition><then> <block>{
        <switch>switch<condition>(<expr><name>type</name></expr>)</condition> <block>{
           <case>case <expr><name>SIGNAL_PARENT_SHUTDOWN</name></expr>:
           <block>{
               <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>shutdown_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               <break>break;</break>
           }</block>
           <comment type="block">/* This MPM supports only graceful restarts right now */</comment>
           </case><case>case <expr><name>SIGNAL_PARENT_RESTART</name></expr>:
           </case><case>case <expr><name>SIGNAL_PARENT_RESTART_GRACEFUL</name></expr>:
           <block>{
               <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>restart_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               <break>break;</break>
           }</block>
        </case>}</block></switch>
        <return>return;</return>
    }</block></then></if>

    <switch>switch<condition>(<expr><name>type</name></expr>)</condition> <block>{
       <case>case <expr><name>SIGNAL_PARENT_SHUTDOWN</name></expr>:
       <block>{
           <expr_stmt><expr><name>signal_name</name> = <name>signal_shutdown_name</name></expr>;</expr_stmt>
           <break>break;</break>
       }</block>
       <comment type="block">/* This MPM supports only graceful restarts right now */</comment>
       </case><case>case <expr><name>SIGNAL_PARENT_RESTART</name></expr>:
       </case><case>case <expr><name>SIGNAL_PARENT_RESTART_GRACEFUL</name></expr>:
       <block>{
           <expr_stmt><expr><name>signal_name</name> = <name>signal_restart_name</name></expr>;</expr_stmt>
           <break>break;</break>
       }</block>
       </case><default>default:
           <return>return;</return>
    </default>}</block></switch>

    <expr_stmt><expr><name>e</name> = <call><name>OpenEvent</name><argument_list>(<argument><expr><name>EVENT_MODIFY_STATE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>signal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>e</name></expr>)</condition><then> <block>{
        <comment type="block">/* Um, problem, can't signal the parent, which means we can't
         * signal ourselves to die. Ignore for now...
         */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00382</expr></argument>)</argument_list></call>
                     "OpenEvent on %s event"</expr></argument>, <argument><expr><name>signal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* Same problem as above */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00383</expr></argument>)</argument_list></call>
                     "SetEvent on %s event"</expr></argument>, <argument><expr><name>signal_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>


<comment type="block">/*
 * Passed the following handles [in sync with send_handles_to_child()]
 *
 *   ready event [signal the parent immediately, then close]
 *   exit event  [save to poll later]
 *   start mutex [signal from the parent to begin accept()]
 *   scoreboard shm handle [to recreate the ap_scoreboard]
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>get_handles_from_parent</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>HANDLE</name> *</type><name>child_exit_event</name></decl></param>,
                                    <param><decl><type><name>apr_proc_mutex_t</name> **</type><name>child_start_mutex</name></decl></param>,
                                    <param><decl><type><name>apr_shm_t</name> **</type><name>scoreboard_shm</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hScore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>ready_event</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>os_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>BytesRead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>sb_shared</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="block">/* *** We now do this way back in winnt_rewrite_args
     * pipe = GetStdHandle(STD_INPUT_HANDLE);
     */</comment>
    <if>if <condition>(<expr>!<call><name>ReadFile</name><argument_list>(<argument><expr><name>pipe</name></expr></argument>, <argument><expr>&amp;<name>ready_event</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                  <argument><expr>&amp;<name>BytesRead</name></expr></argument>, <argument><expr>(<name>LPOVERLAPPED</name>) <name>NULL</name></expr></argument>)</argument_list></call>
        || (<name>BytesRead</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00384</expr></argument>)</argument_list></call>
                     "Child: Unable to retrieve the ready event from the parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>ready_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>ready_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>ReadFile</name><argument_list>(<argument><expr><name>pipe</name></expr></argument>, <argument><expr><name>child_exit_event</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                  <argument><expr>&amp;<name>BytesRead</name></expr></argument>, <argument><expr>(<name>LPOVERLAPPED</name>) <name>NULL</name></expr></argument>)</argument_list></call>
        || (<name>BytesRead</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>HANDLE</name></expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00385</expr></argument>)</argument_list></call>
                     "Child: Unable to retrieve the exit event from the parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>ReadFile</name><argument_list>(<argument><expr><name>pipe</name></expr></argument>, <argument><expr>&amp;<name>os_start</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>os_start</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                  <argument><expr>&amp;<name>BytesRead</name></expr></argument>, <argument><expr>(<name>LPOVERLAPPED</name>) <name>NULL</name></expr></argument>)</argument_list></call>
        || (<name>BytesRead</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>os_start</name></expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00386</expr></argument>)</argument_list></call>
                     "Child: Unable to retrieve the start_mutex from the parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>child_start_mutex</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_os_proc_mutex_put</name><argument_list>(<argument><expr><name>child_start_mutex</name></expr></argument>, <argument><expr>&amp;<name>os_start</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00387</expr></argument>)</argument_list></call>
                     "Child: Unable to access the start_mutex from the parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>ReadFile</name><argument_list>(<argument><expr><name>pipe</name></expr></argument>, <argument><expr>&amp;<name>hScore</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hScore</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                  <argument><expr>&amp;<name>BytesRead</name></expr></argument>, <argument><expr>(<name>LPOVERLAPPED</name>) <name>NULL</name></expr></argument>)</argument_list></call>
        || (<name>BytesRead</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>hScore</name></expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00388</expr></argument>)</argument_list></call>
                     "Child: Unable to retrieve the scoreboard from the parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>scoreboard_shm</name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_os_shm_put</name><argument_list>(<argument><expr><name>scoreboard_shm</name></expr></argument>, <argument><expr>&amp;<name>hScore</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00389</expr></argument>)</argument_list></call>
                     "Child: Unable to access the scoreboard from the parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_reopen_scoreboard</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>scoreboard_shm</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> || !(<name>sb_shared</name> = <call><name>apr_shm_baseaddr_get</name><argument_list>(<argument><expr>*<name>scoreboard_shm</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00390</expr></argument>)</argument_list></call>
                     "Child: Unable to reopen the scoreboard from the parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* We must 'initialize' the scoreboard to relink all the
     * process-local pointer arrays into the shared memory block.
     */</comment>
    <expr_stmt><expr><call><name>ap_init_scoreboard</name><argument_list>(<argument><expr><name>sb_shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00391</expr></argument>)</argument_list></call>
                 "Child: Retrieved our scoreboard from the parent."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>send_handles_to_child</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                 <param><decl><type><name>HANDLE</name></type> <name>child_ready_event</name></decl></param>,
                                 <param><decl><type><name>HANDLE</name></type> <name>child_exit_event</name></decl></param>,
                                 <param><decl><type><name>apr_proc_mutex_t</name> *</type><name>child_start_mutex</name></decl></param>,
                                 <param><decl><type><name>apr_shm_t</name> *</type><name>scoreboard_shm</name></decl></param>,
                                 <param><decl><type><name>HANDLE</name></type> <name>hProcess</name></decl></param>,
                                 <param><decl><type><name>apr_file_t</name> *</type><name>child_in</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hCurrentProcess</name> <init>= <expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hDup</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>os_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hScore</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>BytesWritten</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>child_in</name></expr></argument>, <argument><expr>&amp;<name>my_generation</name></expr></argument>,
                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>my_generation</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02964</expr></argument>)</argument_list></call>
                     "Parent: Unable to send its generation to the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hCurrentProcess</name></expr></argument>, <argument><expr><name>child_ready_event</name></expr></argument>, <argument><expr><name>hProcess</name></expr></argument>, <argument><expr>&amp;<name>hDup</name></expr></argument>,
        <argument><expr><name>EVENT_MODIFY_STATE</name> | <name>SYNCHRONIZE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00392</expr></argument>)</argument_list></call>
                     "Parent: Unable to duplicate the ready event handle for the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>child_in</name></expr></argument>, <argument><expr>&amp;<name>hDup</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hDup</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>BytesWritten</name></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00393</expr></argument>)</argument_list></call>
                     "Parent: Unable to send the exit event handle to the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hCurrentProcess</name></expr></argument>, <argument><expr><name>child_exit_event</name></expr></argument>, <argument><expr><name>hProcess</name></expr></argument>, <argument><expr>&amp;<name>hDup</name></expr></argument>,
                         <argument><expr><name>EVENT_MODIFY_STATE</name> | <name>SYNCHRONIZE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00394</expr></argument>)</argument_list></call>
                     "Parent: Unable to duplicate the exit event handle for the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>child_in</name></expr></argument>, <argument><expr>&amp;<name>hDup</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hDup</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>BytesWritten</name></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00395</expr></argument>)</argument_list></call>
                     "Parent: Unable to send the exit event handle to the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_os_proc_mutex_get</name><argument_list>(<argument><expr>&amp;<name>os_start</name></expr></argument>, <argument><expr><name>child_start_mutex</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00396</expr></argument>)</argument_list></call>
                     "Parent: Unable to retrieve the start mutex for the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hCurrentProcess</name></expr></argument>, <argument><expr><name>os_start</name></expr></argument>, <argument><expr><name>hProcess</name></expr></argument>, <argument><expr>&amp;<name>hDup</name></expr></argument>,
                         <argument><expr><name>SYNCHRONIZE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00397</expr></argument>)</argument_list></call>
                     "Parent: Unable to duplicate the start mutex to the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>child_in</name></expr></argument>, <argument><expr>&amp;<name>hDup</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hDup</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>BytesWritten</name></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00398</expr></argument>)</argument_list></call>
                     "Parent: Unable to send the start mutex to the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_os_shm_get</name><argument_list>(<argument><expr>&amp;<name>hScore</name></expr></argument>, <argument><expr><name>scoreboard_shm</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00399</expr></argument>)</argument_list></call>
                     "Parent: Unable to retrieve the scoreboard handle for the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hCurrentProcess</name></expr></argument>, <argument><expr><name>hScore</name></expr></argument>, <argument><expr><name>hProcess</name></expr></argument>, <argument><expr>&amp;<name>hDup</name></expr></argument>,
                         <argument><expr><name>FILE_MAP_READ</name> | <name>FILE_MAP_WRITE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00400</expr></argument>)</argument_list></call>
                     "Parent: Unable to duplicate the scoreboard handle to the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>child_in</name></expr></argument>, <argument><expr>&amp;<name>hDup</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hDup</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>BytesWritten</name></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00401</expr></argument>)</argument_list></call>
                     "Parent: Unable to send the scoreboard handle to the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00402</expr></argument>)</argument_list></call>
                 "Parent: Sent the scoreboard to the child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
 * get_listeners_from_parent()
 * The listen sockets are opened in the parent. This function, which runs
 * exclusively in the child process, receives them from the parent and
 * makes them availeble in the child.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>get_listeners_from_parent</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>WSAPROTOCOL_INFO</name></type> <name>WSAProtocolInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>lr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>BytesRead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lcnt</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SOCKET</name></type> <name>nsd</name></decl>;</decl_stmt>

    <comment type="block">/* Set up a default listener if necessary */</comment>
    <if>if <condition>(<expr><name>ap_listeners</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>lr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>lr</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ap_listen_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lr</name>-&gt;<name>sd</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lr</name>-&gt;<name>next</name></name> = <name>ap_listeners</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ap_listeners</name> = <name>lr</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Open the pipe to the parent process to receive the inherited socket
     * data. The sockets have been set to listening in the parent process.
     *
     * *** We now do this way back in winnt_rewrite_args
     * pipe = GetStdHandle(STD_INPUT_HANDLE);
     */</comment>
    <for>for (<init><expr><name>lr</name> = <name>ap_listeners</name></expr>;</init> <condition><expr><name>lr</name></expr>;</condition> <incr><expr><name>lr</name> = <name><name>lr</name>-&gt;<name>next</name></name></expr>, <expr>++<name>lcnt</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00403</expr></argument>)</argument_list></call>
                     "Child: Waiting for data for listening socket %pI"</expr></argument>,
                     <argument><expr><name><name>lr</name>-&gt;<name>bind_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>ReadFile</name><argument_list>(<argument><expr><name>pipe</name></expr></argument>, <argument><expr>&amp;<name>WSAProtocolInfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WSAPROTOCOL_INFO</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                      <argument><expr>&amp;<name>BytesRead</name></expr></argument>, <argument><expr>(<name>LPOVERLAPPED</name>) <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00404</expr></argument>)</argument_list></call>
                         "Child: Unable to read socket data from parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>nsd</name> = <call><name>WSASocket</name><argument_list>(<argument><expr><name>FROM_PROTOCOL_INFO</name></expr></argument>, <argument><expr><name>FROM_PROTOCOL_INFO</name></expr></argument>, <argument><expr><name>FROM_PROTOCOL_INFO</name></expr></argument>,
                        <argument><expr>&amp;<name>WSAProtocolInfo</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>nsd</name> == <name>INVALID_SOCKET</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_netos_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00405</expr></argument>)</argument_list></call>
                         "Child: WSASocket failed to open the inherited socket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>SetHandleInformation</name><argument_list>(<argument><expr>(<name>HANDLE</name>)<name>nsd</name></expr></argument>, <argument><expr><name>HANDLE_FLAG_INHERIT</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00406</expr></argument>)</argument_list></call>
                         "Child: SetHandleInformation failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>apr_os_sock_put</name><argument_list>(<argument><expr>&amp;<name><name>lr</name>-&gt;<name>sd</name></name></expr></argument>, <argument><expr>&amp;<name>nsd</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00407</expr></argument>)</argument_list></call>
                 "Child: retrieved %d listeners from parent"</expr></argument>, <argument><expr><name>lcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>send_listeners_to_child</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>DWORD</name></type> <name>dwProcessId</name></decl></param>,
                                   <param><decl><type><name>apr_file_t</name> *</type><name>child_in</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lcnt</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>lr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>LPWSAPROTOCOL_INFO</name></type>  <name>lpWSAProtocolInfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>BytesWritten</name></decl>;</decl_stmt>

    <comment type="block">/* Run the chain of open sockets. For each socket, duplicate it
     * for the target process then send the WSAPROTOCOL_INFO
     * (returned by dup socket) to the child.
     */</comment>
    <for>for (<init><expr><name>lr</name> = <name>ap_listeners</name></expr>;</init> <condition><expr><name>lr</name></expr>;</condition> <incr><expr><name>lr</name> = <name><name>lr</name>-&gt;<name>next</name></name></expr>, <expr>++<name>lcnt</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>apr_os_sock_t</name></type> <name>nsd</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>lpWSAProtocolInfo</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WSAPROTOCOL_INFO</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_os_sock_get</name><argument_list>(<argument><expr>&amp;<name>nsd</name></expr></argument>, <argument><expr><name><name>lr</name>-&gt;<name>sd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00408</expr></argument>)</argument_list></call>
                     "Parent: Duplicating socket %d (%pI) and sending it to child process %lu"</expr></argument>,
                     <argument><expr><name>nsd</name></expr></argument>, <argument><expr><name><name>lr</name>-&gt;<name>bind_addr</name></name></expr></argument>, <argument><expr><name>dwProcessId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>WSADuplicateSocket</name><argument_list>(<argument><expr><name>nsd</name></expr></argument>, <argument><expr><name>dwProcessId</name></expr></argument>,
                               <argument><expr><name>lpWSAProtocolInfo</name></expr></argument>)</argument_list></call> == <name>SOCKET_ERROR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_netos_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00409</expr></argument>)</argument_list></call>
                         "Parent: WSADuplicateSocket failed for socket %d. Check the FAQ."</expr></argument>, <argument><expr><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>child_in</name></expr></argument>, <argument><expr><name>lpWSAProtocolInfo</name></expr></argument>,
                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WSAPROTOCOL_INFO</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>BytesWritten</name></expr></argument>)</argument_list></call>)
                != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00410</expr></argument>)</argument_list></call>
                         "Parent: Unable to write duplicated socket %d to the child."</expr></argument>, <argument><expr><name>nsd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00411</expr></argument>)</argument_list></call>
                 "Parent: Sent %d listeners to child %lu"</expr></argument>, <argument><expr><name>lcnt</name></expr></argument>, <argument><expr><name>dwProcessId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>

<enum>enum <name>waitlist_e</name> <block>{
    <decl><name>waitlist_ready</name> <init>= <expr>0</expr></init></decl>,
    <decl><name>waitlist_term</name> <init>= <expr>1</expr></init></decl>
}</block>;</enum>

<function><type><specifier>static</specifier> <name>int</name></type> <name>create_process</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>HANDLE</name> *</type><name>child_proc</name></decl></param>, <param><decl><type><name>HANDLE</name> *</type><name>child_exit_event</name></decl></param>,
                          <param><decl><type><name>DWORD</name> *</type><name>child_pid</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* These NEVER change for the lifetime of this parent
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name> **</type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>pidbuf</name><index>[<expr>28</expr>]</index></name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_procattr_t</name> *</type><name>attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_proc_t</name></type> <name>new_child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>hExitEvent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name><name>waitlist</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* see waitlist_e */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>cmd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>cwd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>env</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>envc</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>apr_pool_create_ex</name><argument_list>(<argument><expr>&amp;<name>ptemp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Build the command line. Should look something like this:
     * C:/apache/bin/httpd.exe -f ap_server_confname
     * First, get the path to the executable...
     */</comment>
    <expr_stmt><expr><call><name>apr_procattr_create</name><argument_list>(<argument><expr>&amp;<name>attr</name></expr></argument>, <argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_procattr_cmdtype_set</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>APR_PROGRAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_procattr_detach_set</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>((<name>rv</name> = <call><name>apr_filepath_get</name><argument_list>(<argument><expr>&amp;<name>cwd</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ptemp</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name>)
           || ((<name>rv</name> = <call><name>apr_procattr_dir_set</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>cwd</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00412</expr></argument>)</argument_list></call>
                     "Parent: Failed to get the current path"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>args</name></expr>)</condition><then> <block>{
        <comment type="block">/* Build the args array, only once since it won't change
         * for the lifetime of this parent process.
         */</comment>
        <if>if <condition>(<expr>(<name>rv</name> = <call><name>ap_os_proc_filepath</name><argument_list>(<argument><expr>&amp;<name>cmd</name></expr></argument>, <argument><expr><name>ptemp</name></expr></argument>)</argument_list></call>)
                != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>ERROR_BAD_PATHNAME</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00413</expr></argument>)</argument_list></call>
                         "Parent: Failed to get full path of %s"</expr></argument>,
                         <argument><expr><name><name>ap_server_conf</name>-&gt;<name>process</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>args</name> = <call><name>malloc</name><argument_list>(<argument><expr>(<name><name>ap_server_conf</name>-&gt;<name>process</name>-&gt;<name>argc</name></name> + 1) * <sizeof>sizeof <argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>args</name> + 1</expr></argument>, <argument><expr><name><name>ap_server_conf</name>-&gt;<name>process</name>-&gt;<name>argv</name></name> + 1</expr></argument>,
               <argument><expr>(<name><name>ap_server_conf</name>-&gt;<name>process</name>-&gt;<name>argc</name></name> - 1) * <sizeof>sizeof <argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr>0</expr>]</index></name> = <call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>args</name><index>[<expr><name><name>ap_server_conf</name>-&gt;<name>process</name>-&gt;<name>argc</name></name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>cmd</name> = <name><name>args</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Create a pipe to send handles to the child */</comment>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_procattr_io_set</name><argument_list>(<argument><expr><name>attr</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>,
                                  <argument><expr><name>APR_NO_PIPE</name></expr></argument>, <argument><expr><name>APR_NO_PIPE</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00414</expr></argument>)</argument_list></call>
                        "Parent: Unable to create child stdin pipe."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Create the child_ready_event */</comment>
    <expr_stmt><expr><name><name>waitlist</name><index>[<expr><name>waitlist_ready</name></expr>]</index></name> = <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>waitlist</name><index>[<expr><name>waitlist_ready</name></expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00415</expr></argument>)</argument_list></call>
                     "Parent: Could not create ready event for child process"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name> <argument_list>(<argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Create the child_exit_event */</comment>
    <expr_stmt><expr><name>hExitEvent</name> = <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>hExitEvent</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00416</expr></argument>)</argument_list></call>
                     "Parent: Could not create exit event for child process"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>waitlist</name><index>[<expr><name>waitlist_ready</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Build the env array */</comment>
    <for>for (<init><expr><name>envc</name> = 0</expr>;</init> <condition><expr><name><name>_environ</name><index>[<expr><name>envc</name></expr>]</index></name></expr>;</condition> <incr><expr>++<name>envc</name></expr></incr>) <block>{
        <empty_stmt>;</empty_stmt>
    }</block></for>
    <expr_stmt><expr><name>env</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>, <argument><expr>(<name>envc</name> + 2) * <sizeof>sizeof <argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>_environ</name></expr></argument>, <argument><expr><name>envc</name> * <sizeof>sizeof <argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>pidbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pidbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"AP_PARENT_PID=%lu"</expr></argument>, <argument><expr><name>parent_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>env</name><index>[<expr><name>envc</name></expr>]</index></name> = <name>pidbuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>env</name><index>[<expr><name>envc</name> + 1</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_proc_create</name><argument_list>(<argument><expr>&amp;<name>new_child</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr>(const <name>char</name> * const *)<name>args</name></expr></argument>,
                         <argument><expr>(const <name>char</name> * const *)<name>env</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00417</expr></argument>)</argument_list></call>
                     "Parent: Failed to create the child process."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hExitEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>waitlist</name><index>[<expr><name>waitlist_ready</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>new_child</name>.<name>hproc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00418</expr></argument>)</argument_list></call>
                 "Parent: Created child process %d"</expr></argument>, <argument><expr><name><name>new_child</name>.<name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>send_handles_to_child</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>, <argument><expr><name><name>waitlist</name><index>[<expr><name>waitlist_ready</name></expr>]</index></name></expr></argument>, <argument><expr><name>hExitEvent</name></expr></argument>,
                              <argument><expr><name>start_mutex</name></expr></argument>, <argument><expr><name>ap_scoreboard_shm</name></expr></argument>,
                              <argument><expr><name><name>new_child</name>.<name>hproc</name></name></expr></argument>, <argument><expr><name><name>new_child</name>.<name>in</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         * This error is fatal, mop up the child and move on
         * We toggle the child's exit event to cause this child
         * to quit even as it is attempting to start.
         */</comment>
        <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>hExitEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hExitEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>waitlist</name><index>[<expr><name>waitlist_ready</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>new_child</name>.<name>hproc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Important:
     * Give the child process a chance to run before dup'ing the sockets.
     * We have already set the listening sockets noninheritable, but if
     * WSADuplicateSocket runs before the child process initializes
     * the listeners will be inherited anyway.
     */</comment>
    <expr_stmt><expr><name><name>waitlist</name><index>[<expr><name>waitlist_term</name></expr>]</index></name> = <name><name>new_child</name>.<name>hproc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>waitlist</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>waitlist</name><index>[<expr><name>waitlist_ready</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>WAIT_OBJECT_0</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Outch... that isn't a ready signal. It's dead, Jim!
         */</comment>
        <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>hExitEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hExitEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>new_child</name>.<name>hproc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>send_listeners_to_child</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>, <argument><expr><name><name>new_child</name>.<name>pid</name></name></expr></argument>, <argument><expr><name><name>new_child</name>.<name>in</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
         * This error is fatal, mop up the child and move on
         * We toggle the child's exit event to cause this child
         * to quit even as it is attempting to start.
         */</comment>
        <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>hExitEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>hExitEvent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>new_child</name>.<name>hproc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name><name>new_child</name>.<name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>*<name>child_exit_event</name> = <name>hExitEvent</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>child_proc</name> = <name><name>new_child</name>.<name>hproc</name></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>child_pid</name> = <name><name>new_child</name>.<name>pid</name></name></expr>;</expr_stmt>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/***********************************************************************
 * master_main()
 * master_main() runs in the parent process.  It creates the child
 * process which handles HTTP requests then waits on one of three
 * events:
 *
 * restart_event
 * -------------
 * The restart event causes master_main to start a new child process and
 * tells the old child process to exit (by setting the child_exit_event).
 * The restart event is set as a result of one of the following:
 * 1. An apache -k restart command on the command line
 * 2. A command received from Windows service manager which gets
 *    translated into an ap_signal_parent(SIGNAL_PARENT_RESTART)
 *    call by code in service.c.
 * 3. The child process calling ap_signal_parent(SIGNAL_PARENT_RESTART)
 *    as a result of hitting MaxConnectionsPerChild.
 *
 * shutdown_event
 * --------------
 * The shutdown event causes master_main to tell the child process to
 * exit and that the server is shutting down. The shutdown event is
 * set as a result of one of the following:
 * 1. An apache -k shutdown command on the command line
 * 2. A command received from Windows service manager which gets
 *    translated into an ap_signal_parent(SIGNAL_PARENT_SHUTDOWN)
 *    call by code in service.c.
 *
 * child process handle
 * --------------------
 * The child process handle will be signaled if the child process
 * exits for any reason. In a normal running server, the signaling
 * of this event means that the child process has exited prematurely
 * due to a seg fault or other irrecoverable error. For server
 * robustness, master_main will restart the child process under this
 * condtion.
 *
 * master_main uses the child_exit_event to signal the child process
 * to exit.
 **********************************************************************/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_WAIT_HANDLES</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHILD_HANDLE</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHUTDOWN_HANDLE</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTART_HANDLE</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>master_main</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>HANDLE</name></type> <name>shutdown_event</name></decl></param>, <param><decl><type><name>HANDLE</name></type> <name>restart_event</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>, <decl><type ref="prev"/><name>cld</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>child_created</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>restart_pending</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shutdown_pending</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name>child_exit_event</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HANDLE</name></type> <name><name>event_handles</name><index>[<expr><name>NUM_WAIT_HANDLES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DWORD</name></type> <name>child_pid</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>child_created</name> = <name>restart_pending</name> = <name>shutdown_pending</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>event_handles</name><index>[<expr><name>SHUTDOWN_HANDLE</name></expr>]</index></name> = <name>shutdown_event</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>event_handles</name><index>[<expr><name>RESTART_HANDLE</name></expr>]</index></name> = <name>restart_event</name></expr>;</expr_stmt>

    <comment type="block">/* Create a single child process */</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>create_process</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr>&amp;<name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>,
                        <argument><expr>&amp;<name>child_exit_event</name></expr></argument>, <argument><expr>&amp;<name>child_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> &lt; 0</expr>)</condition><then>
    <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00419</expr></argument>)</argument_list></call>
                     "master_main: create child process failed. Exiting."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>shutdown_pending</name> = 1</expr>;</expr_stmt>
        <goto>goto <name>die_now</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><name>child_created</name> = 1</expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"runservice"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>mpm_service_started</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Update the scoreboard. Note that there is only a single active
     * child at once.
     */</comment>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr>0</expr>]</index></name>.<name>quiescing</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>winnt_note_child_started</name><argument_list>(<comment type="block">/* slot */</comment> <argument><expr>0</expr></argument>, <argument><expr><name>child_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wait for shutdown or restart events or for child death */</comment>
    <expr_stmt><expr><name>winnt_mpm_state</name> = <name>AP_MPMQ_RUNNING</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr><name>NUM_WAIT_HANDLES</name></expr></argument>, <argument><expr>(<name>HANDLE</name> *) <name>event_handles</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cld</name> = <name>rv</name> - <name>WAIT_OBJECT_0</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> == <name>WAIT_FAILED</name></expr>)</condition><then> <block>{
        <comment type="block">/* Something serious is wrong */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00420</expr></argument>)</argument_list></call>
                     "master_main: WaitForMultipleObjects WAIT_FAILED -- doing server shutdown"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>shutdown_pending</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>rv</name> == <name>WAIT_TIMEOUT</name></expr>)</condition><then> <block>{
        <comment type="block">/* Hey, this cannot happen */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00421</expr></argument>)</argument_list></call>
                     "master_main: WaitForMultipleObjects with INFINITE wait exited with WAIT_TIMEOUT"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>shutdown_pending</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>cld</name> == <name>SHUTDOWN_HANDLE</name></expr>)</condition><then> <block>{
        <comment type="block">/* shutdown_event signalled */</comment>
        <expr_stmt><expr><name>shutdown_pending</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00422</expr></argument>)</argument_list></call>
                     "Parent: Received shutdown signal -- Shutting down the server."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>ResetEvent</name><argument_list>(<argument><expr><name>shutdown_event</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00423</expr></argument>)</argument_list></call>
                         "ResetEvent(shutdown_event)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>cld</name> == <name>RESTART_HANDLE</name></expr>)</condition><then> <block>{
        <comment type="block">/* Received a restart event. Prepare the restart_event to be reused
         * then signal the child process to exit.
         */</comment>
        <expr_stmt><expr><name>restart_pending</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00424</expr></argument>)</argument_list></call>
                     "Parent: Received restart signal -- Restarting the server."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>ResetEvent</name><argument_list>(<argument><expr><name>restart_event</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00425</expr></argument>)</argument_list></call>
                         "Parent: ResetEvent(restart_event) failed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>child_exit_event</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00426</expr></argument>)</argument_list></call>
                         "Parent: SetEvent for child process event %pp failed."</expr></argument>,
                         <argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/* Don't wait to verify that the child process really exits,
         * just move on with the restart.
         */</comment>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* The child process exited prematurely due to a fatal error. */</comment>
        <decl_stmt><decl><type><name>DWORD</name></type> <name>exitcode</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>GetExitCodeProcess</name><argument_list>(<argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>exitcode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* HUH? We did exit, didn't we? */</comment>
            <expr_stmt><expr><name>exitcode</name> = <name>APEXIT_CHILDFATAL</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(   <expr><name>exitcode</name> == <name>APEXIT_CHILDFATAL</name>
            || <name>exitcode</name> == <name>APEXIT_CHILDINIT</name>
            || <name>exitcode</name> == <name>APEXIT_INIT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00427</expr></argument>)</argument_list></call>
                         "Parent: child process %lu exited with status %lu -- Aborting."</expr></argument>,
                         <argument><expr><name>child_pid</name></expr></argument>, <argument><expr><name>exitcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>shutdown_pending</name> = 1</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>restart_pending</name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00428</expr></argument>)</argument_list></call>
                         "Parent: child process %lu exited with status %lu -- Restarting."</expr></argument>,
                         <argument><expr><name>child_pid</name></expr></argument>, <argument><expr><name>exitcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ap_threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>SERVER_DEAD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></else></if>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if>

    <expr_stmt><expr><call><name>winnt_note_child_killed</name><argument_list>(<comment type="block">/* slot */</comment> <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>restart_pending</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name>my_generation</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name> = <name>my_generation</name></expr>;</expr_stmt>
    }</block></then></if>
<label><name>die_now</name>:</label>
    <if>if <condition>(<expr><name>shutdown_pending</name></expr>)</condition><then>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr>30000</expr></init></decl>;</decl_stmt>  <comment type="block">/* Timeout is milliseconds */</comment>
        <expr_stmt><expr><name>winnt_mpm_state</name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>child_created</name></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>  <comment type="block">/* Tell the caller we do not want to restart */</comment>
        }</block></then></if>

        <comment type="block">/* This shutdown is only marginally graceful. We will give the
         * child a bit of time to exit gracefully. If the time expires,
         * the child will be wacked.
         */</comment>
        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"runservice"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>mpm_service_stopping</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/* Signal the child processes to exit */</comment>
        <if>if <condition>(<expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>child_exit_event</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00429</expr></argument>)</argument_list></call>
                             "Parent: SetEvent for child process event %pp failed"</expr></argument>,
                             <argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> == <name>WAIT_OBJECT_0</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00430</expr></argument>)</argument_list></call>
                             "Parent: Child process %lu exited successfully."</expr></argument>, <argument><expr><name>child_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00431</expr></argument>)</argument_list></call>
                             "Parent: Forcing termination of child process %lu"</expr></argument>,
                             <argument><expr><name>child_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>TerminateProcess</name><argument_list>(<argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>event_handles</name><index>[<expr><name>CHILD_HANDLE</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>child_exit_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>  <comment type="block">/* Tell the caller we do not want to restart */</comment>
    }</block></then></if>
    <expr_stmt><expr><name>winnt_mpm_state</name> = <name>AP_MPMQ_STARTING</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>child_exit_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>      <comment type="block">/* Tell the caller we want a restart */</comment>
}</block></function>

<comment type="block">/* service_nt_main_fn needs to append the StartService() args
 * outside of our call stack and thread as the service starts...
 */</comment>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>mpm_new_argv</name></decl>;</decl_stmt>

<comment type="block">/* Remember service_to_start failures to log and fail in pre_config.
 * Remember inst_argc and inst_argv for installing or starting the
 * service after we preflight the config.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>winnt_query</name><parameter_list>(<param><decl><type><name>int</name></type> <name>query_code</name></decl></param>, <param><decl><type><name>int</name> *</type><name>result</name></decl></param>, <param><decl><type><name>apr_status_t</name> *</type><name>rv</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>query_code</name></expr>)</condition> <block>{
        <case>case <expr><name>AP_MPMQ_MAX_DAEMON_USED</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>MAXIMUM_WAIT_OBJECTS</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_IS_THREADED</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>AP_MPMQ_STATIC</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_IS_FORKED</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>AP_MPMQ_NOT_SUPPORTED</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_HARD_LIMIT_DAEMONS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>HARD_SERVER_LIMIT</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_HARD_LIMIT_THREADS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>thread_limit</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_THREADS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>ap_threads_per_child</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MIN_SPARE_DAEMONS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MIN_SPARE_THREADS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_SPARE_DAEMONS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_SPARE_THREADS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_REQUESTS_DAEMON</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>ap_max_requests_per_child</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_DAEMONS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = 1</expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MPM_STATE</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>winnt_mpm_state</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_GENERATION</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>my_generation</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <expr_stmt><expr>*<name>rv</name> = <name>APR_ENOTIMPL</name></expr>;</expr_stmt>
            <break>break;</break>
    </default>}</block></switch>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>winnt_get_name</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <return>return <expr>"WinNT"</expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SERVICE_UNSET</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>service_set</name> <init>= <expr><name>SERVICE_UNSET</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>service_to_start_success</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>inst_argc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type><name>inst_argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>service_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>winnt_rewrite_args</name><parameter_list>(<param><decl><type><name>process_rec</name> *</type><name>process</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Handle the following SCM aspects in this phase:
     *
     *   -k runservice [transition in service context only]
     *   -k install
     *   -k config
     *   -k uninstall
     *   -k stop
     *   -k shutdown (same as -k stop). Maintained for backward compatibility.
     *
     * We can't leave this phase until we know our identity
     * and modify the command arguments appropriately.
     *
     * We do not care if the .conf file exists or is parsable when
     * attempting to stop or uninstall a service.
     */</comment>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>def_server_root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>binpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>optbuf</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>opt_arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fixed_args</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_getopt_t</name> *</type><name>opt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>running_as_service</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>errout</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>nullfile</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pconf</name> = <name><name>process</name>-&gt;<name>pconf</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>osver</name>.<name>dwOSVersionInfoSize</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>OSVERSIONINFO</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>GetVersionEx</name><argument_list>(<argument><expr>&amp;<name>osver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We wish this was *always* a reservation, but sadly it wasn't so and
     * we couldn't break a hard limit prior to NT Kernel 5.1
     */</comment>
    <if>if <condition>(<expr><name><name>osver</name>.<name>dwPlatformId</name></name> == <name>VER_PLATFORM_WIN32_NT</name>
        &amp;&amp; ((<name><name>osver</name>.<name>dwMajorVersion</name></name> &gt; 5)
         || ((<name><name>osver</name>.<name>dwMajorVersion</name></name> == 5) &amp;&amp; (<name><name>osver</name>.<name>dwMinorVersion</name></name> &gt; 0)))</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>stack_res_flag</name> = <name>STACK_SIZE_PARAM_IS_A_RESERVATION</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* AP_PARENT_PID is only valid in the child */</comment>
    <expr_stmt><expr><name>pid</name> = <call><name>getenv</name><argument_list>(<argument><expr>"AP_PARENT_PID"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pid</name></expr>)</condition><then>
    <block>{
        <decl_stmt><decl><type><name>HANDLE</name></type> <name>filehand</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>HANDLE</name></type> <name>hproc</name> <init>= <expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>DWORD</name></type> <name>BytesRead</name></decl>;</decl_stmt>

        <comment type="block">/* This is the child */</comment>
        <expr_stmt><expr><name>my_pid</name> = <call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>parent_pid</name> = (<name>DWORD</name>) <call><name>atol</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Prevent holding open the (nonexistent) console */</comment>
        <expr_stmt><expr><name>ap_real_exit_code</name> = 0</expr>;</expr_stmt>

        <comment type="block">/* The parent gave us stdin, we need to remember this
         * handle, and no longer inherit it at our children
         * (we can't slurp it up now, we just aren't ready yet).
         * The original handle is closed below, at apr_file_dup2()
         */</comment>
        <expr_stmt><expr><name>pipe</name> = <call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_INPUT_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>DuplicateHandle</name><argument_list>(<argument><expr><name>hproc</name></expr></argument>, <argument><expr><name>pipe</name></expr></argument>,
                            <argument><expr><name>hproc</name></expr></argument>, <argument><expr>&amp;<name>filehand</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                            <argument><expr><name>DUPLICATE_SAME_ACCESS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>pipe</name> = <name>filehand</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* The parent gave us stdout of the NUL device,
         * and expects us to suck up stdin of all of our
         * shared handles and data from the parent.
         * Don't infect child processes with our stdin
         * handle, use another handle to NUL!
         */</comment>
        <block>{
            <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>infile</name></decl>, *<decl><type ref="prev"/><name>outfile</name></decl>;</decl_stmt>
            <if>if <condition>(<expr>(<call><name>apr_file_open_stdout</name><argument_list>(<argument><expr>&amp;<name>outfile</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>)
             &amp;&amp; (<call><name>apr_file_open_stdin</name><argument_list>(<argument><expr>&amp;<name>infile</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>)</expr>)</condition><then>
                <expr_stmt><expr><call><name>apr_file_dup2</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><name>outfile</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block>

        <comment type="block">/* This child needs the existing stderr opened for logging,
         * already
         */</comment>

        <comment type="block">/* Read this child's generation number as soon as now,
         * so that further hooks can query it.
         */</comment>
        <if>if <condition>(<expr>!<call><name>ReadFile</name><argument_list>(<argument><expr><name>pipe</name></expr></argument>, <argument><expr>&amp;<name>my_generation</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>my_generation</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                      <argument><expr>&amp;<name>BytesRead</name></expr></argument>, <argument><expr>(<name>LPOVERLAPPED</name>) <name>NULL</name></expr></argument>)</argument_list></call>
                || (<name>BytesRead</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>my_generation</name></expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02965</expr></argument>)</argument_list></call>
                         "Child: Unable to retrieve my generation from the parent"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* The parent is responsible for providing the
         * COMPLETE ARGUMENTS REQUIRED to the child.
         *
         * No further argument parsing is needed, but
         * for good measure we will provide a simple
         * signal string for later testing.
         */</comment>
        <expr_stmt><expr><name>signal_arg</name> = "runchild"</expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* This is the parent, we have a long way to go :-) */</comment>
    <expr_stmt><expr><name>parent_pid</name> = <name>my_pid</name> = <call><name>GetCurrentProcessId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This behavior is voided by setting real_exit_code to 0 */</comment>
    <expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>hold_console_open_on_error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Rewrite process-&gt;argv[];
     *
     * strip out -k signal into signal_arg
     * strip out -n servicename and set the names
     * add default -d serverroot from the path of this executable
     *
     * The end result will look like:
     *
     * The invocation command (%0)
     *     The -d serverroot default from the running executable
     *         The requested service's (-n) registry ConfigArgs
     *             The WinNT SCM's StartService() args
     */</comment>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>ap_os_proc_filepath</name><argument_list>(<argument><expr>&amp;<name>binpath</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pconf</name></name></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00432</expr></argument>)</argument_list></call>
                     "Failed to get the full path of %s"</expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="block">/* WARNING: There is an implict assumption here that the
     * executable resides in ServerRoot or ServerRoot\bin
     */</comment>
    <expr_stmt><expr><name>def_server_root</name> = (<name>char</name> *) <call><name>apr_filepath_name_get</name><argument_list>(<argument><expr><name>binpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>def_server_root</name> &gt; <name>binpath</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*(<name>def_server_root</name> - 1) = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name>def_server_root</name> = (<name>char</name> *) <call><name>apr_filepath_name_get</name><argument_list>(<argument><expr><name>binpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>def_server_root</name></expr></argument>, <argument><expr>"bin"</expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr>*(<name>def_server_root</name> - 1) = '\0'</expr>;</expr_stmt></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_filepath_merge</name><argument_list>(<argument><expr>&amp;<name>def_server_root</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>binpath</name></expr></argument>,
                       <argument><expr><name>APR_FILEPATH_TRUENAME</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Use process-&gt;pool so that the rewritten argv
     * lasts for the lifetime of the server process,
     * because pconf will be destroyed after the
     * initial pre-flight of the config parser.
     */</comment>
    <expr_stmt><expr><name>mpm_new_argv</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>argc</name></name> + 2</expr></argument>,
                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> = <name><name>process</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> = "-d"</expr>;</expr_stmt>
    <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> = <name>def_server_root</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>fixed_args</name> = <name><name>mpm_new_argv</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>optbuf</name><index>[<expr>0</expr>]</index></name> = '-'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optbuf</name><index>[<expr>2</expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_getopt_init</name><argument_list>(<argument><expr>&amp;<name>opt</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>argc</name></name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name>-&gt;<name>errfn</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <while>while <condition>(<expr>(<name>rv</name> = <call><name>apr_getopt</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr>"wn:k:" <name>AP_SERVER_BASEARGS</name></expr></argument>,
                            <argument><expr><name>optbuf</name> + 1</expr></argument>, <argument><expr>&amp;<name>opt_arg</name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition> <block>{
        <switch>switch <condition>(<expr><name><name>optbuf</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{

        <comment type="block">/* Shortcuts; include the -w option to hold the window open on error.
         * This must not be toggled once we reset ap_real_exit_code to 0!
         */</comment>
        <case>case <expr>'w'</expr>:
            <if>if <condition>(<expr><name>ap_real_exit_code</name></expr>)</condition><then>
                <expr_stmt><expr><name>ap_real_exit_code</name> = 2</expr>;</expr_stmt></then></if>
            <break>break;</break>

        </case><case>case <expr>'n'</expr>:
            <expr_stmt><expr><name>service_set</name> = <call><name>mpm_service_set_name</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>service_name</name></expr></argument>,
                                               <argument><expr><name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>

        </case><case>case <expr>'k'</expr>:
            <expr_stmt><expr><name>signal_arg</name> = <name>opt_arg</name></expr>;</expr_stmt>
            <break>break;</break>

        </case><case>case <expr>'E'</expr>:
            <expr_stmt><expr><name>errout</name> = 1</expr>;</expr_stmt>
            <comment type="block">/* Fall through so the Apache main() handles the 'E' arg */</comment>
        </case><default>default:
            <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> =
                <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>optbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>opt_arg</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> = <name>opt_arg</name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
        </default>}</block></switch>
    }</block></while>

    <comment type="block">/* back up to capture the bad argument */</comment>
    <if>if <condition>(<expr><name>rv</name> == <name>APR_BADCH</name> || <name>rv</name> == <name>APR_BADARG</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>opt</name>-&gt;<name>ind</name></name>--</expr>;</expr_stmt>
    }</block></then></if>

    <while>while <condition>(<expr><name><name>opt</name>-&gt;<name>ind</name></name> &lt; <name><name>opt</name>-&gt;<name>argc</name></name></expr>)</condition> <block>{
        <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> =
            <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>opt</name>-&gt;<name>argv</name><index>[<expr><name><name>opt</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* Track the number of args actually entered by the user */</comment>
    <expr_stmt><expr><name>inst_argc</name> = <name><name>mpm_new_argv</name>-&gt;<name>nelts</name></name> - <name>fixed_args</name></expr>;</expr_stmt>

    <comment type="block">/* Provide a default 'run' -k arg to simplify signal_arg tests */</comment>
    <if>if <condition>(<expr>!<name>signal_arg</name></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><name>signal_arg</name> = "run"</expr>;</expr_stmt>
        <expr_stmt><expr><name>running_as_service</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"runservice"</expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
        <comment type="block">/* Start the NT Service _NOW_ because the WinNT SCM is
         * expecting us to rapidly assume control of our own
         * process, the SCM will tell us our service name, and
         * may have extra StartService() command arguments to
         * add for us.
         *
         * The SCM will generally invoke the executable with
         * the c:\win\system32 default directory.  This is very
         * lethal if folks use ServerRoot /foopath on windows
         * without a drive letter.  Change to the default root
         * (path to apache root, above /bin) for safety.
         */</comment>
        <expr_stmt><expr><call><name>apr_filepath_set</name><argument_list>(<argument><expr><name>def_server_root</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Any other process has a console, so we don't to begin
         * a Win9x service until the configuration is parsed and
         * any command line errors are reported.
         *
         * We hold the return value so that we can die in pre_config
         * after logging begins, and the failure can land in the log.
         */</comment>
        <if>if <condition>(<expr>!<name>errout</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>mpm_nt_eventlog_stderr_open</name><argument_list>(<argument><expr><name>service_name</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>service_to_start_success</name> = <call><name>mpm_service_to_start</name><argument_list>(<argument><expr>&amp;<name>service_name</name></expr></argument>,
                                                        <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>service_to_start_success</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>service_set</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Open a null handle to soak stdout in this process.
         * Windows service processes are missing any file handle
         * usable for stdin/out/err.  This was the cause of later
         * trouble with invocations of apr_file_open_stdout()
         */</comment>
        <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>nullfile</name></expr></argument>, <argument><expr>"NUL"</expr></argument>,
                                <argument><expr><name>APR_READ</name> | <name>APR_WRITE</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                                <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>nullstdout</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>apr_file_open_stdout</name><argument_list>(<argument><expr>&amp;<name>nullstdout</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>
                    == <name>APR_SUCCESS</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>apr_file_dup2</name><argument_list>(<argument><expr><name>nullstdout</name></expr></argument>, <argument><expr><name>nullfile</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>nullfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Get the default for any -k option, except run */</comment>
    <if>if <condition>(<expr><name>service_set</name> == <name>SERVICE_UNSET</name> &amp;&amp; <call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"run"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>service_set</name> = <call><name>mpm_service_set_name</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>service_name</name></expr></argument>,
                                           <argument><expr><name>AP_DEFAULT_SERVICE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"install"</expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="block">/* -k install */</comment>
    <block>{
        <if>if <condition>(<expr><name>service_set</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00433</expr></argument>)</argument_list></call>
                 "%s: Service is already installed."</expr></argument>, <argument><expr><name>service_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>running_as_service</name></expr>)</condition><then>
    <block>{
        <if>if <condition>(<expr><name>service_set</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
        <block>{
            <comment type="block">/* Attempt to Uninstall, or stop, before
             * we can read the arguments or .conf files
             */</comment>
            <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"uninstall"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>mpm_service_uninstall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr>(!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"stop"</expr></argument>)</argument_list></call>) ||
                (!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"shutdown"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>mpm_signal_service</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name>mpm_merge_service_args</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>mpm_new_argv</name></expr></argument>,
                                        <argument><expr><name>fixed_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00434</expr></argument>)</argument_list></call>
                             "Using ConfigArgs of the installed service "
                             "\"%s\"."</expr></argument>, <argument><expr><name>service_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else  <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00435</expr></argument>)</argument_list></call>
                             "No installed ConfigArgs for the service "
                             "\"%s\", using Apache defaults."</expr></argument>, <argument><expr><name>service_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else
        <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>service_set</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00436</expr></argument>)</argument_list></call>
                 "No installed service named \"%s\"."</expr></argument>, <argument><expr><name>service_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if></else></if>
    <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"install"</expr></argument>)</argument_list></call> &amp;&amp; <name>service_set</name> &amp;&amp; <name>service_set</name> != <name>SERVICE_UNSET</name></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>service_set</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00437</expr></argument>)</argument_list></call>
             "No installed service named \"%s\"."</expr></argument>, <argument><expr><name>service_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Track the args actually entered by the user.
     * These will be used for the -k install parameters, as well as
     * for the -k start service override arguments.
     */</comment>
    <expr_stmt><expr><name>inst_argv</name> = (const <name>char</name> * const *)<name><name>mpm_new_argv</name>-&gt;<name>elts</name></name>
        + <name><name>mpm_new_argv</name>-&gt;<name>nelts</name></name> - <name>inst_argc</name></expr>;</expr_stmt>

    <comment type="block">/* Now, do service install or reconfigure then proceed to
     * post_config to test the installed configuration.
     */</comment>
    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"config"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* -k config */</comment>
        <comment type="block">/* Reconfigure the service */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>mpm_service_install</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>inst_argc</name></expr></argument>, <argument><expr><name>inst_argv</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Testing httpd.conf....\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Errors reported here must be corrected before the "
                "service can be started.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"install"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* -k install */</comment>
        <comment type="block">/* Install the service */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>mpm_service_install</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>inst_argc</name></expr></argument>, <argument><expr><name>inst_argv</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Testing httpd.conf....\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr>"Errors reported here must be corrected before the "
                "service can be started.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <expr_stmt><expr><name><name>process</name>-&gt;<name>argc</name></name> = <name><name>mpm_new_argv</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>process</name>-&gt;<name>argv</name></name> = (const <name>char</name> * const *) <name><name>mpm_new_argv</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>winnt_pre_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf_</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Handle the following SCM aspects in this phase:
     *
     *   -k runservice [WinNT errors logged from rewrite_args]
     */</comment>

    <comment type="block">/* Initialize shared static objects.
     * TODO: Put config related statics into an sconf structure.
     */</comment>
    <expr_stmt><expr><name>pconf</name> = <name>pconf_</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"ONE_PROCESS"</expr></argument>)</argument_list></call> ||
        <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"DEBUG"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>one_process</name> = -1</expr>;</expr_stmt></then></if>

    <comment type="block">/* XXX: presume proper privilages; one nice thing would be
     * a loud emit if running as "LocalSystem"/"SYSTEM" to indicate
     * they should change to a user with write access to logs/ alone.
     */</comment>
    <expr_stmt><expr><call><name>ap_sys_privileges_handlers</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"runservice"</expr></argument>)</argument_list></call>
            &amp;&amp; (<name>service_to_start_success</name> != <name>APR_SUCCESS</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>service_to_start_success</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00438</expr></argument>)</argument_list></call>
                     "%s: Unable to start the service manager."</expr></argument>,
                     <argument><expr><name>service_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>ap_state_query</name><argument_list>(<argument><expr><name>AP_SQ_RUN_MODE</name></expr></argument>)</argument_list></call> == <name>AP_SQ_RM_NORMAL</name>
             &amp;&amp; !<name>one_process</name> &amp;&amp; !<name>my_generation</name></expr>)</condition><then> <block>{
        <comment type="block">/* Open a null handle to soak stdout in this process.
         * We need to emulate apr_proc_detach, unix performs this
         * same check in the pre_config hook (although it is
         * arguably premature).  Services already fixed this.
         */</comment>
        <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>nullfile</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pproc</name> <init>= <expr><call><name>apr_pool_parent_get</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>nullfile</name></expr></argument>, <argument><expr>"NUL"</expr></argument>,
                                <argument><expr><name>APR_READ</name> | <name>APR_WRITE</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                                <argument><expr><name>pproc</name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>nullstdout</name></decl>;</decl_stmt>
            <if>if <condition>(<expr><call><name>apr_file_open_stdout</name><argument_list>(<argument><expr>&amp;<name>nullstdout</name></expr></argument>, <argument><expr><name>pproc</name></expr></argument>)</argument_list></call>
                    == <name>APR_SUCCESS</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>apr_file_dup2</name><argument_list>(<argument><expr><name>nullstdout</name></expr></argument>, <argument><expr><name>nullfile</name></expr></argument>, <argument><expr><name>pproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>nullfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if></else></if>

    <expr_stmt><expr><call><name>ap_listen_pre_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>thread_limit</name> = <name>DEFAULT_THREAD_LIMIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_threads_per_child</name> = <name>DEFAULT_THREADS_PER_CHILD</name></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>winnt_check_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name>*</type> <name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>is_parent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>startup</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* We want this only in the parent and only the first time around */</comment>
    <expr_stmt><expr><name>is_parent</name> = (<name>parent_pid</name> == <name>my_pid</name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>is_parent</name> &amp;&amp;
        <call><name>ap_state_query</name><argument_list>(<argument><expr><name>AP_SQ_MAIN_STATE</name></expr></argument>)</argument_list></call> == <name>AP_SQ_MS_CREATE_PRE_CONFIG</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>startup</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>thread_limit</name> &gt; <name>MAX_THREAD_LIMIT</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00439</expr></argument>)</argument_list></call>
                         "WARNING: ThreadLimit of %d exceeds compile-time "
                         "limit of %d threads, decreasing to %d."</expr></argument>,
                         <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>is_parent</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00440</expr></argument>)</argument_list></call>
                         "ThreadLimit of %d exceeds compile-time limit "
                         "of %d, decreasing to match"</expr></argument>,
                         <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>thread_limit</name> = <name>MAX_THREAD_LIMIT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>thread_limit</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00441</expr></argument>)</argument_list></call>
                         "WARNING: ThreadLimit of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>is_parent</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00442</expr></argument>)</argument_list></call>
                         "ThreadLimit of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>thread_limit</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <comment type="block">/* You cannot change ThreadLimit across a restart; ignore
     * any such attempts.
     */</comment>
    <if>if <condition>(<expr>!<name>first_thread_limit</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>first_thread_limit</name> = <name>thread_limit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>thread_limit</name> != <name>first_thread_limit</name></expr>)</condition><then> <block>{
        <comment type="block">/* Don't need a startup console version here */</comment>
        <if>if <condition>(<expr><name>is_parent</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00443</expr></argument>)</argument_list></call>
                         "changing ThreadLimit to %d from original value "
                         "of %d not allowed during restart"</expr></argument>,
                         <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>first_thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>thread_limit</name> = <name>first_thread_limit</name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name>ap_threads_per_child</name> &gt; <name>thread_limit</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00444</expr></argument>)</argument_list></call>
                         "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
                         "of %d threads, decreasing to %d. To increase, please "
                         "see the ThreadLimit directive."</expr></argument>,
                         <argument><expr><name>ap_threads_per_child</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>is_parent</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00445</expr></argument>)</argument_list></call>
                         "ThreadsPerChild of %d exceeds ThreadLimit "
                         "of %d, decreasing to match"</expr></argument>,
                         <argument><expr><name>ap_threads_per_child</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>ap_threads_per_child</name> = <name>thread_limit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>ap_threads_per_child</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00446</expr></argument>)</argument_list></call>
                         "WARNING: ThreadsPerChild of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>ap_threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><name>is_parent</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00447</expr></argument>)</argument_list></call>
                         "ThreadsPerChild of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>ap_threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>ap_threads_per_child</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>winnt_post_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name>*</type> <name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Handle the following SCM aspects in this phase:
     *
     *   -k install (catch and exit as install was handled in rewrite_args)
     *   -k config  (catch and exit as config was handled in rewrite_args)
     *   -k start
     *   -k restart
     *   -k runservice [Win95, only once - after we parsed the config]
     *
     * because all of these signals are useful _only_ if there
     * is a valid conf\httpd.conf environment to start.
     *
     * We reached this phase by avoiding errors that would cause
     * these options to fail unexpectedly in another process.
     */</comment>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"install"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Service install happens in the rewrite_args hooks. If we
         * made it this far, the server configuration is clean and the
         * service will successfully start.
         */</comment>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_terminate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"config"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Service reconfiguration happens in the rewrite_args hooks. If we
         * made it this far, the server configuration is clean and the
         * service will successfully start.
         */</comment>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_terminate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"start"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>lr</name></decl>;</decl_stmt>

        <comment type="block">/* Close the listening sockets. */</comment>
        <for>for (<init><expr><name>lr</name> = <name>ap_listeners</name></expr>;</init> <condition><expr><name>lr</name></expr>;</condition> <incr><expr><name>lr</name> = <name><name>lr</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name><name>lr</name>-&gt;<name>sd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lr</name>-&gt;<name>active</name></name> = 0</expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><name>rv</name> = <call><name>mpm_service_start</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>, <argument><expr><name>inst_argc</name></expr></argument>, <argument><expr><name>inst_argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_terminate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"restart"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>mpm_signal_service</name><argument_list>(<argument><expr><name>ptemp</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_terminate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>exit</name> <argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>parent_pid</name> == <name>my_pid</name></expr>)</condition><then>
    <block>{
        <if>if <condition>(<expr><call><name>ap_state_query</name><argument_list>(<argument><expr><name>AP_SQ_MAIN_STATE</name></expr></argument>)</argument_list></call> != <name>AP_SQ_MS_CREATE_PRE_CONFIG</name>
            &amp;&amp; <call><name>ap_state_query</name><argument_list>(<argument><expr><name>AP_SQ_CONFIG_GEN</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
        <block>{
            <comment type="block">/* This code should be run once in the parent and not run
             * across a restart
             */</comment>
            <decl_stmt><decl><type><name>PSECURITY_ATTRIBUTES</name></type> <name>sa</name> <init>= <expr><call><name>GetNullACL</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>  <comment type="block">/* returns NULL if invalid (Win95?) */</comment>
            <expr_stmt><expr><call><name>setup_signal_names</name><argument_list>(<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr>"ap%lu"</expr></argument>, <argument><expr><name>parent_pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ap_log_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Create shutdown event, apPID_shutdown, where PID is the parent
             * Apache process ID. Shutdown is signaled by 'apache -k shutdown'.
             */</comment>
            <expr_stmt><expr><name>shutdown_event</name> = <call><name>CreateEvent</name><argument_list>(<argument><expr><name>sa</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>signal_shutdown_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>shutdown_event</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00448</expr></argument>)</argument_list></call>
                             "Parent: Cannot create shutdown event %s"</expr></argument>, <argument><expr><name>signal_shutdown_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CleanNullACL</name><argument_list>(<argument><expr>(<name>void</name> *)<name>sa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Create restart event, apPID_restart, where PID is the parent
             * Apache process ID. Restart is signaled by 'apache -k restart'.
             */</comment>
            <expr_stmt><expr><name>restart_event</name> = <call><name>CreateEvent</name><argument_list>(<argument><expr><name>sa</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>signal_restart_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>restart_event</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>shutdown_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00449</expr></argument>)</argument_list></call>
                             "Parent: Cannot create restart event %s"</expr></argument>, <argument><expr><name>signal_restart_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>CleanNullACL</name><argument_list>(<argument><expr>(<name>void</name> *)<name>sa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>CleanNullACL</name><argument_list>(<argument><expr>(<name>void</name> *)<name>sa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Create the start mutex, as an unnamed object for security.
             * Ths start mutex is used during a restart to prevent more than
             * one child process from entering the accept loop at once.
             */</comment>
            <expr_stmt><expr><name>rv</name> =  <call><name>apr_proc_mutex_create</name><argument_list>(<argument><expr>&amp;<name>start_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>APR_LOCK_DEFAULT</name></expr></argument>,
                                        <argument><expr><name><name>ap_server_conf</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00450</expr></argument>)</argument_list></call>
                             "%s: Unable to create the start_mutex."</expr></argument>,
                             <argument><expr><name>service_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <comment type="block">/* Always reset our console handler to be the first, even on a restart
        *  because some modules (e.g. mod_perl) might have set a console
        *  handler to terminate the process.
        */</comment>
        <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"runservice"</expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>mpm_start_console_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <comment type="block">/* parent_pid != my_pid */</comment>
    <block>{
        <expr_stmt><expr><call><name>mpm_start_child_console_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/* This really should be a post_config hook, but the error log is already
 * redirected by that point, so we need to do this in the open_logs phase.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>winnt_open_logs</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Initialize shared static objects.
     */</comment>
    <if>if <condition>(<expr><name>parent_pid</name> != <name>my_pid</name></expr>)</condition><then> <block>{
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* We cannot initialize our listeners if we are restarting
     * (the parent process already has glomed on to them)
     * nor should we do so for service reconfiguration
     * (since the service may already be running.)
     */</comment>
    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"restart"</expr></argument>)</argument_list></call>
            || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>signal_arg</name></expr></argument>, <argument><expr>"config"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ap_setup_listeners</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> &lt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name>|<name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00451</expr></argument>)</argument_list></call> "no listening sockets available, shutting down"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<name>OK</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>winnt_child_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pchild</name></decl></param>, <param><decl><type>struct <name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>setup_signal_names</name><argument_list>(<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr>"ap%lu"</expr></argument>, <argument><expr><name>parent_pid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This is a child process, not in single process mode */</comment>
    <if>if <condition>(<expr>!<name>one_process</name></expr>)</condition><then> <block>{
        <comment type="block">/* Set up events and the scoreboard */</comment>
        <expr_stmt><expr><call><name>get_handles_from_parent</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>exit_event</name></expr></argument>, <argument><expr>&amp;<name>start_mutex</name></expr></argument>,
                                <argument><expr>&amp;<name>ap_scoreboard_shm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Set up the listeners */</comment>
        <expr_stmt><expr><call><name>get_listeners_from_parent</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Done reading from the parent, close that channel */</comment>
        <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>pipe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* Single process mode - this lock doesn't even need to exist */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_proc_mutex_create</name><argument_list>(<argument><expr>&amp;<name>start_mutex</name></expr></argument>, <argument><expr><name>signal_name_prefix</name></expr></argument>,
                                   <argument><expr><name>APR_LOCK_DEFAULT</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>,<argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00452</expr></argument>)</argument_list></call>
                         "%s child: Unable to init the start_mutex."</expr></argument>,
                         <argument><expr><name>service_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDINIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Borrow the shutdown_even as our _child_ loop exit event */</comment>
        <expr_stmt><expr><name>exit_event</name> = <name>shutdown_event</name></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>winnt_run</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>_pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param> )</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>restart</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>            <comment type="block">/* Default is "not a restart" */</comment>

    <comment type="block">/* ### If non-graceful restarts are ever introduced - we need to rerun
     * the pre_mpm hook on subsequent non-graceful restarts.  But Win32
     * has only graceful style restarts - and we need this hook to act
     * the same on Win32 as on Unix.
     */</comment>
    <if>if <condition>(<expr>!<name>restart</name> &amp;&amp; ((<name>parent_pid</name> == <name>my_pid</name>) || <name>one_process</name>)</expr>)</condition><then> <block>{
        <comment type="block">/* Set up the scoreboard. */</comment>
        <if>if <condition>(<expr><call><name>ap_run_pre_mpm</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>SB_SHARED</name></expr></argument>)</argument_list></call> != <name>OK</name></expr>)</condition><then> <block>{
            <return>return <expr>!<name>OK</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>parent_pid</name> != <name>my_pid</name>) || <name>one_process</name></expr>)</condition><then>
    <block>{
        <comment type="block">/* The child process or in one_process (debug) mode
         */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00453</expr></argument>)</argument_list></call>
                     "Child process is running"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>child_main</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>parent_pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00454</expr></argument>)</argument_list></call>
                     "Child process is exiting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DONE</name></expr>;</return>
    }</block></then>
    <else>else
    <block>{
        <comment type="block">/* A real-honest to goodness parent */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00455</expr></argument>)</argument_list></call>
                     "%s configured -- resuming normal operations"</expr></argument>,
                     <argument><expr><call><name>ap_get_server_description</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00456</expr></argument>)</argument_list></call>
                     "Server built: %s"</expr></argument>, <argument><expr><call><name>ap_get_server_built</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_command_line</name><argument_list>(<argument><expr><name>plog</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_mpm_common</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>restart</name> = <call><name>master_main</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>shutdown_event</name></expr></argument>, <argument><expr><name>restart_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>restart</name></expr>)</condition><then>
        <block>{
            <comment type="block">/* Shutting down. Clean up... */</comment>
            <expr_stmt><expr><call><name>ap_remove_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_proc_mutex_destroy</name><argument_list>(<argument><expr><name>start_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>restart_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>shutdown_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>DONE</name></expr>;</return>
        }</block></then></if>
    }</block></else></if>

    <return>return <expr><name>OK</name></expr>;</return> <comment type="block">/* Restart */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>winnt_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Our open_logs hook function must run before the core's, or stderr
     * will be redirected to a file, and the messages won't print to the
     * console.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name><name>aszSucc</name><index>[]</index></name> <init>= <expr><block>{<expr>"core.c"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_hook_pre_config</name><argument_list>(<argument><expr><name>winnt_pre_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_check_config</name><argument_list>(<argument><expr><name>winnt_check_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_post_config</name><argument_list>(<argument><expr><name>winnt_post_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_child_init</name><argument_list>(<argument><expr><name>winnt_child_init</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_open_logs</name><argument_list>(<argument><expr><name>winnt_open_logs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>aszSucc</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm</name><argument_list>(<argument><expr><name>winnt_run</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm_query</name><argument_list>(<argument><expr><name>winnt_query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm_get_name</name><argument_list>(<argument><expr><name>winnt_get_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>mpm_winnt</name></expr></argument>)</argument_list></call> = <block>{
    <expr><name>MPM20_MODULE_STUFF</name></expr>,
    <expr><name>winnt_rewrite_args</name></expr>,    <comment type="block">/* hook to run before apache parses args */</comment>
    <expr><name>NULL</name></expr>,                  <comment type="block">/* create per-directory config structure */</comment>
    <expr><name>NULL</name></expr>,                  <comment type="block">/* merge per-directory config structures */</comment>
    <expr><name>NULL</name></expr>,                  <comment type="block">/* create per-server config structure */</comment>
    <expr><name>NULL</name></expr>,                  <comment type="block">/* merge per-server config structures */</comment>
    <expr><name>winnt_cmds</name></expr>,            <comment type="block">/* command apr_table_t */</comment>
    <expr><name>winnt_hooks</name></expr>            <comment type="block">/* register_hooks */</comment>
}</block></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* def WIN32 */</comment>
</unit>
