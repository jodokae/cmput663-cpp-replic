<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/mpm/prefork/prefork.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_portable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_signal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STDIO</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_SYS_TYPES_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_default.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>          <comment type="block">/* for get_remote_host */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unixd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_listen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mmn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_poll.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TIME_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_PROCESSOR_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/processor.h&gt;</cpp:file></cpp:include> <comment type="block">/* for bindprocessor() */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/times.h&gt;</cpp:file></cpp:include>

<comment type="block">/* Limit on the total --- clients will be locked out if more servers than
 * this are needed.  It is intended solely to keep the server from crashing
 * when things get out of hand.
 *
 * We keep a hard maximum number of servers, for two reasons --- first off,
 * in case something goes seriously wrong, we want to stop the fork bomb
 * short of actually crashing the machine we're running on by filling some
 * kernel table.  Secondly, it keeps the size of the scoreboard file small
 * enough that we can read the whole thing without worrying too much about
 * the overhead.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_SERVER_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SERVER_LIMIT</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Admin can't tune ServerLimit beyond MAX_SERVER_LIMIT.  We want
 * some sort of compile-time limit to help catch typos.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX_SERVER_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SERVER_LIMIT</name></cpp:macro> <cpp:value>200000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HARD_THREAD_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HARD_THREAD_LIMIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* config globals */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ap_daemons_to_start</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ap_daemons_min_free</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ap_daemons_max_free</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ap_daemons_limit</name><init>=<expr>0</expr></init></decl>;</decl_stmt>      <comment type="block">/* MaxRequestWorkers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>server_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<comment type="block">/* data retained by prefork across load/unload of the module
 * allocated on first call to pre-config hook; located on
 * subsequent calls to pre-config hook
 */</comment>
<typedef>typedef <type><struct>struct <name>prefork_retained_data</name> <block>{
    <decl_stmt><decl><type><name>ap_unixd_mpm_retained_data</name> *</type><name>mpm</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>first_server_limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxclients_reported</name></decl>;</decl_stmt>
    <comment type="block">/*
     * The max child slot ever assigned, preserved across restarts.  Necessary
     * to deal with MaxRequestWorkers changes across AP_SIG_GRACEFUL restarts.  We
     * use this value to optimize routines that have to scan the entire scoreboard.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_daemons_limit</name></decl>;</decl_stmt>
    <comment type="block">/*
     * idle_spawn_rate is the number of children that will be spawned on the
     * next maintenance cycle if there aren't enough idle servers.  It is
     * doubled up to MAX_SPAWN_RATE, and reset only when a cycle goes by
     * without the need to spawn.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>idle_spawn_rate</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX_SPAWN_RATE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SPAWN_RATE</name></cpp:macro>  <cpp:value>(32)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>hold_off_on_exponential_spawning</name></decl>;</decl_stmt>
}</block></struct></type> <name>prefork_retained_data</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>prefork_retained_data</name> *</type><name>retained</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>prefork_child_bucket</name> <block>{
    <decl_stmt><decl><type><name>ap_pod_t</name> *</type><name>pod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>listeners</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_proc_mutex_t</name> *</type><name>mutex</name></decl>;</decl_stmt>
}</block></struct></type> <name>prefork_child_bucket</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>prefork_child_bucket</name> *</type><name>all_buckets</name></decl>, <comment type="block">/* All listeners buckets */</comment>
                            *<decl><type ref="prev"/><name>my_bucket</name></decl>;</decl_stmt>   <comment type="block">/* Current child bucket */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MPM_CHILD_PID</name><parameter_list>(<param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(ap_scoreboard_image-&gt;parent[i].pid)</cpp:value></cpp:define>

<comment type="block">/* one_process --- debugging mode variable; can be set from the command line
 * with the -X flag.  If set, this gets you the child_main loop running
 * in the process which originally started up (no detach, no make_child),
 * which is a pretty nice debugging environment.  (You'll get a SIGHUP
 * early in standalone_main; just continue through.  This is the server
 * trying to kill off any child processes which it might have lying
 * around --- Apache doesn't keep track of their pids, it just sends
 * SIGHUP to the process group, ignoring it in the root process.
 * Continue through and you'll be fine.).
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>one_process</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>apr_pool_t</name> *</type><name>pconf</name></decl>;</decl_stmt>               <comment type="block">/* Pool for config stuff */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_pool_t</name> *</type><name>pchild</name></decl>;</decl_stmt>              <comment type="block">/* Pool for httpd child stuff */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>ap_my_pid</name></decl>;</decl_stmt> <comment type="block">/* it seems silly to call getpid all the time */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>parent_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>my_child_num</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPROF</name></cpp:ifdef>
<comment type="block">/*
 * change directory for gprof to plop the gmon.out file
 * configure in httpd.conf:
 * GprofDir $RuntimeDir/   -&gt; $ServerRoot/$RuntimeDir/gmon.out
 * GprofDir $RuntimeDir/%  -&gt; $ServerRoot/$RuntimeDir/gprof.$pid/gmon.out
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>chdir_for_gprof</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>sconf</name> <init>=
        <expr><call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>ap_server_conf</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>dir</name> <init>= <expr><name><name>sconf</name>-&gt;<name>gprof_dir</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>use_dir</name></decl>;</decl_stmt>

    <if>if<condition>(<expr><name>dir</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>res</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl> ;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>sconf</name>-&gt;<name>gprof_dir</name></name></expr></argument>)</argument_list></call> - 1</expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr>*(<name>dir</name> + <name>len</name>) == '%'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>dir</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><name>buf</name> = <call><name>ap_append_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr>"gprof."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>use_dir</name> = <call><name>ap_server_root_relative</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>buf</name> ? <name>buf</name> : <name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>res</name> = <call><name>apr_dir_make</name><argument_list>(<argument><expr><name>use_dir</name></expr></argument>,
                           <argument><expr><name>APR_UREAD</name> | <name>APR_UWRITE</name> | <name>APR_UEXECUTE</name> |
                           <name>APR_GREAD</name> | <name>APR_GEXECUTE</name> |
                           <name>APR_WREAD</name> | <name>APR_WEXECUTE</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><name>res</name> != <name>APR_SUCCESS</name> &amp;&amp; !<call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00142</expr></argument>)</argument_list></call>
                         "gprof: error creating directory %s"</expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>use_dir</name> = <call><name>ap_runtime_dir_relative</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>chdir</name><argument_list>(<argument><expr><name>use_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>chdir_for_gprof</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>prefork_note_child_killed</name><parameter_list>(<param><decl><type><name>int</name></type> <name>childnum</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>,
                                      <param><decl><type><name>ap_generation_t</name></type> <name>gen</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>childnum</name> != -1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* no scoreboard squatting with this MPM */</comment>
    <expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>generation</name></expr></argument>,
                        <argument><expr><name>childnum</name></expr></argument>, <argument><expr><name>MPM_CHILD_EXITED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>pid</name> = 0</expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>prefork_note_child_started</name><parameter_list>(<param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name> = <name>pid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                        <argument><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MPM_CHILD_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* a clean exit from a child with proper cleanup */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clean_child_exit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list> __attribute__ <parameter_list>(<param/></parameter_list>(noreturn</function_decl>))<empty_stmt>;</empty_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clean_child_exit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>pchild</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>prefork_note_child_killed</name><argument_list>(<comment type="block">/* slot */</comment> <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_mpm_pod_close</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>pod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>chdir_for_gprof</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>accept_mutex_on</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><call><name>apr_proc_mutex_lock</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name> <init>= <expr>"couldn't grab the accept mutex"</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name> !=
            <name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00143</expr></argument>)</argument_list></call> "%s"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00144</expr></argument>)</argument_list></call> "%s"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>accept_mutex_off</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><call><name>apr_proc_mutex_unlock</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name> <init>= <expr>"couldn't release the accept mutex"</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name> !=
            <name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00145</expr></argument>)</argument_list></call> "%s"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* don't exit here... we have a connection to
             * process, after which point we'll see that the
             * generation changed and we'll exit cleanly
             */</comment>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00146</expr></argument>)</argument_list></call> "%s"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/* On some architectures it's safe to do unserialized accept()s in the single
 * Listen case.  But it's never safe to do it in the case where there's
 * multiple Listen statements.  Define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
 * when it's safe in the single Listen case.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SINGLE_LISTEN_UNSERIALIZED_ACCEPT</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAFE_ACCEPT</name><parameter_list>(<param><type><name>stmt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(ap_listeners-&gt;next ? (stmt) : APR_SUCCESS)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAFE_ACCEPT</name><parameter_list>(<param><type><name>stmt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(stmt)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prefork_query</name><parameter_list>(<param><decl><type><name>int</name></type> <name>query_code</name></decl></param>, <param><decl><type><name>int</name> *</type><name>result</name></decl></param>, <param><decl><type><name>apr_status_t</name> *</type><name>rv</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    <switch>switch<condition>(<expr><name>query_code</name></expr>)</condition><block>{
    <case>case <expr><name>AP_MPMQ_MAX_DAEMON_USED</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>ap_daemons_limit</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_IS_THREADED</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>AP_MPMQ_NOT_SUPPORTED</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_IS_FORKED</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>AP_MPMQ_DYNAMIC</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_HARD_LIMIT_DAEMONS</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>server_limit</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_HARD_LIMIT_THREADS</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>HARD_THREAD_LIMIT</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_MAX_THREADS</name></expr>:
        <expr_stmt><expr>*<name>result</name> = 1</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_MIN_SPARE_DAEMONS</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>ap_daemons_min_free</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_MIN_SPARE_THREADS</name></expr>:
        <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_MAX_SPARE_DAEMONS</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>ap_daemons_max_free</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_MAX_SPARE_THREADS</name></expr>:
        <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_MAX_REQUESTS_DAEMON</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>ap_max_requests_per_child</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_MAX_DAEMONS</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name>ap_daemons_limit</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_MPM_STATE</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>AP_MPMQ_GENERATION</name></expr>:
        <expr_stmt><expr>*<name>result</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
        <break>break;</break>
    </case><default>default:
        <expr_stmt><expr>*<name>rv</name> = <name>APR_ENOTIMPL</name></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>prefork_get_name</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <return>return <expr>"prefork"</expr>;</return>
}</block></function>

<comment type="block">/*****************************************************************
 * Connection structures and accounting...
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>just_die</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* volatile because it's updated from a signal handler */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name> <specifier>volatile</specifier></type> <name>die_now</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>stop_listening</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_close_listeners_ex</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* For a graceful stop, we want the child to exit when done */</comment>
    <expr_stmt><expr><name>die_now</name> = 1</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*****************************************************************
 * Child process main loop.
 * The following vars are static to avoid getting clobbered by longjmp();
 * they are really private to child_main.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>requests_this_child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>num_listensocks</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>child_num_arg</name></decl></param>, <param><decl><type><name>int</name></type> <name>child_bucket</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>apr_thread_t</name> *</type><name>thd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_os_thread_t</name></type> <name>osthd</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>ptrans</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>lr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pollset_t</name> *</type><name>pollset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_sb_handle_t</name> *</type><name>sbh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_alloc_t</name> *</type><name>bucket_alloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last_poll_idx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lockfile</name></decl>;</decl_stmt>

    <comment type="block">/* for benefit of any hooks that run as this child initializes */</comment>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STARTING</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>my_child_num</name> = <name>child_num_arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_my_pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>requests_this_child</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_fatal_signal_child_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get a sub context for global allocations in this child, so that
     * we can have cleanups occur when the child exits.
     */</comment>
    <expr_stmt><expr><call><name>apr_allocator_create</name><argument_list>(<argument><expr>&amp;<name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_allocator_max_free_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>ap_max_mem_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_create_ex</name><argument_list>(<argument><expr>&amp;<name>pchild</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_allocator_owner_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_tag</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr>"pchild"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
    <expr_stmt><expr><name>osthd</name> = <call><name>apr_os_thread_current</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_os_thread_put</name><argument_list>(<argument><expr>&amp;<name>thd</name></expr></argument>, <argument><expr>&amp;<name>osthd</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>ptrans</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_tag</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>, <argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* close unused listeners and pods */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name>i</name> != <name>child_bucket</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_close_listeners_ex</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>listeners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_mpm_pod_close</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* needs to be done before we switch UIDs so we have permissions */</comment>
    <expr_stmt><expr><call><name>ap_reopen_scoreboard</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>status</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_child_init</name><argument_list>(<argument><expr>&amp;<name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>,
                                    <argument><expr><call><name>apr_proc_mutex_lockfile</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>lockfile</name> = <call><name>apr_proc_mutex_lockfile</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00155</expr></argument>)</argument_list></call>
                     "Couldn't initialize cross-process lock in child "
                     "(%s) (%s)"</expr></argument>,
                     <argument><expr><name>lockfile</name> ? <name>lockfile</name> : "none"</expr></argument>,
                     <argument><expr><call><name>apr_proc_mutex_name</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ap_run_drop_privileges</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_run_child_init</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_create_sb_handle</name><argument_list>(<argument><expr>&amp;<name>sbh</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>my_child_num</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>(<name>void</name>) <call><name>ap_update_child_status</name><argument_list>(<argument><expr><name>sbh</name></expr></argument>, <argument><expr><name>SERVER_READY</name></expr></argument>, <argument><expr>(<name>request_rec</name> *) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Set up the pollfd array */</comment>
    <expr_stmt><expr><name>status</name> = <call><name>apr_pollset_create</name><argument_list>(<argument><expr>&amp;<name>pollset</name></expr></argument>, <argument><expr><name>num_listensocks</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>,
                                <argument><expr><name>APR_POLLSET_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00156</expr></argument>)</argument_list></call>
                     "Couldn't create pollset in child; check system or user limits"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* assume temporary resource issue */</comment>
    }</block></then></if>

    <for>for (<init><expr><name>lr</name> = <name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr>, <expr><name>i</name> = <name>num_listensocks</name></expr>;</init> <condition><expr><name>i</name>--</expr>;</condition> <incr><expr><name>lr</name> = <name><name>lr</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>apr_pollfd_t</name> *</type><name>pfd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr>sizeof *<name>pfd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pfd</name>-&gt;<name>desc_type</name></name> = <name>APR_POLL_SOCKET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfd</name>-&gt;<name>desc</name>.<name>s</name></name> = <name><name>lr</name>-&gt;<name>sd</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfd</name>-&gt;<name>reqevents</name></name> = <name>APR_POLLIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfd</name>-&gt;<name>client_data</name></name> = <name>lr</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>status</name> = <call><name>apr_pollset_add</name><argument_list>(<argument><expr><name>pollset</name></expr></argument>, <argument><expr><name>pfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="block">/* If the child processed a SIGWINCH before setting up the
             * pollset, this error path is expected and harmless,
             * since the listener fd was already closed; so don't
             * pollute the logs in that case. */</comment>
            <if>if <condition>(<expr>!<name>die_now</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00157</expr></argument>)</argument_list></call>
                             "Couldn't add listener to pollset; check system or user limits"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name><name>lr</name>-&gt;<name>accept_func</name></name> = <name>ap_unixd_accept</name></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_RUNNING</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>bucket_alloc</name> = <call><name>apr_bucket_alloc_create</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* die_now is set when AP_SIG_GRACEFUL is received in the child;
     * {shutdown,restart}_pending are set when a signal is received while
     * running in single process mode.
     */</comment>
    <while>while <condition>(<expr>!<name>die_now</name>
           &amp;&amp; !<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name>
           &amp;&amp; !<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>restart_pending</name></name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>conn_rec</name> *</type><name>current_conn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>csd</name></decl>;</decl_stmt>

        <comment type="block">/*
         * (Re)initialize this child to a pre-connection state.
         */</comment>

        <expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>(<name>ap_max_requests_per_child</name> &gt; 0
             &amp;&amp; <name>requests_this_child</name>++ &gt;= <name>ap_max_requests_per_child</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr>(<name>void</name>) <call><name>ap_update_child_status</name><argument_list>(<argument><expr><name>sbh</name></expr></argument>, <argument><expr><name>SERVER_READY</name></expr></argument>, <argument><expr>(<name>request_rec</name> *) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Wait for an acceptable connection to arrive.
         */</comment>

        <comment type="block">/* Lock around "accept", if necessary */</comment>
        <expr_stmt><expr><call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>accept_mutex_on</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>num_listensocks</name> == 1</expr>)</condition><then> <block>{
            <comment type="block">/* There is only one listener record, so refer to that one. */</comment>
            <expr_stmt><expr><name>lr</name> = <name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* multiple listening sockets - need to poll */</comment>
            <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
                <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>numdesc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>apr_pollfd_t</name> *</type><name>pdesc</name></decl>;</decl_stmt>

                <comment type="block">/* check for termination first so we don't sleep for a while in
                 * poll if already signalled
                 */</comment>
                <if>if <condition>(<expr><name>die_now</name>         <comment type="block">/* in graceful stop/restart */</comment>
                        || <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name>
                        || <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>restart_pending</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>accept_mutex_off</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/* timeout == 10 seconds to avoid a hang at graceful restart/stop
                 * caused by the closing of sockets by the signal handler
                 */</comment>
                <expr_stmt><expr><name>status</name> = <call><name>apr_pollset_poll</name><argument_list>(<argument><expr><name>pollset</name></expr></argument>, <argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr>&amp;<name>numdesc</name></expr></argument>, <argument><expr>&amp;<name>pdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name>APR_STATUS_IS_TIMEUP</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> ||
                        <call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <continue>continue;</continue>
                    }</block></then></if>
                    <comment type="block">/* Single Unix documents select as returning errnos
                     * EBADF, EINTR, and EINVAL... and in none of those
                     * cases does it make sense to continue.  In fact
                     * on Linux 2.0.x we seem to end up with EFAULT
                     * occasionally, and we'd loop forever due to it.
                     */</comment>
                    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>status</name></expr></argument>,
                                 <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00158</expr></argument>)</argument_list></call> "apr_pollset_poll: (listen)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>accept_mutex_off</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/* We can always use pdesc[0], but sockets at position N
                 * could end up completely starved of attention in a very
                 * busy server. Therefore, we round-robin across the
                 * returned set of descriptors. While it is possible that
                 * the returned set of descriptors might flip around and
                 * continue to starve some sockets, we happen to know the
                 * internal pollset implementation retains ordering
                 * stability of the sockets. Thus, the round-robin should
                 * ensure that a socket will eventually be serviced.
                 */</comment>
                <if>if <condition>(<expr><name>last_poll_idx</name> &gt;= <name>numdesc</name></expr>)</condition><then>
                    <expr_stmt><expr><name>last_poll_idx</name> = 0</expr>;</expr_stmt></then></if>

                <comment type="block">/* Grab a listener record from the client_data of the poll
                 * descriptor, and advance our saved index to round-robin
                 * the next fetch.
                 *
                 * ### hmm... this descriptor might have POLLERR rather
                 * ### than POLLIN
                 */</comment>
                <expr_stmt><expr><name>lr</name> = <name><name>pdesc</name><index>[<expr><name>last_poll_idx</name>++</expr>]</index></name>.<name>client_data</name></expr>;</expr_stmt>
                <goto>goto <name>got_fd</name>;</goto>
            }</block></for>
        }</block></else></if>
    <label><name>got_fd</name>:</label>
        <comment type="block">/* if we accept() something we don't want to die, so we have to
         * defer the exit
         */</comment>
        <expr_stmt><expr><name>status</name> = <call><name><name>lr</name>-&gt;<name>accept_func</name></name><argument_list>(<argument><expr>&amp;<name>csd</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>accept_mutex_off</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>      <comment type="block">/* unlock after "accept" */</comment>

        <if>if <condition>(<expr><name>status</name> == <name>APR_EGENERAL</name></expr>)</condition><then> <block>{
            <comment type="block">/* resource shortage or should-not-occur occurred */</comment>
            <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if></else></if>

        <comment type="block">/*
         * We now have a connection, so set it up with the appropriate
         * socket options, file descriptors, and read/write buffers.
         */</comment>

        <expr_stmt><expr><name>current_conn</name> = <call><name>ap_run_create_connection</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>csd</name></expr></argument>, <argument><expr><name>my_child_num</name></expr></argument>, <argument><expr><name>sbh</name></expr></argument>, <argument><expr><name>bucket_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>current_conn</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
            <expr_stmt><expr><name><name>current_conn</name>-&gt;<name>current_thread</name></name> = <name>thd</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>ap_process_connection</name><argument_list>(<argument><expr><name>current_conn</name></expr></argument>, <argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_lingering_close</name><argument_list>(<argument><expr><name>current_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Check the pod and the generation number after processing a
         * connection so that we'll go away if a graceful restart occurred
         * while we were processing the connection or we are the lucky
         * idle server process that gets to die.
         */</comment>
        <if>if <condition>(<expr><call><name>ap_mpm_pod_check</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>pod</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{ <comment type="block">/* selected as idle? */</comment>
            <expr_stmt><expr><name>die_now</name> = 1</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name> !=
                 <name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name></expr>)</condition><then> <block>{ <comment type="block">/* restart? */</comment>
            <comment type="block">/* yeah, this could be non-graceful restart, in which case the
             * parent will kill us soon enough, but why bother checking?
             */</comment>
            <expr_stmt><expr><name>die_now</name> = 1</expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></while>
    <expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* kludge to avoid crash in APR reslist cleanup code */</comment>
    <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>make_child</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>int</name></type> <name>bucket</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>slot</name> + 1 &gt; <name><name>retained</name>-&gt;<name>max_daemons_limit</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = <name>slot</name> + 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>my_bucket</name> = &amp;<name><name>all_buckets</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>prefork_note_child_started</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>child_main</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* NOTREACHED */</comment>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>(<name>void</name>) <call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SERVER_STARTING</name></expr></argument>,
                                               <argument><expr>(<name>request_rec</name> *) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_OSD_POSIX</name></cpp:ifdef>
    <comment type="block">/* BS2000 requires a "special" version of fork() before a setuid() call */</comment>
    <if>if <condition>(<expr>(<name>pid</name> = <call><name>os_fork</name><argument_list>(<argument><expr><name><name>ap_unixd_config</name>.<name>user_name</name></name></expr></argument>)</argument_list></call>) == -1</expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if <condition>(<expr>(<name>pid</name> = <call><name>fork</name><argument_list>()</argument_list></call>) == -1</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00159</expr></argument>)</argument_list></call> "fork: Unable to fork new process"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* fork didn't succeed. Fix the scoreboard or else
         * it will say SERVER_STARTING forever and ever
         */</comment>
        <expr_stmt><expr>(<name>void</name>) <call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SERVER_DEAD</name></expr></argument>,
                                                   <argument><expr>(<name>request_rec</name> *) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* In case system resources are maxxed out, we don't want
         * Apache running away with the CPU trying to fork over and
         * over and over again.
         */</comment>
        <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>pid</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>my_bucket</name> = &amp;<name><name>all_buckets</name><index>[<expr><name>bucket</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BINDPROCESSOR</name></cpp:ifdef>
        <comment type="block">/* by default AIX binds to a single processor
         * this bit unbinds children which will then bind to another cpu
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>bindprocessor</name><argument_list>(<argument><expr><name>BINDPROCESS</name></expr></argument>, <argument><expr>(<name>int</name>)<call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>,
                                   <argument><expr><name>PROCESSOR_CLASS_ANY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>status</name> != <name>OK</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>,
                         <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00160</expr></argument>)</argument_list></call> "processor unbind failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>RAISE_SIGSTOP</name><argument_list>(<argument><expr><name>MAKE_CHILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>AP_MONCONTROL</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Disable the parent's signal handlers and set up proper handling in
         * the child.
         */</comment>
        <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>just_die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>just_die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Ignore SIGINT in child. This fixes race-condition in signals
         * handling when httpd is runnning on foreground and user hits ctrl+c.
         * In this case, SIGINT is sent to all children followed by SIGTERM
         * from the main process, which interrupts the SIGINT handler and
         * leads to inconsistency.
         */</comment>
        <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* The child process just closes listeners on AP_SIG_GRACEFUL.
         * The pod is used for signalling the graceful restart.
         */</comment>
        <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>AP_SIG_GRACEFUL</name></expr></argument>, <argument><expr><name>stop_listening</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>child_main</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>bucket</name> = <name>bucket</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>prefork_note_child_started</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>0</expr>;</return>
}</block></then></if>


<comment type="block">/* start up a bunch of children */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>startup_children</name><parameter_list>(<param><decl><type><name>int</name></type> <name>number_to_start</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>number_to_start</name> &amp;&amp; <name>i</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name>.<name>status</name> != <name>SERVER_DEAD</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> % <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr>--<name>number_to_start</name></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>perform_idle_server_maintenance</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bucket_make_child_record</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bucket_kill_child_record</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idle_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>worker_score</name> *</type><name>ws</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>free_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>free_slots</name><index>[<expr><name>MAX_SPAWN_RATE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last_non_dead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>total_non_dead</name></decl>;</decl_stmt>

    <comment type="block">/* initialize the free_list */</comment>
    <expr_stmt><expr><name>free_length</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>idle_count</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>last_non_dead</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>total_non_dead</name> = 0</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>i</name> &gt;= <name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> &amp;&amp; <name>free_length</name> == <name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
        <expr_stmt><expr><name>ws</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> = <name><name>ws</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> == <name>SERVER_DEAD</name></expr>)</condition><then> <block>{
            <comment type="block">/* try to keep children numbers as low as possible */</comment>
            <if>if <condition>(<expr><name>free_length</name> &lt; <name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>free_slots</name><index>[<expr><name>free_length</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>free_length</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* We consider a starting server as idle because we started it
             * at least a cycle ago, and if it still hasn't finished starting
             * then we're just going to swamp things worse by forking more.
             * So we hopefully won't need to fork more if we count it.
             * This depends on the ordering of SERVER_READY and SERVER_STARTING.
             */</comment>
            <if>if <condition>(<expr><name>status</name> &lt;= <name>SERVER_READY</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>++ <name>idle_count</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr>++<name>total_non_dead</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>last_non_dead</name> = <name>i</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = <name>last_non_dead</name> + 1</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>idle_count</name> &gt; <name>ap_daemons_max_free</name></expr>)</condition><then> <block>{
        <comment type="block">/* kill off one child... we use the pod because that'll cause it to
         * shut down gracefully, in case it happened to pick up a request
         * while we were counting
         */</comment>
        <expr_stmt><expr><name>bucket_kill_child_record</name> = (<name>bucket_kill_child_record</name> + 1) % <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_mpm_pod_signal</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>bucket_kill_child_record</name></expr>]</index></name>.<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>idle_count</name> &lt; <name>ap_daemons_min_free</name></expr>)</condition><then> <block>{
        <comment type="block">/* terminate the free list */</comment>
        <if>if <condition>(<expr><name>free_length</name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* only report this condition once */</comment>
            <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>maxclients_reported</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00161</expr></argument>)</argument_list></call>
                            "server reached MaxRequestWorkers setting, consider"
                            " raising the MaxRequestWorkers setting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>retained</name>-&gt;<name>maxclients_reported</name></name> = 1</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> = 1</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> &gt;= 8</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00162</expr></argument>)</argument_list></call>
                    "server seems busy, (you may need "
                    "to increase StartServers, or Min/MaxSpareServers), "
                    "spawning %d children, there are %d idle, and "
                    "%d total children"</expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name></expr></argument>,
                    <argument><expr><name>idle_count</name></expr></argument>, <argument><expr><name>total_non_dead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>free_length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <expr_stmt><expr><name>bucket_make_child_record</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>bucket_make_child_record</name> %= <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name><name>free_slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                           <argument><expr><name>bucket_make_child_record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <comment type="block">/* the next time around we want to spawn twice as many if this
             * wasn't good enough, but not if we've just done a graceful
             */</comment>
            <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr>--<name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> &lt; <name>MAX_SPAWN_RATE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> *= 2</expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> = 1</expr>;</expr_stmt>
    }</block></else></if></else></if>
}</block></function>

<comment type="block">/*****************************************************************
 * Executive routines.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prefork_run</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>_pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>remaining_children_to_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_log_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>ap_run_pre_mpm</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>SB_SHARED</name></expr></argument>)</argument_list></call> != <name>OK</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
            <return>return <expr>!<name>OK</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* fix the generation number in the global score; we just got a new,
         * cleared scoreboard
         */</comment>
        <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_fatal_signal_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ap_unixd_mpm_set_signals</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>one_process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>AP_MONCONTROL</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* NOTREACHED */</comment>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<name>OK</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Don't thrash since num_buckets depends on the
     * system and the number of online CPU cores...
     */</comment>
    <if>if <condition>(<expr><name>ap_daemons_limit</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>ap_daemons_limit</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>ap_daemons_to_start</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>ap_daemons_to_start</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>ap_daemons_min_free</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>ap_daemons_min_free</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>ap_daemons_max_free</name> &lt; <name>ap_daemons_min_free</name> + <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>ap_daemons_max_free</name> = <name>ap_daemons_min_free</name> + <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</expr_stmt></then></if>

    <comment type="block">/* If we're doing a graceful_restart then we're going to see a lot
     * of children exiting immediately when we get into the main loop
     * below (because we just sent them AP_SIG_GRACEFUL).  This happens pretty
     * rapidly... and for each one that exits we'll start a new one until
     * we reach at least daemons_min_free.  But we may be permitted to
     * start more than that, so we'll just keep track of how many we're
     * supposed to start up without the 1 second penalty between each fork.
     */</comment>
    <expr_stmt><expr><name>remaining_children_to_start</name> = <name>ap_daemons_to_start</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>remaining_children_to_start</name> &gt; <name>ap_daemons_limit</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>remaining_children_to_start</name> = <name>ap_daemons_limit</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>startup_children</name><argument_list>(<argument><expr><name>remaining_children_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remaining_children_to_start</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* give the system some time to recover before kicking into
         * exponential mode
         */</comment>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name> = 10</expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00163</expr></argument>)</argument_list></call>
                "%s configured -- resuming normal operations"</expr></argument>,
                <argument><expr><call><name>ap_get_server_description</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00164</expr></argument>)</argument_list></call>
                "Server built: %s"</expr></argument>, <argument><expr><call><name>ap_get_server_built</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_command_line</name><argument_list>(<argument><expr><name>plog</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_mpm_common</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00165</expr></argument>)</argument_list></call>
                "Accept mutex: %s (default: %s)"</expr></argument>,
                <argument><expr>(<name><name>all_buckets</name><index>[<expr>0</expr>]</index></name>.<name>mutex</name>)
                    ? <call><name>apr_proc_mutex_name</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr>0</expr>]</index></name>.<name>mutex</name></expr></argument>)</argument_list></call>
                    : "none"</expr></argument>,
                <argument><expr><call><name>apr_proc_mutex_defname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_RUNNING</name></expr>;</expr_stmt>

    <while>while <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>restart_pending</name></name> &amp;&amp; !<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>child_slot</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_exit_why_e</name></type> <name>exitwhy</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>processed_status</name></decl>;</decl_stmt>
        <comment type="block">/* this is a memory leak, but I'll fix it later. */</comment>
        <decl_stmt><decl><type><name>apr_proc_t</name></type> <name>pid</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ap_wait_or_timeout</name><argument_list>(<argument><expr>&amp;<name>exitwhy</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* XXX: if it takes longer than 1 second for all our children
         * to start up and get into IDLE state then we may spawn an
         * extra child
         */</comment>
        <if>if <condition>(<expr><name><name>pid</name>.<name>pid</name></name> != -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>processed_status</name> = <call><name>ap_process_child_status</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>exitwhy</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>child_slot</name> = <call><name>ap_find_child_by_pid</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDFATAL</name></expr>)</condition><then> <block>{
                <comment type="block">/* fix race condition found in PR 39311
                 * A child created at the same time as a graceful happens 
                 * can find the lock missing and create a fatal error.
                 * It is not fatal for the last generation to be in this state.
                 */</comment>
                <if>if <condition>(<expr><name>child_slot</name> &lt; 0
                    || <call><name>ap_get_scoreboard_process</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>)</argument_list></call>-&gt;<name>generation</name>
                       == <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
                    <return>return <expr>!<name>OK</name></expr>;</return>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00166</expr></argument>)</argument_list></call>
                                 "Ignoring fatal error in child of previous "
                                 "generation (pid %ld)."</expr></argument>,
                                 <argument><expr>(<name>long</name>)<name><name>pid</name>.<name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>

            <comment type="block">/* non-fatal death... note that it's gone in the scoreboard. */</comment>
            <if>if <condition>(<expr><name>child_slot</name> &gt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr>(<name>void</name>) <call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SERVER_DEAD</name></expr></argument>,
                                                           <argument><expr>(<name>request_rec</name> *) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>prefork_note_child_killed</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDSICK</name></expr>)</condition><then> <block>{
                    <comment type="block">/* child detected a resource shortage (E[NM]FILE, ENOBUFS, etc)
                     * cut the fork rate to the minimum
                     */</comment>
                    <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> = 1</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>remaining_children_to_start</name>
                    &amp;&amp; <name>child_slot</name> &lt; <name>ap_daemons_limit</name></expr>)</condition><then> <block>{
                    <comment type="block">/* we're still doing a 1-for-1 replacement of dead
                     * children with new children
                     */</comment>
                    <expr_stmt><expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>child_slot</name></expr></argument>,
                               <argument><expr><call><name>ap_get_scoreboard_process</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>)</argument_list></call>-&gt;<name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr>--<name>remaining_children_to_start</name></expr>;</expr_stmt>
                }</block></then></if></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_OTHER_CHILD</name></expr></cpp:if>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>apr_proc_other_child_alert</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>APR_OC_REASON_DEATH</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <comment type="block">/* handled */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* Great, we've probably just lost a slot in the
                 * scoreboard.  Somehow we don't know about this
                 * child.
                 */</comment>
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>,
                            <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00167</expr></argument>)</argument_list></call>
                            "long lost child came home! (pid %ld)"</expr></argument>, <argument><expr>(<name>long</name>)<name><name>pid</name>.<name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if></else></if>
            <comment type="block">/* Don't perform idle maintenance when a child dies,
             * only do it when there's a timeout.  Remember only a
             * finite number of children can die, and it's pretty
             * pathological for a lot to die suddenly.
             */</comment>
            <continue>continue;</continue>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>remaining_children_to_start</name></expr>)</condition><then> <block>{
            <comment type="block">/* we hit a 1 second timeout in which none of the previous
             * generation of children needed to be reaped... so assume
             * they're all done, and pick up the slack if any is left.
             */</comment>
            <expr_stmt><expr><call><name>startup_children</name><argument_list>(<argument><expr><name>remaining_children_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining_children_to_start</name> = 0</expr>;</expr_stmt>
            <comment type="block">/* In any event we really shouldn't do the code below because
             * few of the servers we just started are in the IDLE state
             * yet, so we'd mistakenly create an extra server.
             */</comment>
            <continue>continue;</continue>
        }</block></then></if></else></if>

        <expr_stmt><expr><call><name>perform_idle_server_maintenance</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> &amp;&amp; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>is_ungraceful</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Time to shut down:
         * Kill child processes, tell them to call child_exit, etc...
         */</comment>
        <if>if <condition>(<expr><call><name>ap_unixd_killpg</name><argument_list>(<argument><expr><call><name>getpgrp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00168</expr></argument>)</argument_list></call> "killpg SIGTERM"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>ap_reclaim_child_processes</name><argument_list>(<argument><expr>1</expr></argument>, <comment type="block">/* Start with SIGTERM */</comment>
                                   <argument><expr><name>prefork_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* cleanup pid file on normal shutdown */</comment>
        <expr_stmt><expr><call><name>ap_remove_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00169</expr></argument>)</argument_list></call>
                    "caught SIGTERM, shutting down"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>DONE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Time to perform a graceful shut down:
         * Reap the inactive children, and ask the active ones
         * to close their listeners, then wait until they are
         * all done to exit.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>active_children</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_time_t</name></type> <name>cutoff</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <comment type="block">/* Stop listening */</comment>
        <expr_stmt><expr><call><name>ap_close_listeners</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* kill off the idle ones */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>ap_mpm_pod_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/* Send SIGUSR1 to the active children */</comment>
        <expr_stmt><expr><name>active_children</name> = 0</expr>;</expr_stmt>
        <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>index</name></expr>]</index><index>[<expr>0</expr>]</index></name>.<name>status</name> != <name>SERVER_DEAD</name></expr>)</condition><then> <block>{
                <comment type="block">/* Ask each child to close its listeners. */</comment>
                <expr_stmt><expr><call><name>ap_mpm_safe_kill</name><argument_list>(<argument><expr><call><name>MPM_CHILD_PID</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AP_SIG_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>active_children</name>++</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <comment type="block">/* Allow each child which actually finished to exit */</comment>
        <expr_stmt><expr><call><name>ap_relieve_child_processes</name><argument_list>(<argument><expr><name>prefork_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* cleanup pid file */</comment>
        <expr_stmt><expr><call><name>ap_remove_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00170</expr></argument>)</argument_list></call>
           "caught " <name>AP_SIG_GRACEFUL_STOP_STRING</name> ", shutting down gracefully"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>ap_graceful_shutdown_timeout</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cutoff</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call> +
                     <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>ap_graceful_shutdown_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Don't really exit until each child has finished */</comment>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> = 0</expr>;</expr_stmt>
        <do>do <block>{
            <comment type="block">/* Pause for a second */</comment>
            <expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Relieve any children which have now exited */</comment>
            <expr_stmt><expr><call><name>ap_relieve_child_processes</name><argument_list>(<argument><expr><name>prefork_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>active_children</name> = 0</expr>;</expr_stmt>
            <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
                <if>if <condition>(<expr><call><name>ap_mpm_safe_kill</name><argument_list>(<argument><expr><call><name>MPM_CHILD_PID</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>active_children</name> = 1</expr>;</expr_stmt>
                    <comment type="block">/* Having just one child is enough to stay around */</comment>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block> while <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> &amp;&amp; <name>active_children</name> &amp;&amp;
                 (!<name>ap_graceful_shutdown_timeout</name> || <call><name>apr_time_now</name><argument_list>()</argument_list></call> &lt; <name>cutoff</name>)</expr>)</condition>;</do>

        <comment type="block">/* We might be here because we received SIGTERM, either
         * way, try and make sure that all of our processes are
         * really dead.
         */</comment>
        <expr_stmt><expr><call><name>ap_unixd_killpg</name><argument_list>(<argument><expr><call><name>getpgrp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>DONE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* we've been told to restart */</comment>
    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <comment type="block">/* not worth thinking about */</comment>
        <return>return <expr><name>DONE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* advance to the next generation */</comment>
    <comment type="block">/* XXX: we really need to make sure this new generation number isn't in
     * use by any of the children.
     */</comment>
    <expr_stmt><expr>++<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>is_ungraceful</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00171</expr></argument>)</argument_list></call>
                    "Graceful restart requested, doing restart"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* kill off the idle ones */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>ap_mpm_pod_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/* This is mostly for debugging... so that we know what is still
         * gracefully dealing with existing request.  This will break
         * in a very nasty way if we ever have the scoreboard totally
         * file-based (no shared memory)
         */</comment>
        <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>index</name></expr>]</index><index>[<expr>0</expr>]</index></name>.<name>status</name> != <name>SERVER_DEAD</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>index</name></expr>]</index><index>[<expr>0</expr>]</index></name>.<name>status</name> = <name>SERVER_GRACEFUL</name></expr>;</expr_stmt>
                <comment type="block">/* Ask each child to close its listeners.
                 *
                 * NOTE: we use the scoreboard, because if we send SIGUSR1
                 * to every process in the group, this may include CGI's,
                 * piped loggers, etc. They almost certainly won't handle
                 * it gracefully.
                 */</comment>
                <expr_stmt><expr><call><name>ap_mpm_safe_kill</name><argument_list>(<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>index</name></expr>]</index></name>.<name>pid</name></expr></argument>, <argument><expr><name>AP_SIG_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* Kill 'em off */</comment>
        <if>if <condition>(<expr><call><name>ap_unixd_killpg</name><argument_list>(<argument><expr><call><name>getpgrp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00172</expr></argument>)</argument_list></call> "killpg SIGHUP"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>ap_reclaim_child_processes</name><argument_list>(<argument><expr>0</expr></argument>, <comment type="block">/* Not when just starting up */</comment>
                                   <argument><expr><name>prefork_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00173</expr></argument>)</argument_list></call>
                    "SIGHUP received.  Attempting to restart"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/* This really should be a post_config hook, but the error log is already
 * redirected by that point, so we need to do this in the open_logs phase.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>prefork_open_logs</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>startup</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level_flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> **</type><name>listen_buckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>id</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pconf</name> = <name>p</name></expr>;</expr_stmt>

    <comment type="block">/* the reverse of pre_config, we want this only the first time around */</comment>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>startup</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>level_flags</name> |= <name>APLOG_STARTUP</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>num_listensocks</name> = <call><name>ap_setup_listeners</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call>) &lt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name> | <name>level_flags</name></expr></argument>, <argument><expr>0</expr></argument>,
                     <argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
                     <argument><expr>"no listening sockets available, shutting down"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<name>OK</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Preserve the number of buckets on graceful restarts. */</comment>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> = 0</expr>;</expr_stmt>
    }</block></then></if></else></if>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>ap_duplicate_listeners</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                                     <argument><expr>&amp;<name>listen_buckets</name></expr></argument>, <argument><expr>&amp;<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                     <argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
                     <argument><expr>"could not duplicate listeners"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<name>OK</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>all_buckets</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> *
                                     <sizeof>sizeof<argument_list>(<argument><expr><name>prefork_child_bucket</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr>(<name>rv</name> = <call><name>ap_mpm_pod_open</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr>&amp;<name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                         <argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
                         <argument><expr>"could not open pipe-of-death"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>!<name>OK</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* Initialize cross-process accept lock (safe accept needed only) */</comment>
        <if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr>(<call><name>apr_snprintf</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr>sizeof <name>id</name></expr></argument>, <argument><expr>"%i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>,
                               <call><name>ap_proc_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mutex</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AP_ACCEPT_MUTEX_TYPE</name></expr></argument>,
                                                    <argument><expr><name>id</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                         <argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
                         <argument><expr>"could not create accept mutex"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>!<name>OK</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>listeners</name> = <name><name>listen_buckets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prefork_pre_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>no_detach</name></decl>, <decl><type ref="prev"/><name>debug</name></decl>, <decl><type ref="prev"/><name>foreground</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>userdata_key</name> <init>= <expr>"mpm_prefork_module"</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>debug</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"DEBUG"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>debug</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>foreground</name> = <name>one_process</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>no_detach</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else
    <block>{
        <expr_stmt><expr><name>no_detach</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"NO_DETACH"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>one_process</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"ONE_PROCESS"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>foreground</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"FOREGROUND"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>ap_mutex_register</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>AP_ACCEPT_MUTEX_TYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_LOCK_DEFAULT</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retained</name> = <call><name>ap_retained_data_get</name><argument_list>(<argument><expr><name>userdata_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>retained</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>retained</name> = <call><name>ap_retained_data_create</name><argument_list>(<argument><expr><name>userdata_key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>retained</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name></name> = <call><name>ap_unixd_mpm_get_retained_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = -1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STARTING</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>baton</name></name> != <name>retained</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>baton</name></name> = <name>retained</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>++<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name></expr>;</expr_stmt>

    <comment type="block">/* sigh, want this only the second time around */</comment>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 2</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>one_process</name> &amp;&amp; !<name>foreground</name></expr>)</condition><then> <block>{
            <comment type="block">/* before we detach, setup crash handlers to log to errorlog */</comment>
            <expr_stmt><expr><call><name>ap_fatal_signal_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>apr_proc_detach</name><argument_list>(<argument><expr><name>no_detach</name> ? <name>APR_PROC_DETACH_FOREGROUND</name>
                                           : <name>APR_PROC_DETACH_DAEMONIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00174</expr></argument>)</argument_list></call>
                             "apr_proc_detach failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>parent_pid</name> = <name>ap_my_pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_listen_pre_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_daemons_to_start</name> = <name>DEFAULT_START_DAEMON</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_daemons_min_free</name> = <name>DEFAULT_MIN_FREE_DAEMON</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_daemons_max_free</name> = <name>DEFAULT_MAX_FREE_DAEMON</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>server_limit</name> = <name>DEFAULT_SERVER_LIMIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_daemons_limit</name> = <name>server_limit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_extended_status</name> = 0</expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prefork_check_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>startup</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* the reverse of pre_config, we want this only the first time around */</comment>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>startup</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>server_limit</name> &gt; <name>MAX_SERVER_LIMIT</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00175</expr></argument>)</argument_list></call>
                         "WARNING: ServerLimit of %d exceeds compile-time "
                         "limit of %d servers, decreasing to %d."</expr></argument>,
                         <argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00176</expr></argument>)</argument_list></call>
                         "ServerLimit of %d exceeds compile-time limit "
                         "of %d, decreasing to match"</expr></argument>,
                         <argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>server_limit</name> = <name>MAX_SERVER_LIMIT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>server_limit</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00177</expr></argument>)</argument_list></call>
                         "WARNING: ServerLimit of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00178</expr></argument>)</argument_list></call>
                         "ServerLimit of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>server_limit</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <comment type="block">/* you cannot change ServerLimit across a restart; ignore
     * any such attempts
     */</comment>
    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>first_server_limit</name></name> = <name>server_limit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>server_limit</name> != <name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* don't need a startup console version here */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00179</expr></argument>)</argument_list></call>
                     "changing ServerLimit to %d from original value of %d "
                     "not allowed during restart"</expr></argument>,
                     <argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>server_limit</name> = <name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name>ap_daemons_limit</name> &gt; <name>server_limit</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00180</expr></argument>)</argument_list></call>
                         "WARNING: MaxRequestWorkers of %d exceeds ServerLimit "
                         "value of %d servers, decreasing MaxRequestWorkers to %d. "
                         "To increase, please see the ServerLimit directive."</expr></argument>,
                         <argument><expr><name>ap_daemons_limit</name></expr></argument>, <argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00181</expr></argument>)</argument_list></call>
                         "MaxRequestWorkers of %d exceeds ServerLimit value "
                         "of %d, decreasing to match"</expr></argument>,
                         <argument><expr><name>ap_daemons_limit</name></expr></argument>, <argument><expr><name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>ap_daemons_limit</name> = <name>server_limit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>ap_daemons_limit</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00182</expr></argument>)</argument_list></call>
                         "WARNING: MaxRequestWorkers of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00183</expr></argument>)</argument_list></call>
                         "MaxRequestWorkers of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>ap_daemons_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>ap_daemons_limit</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <comment type="block">/* ap_daemons_to_start &gt; ap_daemons_limit checked in prefork_run() */</comment>
    <if>if <condition>(<expr><name>ap_daemons_to_start</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00184</expr></argument>)</argument_list></call>
                         "WARNING: StartServers of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>ap_daemons_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00185</expr></argument>)</argument_list></call>
                         "StartServers of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>ap_daemons_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>ap_daemons_to_start</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>ap_daemons_min_free</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00186</expr></argument>)</argument_list></call>
                         "WARNING: MinSpareServers of %d not allowed, "
                         "increasing to 1 to avoid almost certain server failure. "
                         "Please read the documentation."</expr></argument>, <argument><expr><name>ap_daemons_min_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00187</expr></argument>)</argument_list></call>
                         "MinSpareServers of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>ap_daemons_min_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>ap_daemons_min_free</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* ap_daemons_max_free &lt; ap_daemons_min_free + 1 checked in prefork_run() */</comment>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>prefork_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Our open_logs hook function must run before the core's, or stderr
     * will be redirected to a file, and the messages won't print to the
     * console.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name><name>aszSucc</name><index>[]</index></name> <init>= <expr><block>{<expr>"core.c"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_hook_open_logs</name><argument_list>(<argument><expr><name>prefork_open_logs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>aszSucc</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* we need to set the MPM state before other pre-config hooks use MPM query
     * to retrieve it, so register as REALLY_FIRST
     */</comment>
    <expr_stmt><expr><call><name>ap_hook_pre_config</name><argument_list>(<argument><expr><name>prefork_pre_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_check_config</name><argument_list>(<argument><expr><name>prefork_check_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm</name><argument_list>(<argument><expr><name>prefork_run</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm_query</name><argument_list>(<argument><expr><name>prefork_query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm_get_name</name><argument_list>(<argument><expr><name>prefork_get_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_daemons_to_start</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ap_daemons_to_start</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_min_free_servers</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ap_daemons_min_free</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_max_free_servers</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ap_daemons_max_free</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_max_clients</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"MaxClients"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00188</expr></argument>)</argument_list></call>
                     "MaxClients is deprecated, use MaxRequestWorkers "
                     "instead."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>ap_daemons_limit</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_server_limit</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>server_limit</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>prefork_cmds</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>LISTEN_COMMANDS</name></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"StartServers"</expr></argument>, <argument><expr><name>set_daemons_to_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
              <argument><expr>"Number of child processes launched at server startup"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MinSpareServers"</expr></argument>, <argument><expr><name>set_min_free_servers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
              <argument><expr>"Minimum number of idle children, to handle request spikes"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxSpareServers"</expr></argument>, <argument><expr><name>set_max_free_servers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
              <argument><expr>"Maximum number of idle children"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxClients"</expr></argument>, <argument><expr><name>set_max_clients</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
              <argument><expr>"Deprecated name of MaxRequestWorkers"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxRequestWorkers"</expr></argument>, <argument><expr><name>set_max_clients</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
              <argument><expr>"Maximum number of children alive at the same time"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ServerLimit"</expr></argument>, <argument><expr><name>set_server_limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
              <argument><expr>"Maximum value of MaxRequestWorkers for this run of Apache"</expr></argument>)</argument_list></call></expr>,
<expr><name>AP_GRACEFUL_SHUTDOWN_TIMEOUT_COMMAND</name></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>mpm_prefork</name></expr></argument>)</argument_list></call> = <block>{
    <expr><name>MPM20_MODULE_STUFF</name></expr>,
    <expr><name>NULL</name></expr>,                       <comment type="block">/* hook to run before apache parses args */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* create per-directory config structure */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* merge per-directory config structures */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* create per-server config structure */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* merge per-server config structures */</comment>
    <expr><name>prefork_cmds</name></expr>,               <comment type="block">/* command apr_table_t */</comment>
    <expr><name>prefork_hooks</name></expr>,              <comment type="block">/* register hooks */</comment>
}</block></expr>;</expr_stmt></block></function>
</unit>
