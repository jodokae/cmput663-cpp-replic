<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/mpm/worker/worker.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/* The purpose of this MPM is to fix the design flaws in the threaded
 * model.  Because of the way that pthreads and mutex locks interact,
 * it is basically impossible to cleanly gracefully shutdown a child
 * process if multiple threads are all blocked in accept.  This model
 * fixes those problems.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_portable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_file_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_signal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_proc_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_poll.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_SYS_SOCKET_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_SYS_WAIT_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_PROCESSOR_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/processor.h&gt;</cpp:file></cpp:include> <comment type="block">/* for bindprocessor() */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<name>APR_HAS_THREADS</name></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> The Worker MPM requires APR threads, but they are unavailable.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>        <comment type="block">/* for read_config */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>          <comment type="block">/* for get_remote_host */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_listen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fdqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_default.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unixd.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>             <comment type="block">/* for INT_MAX */</comment>

<comment type="block">/* Limit on the total --- clients will be locked out if more servers than
 * this are needed.  It is intended solely to keep the server from crashing
 * when things get out of hand.
 *
 * We keep a hard maximum number of servers, for two reasons --- first off,
 * in case something goes seriously wrong, we want to stop the fork bomb
 * short of actually crashing the machine we're running on by filling some
 * kernel table.  Secondly, it keeps the size of the scoreboard file small
 * enough that we can read the whole thing without worrying too much about
 * the overhead.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_SERVER_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SERVER_LIMIT</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Admin can't tune ServerLimit beyond MAX_SERVER_LIMIT.  We want
 * some sort of compile-time limit to help catch typos.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX_SERVER_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SERVER_LIMIT</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Limit on the threads per process.  Clients will be locked out if more than
 * this  * server_limit are needed.
 *
 * We keep this for one reason it keeps the size of the scoreboard file small
 * enough that we can read the whole thing without worrying too much about
 * the overhead.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_THREAD_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_THREAD_LIMIT</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Admin can't tune ThreadLimit beyond MAX_THREAD_LIMIT.  We want
 * some sort of compile-time limit to help catch typos.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX_THREAD_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_THREAD_LIMIT</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Actual definitions of config globals
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>threads_per_child</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>     <comment type="block">/* Worker threads per child */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ap_daemons_to_start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>min_spare_threads</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_spare_threads</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ap_daemons_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>max_workers</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>server_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>thread_limit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>had_healthy_child</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dying</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>workers_may_exit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>start_thread_may_exit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>listener_may_exit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>requests_this_child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>num_listensocks</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>resource_shortage</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fd_queue_t</name> *</type><name>worker_queue</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>fd_queue_info_t</name> *</type><name>worker_queue_info</name></decl>;</decl_stmt>

<comment type="block">/* data retained by worker across load/unload of the module
 * allocated on first call to pre-config hook; located on
 * subsequent calls to pre-config hook
 */</comment>
<typedef>typedef <type><struct>struct <name>worker_retained_data</name> <block>{
    <decl_stmt><decl><type><name>ap_unixd_mpm_retained_data</name> *</type><name>mpm</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>first_server_limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>first_thread_limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sick_child_detected</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>maxclients_reported</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>near_maxclients_reported</name></decl>;</decl_stmt>
    <comment type="block">/*
     * The max child slot ever assigned, preserved across restarts.  Necessary
     * to deal with MaxRequestWorkers changes across AP_SIG_GRACEFUL restarts.
     * We use this value to optimize routines that have to scan the entire
     * scoreboard.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_daemons_limit</name></decl>;</decl_stmt>
    <comment type="block">/*
     * idle_spawn_rate is the number of children that will be spawned on the
     * next maintenance cycle if there aren't enough idle servers.  It is
     * maintained per listeners bucket, doubled up to MAX_SPAWN_RATE, and
     * reset only when a cycle goes by without the need to spawn.
     */</comment>
    <decl_stmt><decl><type><name>int</name> *</type><name>idle_spawn_rate</name></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX_SPAWN_RATE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SPAWN_RATE</name></cpp:macro>        <cpp:value>(32)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>hold_off_on_exponential_spawning</name></decl>;</decl_stmt>
}</block></struct></type> <name>worker_retained_data</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>worker_retained_data</name> *</type><name>retained</name></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>worker_child_bucket</name> <block>{
    <decl_stmt><decl><type><name>ap_pod_t</name> *</type><name>pod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>listeners</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_proc_mutex_t</name> *</type><name>mutex</name></decl>;</decl_stmt>
}</block></struct></type> <name>worker_child_bucket</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>worker_child_bucket</name> *</type><name>all_buckets</name></decl>, <comment type="block">/* All listeners buckets */</comment>
                           *<decl><type ref="prev"/><name>my_bucket</name></decl>;</decl_stmt>   <comment type="block">/* Current child bucket */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MPM_CHILD_PID</name><parameter_list>(<param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(ap_scoreboard_image-&gt;parent[i].pid)</cpp:value></cpp:define>

<comment type="block">/* The structure used to pass unique initialization info to each thread */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sd</name></decl>;</decl_stmt>
}</block></struct></type> <name>proc_info</name>;</typedef>

<comment type="block">/* Structure used to pass information to the thread responsible for
 * creating the rest of the threads.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_thread_t</name> **</type><name>threads</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_thread_t</name> *</type><name>listener</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>child_num_arg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_threadattr_t</name> *</type><name>threadattr</name></decl>;</decl_stmt>
}</block></struct></type> <name>thread_starter</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ID_FROM_CHILD_THREAD</name><parameter_list>(<param><type><name>c</name></type></param>, <param><type><name>t</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>((c * thread_limit) + t)</cpp:value></cpp:define>

<comment type="block">/* The worker MPM respects a couple of runtime flags that can aid
 * in debugging. Setting the -DNO_DETACH flag will prevent the root process
 * from detaching from its controlling terminal. Additionally, setting
 * the -DONE_PROCESS flag (which implies -DNO_DETACH) will get you the
 * child_main loop running in the process which originally started up.
 * This gives you a pretty nice debugging environment.  (You'll get a SIGHUP
 * early in standalone_main; just continue through.  This is the server
 * trying to kill off any child processes which it might have lying
 * around --- Apache doesn't keep track of their pids, it just sends
 * SIGHUP to the process group, ignoring it in the root process.
 * Continue through and you'll be fine.).
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>one_process</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_SIGSTOP</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>raise_sigstop_flags</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>apr_pool_t</name> *</type><name>pconf</name></decl>;</decl_stmt>                 <comment type="block">/* Pool for config stuff */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_pool_t</name> *</type><name>pchild</name></decl>;</decl_stmt>                <comment type="block">/* Pool for httpd child stuff */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>ap_my_pid</name></decl>;</decl_stmt> <comment type="block">/* Linux getpid() doesn't work except in main
                           thread. Use this instead */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>parent_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_os_thread_t</name> *</type><name>listener_os_thread</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SINGLE_LISTEN_UNSERIALIZED_ACCEPT</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAFE_ACCEPT</name><parameter_list>(<param><type><name>stmt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(ap_listeners-&gt;next ? (stmt) : APR_SUCCESS)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAFE_ACCEPT</name><parameter_list>(<param><type><name>stmt</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(stmt)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The LISTENER_SIGNAL signal will be sent from the main thread to the
 * listener thread to wake it up for graceful termination (what a child
 * process from an old generation does when the admin does "apachectl
 * graceful").  This signal will be blocked in all threads of a child
 * process except for the listener thread.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LISTENER_SIGNAL</name></cpp:macro>     <cpp:value>SIGHUP</cpp:value></cpp:define>

<comment type="block">/* The WORKER_SIGNAL signal will be sent from the main thread to the
 * worker threads during an ungraceful restart or shutdown.
 * This ensures that on systems (i.e., Linux) where closing the worker
 * socket doesn't awake the worker thread when it is polling on the socket
 * (especially in apr_wait_for_io_or_timeout() when handling
 * Keep-Alive connections), close_worker_sockets() and join_workers()
 * still function in timely manner and allow ungraceful shutdowns to
 * proceed to completion.  Otherwise join_workers() doesn't return
 * before the main process decides the child process is non-responsive
 * and sends a SIGKILL.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WORKER_SIGNAL</name></cpp:macro>       <cpp:value>AP_SIG_GRACEFUL</cpp:value></cpp:define>

<comment type="block">/* An array of socket descriptors in use by each thread used to
 * perform a non-graceful (forced) shutdown of the server. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_socket_t</name> **</type><name>worker_sockets</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>close_worker_sockets</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>worker_sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name><name>worker_sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>worker_sockets</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>wakeup_listener</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>listener_may_exit</name> = 1</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>listener_os_thread</name></expr>)</condition><then> <block>{
        <comment type="block">/* XXX there is an obscure path that this doesn't handle perfectly:
         *     right after listener thread is created but before
         *     listener_os_thread is set, the first worker thread hits an
         *     error and starts graceful termination
         */</comment>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* unblock the listener if it's waiting for a worker */</comment>
    <expr_stmt><expr><call><name>ap_queue_info_term</name><argument_list>(<argument><expr><name>worker_queue_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * we should just be able to "kill(ap_my_pid, LISTENER_SIGNAL)" on all
     * platforms and wake up the listener thread since it is the only thread
     * with SIGHUP unblocked, but that doesn't work on Linux
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_KILL</name></cpp:ifdef>
    <expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr>*<name>listener_os_thread</name></expr></argument>, <argument><expr><name>LISTENER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>ap_my_pid</name></expr></argument>, <argument><expr><name>LISTENER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_INIT</name></cpp:macro>              <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_GRACEFUL</name></cpp:macro>          <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ST_UNGRACEFUL</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>terminate_mode</name> <init>= <expr><name>ST_INIT</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>signal_threads</name><parameter_list>(<param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>terminate_mode</name> == <name>mode</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><name>terminate_mode</name> = <name>mode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>

    <comment type="block">/* in case we weren't called from the listener thread, wake up the
     * listener thread
     */</comment>
    <expr_stmt><expr><call><name>wakeup_listener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* for ungraceful termination, let the workers exit now;
     * for graceful termination, the listener thread will notify the
     * workers to exit once it has stopped accepting new connections
     */</comment>
    <if>if <condition>(<expr><name>mode</name> == <name>ST_UNGRACEFUL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>workers_may_exit</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_queue_interrupt_all</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>close_worker_sockets</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* forcefully kill all current connections */</comment>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_query</name><parameter_list>(<param><decl><type><name>int</name></type> <name>query_code</name></decl></param>, <param><decl><type><name>int</name> *</type><name>result</name></decl></param>, <param><decl><type><name>apr_status_t</name> *</type><name>rv</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>*<name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>query_code</name></expr>)</condition> <block>{
        <case>case <expr><name>AP_MPMQ_MAX_DAEMON_USED</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name><name>retained</name>-&gt;<name>max_daemons_limit</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_IS_THREADED</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>AP_MPMQ_STATIC</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_IS_FORKED</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>AP_MPMQ_DYNAMIC</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_HARD_LIMIT_DAEMONS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>server_limit</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_HARD_LIMIT_THREADS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>thread_limit</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_THREADS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>threads_per_child</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MIN_SPARE_DAEMONS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MIN_SPARE_THREADS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>min_spare_threads</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_SPARE_DAEMONS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_SPARE_THREADS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>max_spare_threads</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_REQUESTS_DAEMON</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>ap_max_requests_per_child</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MAX_DAEMONS</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name>ap_daemons_limit</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_MPM_STATE</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPMQ_GENERATION</name></expr>:
            <expr_stmt><expr>*<name>result</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <expr_stmt><expr>*<name>rv</name> = <name>APR_ENOTIMPL</name></expr>;</expr_stmt>
            <break>break;</break>
    </default>}</block></switch>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>worker_note_child_killed</name><parameter_list>(<param><decl><type><name>int</name></type> <name>childnum</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>, <param><decl><type><name>ap_generation_t</name></type> <name>gen</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>childnum</name> != -1</expr>)</condition><then> <block>{ <comment type="block">/* child had a scoreboard slot? */</comment>
        <expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
                            <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                            <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>generation</name></expr></argument>,
                            <argument><expr><name>childnum</name></expr></argument>, <argument><expr><name>MPM_CHILD_EXITED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>childnum</name></expr>]</index></name>.<name>pid</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>gen</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>MPM_CHILD_EXITED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>worker_note_child_started</name><parameter_list>(<param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name> = <name>pid</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                        <argument><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MPM_CHILD_STARTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>worker_note_child_lost_slot</name><parameter_list>(<param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>newpid</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00263</expr></argument>)</argument_list></call>
                 "pid %" <name>APR_PID_T_FMT</name> " taking over scoreboard slot from "
                 "%" <name>APR_PID_T_FMT</name> "%s"</expr></argument>,
                 <argument><expr><name>newpid</name></expr></argument>,
                 <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                 <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>quiescing</name> ?
                 " (quiescing)" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_run_child_status</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                        <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>generation</name></expr></argument>,
                        <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>MPM_CHILD_LOST_SLOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Don't forget about this exiting child process, or we
     * won't be able to kill it if it doesn't exit by the
     * time the server is shut down.
     */</comment>
    <expr_stmt><expr><call><name>ap_register_extra_mpm_process</name><argument_list>(<argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name></expr></argument>,
                                  <argument><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>generation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>worker_get_name</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <return>return <expr>"worker"</expr>;</return>
}</block></function>

<comment type="block">/* a clean exit from a child with proper cleanup */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clean_child_exit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list> __attribute__ <parameter_list>(<param/></parameter_list>(noreturn</function_decl>))<empty_stmt>;</empty_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>clean_child_exit</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pchild</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>worker_note_child_killed</name><argument_list>(<comment type="block">/* slot */</comment> <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>just_die</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*****************************************************************
 * Connection structures and accounting...
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>child_fatal</name></decl>;</decl_stmt>

<comment type="block">/*****************************************************************
 * Here follows a long bunch of generic server bookkeeping stuff...
 */</comment>

<comment type="block">/*****************************************************************
 * Child process main loop.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>process_socket</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>thd</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_socket_t</name> *</type><name>sock</name></decl></param>,
                           <param><decl><type><name>int</name></type> <name>my_child_num</name></decl></param>,
                           <param><decl><type><name>int</name></type> <name>my_thread_num</name></decl></param>, <param><decl><type><name>apr_bucket_alloc_t</name> *</type><name>bucket_alloc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>current_conn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>conn_id</name> <init>= <expr><call><name>ID_FROM_CHILD_THREAD</name><argument_list>(<argument><expr><name>my_child_num</name></expr></argument>, <argument><expr><name>my_thread_num</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_sb_handle_t</name> *</type><name>sbh</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_create_sb_handle</name><argument_list>(<argument><expr>&amp;<name>sbh</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>my_child_num</name></expr></argument>, <argument><expr><name>my_thread_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>current_conn</name> = <call><name>ap_run_create_connection</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>,
                                            <argument><expr><name>conn_id</name></expr></argument>, <argument><expr><name>sbh</name></expr></argument>, <argument><expr><name>bucket_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>current_conn</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>current_conn</name>-&gt;<name>current_thread</name></name> = <name>thd</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_process_connection</name><argument_list>(<argument><expr><name>current_conn</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_lingering_close</name><argument_list>(<argument><expr><name>current_conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* requests_this_child has gone to zero or below.  See if the admin coded
   "MaxConnectionsPerChild 0", and keep going in that case.  Doing it this way
   simplifies the hot path in worker_thread */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>check_infinite_requests</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>ap_max_requests_per_child</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>requests_this_child</name> = <name>INT_MAX</name></expr>;</expr_stmt>      <comment type="block">/* keep going */</comment>
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unblock_signal</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>sigset_t</name></type> <name>sig_mask</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr>&amp;<name>sig_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr>&amp;<name>sig_mask</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SIGPROCMASK_SETS_THREAD_MASK</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>sigprocmask</name><argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr>&amp;<name>sig_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_UNBLOCK</name></expr></argument>, <argument><expr>&amp;<name>sig_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dummy_signal_handler</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* XXX If specifying SIG_IGN is guaranteed to unblock a syscall,
     *     then we don't need this goofy function.
     */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>accept_mutex_error</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>func</name></decl></param>, <param><decl><type><name>apr_status_t</name></type> <name>rv</name></decl></param>, <param><decl><type><name>int</name></type> <name>process_slot</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><name>APLOG_EMERG</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>process_slot</name></expr>]</index></name>.<name>generation</name> !=
        <name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>level</name> = <name>APLOG_DEBUG</name></expr>;</expr_stmt> <comment type="block">/* common to get these at restart time */</comment>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>requests_this_child</name> == <name>INT_MAX</name>
        || ((<name>requests_this_child</name> == <name>ap_max_requests_per_child</name>)
            &amp;&amp; <name>ap_max_requests_per_child</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00272</expr></argument>)</argument_list></call>
                     "apr_proc_mutex_%s failed "
                     "before this child process served any requests."</expr></argument>,
                     <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00273</expr></argument>)</argument_list></call>
                 "apr_proc_mutex_%s failed. Attempting to "
                 "shutdown process gracefully."</expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> * <name>APR_THREAD_FUNC</name></type> <name>listener_thread</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>thd</name></decl></param>, <param><decl><type><name>void</name> *</type> <name>dummy</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>proc_info</name> *</type> <name>ti</name> <init>= <expr><name>dummy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>process_slot</name> <init>= <expr><name><name>ti</name>-&gt;<name>pid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>tpool</name> <init>= <expr><call><name>apr_thread_pool_get</name><argument_list>(<argument><expr><name>thd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>csd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>ptrans</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>            <comment type="block">/* Pool for per-transaction stuff */</comment>
    <decl_stmt><decl><type><name>apr_pollset_t</name> *</type><name>pollset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>lr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>have_idle_worker</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last_poll_idx</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_pollset_create</name><argument_list>(<argument><expr>&amp;<name>pollset</name></expr></argument>, <argument><expr><name>num_listensocks</name></expr></argument>, <argument><expr><name>tpool</name></expr></argument>,
                            <argument><expr><name>APR_POLLSET_NOCOPY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                     <argument><expr>"Couldn't create pollset in thread;"
                     " check system or user limits"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* let the parent decide how bad this really is */</comment>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <for>for (<init><expr><name>lr</name> = <name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr>;</init> <condition><expr><name>lr</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>lr</name> = <name><name>lr</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>apr_pollfd_t</name> *</type><name>pfd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>tpool</name></expr></argument>, <argument><expr>sizeof *<name>pfd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pfd</name>-&gt;<name>desc_type</name></name> = <name>APR_POLL_SOCKET</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfd</name>-&gt;<name>desc</name>.<name>s</name></name> = <name><name>lr</name>-&gt;<name>sd</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfd</name>-&gt;<name>reqevents</name></name> = <name>APR_POLLIN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pfd</name>-&gt;<name>client_data</name></name> = <name>lr</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>apr_pollset_add</name><argument_list>(<argument><expr><name>pollset</name></expr></argument>, <argument><expr><name>pfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                         <argument><expr>"Couldn't create add listener to pollset;"
                         " check system or user limits"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* let the parent decide how bad this really is */</comment>
            <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name><name>lr</name>-&gt;<name>accept_func</name></name> = <name>ap_unixd_accept</name></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* Unblock the signal used to wake this thread up, and set a handler for
     * it.
     */</comment>
    <expr_stmt><expr><call><name>unblock_signal</name><argument_list>(<argument><expr><name>LISTENER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>LISTENER_SIGNAL</name></expr></argument>, <argument><expr><name>dummy_signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* TODO: Switch to a system where threads reuse the results from earlier
       poll calls - manoj */</comment>
    <while>while <condition>(<expr>1</expr>)</condition> <block>{
        <comment type="block">/* TODO: requests_this_child should be synchronized - aaron */</comment>
        <if>if <condition>(<expr><name>requests_this_child</name> &lt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>check_infinite_requests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>listener_may_exit</name></expr>)</condition><then> <break>break;</break></then></if>

        <if>if <condition>(<expr>!<name>have_idle_worker</name></expr>)</condition><then> <block>{
            <comment type="block">/* the following pops a recycled ptrans pool off a stack
             * if there is one, in addition to reserving a worker thread
             */</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>ap_queue_info_wait_for_idler</name><argument_list>(<argument><expr><name>worker_queue_info</name></expr></argument>,
                                              <argument><expr>&amp;<name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break> <comment type="block">/* we've been signaled to die now */</comment>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                             <argument><expr>"apr_queue_info_wait failed. Attempting to "
                             " shutdown process gracefully."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if></else></if>
            <expr_stmt><expr><name>have_idle_worker</name> = 1</expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* We've already decremented the idle worker count inside
         * ap_queue_info_wait_for_idler. */</comment>

        <if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_lock</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
            != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{

            <if>if <condition>(<expr>!<name>listener_may_exit</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>accept_mutex_error</name><argument_list>(<argument><expr>"lock"</expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>process_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>                    <comment type="block">/* skip the lock release */</comment>
        }</block></then></if>

        <if>if <condition>(<expr>!<name><name>my_bucket</name>-&gt;<name>listeners</name>-&gt;<name>next</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* Only one listener, so skip the poll */</comment>
            <expr_stmt><expr><name>lr</name> = <name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <while>while <condition>(<expr>!<name>listener_may_exit</name></expr>)</condition> <block>{
                <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>numdesc</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>apr_pollfd_t</name> *</type><name>pdesc</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rv</name> = <call><name>apr_pollset_poll</name><argument_list>(<argument><expr><name>pollset</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr>&amp;<name>numdesc</name></expr></argument>, <argument><expr>&amp;<name>pdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <continue>continue;</continue>
                    }</block></then></if>

                    <comment type="block">/* apr_pollset_poll() will only return errors in catastrophic
                     * circumstances. Let's try exiting gracefully, for now. */</comment>
                    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03137</expr></argument>)</argument_list></call>
                                 "apr_pollset_poll: (listen)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <if>if <condition>(<expr><name>listener_may_exit</name></expr>)</condition><then> <break>break;</break></then></if>

                <comment type="block">/* We can always use pdesc[0], but sockets at position N
                 * could end up completely starved of attention in a very
                 * busy server. Therefore, we round-robin across the
                 * returned set of descriptors. While it is possible that
                 * the returned set of descriptors might flip around and
                 * continue to starve some sockets, we happen to know the
                 * internal pollset implementation retains ordering
                 * stability of the sockets. Thus, the round-robin should
                 * ensure that a socket will eventually be serviced.
                 */</comment>
                <if>if <condition>(<expr><name>last_poll_idx</name> &gt;= <name>numdesc</name></expr>)</condition><then>
                    <expr_stmt><expr><name>last_poll_idx</name> = 0</expr>;</expr_stmt></then></if>

                <comment type="block">/* Grab a listener record from the client_data of the poll
                 * descriptor, and advance our saved index to round-robin
                 * the next fetch.
                 *
                 * ### hmm... this descriptor might have POLLERR rather
                 * ### than POLLIN
                 */</comment>
                <expr_stmt><expr><name>lr</name> = <name><name>pdesc</name><index>[<expr><name>last_poll_idx</name>++</expr>]</index></name>.<name>client_data</name></expr>;</expr_stmt>
                <break>break;</break>

            }</block></while> <comment type="block">/* while */</comment>

        }</block></else></if> <comment type="block">/* if/else */</comment>

        <if>if <condition>(<expr>!<name>listener_may_exit</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>ptrans</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <comment type="block">/* we can't use a recycled transaction pool this time.
                 * create a new transaction pool */</comment>
                <decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>apr_allocator_create</name><argument_list>(<argument><expr>&amp;<name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_allocator_max_free_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>ap_max_mem_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_pool_create_ex</name><argument_list>(<argument><expr>&amp;<name>ptrans</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_allocator_owner_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>apr_pool_tag</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>, <argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name><name>lr</name>-&gt;<name>accept_func</name></name><argument_list>(<argument><expr>&amp;<name>csd</name></expr></argument>, <argument><expr><name>lr</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* later we trash rv and rely on csd to indicate success/failure */</comment>
            <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>rv</name> == <name>APR_SUCCESS</name> || !<name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>rv</name> == <name>APR_EGENERAL</name></expr>)</condition><then> <block>{
                <comment type="block">/* E[NM]FILE, ENOMEM, etc */</comment>
                <expr_stmt><expr><name>resource_shortage</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_unlock</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
                != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{

                <if>if <condition>(<expr><name>listener_may_exit</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><call><name>accept_mutex_error</name><argument_list>(<argument><expr>"unlock"</expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>process_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>csd</name> != <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>ap_queue_push</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>, <argument><expr><name>csd</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
                    <comment type="block">/* trash the connection; we couldn't queue the connected
                     * socket to a worker
                     */</comment>
                    <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>csd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03138</expr></argument>)</argument_list></call>
                                 "ap_queue_push failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><name>have_idle_worker</name> = 0</expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_unlock</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
                != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>level</name> <init>= <expr><name>APLOG_EMERG</name></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>process_slot</name></expr>]</index></name>.<name>generation</name> !=
                    <name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>level</name> = <name>APLOG_DEBUG</name></expr>;</expr_stmt> <comment type="block">/* common to get these at restart time */</comment>
                }</block></then></if>
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00274</expr></argument>)</argument_list></call>
                             "apr_proc_mutex_unlock failed. Attempting to "
                             "shutdown process gracefully."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
        }</block></else></if>
    }</block></while>

    <expr_stmt><expr><call><name>ap_close_listeners_ex</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>listeners</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_queue_term</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dying</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>process_slot</name></expr>]</index></name>.<name>quiescing</name> = 1</expr>;</expr_stmt>

    <comment type="block">/* wake up the main thread */</comment>
    <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>ap_my_pid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_thread_exit</name><argument_list>(<argument><expr><name>thd</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* XXX For ungraceful termination/restart, we definitely don't want to
 *     wait for active connections to finish but we may want to wait
 *     for idle workers to get out of the queue code and release mutexes,
 *     since those mutexes are cleaned up pretty soon and some systems
 *     may not react favorably (i.e., segfault) if operations are attempted
 *     on cleaned-up mutexes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> * <name>APR_THREAD_FUNC</name></type> <name>worker_thread</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>thd</name></decl></param>, <param><decl><type><name>void</name> *</type> <name>dummy</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>proc_info</name> *</type> <name>ti</name> <init>= <expr><name>dummy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>process_slot</name> <init>= <expr><name><name>ti</name>-&gt;<name>pid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>thread_slot</name> <init>= <expr><name><name>ti</name>-&gt;<name>tid</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>csd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_alloc_t</name> *</type><name>bucket_alloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>last_ptrans</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>ptrans</name></decl>;</decl_stmt>                <comment type="block">/* Pool for per-transaction stuff */</comment>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_idle</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>process_slot</name></expr>]</index><index>[<expr><name>thread_slot</name></expr>]</index></name>.<name>pid</name> = <name>ap_my_pid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>process_slot</name></expr>]</index><index>[<expr><name>thread_slot</name></expr>]</index></name>.<name>tid</name> = <call><name>apr_os_thread_current</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>process_slot</name></expr>]</index><index>[<expr><name>thread_slot</name></expr>]</index></name>.<name>generation</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>process_slot</name></expr></argument>, <argument><expr><name>thread_slot</name></expr></argument>,
                                        <argument><expr><name>SERVER_STARTING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_KILL</name></cpp:ifdef>
    <expr_stmt><expr><call><name>unblock_signal</name><argument_list>(<argument><expr><name>WORKER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>WORKER_SIGNAL</name></expr></argument>, <argument><expr><name>dummy_signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <while>while <condition>(<expr>!<name>workers_may_exit</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<name>is_idle</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>ap_queue_info_set_idle</name><argument_list>(<argument><expr><name>worker_queue_info</name></expr></argument>, <argument><expr><name>last_ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>last_ptrans</name> = <name>NULL</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                             <argument><expr>"ap_queue_info_set_idle failed. Attempting to "
                             "shutdown process gracefully."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>is_idle</name> = 1</expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>process_slot</name></expr></argument>, <argument><expr><name>thread_slot</name></expr></argument>,
                                            <argument><expr><name>SERVER_READY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>worker_pop</name>:</label>
        <if>if <condition>(<expr><name>workers_may_exit</name></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name>ap_queue_pop</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>, <argument><expr>&amp;<name>csd</name></expr></argument>, <argument><expr>&amp;<name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="block">/* We get APR_EOF during a graceful shutdown once all the connections
             * accepted by this server process have been handled.
             */</comment>
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then>
            <comment type="block">/* We get APR_EINTR whenever ap_queue_pop() has been interrupted
             * from an explicit call to ap_queue_interrupt_all(). This allows
             * us to unblock threads stuck in ap_queue_pop() when a shutdown
             * is pending.
             *
             * If workers_may_exit is set and this is ungraceful termination/
             * restart, we are bound to get an error on some systems (e.g.,
             * AIX, which sanity-checks mutex operations) since the queue
             * may have already been cleaned up.  Don't log the "error" if
             * workers_may_exit is set.
             */</comment>
            <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <goto>goto <name>worker_pop</name>;</goto>
            }</block></then>
            <comment type="block">/* We got some other error. */</comment>
            <else>else <if>if <condition>(<expr>!<name>workers_may_exit</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03139</expr></argument>)</argument_list></call>
                             "ap_queue_pop failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if></else></if>
            <continue>continue;</continue>
        }</block></then></if>
        <expr_stmt><expr><name>is_idle</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>worker_sockets</name><index>[<expr><name>thread_slot</name></expr>]</index></name> = <name>csd</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>bucket_alloc</name> = <call><name>apr_bucket_alloc_create</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>process_socket</name><argument_list>(<argument><expr><name>thd</name></expr></argument>, <argument><expr><name>ptrans</name></expr></argument>, <argument><expr><name>csd</name></expr></argument>, <argument><expr><name>process_slot</name></expr></argument>, <argument><expr><name>thread_slot</name></expr></argument>, <argument><expr><name>bucket_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>worker_sockets</name><index>[<expr><name>thread_slot</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>requests_this_child</name>--</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name>ptrans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_ptrans</name> = <name>ptrans</name></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>process_slot</name></expr></argument>, <argument><expr><name>thread_slot</name></expr></argument>,
                                        <argument><expr><name>dying</name> ? <name>SERVER_DEAD</name>
                                              : <name>SERVER_GRACEFUL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_thread_exit</name><argument_list>(<argument><expr><name>thd</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_signal</name><parameter_list>(<param><decl><type><name>int</name></type> <name>signum</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>signum</name></expr>)</condition> <block>{
    <case>case <expr><name>SIGTERM</name></expr>:
    </case><case>case <expr><name>SIGINT</name></expr>:
        <return>return <expr>1</expr>;</return>
    </case>}</block></switch>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_listener_thread</name><parameter_list>(<param><decl><type><name>thread_starter</name> *</type><name>ts</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>my_child_num</name> <init>= <expr><name><name>ts</name>-&gt;<name>child_num_arg</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_threadattr_t</name> *</type><name>thread_attr</name> <init>= <expr><name><name>ts</name>-&gt;<name>threadattr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>proc_info</name> *</type><name>my_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>my_info</name> = (<name>proc_info</name> *)<call><name>ap_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>proc_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_info</name>-&gt;<name>pid</name></name> = <name>my_child_num</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>my_info</name>-&gt;<name>tid</name></name> = -1</expr>;</expr_stmt> <comment type="block">/* listener thread doesn't have a thread slot */</comment>
    <expr_stmt><expr><name><name>my_info</name>-&gt;<name>sd</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_create</name><argument_list>(<argument><expr>&amp;<name><name>ts</name>-&gt;<name>listener</name></name></expr></argument>, <argument><expr><name>thread_attr</name></expr></argument>, <argument><expr><name>listener_thread</name></expr></argument>,
                           <argument><expr><name>my_info</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00275</expr></argument>)</argument_list></call>
                     "apr_thread_create: unable to create listener thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* let the parent decide how bad this really is */</comment>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_os_thread_get</name><argument_list>(<argument><expr>&amp;<name>listener_os_thread</name></expr></argument>, <argument><expr><name><name>ts</name>-&gt;<name>listener</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* XXX under some circumstances not understood, children can get stuck
 *     in start_threads forever trying to take over slots which will
 *     never be cleaned up; for now there is an APLOG_DEBUG message issued
 *     every so often when this condition occurs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> * <name>APR_THREAD_FUNC</name></type> <name>start_threads</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>thd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>thread_starter</name> *</type><name>ts</name> <init>= <expr><name>dummy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_thread_t</name> **</type><name>threads</name> <init>= <expr><name><name>ts</name>-&gt;<name>threads</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_threadattr_t</name> *</type><name>thread_attr</name> <init>= <expr><name><name>ts</name>-&gt;<name>threadattr</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>my_child_num</name> <init>= <expr><name><name>ts</name>-&gt;<name>child_num_arg</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>proc_info</name> *</type><name>my_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>threads_created</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>listener_started</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>loops</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>prev_threads_created</name></decl>;</decl_stmt>

    <comment type="block">/* We must create the fd queues before we start up the listener
     * and worker threads. */</comment>
    <expr_stmt><expr><name>worker_queue</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>worker_queue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>ap_queue_init</name><argument_list>(<argument><expr><name>worker_queue</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03140</expr></argument>)</argument_list></call>
                     "ap_queue_init() failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_queue_info_create</name><argument_list>(<argument><expr>&amp;<name>worker_queue_info</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>,
                              <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03141</expr></argument>)</argument_list></call>
                     "ap_queue_info_create() failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>worker_sockets</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>threads_per_child</name>
                                        * <sizeof>sizeof<argument_list>(<argument><expr><name>apr_socket_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>loops</name> = <name>prev_threads_created</name> = 0</expr>;</expr_stmt>
    <while>while <condition>(<expr>1</expr>)</condition> <block>{
        <comment type="block">/* threads_per_child does not include the listener thread */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>my_child_num</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name>.<name>status</name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>status</name> != <name>SERVER_GRACEFUL</name> &amp;&amp; <name>status</name> != <name>SERVER_DEAD</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name>my_info</name> = (<name>proc_info</name> *)<call><name>ap_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>proc_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>my_info</name>-&gt;<name>pid</name></name> = <name>my_child_num</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>my_info</name>-&gt;<name>tid</name></name> = <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>my_info</name>-&gt;<name>sd</name></name> = 0</expr>;</expr_stmt>

            <comment type="block">/* We are creating threads right now */</comment>
            <expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>my_child_num</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                                <argument><expr><name>SERVER_STARTING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* We let each thread update its own scoreboard entry.  This is
             * done because it lets us deal with tid better.
             */</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_create</name><argument_list>(<argument><expr>&amp;<name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>thread_attr</name></expr></argument>,
                                   <argument><expr><name>worker_thread</name></expr></argument>, <argument><expr><name>my_info</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03142</expr></argument>)</argument_list></call>
                             "apr_thread_create: unable to create worker thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* let the parent decide how bad this really is */</comment>
                <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>threads_created</name>++</expr>;</expr_stmt>
        }</block></for>
        <comment type="block">/* Start the listener only when there are workers available */</comment>
        <if>if <condition>(<expr>!<name>listener_started</name> &amp;&amp; <name>threads_created</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>create_listener_thread</name><argument_list>(<argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>listener_started</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>start_thread_may_exit</name> || <name>threads_created</name> == <name>threads_per_child</name></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <comment type="block">/* wait for previous generation to clean up an entry */</comment>
        <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>loops</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>loops</name> % 120 == 0</expr>)</condition><then> <block>{ <comment type="block">/* every couple of minutes */</comment>
            <if>if <condition>(<expr><name>prev_threads_created</name> == <name>threads_created</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                             <argument><expr>"child %" <name>APR_PID_T_FMT</name> " isn't taking over "
                             "slots very quickly (%d of %d)"</expr></argument>,
                             <argument><expr><name>ap_my_pid</name></expr></argument>, <argument><expr><name>threads_created</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>prev_threads_created</name> = <name>threads_created</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></while>

    <comment type="block">/* What state should this child_main process be listed as in the
     * scoreboard...?
     *  ap_update_child_status_from_indexes(my_child_num, i, SERVER_STARTING,
     *                                      (request_rec *) NULL);
     *
     *  This state should be listed separately in the scoreboard, in some kind
     *  of process_status, not mixed in with the worker threads' status.
     *  "life_status" is almost right, but it's in the worker's structure, and
     *  the name could be clearer.   gla
     */</comment>
    <expr_stmt><expr><call><name>apr_thread_exit</name><argument_list>(<argument><expr><name>thd</name></expr></argument>, <argument><expr><name>APR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>join_workers</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>listener</name></decl></param>, <param><decl><type><name>apr_thread_t</name> **</type><name>threads</name></decl></param>,
                         <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>, <decl><type ref="prev"/><name>thread_rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>listener</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>iter</name></decl>;</decl_stmt>

        <comment type="block">/* deal with a rare timing window which affects waking up the
         * listener thread...  if the signal sent to the listener thread
         * is delivered between the time it verifies that the
         * listener_may_exit flag is clear and the time it enters a
         * blocking syscall, the signal didn't do any good...  work around
         * that by sleeping briefly and sending it again
         */</comment>

        <expr_stmt><expr><name>iter</name> = 0</expr>;</expr_stmt>
        <while>while <condition>(<expr><name>iter</name> &lt; 10 &amp;&amp;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_KILL</name></cpp:ifdef>
               <call><name>pthread_kill</name><argument_list>(<argument><expr>*<name>listener_os_thread</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
               <call><name>kill</name><argument_list>(<argument><expr><name>ap_my_pid</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
               == 0</expr>)</condition> <block>{
            <comment type="block">/* listener not dead yet */</comment>
            <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><call><name>apr_time_make</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>500000</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>wakeup_listener</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>iter</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>iter</name> &gt;= 10</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00276</expr></argument>)</argument_list></call>
                         "the listener thread didn't exit"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_join</name><argument_list>(<argument><expr>&amp;<name>thread_rv</name></expr></argument>, <argument><expr><name>listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00277</expr></argument>)</argument_list></call>
                             "apr_thread_join: unable to join listener thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{ <comment type="block">/* if we ever created this thread */</comment>
            <if>if <condition>(<expr><name>mode</name> != <name>ST_GRACEFUL</name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PTHREAD_KILL</name></cpp:ifdef>
                <decl_stmt><decl><type><name>apr_os_thread_t</name> *</type><name>worker_os_thread</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>apr_os_thread_get</name><argument_list>(<argument><expr>&amp;<name>worker_os_thread</name></expr></argument>, <argument><expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>pthread_kill</name><argument_list>(<argument><expr>*<name>worker_os_thread</name></expr></argument>, <argument><expr><name>WORKER_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_join</name><argument_list>(<argument><expr>&amp;<name>thread_rv</name></expr></argument>, <argument><expr><name><name>threads</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00278</expr></argument>)</argument_list></call>
                             "apr_thread_join: unable to join worker "
                             "thread %d"</expr></argument>,
                             <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>join_start_thread</name><parameter_list>(<param><decl><type><name>apr_thread_t</name> *</type><name>start_thread_id</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>, <decl><type ref="prev"/><name>thread_rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>start_thread_may_exit</name> = 1</expr>;</expr_stmt> <comment type="block">/* tell it to give up in case it is still
                                * trying to take over slots from a
                                * previous generation
                                */</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_join</name><argument_list>(<argument><expr>&amp;<name>thread_rv</name></expr></argument>, <argument><expr><name>start_thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00279</expr></argument>)</argument_list></call>
                     "apr_thread_join: unable to join the start "
                     "thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>child_main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>child_num_arg</name></decl></param>, <param><decl><type><name>int</name></type> <name>child_bucket</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_thread_t</name> **</type><name>threads</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>thread_starter</name> *</type><name>ts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_threadattr_t</name> *</type><name>thread_attr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_thread_t</name> *</type><name>start_thread_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* for benefit of any hooks that run as this child initializes */</comment>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STARTING</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>ap_my_pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_fatal_signal_child_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>pchild</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* close unused listeners and pods */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name>i</name> != <name>child_bucket</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_close_listeners_ex</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>listeners</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_mpm_podx_close</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <comment type="block">/*stuff to do before we switch id's, so we have permissions.*/</comment>
    <expr_stmt><expr><call><name>ap_reopen_scoreboard</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr><call><name>apr_proc_mutex_child_init</name><argument_list>(<argument><expr>&amp;<name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>,
                                    <argument><expr><call><name>apr_proc_mutex_lockfile</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00280</expr></argument>)</argument_list></call>
                     "Couldn't initialize cross-process lock in child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ap_run_drop_privileges</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_run_child_init</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* done with init critical section */</comment>

    <comment type="block">/* Just use the standard apr_setup_signal_thread to block all signals
     * from being received.  The child processes no longer use signals for
     * any communication with the parent process.
     */</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_setup_signal_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_EMERG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00281</expr></argument>)</argument_list></call>
                     "Couldn't initialize signal thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDFATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>ap_max_requests_per_child</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>requests_this_child</name> = <name>ap_max_requests_per_child</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* coding a value of zero means infinity */</comment>
        <expr_stmt><expr><name>requests_this_child</name> = <name>INT_MAX</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Setup worker threads */</comment>

    <comment type="block">/* clear the storage; we may not create all our threads immediately,
     * and we want a 0 entry to indicate a thread which was not created
     */</comment>
    <expr_stmt><expr><name>threads</name> = (<name>apr_thread_t</name> **)<call><name>ap_calloc</name><argument_list>(<argument><expr>1</expr></argument>,
                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>apr_thread_t</name> *</expr></argument>)</argument_list></sizeof> * <name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ts</name> = (<name>thread_starter</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>pchild</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_threadattr_create</name><argument_list>(<argument><expr>&amp;<name>thread_attr</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* 0 means PTHREAD_CREATE_JOINABLE */</comment>
    <expr_stmt><expr><call><name>apr_threadattr_detach_set</name><argument_list>(<argument><expr><name>thread_attr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>ap_thread_stacksize</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_threadattr_stacksize_set</name><argument_list>(<argument><expr><name>thread_attr</name></expr></argument>, <argument><expr><name>ap_thread_stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name> &amp;&amp; <name>rv</name> != <name>APR_ENOTIMPL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02435</expr></argument>)</argument_list></call>
                         "WARNING: ThreadStackSize of %" <name>APR_SIZE_T_FMT</name> " is "
                         "inappropriate, using default"</expr></argument>, 
                         <argument><expr><name>ap_thread_stacksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>ts</name>-&gt;<name>threads</name></name> = <name>threads</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>listener</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>child_num_arg</name></name> = <name>child_num_arg</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ts</name>-&gt;<name>threadattr</name></name> = <name>thread_attr</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_create</name><argument_list>(<argument><expr>&amp;<name>start_thread_id</name></expr></argument>, <argument><expr><name>thread_attr</name></expr></argument>, <argument><expr><name>start_threads</name></expr></argument>,
                           <argument><expr><name>ts</name></expr></argument>, <argument><expr><name>pchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00282</expr></argument>)</argument_list></call>
                     "apr_thread_create: unable to create worker thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* let the parent decide how bad this really is */</comment>
        <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>APEXIT_CHILDSICK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_RUNNING</name></expr>;</expr_stmt>

    <comment type="block">/* If we are only running in one_process mode, we will want to
     * still handle signals. */</comment>
    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <comment type="block">/* Block until we get a terminating signal. */</comment>
        <expr_stmt><expr><call><name>apr_signal_thread</name><argument_list>(<argument><expr><name>check_signal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* make sure the start thread has finished; signal_threads()
         * and join_workers() depend on that
         */</comment>
        <comment type="block">/* XXX join_start_thread() won't be awakened if one of our
         *     threads encounters a critical error and attempts to
         *     shutdown this child
         */</comment>
        <expr_stmt><expr><call><name>join_start_thread</name><argument_list>(<argument><expr><name>start_thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>ST_UNGRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* helps us terminate a little more
                           * quickly than the dispatch of the signal thread
                           * beats the Pipe of Death and the browsers
                           */</comment>
        <comment type="block">/* A terminating signal was received. Now join each of the
         * workers to clean them up.
         *   If the worker already exited, then the join frees
         *   their resources and returns.
         *   If the worker hasn't exited, then this blocks until
         *   they have (then cleans up).
         */</comment>
        <expr_stmt><expr><call><name>join_workers</name><argument_list>(<argument><expr><name><name>ts</name>-&gt;<name>listener</name></name></expr></argument>, <argument><expr><name>threads</name></expr></argument>, <argument><expr><name>ST_UNGRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{ <comment type="block">/* !one_process */</comment>
        <comment type="block">/* remove SIGTERM from the set of blocked signals...  if one of
         * the other threads in the process needs to take us down
         * (e.g., for MaxConnectionsPerChild) it will send us SIGTERM
         */</comment>
        <expr_stmt><expr><call><name>unblock_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>dummy_signal_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Watch for any messages from the parent over the POD */</comment>
        <while>while <condition>(<expr>1</expr>)</condition> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>ap_mpm_podx_check</name><argument_list>(<argument><expr><name><name>my_bucket</name>-&gt;<name>pod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> == <name>AP_MPM_PODX_NORESTART</name></expr>)</condition><then> <block>{
                <comment type="block">/* see if termination was triggered while we slept */</comment>
                <switch>switch<condition>(<expr><name>terminate_mode</name></expr>)</condition> <block>{
                <case>case <expr><name>ST_GRACEFUL</name></expr>:
                    <expr_stmt><expr><name>rv</name> = <name>AP_MPM_PODX_GRACEFUL</name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>ST_UNGRACEFUL</name></expr>:
                    <expr_stmt><expr><name>rv</name> = <name>AP_MPM_PODX_RESTART</name></expr>;</expr_stmt>
                    <break>break;</break>
                </case>}</block></switch>
            }</block></then></if>
            <if>if <condition>(<expr><name>rv</name> == <name>AP_MPM_PODX_GRACEFUL</name> || <name>rv</name> == <name>AP_MPM_PODX_RESTART</name></expr>)</condition><then> <block>{
                <comment type="block">/* make sure the start thread has finished;
                 * signal_threads() and join_workers depend on that
                 */</comment>
                <expr_stmt><expr><call><name>join_start_thread</name><argument_list>(<argument><expr><name>start_thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>signal_threads</name><argument_list>(<argument><expr><name>rv</name> == <name>AP_MPM_PODX_GRACEFUL</name> ? <name>ST_GRACEFUL</name> : <name>ST_UNGRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></while>

        <comment type="block">/* A terminating signal was received. Now join each of the
         * workers to clean them up.
         *   If the worker already exited, then the join frees
         *   their resources and returns.
         *   If the worker hasn't exited, then this blocks until
         *   they have (then cleans up).
         */</comment>
        <expr_stmt><expr><call><name>join_workers</name><argument_list>(<argument><expr><name><name>ts</name>-&gt;<name>listener</name></name></expr></argument>, <argument><expr><name>threads</name></expr></argument>,
                     <argument><expr><name>rv</name> == <name>AP_MPM_PODX_GRACEFUL</name> ? <name>ST_GRACEFUL</name> : <name>ST_UNGRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>clean_child_exit</name><argument_list>(<argument><expr><name>resource_shortage</name> ? <name>APEXIT_CHILDSICK</name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>make_child</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>int</name></type> <name>bucket</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>pid</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>slot</name> + 1 &gt; <name><name>retained</name>-&gt;<name>max_daemons_limit</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = <name>slot</name> + 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>my_bucket</name> = &amp;<name><name>all_buckets</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>worker_note_child_started</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>child_main</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* NOTREACHED */</comment>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>pid</name> = <call><name>fork</name><argument_list>()</argument_list></call>) == -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00283</expr></argument>)</argument_list></call>
                     "fork: Unable to fork new process"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* fork didn't succeed.  There's no need to touch the scoreboard;
         * if we were trying to replace a failed child process, then
         * server_main_loop() marked its workers SERVER_DEAD, and if
         * we were trying to replace a child process that exited normally,
         * its worker_thread()s left SERVER_DEAD or SERVER_GRACEFUL behind.
         */</comment>

        <comment type="block">/* In case system resources are maxxed out, we don't want
           Apache running away with the CPU trying to fork over and
           over and over again. */</comment>
        <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>10</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>pid</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>my_bucket</name> = &amp;<name><name>all_buckets</name><index>[<expr><name>bucket</name></expr>]</index></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BINDPROCESSOR</name></cpp:ifdef>
        <comment type="block">/* By default, AIX binds to a single processor.  This bit unbinds
         * children which will then bind to another CPU.
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><call><name>bindprocessor</name><argument_list>(<argument><expr><name>BINDPROCESS</name></expr></argument>, <argument><expr>(<name>int</name>)<call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>,
                               <argument><expr><name>PROCESSOR_CLASS_ANY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>status</name> != <name>OK</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>,
                         <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00284</expr></argument>)</argument_list></call>
                         "processor unbind failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>RAISE_SIGSTOP</name><argument_list>(<argument><expr><name>MAKE_CHILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>just_die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>child_main</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* NOTREACHED */</comment>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>pid</name> != 0</expr>)</condition><then> <block>{
        <comment type="block">/* This new child process is squatting on the scoreboard
         * entry owned by an exiting child process, which cannot
         * exit until all active requests complete.
         */</comment>
        <expr_stmt><expr><call><name>worker_note_child_lost_slot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>quiescing</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>slot</name></expr>]</index></name>.<name>bucket</name> = <name>bucket</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>worker_note_child_started</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* start up a bunch of children */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>startup_children</name><parameter_list>(<param><decl><type><name>int</name></type> <name>number_to_start</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>number_to_start</name> &amp;&amp; <name>i</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pid</name> != 0</expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> % <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr>--<name>number_to_start</name></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>perform_idle_server_maintenance</name><parameter_list>(<param><decl><type><name>int</name></type> <name>child_bucket</name></decl></param>, <param><decl><type><name>int</name></type> <name>num_buckets</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>idle_thread_count</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>worker_score</name> *</type><name>ws</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>process_score</name> *</type><name>ps</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>free_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>totally_free_length</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name><name>free_slots</name><index>[<expr><name>MAX_SPAWN_RATE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>last_non_dead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>total_non_dead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>active_thread_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* initialize the free_list */</comment>
    <expr_stmt><expr><name>free_length</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>idle_thread_count</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>last_non_dead</name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name>total_non_dead</name> = 0</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <comment type="block">/* Initialization to satisfy the compiler. It doesn't know
         * that threads_per_child is always &gt; 0 */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>SERVER_DEAD</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>any_dying_threads</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>any_dead_threads</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>all_dead_threads</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>child_threads_active</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>i</name> &gt;= <name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> &amp;&amp;
            <name>totally_free_length</name> == <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name></expr>)</condition><then> <block>{
            <comment type="block">/* short cut if all active processes have been examined and
             * enough empty scoreboard slots have been found
             */</comment>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>ps</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>ws</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <name><name>ws</name>-&gt;<name>status</name></name></expr>;</expr_stmt>

            <comment type="block">/* XXX any_dying_threads is probably no longer needed    GLA */</comment>
            <expr_stmt><expr><name>any_dying_threads</name> = <name>any_dying_threads</name> ||
                                (<name>status</name> == <name>SERVER_GRACEFUL</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>any_dead_threads</name> = <name>any_dead_threads</name> || (<name>status</name> == <name>SERVER_DEAD</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>all_dead_threads</name> = <name>all_dead_threads</name> &amp;&amp;
                                   (<name>status</name> == <name>SERVER_DEAD</name> ||
                                    <name>status</name> == <name>SERVER_GRACEFUL</name>)</expr>;</expr_stmt>

            <comment type="block">/* We consider a starting server as idle because we started it
             * at least a cycle ago, and if it still hasn't finished starting
             * then we're just going to swamp things worse by forking more.
             * So we hopefully won't need to fork more if we count it.
             * This depends on the ordering of SERVER_READY and SERVER_STARTING.
             */</comment>
            <if>if <condition>(<expr><name><name>ps</name>-&gt;<name>pid</name></name> != 0</expr>)</condition><then> <block>{ <comment type="block">/* XXX just set all_dead_threads in outer for
                                   loop if no pid?  not much else matters */</comment>
                <if>if <condition>(<expr><name>status</name> &lt;= <name>SERVER_READY</name> &amp;&amp;
                        !<name><name>ps</name>-&gt;<name>quiescing</name></name> &amp;&amp;
                        <name><name>ps</name>-&gt;<name>generation</name></name> == <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name> &amp;&amp;
                        <name><name>ps</name>-&gt;<name>bucket</name></name> == <name>child_bucket</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr>++<name>idle_thread_count</name></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><name>status</name> &gt;= <name>SERVER_READY</name> &amp;&amp; <name>status</name> &lt; <name>SERVER_GRACEFUL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr>++<name>child_threads_active</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><name>active_thread_count</name> += <name>child_threads_active</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>any_dead_threads</name>
                &amp;&amp; <name>totally_free_length</name> &lt; <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name>
                &amp;&amp; <name>free_length</name> &lt; <name>MAX_SPAWN_RATE</name> / <name>num_buckets</name>
                &amp;&amp; (!<name><name>ps</name>-&gt;<name>pid</name></name>               <comment type="block">/* no process in the slot */</comment>
                    || <name><name>ps</name>-&gt;<name>quiescing</name></name>)</expr>)</condition><then> <block>{   <comment type="block">/* or at least one is going away */</comment>
            <if>if <condition>(<expr><name>all_dead_threads</name></expr>)</condition><then> <block>{
                <comment type="block">/* great! we prefer these, because the new process can
                 * start more threads sooner.  So prioritize this slot
                 * by putting it ahead of any slots with active threads.
                 *
                 * first, make room by moving a slot that's potentially still
                 * in use to the end of the array
                 */</comment>
                <expr_stmt><expr><name><name>free_slots</name><index>[<expr><name>free_length</name></expr>]</index></name> = <name><name>free_slots</name><index>[<expr><name>totally_free_length</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>free_slots</name><index>[<expr><name>totally_free_length</name>++</expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* slot is still in use - back of the bus
                 */</comment>
                <expr_stmt><expr><name><name>free_slots</name><index>[<expr><name>free_length</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr>++<name>free_length</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>child_threads_active</name> == <name>threads_per_child</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>had_healthy_child</name> = 1</expr>;</expr_stmt>
        }</block></then></if></else></if>
        <comment type="block">/* XXX if (!ps-&gt;quiescing)     is probably more reliable  GLA */</comment>
        <if>if <condition>(<expr>!<name>any_dying_threads</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>last_non_dead</name> = <name>i</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>total_non_dead</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>sick_child_detected</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>had_healthy_child</name></expr>)</condition><then> <block>{
            <comment type="block">/* Assume this is a transient error, even though it may not be.  Leave
             * the server up in case it is able to serve some requests or the
             * problem will be resolved.
             */</comment>
            <expr_stmt><expr><name><name>retained</name>-&gt;<name>sick_child_detected</name></name> = 0</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* looks like a basket case, as no child ever fully initialized; give up.
             */</comment>
            <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>child_fatal</name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02325</expr></argument>)</argument_list></call>
                         "A resource shortage or other unrecoverable failure "
                         "was encountered before any child process initialized "
                         "successfully... httpd is exiting!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* the child already logged the failure details */</comment>
            <return>return;</return>
        }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = <name>last_non_dead</name> + 1</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>idle_thread_count</name> &gt; <name>max_spare_threads</name> / <name>num_buckets</name></expr>)</condition><then> <block>{
        <comment type="block">/* Kill off one child */</comment>
        <expr_stmt><expr><call><name>ap_mpm_podx_signal</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>child_bucket</name></expr>]</index></name>.<name>pod</name></expr></argument>,
                           <argument><expr><name>AP_MPM_PODX_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>idle_thread_count</name> &lt; <name>min_spare_threads</name> / <name>num_buckets</name></expr>)</condition><then> <block>{
        <comment type="block">/* terminate the free list */</comment>
        <if>if <condition>(<expr><name>free_length</name> == 0</expr>)</condition><then> <block>{ <comment type="block">/* scoreboard is full, can't fork */</comment>

            <if>if <condition>(<expr><name>active_thread_count</name> &gt;= <name>ap_daemons_limit</name> * <name>threads_per_child</name></expr>)</condition><then> <block>{
                <comment type="block">/* no threads are "inactive" - starting, stopping, etc. */</comment>
                <comment type="block">/* have we reached MaxRequestWorkers, or just getting close? */</comment>
                <if>if <condition>(<expr>0 == <name>idle_thread_count</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>maxclients_reported</name></name></expr>)</condition><then> <block>{
                        <comment type="block">/* only report this condition once */</comment>
                        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00286</expr></argument>)</argument_list></call>
                                     "server reached MaxRequestWorkers "
                                     "setting, consider raising the "
                                     "MaxRequestWorkers setting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>retained</name>-&gt;<name>maxclients_reported</name></name> = 1</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then> <else>else <block>{
                    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>near_maxclients_reported</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00287</expr></argument>)</argument_list></call>
                                     "server is within MinSpareThreads of "
                                     "MaxRequestWorkers, consider raising the "
                                     "MaxRequestWorkers setting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>retained</name>-&gt;<name>near_maxclients_reported</name></name> = 1</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00288</expr></argument>)</argument_list></call>
                             "scoreboard is full, not at MaxRequestWorkers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> = 1</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr><name>free_length</name> &gt; <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>free_length</name> = <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> &gt;= 8</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00289</expr></argument>)</argument_list></call>
                             "server seems busy, (you may need "
                             "to increase StartServers, ThreadsPerChild "
                             "or Min/MaxSpareThreads), "
                             "spawning %d children, there are around %d idle "
                             "threads, and %d total children"</expr></argument>, <argument><expr><name>free_length</name></expr></argument>,
                             <argument><expr><name>idle_thread_count</name></expr></argument>, <argument><expr><name>total_non_dead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>free_length</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <expr_stmt><expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name><name>free_slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>child_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
            <comment type="block">/* the next time around we want to spawn twice as many if this
             * wasn't good enough, but not if we've just done a graceful
             */</comment>
            <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr>--<name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name>
                     &lt; <name>MAX_SPAWN_RATE</name> / <name>num_buckets</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> *= 2</expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>child_bucket</name></expr>]</index></name> = 1</expr>;</expr_stmt>
    }</block></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>server_main_loop</name><parameter_list>(<param><decl><type><name>int</name></type> <name>remaining_children_to_start</name></decl></param>, <param><decl><type><name>int</name></type> <name>num_buckets</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ap_generation_t</name></type> <name>old_gen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>child_slot</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_exit_why_e</name></type> <name>exitwhy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>, <decl><type ref="prev"/><name>processed_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_proc_t</name></type> <name>pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>restart_pending</name></name> &amp;&amp; !<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>ap_wait_or_timeout</name><argument_list>(<argument><expr>&amp;<name>exitwhy</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>pid</name>.<name>pid</name></name> != -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>processed_status</name> = <call><name>ap_process_child_status</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>exitwhy</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>child_slot</name> = <call><name>ap_find_child_by_pid</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDFATAL</name></expr>)</condition><then> <block>{
                <comment type="block">/* fix race condition found in PR 39311
                 * A child created at the same time as a graceful happens 
                 * can find the lock missing and create a fatal error.
                 * It is not fatal for the last generation to be in this state.
                 */</comment>
                <if>if <condition>(<expr><name>child_slot</name> &lt; 0
                    || <call><name>ap_get_scoreboard_process</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>)</argument_list></call>-&gt;<name>generation</name>
                       == <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> = 1</expr>;</expr_stmt>
                    <expr_stmt><expr><name>child_fatal</name> = 1</expr>;</expr_stmt>
                    <return>return;</return>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00290</expr></argument>)</argument_list></call>
                                 "Ignoring fatal error in child of previous "
                                 "generation (pid %ld)."</expr></argument>,
                                 <argument><expr>(<name>long</name>)<name><name>pid</name>.<name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>retained</name>-&gt;<name>sick_child_detected</name></name> = 1</expr>;</expr_stmt>
                }</block></else></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDSICK</name></expr>)</condition><then> <block>{
                <comment type="block">/* tell perform_idle_server_maintenance to check into this
                 * on the next timer pop
                 */</comment>
                <expr_stmt><expr><name><name>retained</name>-&gt;<name>sick_child_detected</name></name> = 1</expr>;</expr_stmt>
            }</block></then></if></else></if>
            <comment type="block">/* non-fatal death... note that it's gone in the scoreboard. */</comment>
            <if>if <condition>(<expr><name>child_slot</name> &gt;= 0</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>process_score</name> *</type><name>ps</name></decl>;</decl_stmt>

                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>threads_per_child</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
                    <expr_stmt><expr><call><name>ap_update_child_status_from_indexes</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                                        <argument><expr><name>SERVER_DEAD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

                <expr_stmt><expr><call><name>worker_note_child_killed</name><argument_list>(<argument><expr><name>child_slot</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>ps</name> = &amp;<name><name>ap_scoreboard_image</name>-&gt;<name>parent</name><index>[<expr><name>child_slot</name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ps</name>-&gt;<name>quiescing</name></name> = 0</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDSICK</name></expr>)</condition><then> <block>{
                    <comment type="block">/* resource shortage, minimize the fork rate */</comment>
                    <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name><name>ps</name>-&gt;<name>bucket</name></name></expr>]</index></name> = 1</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>remaining_children_to_start</name>
                    &amp;&amp; <name>child_slot</name> &lt; <name>ap_daemons_limit</name></expr>)</condition><then> <block>{
                    <comment type="block">/* we're still doing a 1-for-1 replacement of dead
                     * children with new children
                     */</comment>
                    <expr_stmt><expr><call><name>make_child</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>child_slot</name></expr></argument>, <argument><expr><name><name>ps</name>-&gt;<name>bucket</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr>--<name>remaining_children_to_start</name></expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>ap_unregister_extra_mpm_process</name><argument_list>(<argument><expr><name><name>pid</name>.<name>pid</name></name></expr></argument>, <argument><expr>&amp;<name>old_gen</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>worker_note_child_killed</name><argument_list>(<argument><expr>-1</expr></argument>, <comment type="block">/* already out of the scoreboard */</comment>
                                         <argument><expr><name><name>pid</name>.<name>pid</name></name></expr></argument>, <argument><expr><name>old_gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>processed_status</name> == <name>APEXIT_CHILDSICK</name>
                    &amp;&amp; <name>old_gen</name> == <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/* resource shortage, minimize the fork rate */</comment>
                    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                        <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>i</name></expr>]</index></name> = 1</expr>;</expr_stmt>
                    }</block></for>
                }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_OTHER_CHILD</name></expr></cpp:if>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>apr_proc_other_child_alert</name><argument_list>(<argument><expr>&amp;<name>pid</name></expr></argument>, <argument><expr><name>APR_OC_REASON_DEATH</name></expr></argument>,
                                                <argument><expr><name>status</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <comment type="block">/* handled */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* Great, we've probably just lost a slot in the
                 * scoreboard.  Somehow we don't know about this child.
                 */</comment>
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00291</expr></argument>)</argument_list></call>
                             "long lost child came home! (pid %ld)"</expr></argument>,
                             <argument><expr>(<name>long</name>)<name><name>pid</name>.<name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if></else></if></else></if>
            <comment type="block">/* Don't perform idle maintenance when a child dies,
             * only do it when there's a timeout.  Remember only a
             * finite number of children can die, and it's pretty
             * pathological for a lot to die suddenly.
             */</comment>
            <continue>continue;</continue>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>remaining_children_to_start</name></expr>)</condition><then> <block>{
            <comment type="block">/* we hit a 1 second timeout in which none of the previous
             * generation of children needed to be reaped... so assume
             * they're all done, and pick up the slack if any is left.
             */</comment>
            <expr_stmt><expr><call><name>startup_children</name><argument_list>(<argument><expr><name>remaining_children_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remaining_children_to_start</name> = 0</expr>;</expr_stmt>
            <comment type="block">/* In any event we really shouldn't do the code below because
             * few of the servers we just started are in the IDLE state
             * yet, so we'd mistakenly create an extra server.
             */</comment>
            <continue>continue;</continue>
        }</block></then></if></else></if>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>perform_idle_server_maintenance</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>num_buckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_run</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>_pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>num_buckets</name> <init>= <expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>remaining_children_to_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_log_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>ap_run_pre_mpm</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>SB_SHARED</name></expr></argument>)</argument_list></call> != <name>OK</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>
            <return>return <expr>!<name>OK</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* fix the generation number in the global score; we just got a new,
         * cleared scoreboard
         */</comment>
        <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_fatal_signal_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ap_unixd_mpm_set_signals</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>one_process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Don't thrash since num_buckets depends on the
     * system and the number of online CPU cores...
     */</comment>
    <if>if <condition>(<expr><name>ap_daemons_limit</name> &lt; <name>num_buckets</name></expr>)</condition><then>
        <expr_stmt><expr><name>ap_daemons_limit</name> = <name>num_buckets</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>ap_daemons_to_start</name> &lt; <name>num_buckets</name></expr>)</condition><then>
        <expr_stmt><expr><name>ap_daemons_to_start</name> = <name>num_buckets</name></expr>;</expr_stmt></then></if>
    <comment type="block">/* We want to create as much children at a time as the number of buckets,
     * so to optimally accept connections (evenly distributed across buckets).
     * Thus min_spare_threads should at least maintain num_buckets children,
     * and max_spare_threads allow num_buckets more children w/o triggering
     * immediately (e.g. num_buckets idle threads margin, one per bucket).
     */</comment>
    <if>if <condition>(<expr><name>min_spare_threads</name> &lt; <call><name>threads_per_child</name> * <argument_list>(<argument><expr><name>num_buckets</name> - 1</expr></argument>)</argument_list></call> + <name>num_buckets</name></expr>)</condition><then>
        <expr_stmt><expr><name>min_spare_threads</name> = <call><name>threads_per_child</name> * <argument_list>(<argument><expr><name>num_buckets</name> - 1</expr></argument>)</argument_list></call> + <name>num_buckets</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>max_spare_threads</name> &lt; <name>min_spare_threads</name> + (<name>threads_per_child</name> + 1) * <name>num_buckets</name></expr>)</condition><then>
        <expr_stmt><expr><name>max_spare_threads</name> = <name>min_spare_threads</name> + (<name>threads_per_child</name> + 1) * <name>num_buckets</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* If we're doing a graceful_restart then we're going to see a lot
     * of children exiting immediately when we get into the main loop
     * below (because we just sent them AP_SIG_GRACEFUL).  This happens pretty
     * rapidly... and for each one that exits we may start a new one, until
     * there are at least min_spare_threads idle threads, counting across
     * all children.  But we may be permitted to start more children than
     * that, so we'll just keep track of how many we're
     * supposed to start up without the 1 second penalty between each fork.
     */</comment>
    <expr_stmt><expr><name>remaining_children_to_start</name> = <name>ap_daemons_to_start</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>remaining_children_to_start</name> &gt; <name>ap_daemons_limit</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>remaining_children_to_start</name> = <name>ap_daemons_limit</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>startup_children</name><argument_list>(<argument><expr><name>remaining_children_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>remaining_children_to_start</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* give the system some time to recover before kicking into
            * exponential mode */</comment>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>hold_off_on_exponential_spawning</name></name> = 10</expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00292</expr></argument>)</argument_list></call>
                "%s configured -- resuming normal operations"</expr></argument>,
                <argument><expr><call><name>ap_get_server_description</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00293</expr></argument>)</argument_list></call>
                "Server built: %s"</expr></argument>, <argument><expr><call><name>ap_get_server_built</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_command_line</name><argument_list>(<argument><expr><name>plog</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_mpm_common</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00294</expr></argument>)</argument_list></call>
                "Accept mutex: %s (default: %s)"</expr></argument>,
                <argument><expr>(<name><name>all_buckets</name><index>[<expr>0</expr>]</index></name>.<name>mutex</name>)
                    ? <call><name>apr_proc_mutex_name</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr>0</expr>]</index></name>.<name>mutex</name></expr></argument>)</argument_list></call>
                    : "none"</expr></argument>,
                <argument><expr><call><name>apr_proc_mutex_defname</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_RUNNING</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>server_main_loop</name><argument_list>(<argument><expr><name>remaining_children_to_start</name></expr></argument>, <argument><expr><name>num_buckets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STOPPING</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> &amp;&amp; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>is_ungraceful</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Time to shut down:
         * Kill child processes, tell them to call child_exit, etc...
         */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
                               <argument><expr><name>AP_MPM_PODX_RESTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>ap_reclaim_child_processes</name><argument_list>(<argument><expr>1</expr></argument>, <comment type="block">/* Start with SIGTERM */</comment>
                                   <argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>child_fatal</name></expr>)</condition><then> <block>{
            <comment type="block">/* cleanup pid file on normal shutdown */</comment>
            <expr_stmt><expr><call><name>ap_remove_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00295</expr></argument>)</argument_list></call> "caught SIGTERM, shutting down"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>DONE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Time to gracefully shut down:
         * Kill child processes, tell them to call child_exit, etc...
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>active_children</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_time_t</name></type> <name>cutoff</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <comment type="block">/* Close our listeners, and then ask our children to do same */</comment>
        <expr_stmt><expr><call><name>ap_close_listeners</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
                               <argument><expr><name>AP_MPM_PODX_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>ap_relieve_child_processes</name><argument_list>(<argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>child_fatal</name></expr>)</condition><then> <block>{
            <comment type="block">/* cleanup pid file on normal shutdown */</comment>
            <expr_stmt><expr><call><name>ap_remove_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00296</expr></argument>)</argument_list></call>
                         "caught " <name>AP_SIG_GRACEFUL_STOP_STRING</name>
                         ", shutting down gracefully"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>ap_graceful_shutdown_timeout</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cutoff</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call> +
                     <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>ap_graceful_shutdown_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Don't really exit until each child has finished */</comment>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> = 0</expr>;</expr_stmt>
        <do>do <block>{
            <comment type="block">/* Pause for a second */</comment>
            <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Relieve any children which have now exited */</comment>
            <expr_stmt><expr><call><name>ap_relieve_child_processes</name><argument_list>(<argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>active_children</name> = 0</expr>;</expr_stmt>
            <for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition><expr><name>index</name> &lt; <name>ap_daemons_limit</name></expr>;</condition> <incr><expr>++<name>index</name></expr></incr>) <block>{
                <if>if <condition>(<expr><call><name>ap_mpm_safe_kill</name><argument_list>(<argument><expr><call><name>MPM_CHILD_PID</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>active_children</name> = 1</expr>;</expr_stmt>
                    <comment type="block">/* Having just one child is enough to stay around */</comment>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block> while <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>shutdown_pending</name></name> &amp;&amp; <name>active_children</name> &amp;&amp;
                 (!<name>ap_graceful_shutdown_timeout</name> || <call><name>apr_time_now</name><argument_list>()</argument_list></call> &lt; <name>cutoff</name>)</expr>)</condition>;</do>

        <comment type="block">/* We might be here because we received SIGTERM, either
         * way, try and make sure that all of our processes are
         * really dead.
         */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
                               <argument><expr><name>AP_MPM_PODX_RESTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>ap_reclaim_child_processes</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>DONE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* we've been told to restart */</comment>
    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <comment type="block">/* not worth thinking about */</comment>
        <return>return <expr><name>DONE</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* advance to the next generation */</comment>
    <comment type="block">/* XXX: we really need to make sure this new generation number isn't in
     * use by any of the children.
     */</comment>
    <expr_stmt><expr>++<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ap_scoreboard_image</name>-&gt;<name>global</name>-&gt;<name>running_generation</name></name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>my_generation</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>is_ungraceful</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>00297</argument>)</argument_list></macro>
                     <name>AP_SIG_GRACEFUL_STRING</name> " received.  Doing graceful restart"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* wake up the children...time to die.  But we'll have more soon */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
                               <argument><expr><name>AP_MPM_PODX_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/* This is mostly for debugging... so that we know what is still
         * gracefully dealing with existing request.
         */</comment>

    }</block></then>
    <else>else <block>{
        <comment type="block">/* Kill 'em all.  Since the child acts the same on the parents SIGTERM
         * and a SIGHUP, we may as well use the same signal, because some user
         * pthreads are stealing signals from us left and right.
         */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><call><name>ap_mpm_podx_killpg</name><argument_list>(<argument><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>,
                               <argument><expr><name>AP_MPM_PODX_RESTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name>ap_reclaim_child_processes</name><argument_list>(<argument><expr>1</expr></argument>, <comment type="block">/* Start with SIGTERM */</comment>
                                   <argument><expr><name>worker_note_child_killed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00298</expr></argument>)</argument_list></call>
                    "SIGHUP received.  Attempting to restart"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/* This really should be a post_config hook, but the error log is already
 * redirected by that point, so we need to do this in the open_logs phase.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_open_logs</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>startup</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>level_flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_buckets</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> **</type><name>listen_buckets</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>id</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>pconf</name> = <name>p</name></expr>;</expr_stmt>

    <comment type="block">/* the reverse of pre_config, we want this only the first time around */</comment>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>startup</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>level_flags</name> |= <name>APLOG_STARTUP</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>num_listensocks</name> = <call><name>ap_setup_listeners</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>)</argument_list></call>) &lt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name> | <name>level_flags</name></expr></argument>, <argument><expr>0</expr></argument>,
                     <argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
                     <argument><expr>"no listening sockets available, shutting down"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<name>OK</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>one_process</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>num_buckets</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Preserve the number of buckets on graceful restarts. */</comment>
        <expr_stmt><expr><name>num_buckets</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <if>if <condition>(<expr>(<name>rv</name> = <call><name>ap_duplicate_listeners</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                                     <argument><expr>&amp;<name>listen_buckets</name></expr></argument>, <argument><expr>&amp;<name>num_buckets</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                     <argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
                     <argument><expr>"could not duplicate listeners"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>!<name>OK</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>all_buckets</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>num_buckets</name> * <sizeof>sizeof<argument_list>(<argument><expr>*<name>all_buckets</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr>!<name>one_process</name> &amp;&amp; <comment type="block">/* no POD in one_process mode */</comment>
                (<name>rv</name> = <call><name>ap_mpm_podx_open</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr>&amp;<name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pod</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                         <argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
                         <argument><expr>"could not open pipe-of-death"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>!<name>OK</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* Initialize cross-process accept lock (safe accept needed only) */</comment>
        <if>if <condition>(<expr>(<name>rv</name> = <call><name>SAFE_ACCEPT</name><argument_list>(<argument><expr>(<call><name>apr_snprintf</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr>sizeof <name>id</name></expr></argument>, <argument><expr>"%i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>,
                               <call><name>ap_proc_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mutex</name></expr></argument>,
                                                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AP_ACCEPT_MUTEX_TYPE</name></expr></argument>,
                                                    <argument><expr><name>id</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name> | <name>level_flags</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                         <argument><expr>(<name>startup</name> ? <name>NULL</name> : <name>s</name>)</expr></argument>,
                         <argument><expr>"could not create accept mutex"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>!<name>OK</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>all_buckets</name><index>[<expr><name>i</name></expr>]</index></name>.<name>listeners</name> = <name><name>listen_buckets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>max_buckets</name></name> &lt; <name>num_buckets</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>new_max</name></decl>, *<decl><type ref="prev"/><name>new_ptr</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>new_max</name> = <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>max_buckets</name></name> * 2</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>new_max</name> &lt; <name>num_buckets</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>new_max</name> = <name>num_buckets</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>new_ptr</name> = (<name>int</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>ap_pglobal</name></expr></argument>, <argument><expr><name>new_max</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_ptr</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name></expr></argument>,
               <argument><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name></name> = <name>new_ptr</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>max_buckets</name></name> = <name>new_max</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> &lt; <name>num_buckets</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>rate_max</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
        <comment type="block">/* If new buckets are added, set their idle spawn rate to
         * the highest so far, so that they get filled as quickly
         * as the existing ones.
         */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name>rate_max</name> &lt; <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rate_max</name> = <name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <for>for (<comment type="block">/* up to date i */</comment><init>;</init> <condition><expr><name>i</name> &lt; <name>num_buckets</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>retained</name>-&gt;<name>idle_spawn_rate</name><index>[<expr><name>i</name></expr>]</index></name> = <name>rate_max</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>num_buckets</name></name> = <name>num_buckets</name></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_pre_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>no_detach</name></decl>, <decl><type ref="prev"/><name>debug</name></decl>, <decl><type ref="prev"/><name>foreground</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>userdata_key</name> <init>= <expr>"mpm_worker_module"</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>debug</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"DEBUG"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>debug</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>foreground</name> = <name>one_process</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>no_detach</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>one_process</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"ONE_PROCESS"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>no_detach</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"NO_DETACH"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>foreground</name> = <call><name>ap_exists_config_define</name><argument_list>(<argument><expr>"FOREGROUND"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>ap_mutex_register</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>AP_ACCEPT_MUTEX_TYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_LOCK_DEFAULT</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>retained</name> = <call><name>ap_retained_data_get</name><argument_list>(<argument><expr><name>userdata_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>retained</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>retained</name> = <call><name>ap_retained_data_create</name><argument_list>(<argument><expr><name>userdata_key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>retained</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name></name> = <call><name>ap_unixd_mpm_get_retained_data</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>max_daemons_limit</name></name> = -1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>mpm_state</name></name> = <name>AP_MPMQ_STARTING</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>baton</name></name> != <name>retained</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>was_graceful</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>baton</name></name> = <name>retained</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>++<name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name></expr>;</expr_stmt>

    <comment type="block">/* sigh, want this only the second time around */</comment>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 2</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>one_process</name> &amp;&amp; !<name>foreground</name></expr>)</condition><then> <block>{
            <comment type="block">/* before we detach, setup crash handlers to log to errorlog */</comment>
            <expr_stmt><expr><call><name>ap_fatal_signal_setup</name><argument_list>(<argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <call><name>apr_proc_detach</name><argument_list>(<argument><expr><name>no_detach</name> ? <name>APR_PROC_DETACH_FOREGROUND</name>
                                           : <name>APR_PROC_DETACH_DAEMONIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00299</expr></argument>)</argument_list></call>
                             "apr_proc_detach failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>parent_pid</name> = <name>ap_my_pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_listen_pre_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_daemons_to_start</name> = <name>DEFAULT_START_DAEMON</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>min_spare_threads</name> = <name>DEFAULT_MIN_FREE_DAEMON</name> * <name>DEFAULT_THREADS_PER_CHILD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>max_spare_threads</name> = <name>DEFAULT_MAX_FREE_DAEMON</name> * <name>DEFAULT_THREADS_PER_CHILD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>server_limit</name> = <name>DEFAULT_SERVER_LIMIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>thread_limit</name> = <name>DEFAULT_THREAD_LIMIT</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_daemons_limit</name> = <name>server_limit</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>threads_per_child</name> = <name>DEFAULT_THREADS_PER_CHILD</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>max_workers</name> = <name>ap_daemons_limit</name> * <name>threads_per_child</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>had_healthy_child</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>ap_extended_status</name> = 0</expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>worker_check_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>startup</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* the reverse of pre_config, we want this only the first time around */</comment>
    <if>if <condition>(<expr><name><name>retained</name>-&gt;<name>mpm</name>-&gt;<name>module_loads</name></name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>startup</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>server_limit</name> &gt; <name>MAX_SERVER_LIMIT</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00300</expr></argument>)</argument_list></call>
                         "WARNING: ServerLimit of %d exceeds compile-time "
                         "limit of %d servers, decreasing to %d."</expr></argument>,
                         <argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00301</expr></argument>)</argument_list></call>
                         "ServerLimit of %d exceeds compile-time limit "
                         "of %d, decreasing to match"</expr></argument>,
                         <argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name>MAX_SERVER_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>server_limit</name> = <name>MAX_SERVER_LIMIT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>server_limit</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00302</expr></argument>)</argument_list></call>
                         "WARNING: ServerLimit of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00303</expr></argument>)</argument_list></call>
                         "ServerLimit of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>server_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>server_limit</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <comment type="block">/* you cannot change ServerLimit across a restart; ignore
     * any such attempts
     */</comment>
    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>first_server_limit</name></name> = <name>server_limit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>server_limit</name> != <name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* don't need a startup console version here */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00304</expr></argument>)</argument_list></call>
                     "changing ServerLimit to %d from original value of %d "
                     "not allowed during restart"</expr></argument>,
                     <argument><expr><name>server_limit</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>server_limit</name> = <name><name>retained</name>-&gt;<name>first_server_limit</name></name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name>thread_limit</name> &gt; <name>MAX_THREAD_LIMIT</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00305</expr></argument>)</argument_list></call>
                         "WARNING: ThreadLimit of %d exceeds compile-time "
                         "limit of %d threads, decreasing to %d."</expr></argument>,
                         <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00306</expr></argument>)</argument_list></call>
                         "ThreadLimit of %d exceeds compile-time limit "
                         "of %d, decreasing to match"</expr></argument>,
                         <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>MAX_THREAD_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>thread_limit</name> = <name>MAX_THREAD_LIMIT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>thread_limit</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00307</expr></argument>)</argument_list></call>
                         "WARNING: ThreadLimit of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00308</expr></argument>)</argument_list></call>
                         "ThreadLimit of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>thread_limit</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <comment type="block">/* you cannot change ThreadLimit across a restart; ignore
     * any such attempts
     */</comment>
    <if>if <condition>(<expr>!<name><name>retained</name>-&gt;<name>first_thread_limit</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>retained</name>-&gt;<name>first_thread_limit</name></name> = <name>thread_limit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>thread_limit</name> != <name><name>retained</name>-&gt;<name>first_thread_limit</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* don't need a startup console version here */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00309</expr></argument>)</argument_list></call>
                     "changing ThreadLimit to %d from original value of %d "
                     "not allowed during restart"</expr></argument>,
                     <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name><name>retained</name>-&gt;<name>first_thread_limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>thread_limit</name> = <name><name>retained</name>-&gt;<name>first_thread_limit</name></name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name>threads_per_child</name> &gt; <name>thread_limit</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00310</expr></argument>)</argument_list></call>
                         "WARNING: ThreadsPerChild of %d exceeds ThreadLimit "
                         "of %d threads, decreasing to %d. "
                         "To increase, please see the ThreadLimit directive."</expr></argument>,
                         <argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00311</expr></argument>)</argument_list></call>
                         "ThreadsPerChild of %d exceeds ThreadLimit "
                         "of %d, decreasing to match"</expr></argument>,
                         <argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>thread_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>threads_per_child</name> = <name>thread_limit</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>threads_per_child</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00312</expr></argument>)</argument_list></call>
                         "WARNING: ThreadsPerChild of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00313</expr></argument>)</argument_list></call>
                         "ThreadsPerChild of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>threads_per_child</name> = 1</expr>;</expr_stmt>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name>max_workers</name> &lt; <name>threads_per_child</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00314</expr></argument>)</argument_list></call>
                         "WARNING: MaxRequestWorkers of %d is less than "
                         "ThreadsPerChild of %d, increasing to %d. "
                         "MaxRequestWorkers must be at least as large "
                         "as the number of threads in a single server."</expr></argument>,
                         <argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00315</expr></argument>)</argument_list></call>
                         "MaxRequestWorkers of %d is less than ThreadsPerChild "
                         "of %d, increasing to match"</expr></argument>,
                         <argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>max_workers</name> = <name>threads_per_child</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>ap_daemons_limit</name> = <name>max_workers</name> / <name>threads_per_child</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>max_workers</name> % <name>threads_per_child</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>tmp_max_workers</name> <init>= <expr><name>ap_daemons_limit</name> * <name>threads_per_child</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00316</expr></argument>)</argument_list></call>
                         "WARNING: MaxRequestWorkers of %d is not an integer "
                         "multiple of ThreadsPerChild of %d, decreasing to nearest "
                         "multiple %d, for a maximum of %d servers."</expr></argument>,
                         <argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>, <argument><expr><name>tmp_max_workers</name></expr></argument>,
                         <argument><expr><name>ap_daemons_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00317</expr></argument>)</argument_list></call>
                         "MaxRequestWorkers of %d is not an integer multiple of "
                         "ThreadsPerChild of %d, decreasing to nearest "
                         "multiple %d"</expr></argument>, <argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>threads_per_child</name></expr></argument>,
                         <argument><expr><name>tmp_max_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>max_workers</name> = <name>tmp_max_workers</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>ap_daemons_limit</name> &gt; <name>server_limit</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00318</expr></argument>)</argument_list></call>
                         "WARNING: MaxRequestWorkers of %d would require %d "
                         "servers and would exceed ServerLimit of %d, decreasing to %d. "
                         "To increase, please see the ServerLimit directive."</expr></argument>,
                         <argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>, <argument><expr><name>server_limit</name></expr></argument>,
                         <argument><expr><name>server_limit</name> * <name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00319</expr></argument>)</argument_list></call>
                         "MaxRequestWorkers of %d would require %d servers and "
                         "exceed ServerLimit of %d, decreasing to %d"</expr></argument>,
                         <argument><expr><name>max_workers</name></expr></argument>, <argument><expr><name>ap_daemons_limit</name></expr></argument>, <argument><expr><name>server_limit</name></expr></argument>,
                         <argument><expr><name>server_limit</name> * <name>threads_per_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>ap_daemons_limit</name> = <name>server_limit</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* ap_daemons_to_start &gt; ap_daemons_limit checked in worker_run() */</comment>
    <if>if <condition>(<expr><name>ap_daemons_to_start</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00320</expr></argument>)</argument_list></call>
                         "WARNING: StartServers of %d not allowed, "
                         "increasing to 1."</expr></argument>, <argument><expr><name>ap_daemons_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00321</expr></argument>)</argument_list></call>
                         "StartServers of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>ap_daemons_to_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>ap_daemons_to_start</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>min_spare_threads</name> &lt; 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>startup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name> | <name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00322</expr></argument>)</argument_list></call>
                         "WARNING: MinSpareThreads of %d not allowed, "
                         "increasing to 1 to avoid almost certain server failure. "
                         "Please read the documentation."</expr></argument>, <argument><expr><name>min_spare_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00323</expr></argument>)</argument_list></call>
                         "MinSpareThreads of %d not allowed, increasing to 1"</expr></argument>,
                         <argument><expr><name>min_spare_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name>min_spare_threads</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* max_spare_threads &lt; min_spare_threads + threads_per_child
     * checked in worker_run()
     */</comment>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>worker_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Our open_logs hook function must run before the core's, or stderr
     * will be redirected to a file, and the messages won't print to the
     * console.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name><name>aszSucc</name><index>[]</index></name> <init>= <expr><block>{<expr>"core.c"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>one_process</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_hook_open_logs</name><argument_list>(<argument><expr><name>worker_open_logs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>aszSucc</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* we need to set the MPM state before other pre-config hooks use MPM query
     * to retrieve it, so register as REALLY_FIRST
     */</comment>
    <expr_stmt><expr><call><name>ap_hook_pre_config</name><argument_list>(<argument><expr><name>worker_pre_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_check_config</name><argument_list>(<argument><expr><name>worker_check_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm</name><argument_list>(<argument><expr><name>worker_run</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm_query</name><argument_list>(<argument><expr><name>worker_query</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_mpm_get_name</name><argument_list>(<argument><expr><name>worker_get_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_daemons_to_start</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ap_daemons_to_start</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_min_spare_threads</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>min_spare_threads</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_max_spare_threads</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>max_spare_threads</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_max_workers</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"MaxClients"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00324</expr></argument>)</argument_list></call>
                     "MaxClients is deprecated, use MaxRequestWorkers "
                     "instead."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>max_workers</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_threads_per_child</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>threads_per_child</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_server_limit</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>server_limit</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_thread_limit</name> <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>thread_limit</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>worker_cmds</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>LISTEN_COMMANDS</name></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"StartServers"</expr></argument>, <argument><expr><name>set_daemons_to_start</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Number of child processes launched at server startup"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MinSpareThreads"</expr></argument>, <argument><expr><name>set_min_spare_threads</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Minimum number of idle threads, to handle request spikes"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxSpareThreads"</expr></argument>, <argument><expr><name>set_max_spare_threads</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Maximum number of idle threads"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxRequestWorkers"</expr></argument>, <argument><expr><name>set_max_workers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Maximum number of threads alive at the same time"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MaxClients"</expr></argument>, <argument><expr><name>set_max_workers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Deprecated name of MaxRequestWorkers"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ThreadsPerChild"</expr></argument>, <argument><expr><name>set_threads_per_child</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Number of threads each child creates"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ServerLimit"</expr></argument>, <argument><expr><name>set_server_limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Maximum number of child processes for this run of Apache"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"ThreadLimit"</expr></argument>, <argument><expr><name>set_thread_limit</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
  <argument><expr>"Maximum number of worker threads per child process for this run of Apache - Upper limit for ThreadsPerChild"</expr></argument>)</argument_list></call></expr>,
<expr><name>AP_GRACEFUL_SHUTDOWN_TIMEOUT_COMMAND</name></expr>,
<expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>mpm_worker</name></expr></argument>)</argument_list></call> = <block>{
    <expr><name>MPM20_MODULE_STUFF</name></expr>,
    <expr><name>NULL</name></expr>,                       <comment type="block">/* hook to run before apache parses args */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* create per-directory config structure */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* merge per-directory config structures */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* create per-server config structure */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* merge per-server config structures */</comment>
    <expr><name>worker_cmds</name></expr>,                <comment type="block">/* command apr_table_t */</comment>
    <expr><name>worker_hooks</name></expr>                <comment type="block">/* register_hooks */</comment>
}</block></expr>;</expr_stmt>

</unit>
