<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/protocol.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * protocol.c --- routines which directly communicate with the client.
 *
 * Code originally by Rob McCool; much redone by Robert S. Thau
 * and the Apache Software Foundation.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_signal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strmatch.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STDIO</name></cpp:macro></cpp:define>          <comment type="block">/* for sscanf */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_MEMFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>           <comment type="block">/* For errors detected in basic auth common
                                 * support code... */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_charset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ebcdic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STDARG_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* we know core's module_index is 0 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APLOG_MODULE_INDEX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro> <cpp:value>AP_CORE_MODULE_INDEX</cpp:value></cpp:define>

<macro><name>APR_HOOK_STRUCT</name><argument_list>(
    <argument>APR_HOOK_LINK(pre_read_request)
    APR_HOOK_LINK(post_read_request)
    APR_HOOK_LINK(log_transaction)
    APR_HOOK_LINK(http_scheme)
    APR_HOOK_LINK(default_port)
    APR_HOOK_LINK(note_auth_failure)
    APR_HOOK_LINK(protocol_propose)
    APR_HOOK_LINK(protocol_switch)
    APR_HOOK_LINK(protocol_get)</argument>
)</argument_list></macro>

<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <name>ap_filter_rec_t</name> *</type><name>ap_old_write_func</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* Patterns to match in ap_make_content_type() */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>needcset</name><index>[]</index></name> <init>= <expr><block>{
    <expr>"text/plain"</expr>,
    <expr>"text/html"</expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>apr_strmatch_pattern</name> **</type><name>needcset_patterns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>apr_strmatch_pattern</name> *</type><name>charset_pattern</name></decl>;</decl_stmt>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_setup_make_content_type</name><argument_list>(<argument>apr_pool_t *pool</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>needcset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <continue>continue;</continue>
    }</block></for>
    <expr_stmt><expr><name>needcset_patterns</name> = (const <name>apr_strmatch_pattern</name> **)
        <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>(<name>i</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>apr_strmatch_pattern</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>needcset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>needcset_patterns</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>apr_strmatch_precompile</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>needcset</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>needcset_patterns</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>charset_pattern</name> = <call><name>apr_strmatch_precompile</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"charset="</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<comment type="block">/*
 * Builds the content-type that should be sent to the client from the
 * content-type specified.  The following rules are followed:
 *    - if type is NULL or "", return NULL (do not set content-type).
 *    - if charset adding is disabled, stop processing and return type.
 *    - then, if there are no parameters on type, add the default charset
 *    - return type
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro><macro><name>ap_make_content_type</name><argument_list>(<argument>request_rec *r</argument>, <argument>const char *type</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_strmatch_pattern</name> **</type><name>pcset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_dir_config</name> *</type><name>conf</name> <init>=
        <expr>(<name>core_dir_config</name> *)<call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_request_config</name> *</type><name>request_conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>type_len</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>type</name> || *<name>type</name> == '\0'</expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>add_default_charset</name></name> != <name>ADD_DEFAULT_CHARSET_ON</name></expr>)</condition><then> <block>{
        <return>return <expr><name>type</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>request_conf</name> = <call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>request_conf</name>-&gt;<name>suppress_charset</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>type</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>type_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>apr_strmatch</name><argument_list>(<argument><expr><name>charset_pattern</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>type_len</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* already has parameter, do nothing */</comment>
        <comment type="block">/* XXX we don't check the validity */</comment>
        <empty_stmt>;</empty_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* see if it makes sense to add the charset. At present,
         * we only add it if the Content-type is one of needcset[]
         */</comment>
        <for>for (<init><expr><name>pcset</name> = <name>needcset_patterns</name></expr>;</init> <condition><expr>*<name>pcset</name></expr> ;</condition> <incr><expr><name>pcset</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>apr_strmatch</name><argument_list>(<argument><expr>*<name>pcset</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>type_len</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type>struct <name>iovec</name></type> <name><name>concat</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>concat</name><index>[<expr>0</expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name>type</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>concat</name><index>[<expr>0</expr>]</index></name>.<name>iov_len</name> = <name>type_len</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>concat</name><index>[<expr>1</expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)"; charset="</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>concat</name><index>[<expr>1</expr>]</index></name>.<name>iov_len</name> = <sizeof>sizeof<argument_list>(<argument><expr>"; charset="</expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>concat</name><index>[<expr>2</expr>]</index></name>.<name>iov_base</name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name><name>conf</name>-&gt;<name>add_default_charset_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>concat</name><index>[<expr>2</expr>]</index></name>.<name>iov_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>conf</name>-&gt;<name>add_default_charset_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>type</name> = <call><name>apr_pstrcatv</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>concat</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
    }</block></else></if>

    <return>return <expr><name>type</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_set_content_length</name><argument_list>(<argument>request_rec *r</argument>, <argument>apr_off_t clength</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><name><name>r</name>-&gt;<name>clength</name></name> = <name>clength</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>,
                   <argument><expr><call><name>apr_off_t_toa</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>clength</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<comment type="block">/*
 * Return the latest rational time from a request/mtime (modification time)
 * pair.  We return the mtime unless it's in the future, in which case we
 * return the current time.  We use the request time as a reference in order
 * to limit the number of calls to time().  We don't check for futurosity
 * unless the mtime is at least as new as the reference.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_time_t</argument>)</argument_list></macro> <macro><name>ap_rationalize_mtime</name><argument_list>(<argument>request_rec *r</argument>, <argument>apr_time_t mtime</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>now</name></decl>;</decl_stmt>

    <comment type="block">/* For all static responses, it's almost certain that the file was
     * last modified before the beginning of the request.  So there's
     * no reason to call time(NULL) again.  But if the response has been
     * created on demand, then it might be newer than the time the request
     * started.  In this event we really have to call time(NULL) again
     * so that we can give the clients the most accurate Last-Modified.  If we
     * were given a time in the future, we return the current time - the
     * Last-Modified can't be in the future.
     */</comment>
    <expr_stmt><expr><name>now</name> = (<name>mtime</name> &lt; <name><name>r</name>-&gt;<name>request_time</name></name>) ? <name><name>r</name>-&gt;<name>request_time</name></name> : <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>mtime</name> &gt; <name>now</name>) ? <name>now</name> : <name>mtime</name></expr>;</return>
}</block>

<comment type="block">/* Get a line of protocol input, including any continuation lines
 * caused by MIME folding (or broken clients) if fold != 0, and place it
 * in the buffer s, of size n bytes, without the ending newline.
 * 
 * Pulls from r-&gt;proto_input_filters instead of r-&gt;input_filters for
 * stricter protocol adherence and better input filter behavior during
 * chunked trailer processing (for http).
 *
 * If s is NULL, ap_rgetline_core will allocate necessary memory from r-&gt;pool.
 *
 * Returns APR_SUCCESS if there are no problems and sets *read to be
 * the full length of s.
 *
 * APR_ENOSPC is returned if there is not enough buffer space.
 * Other errors may be returned on other errors.
 *
 * The [CR]LF are *not* returned in the buffer.  Therefore, a *read of 0
 * indicates that an empty line was read.
 *
 * Notes: Because the buffer uses 1 char for NUL, the most we can return is
 *        (n - 1) actual characters.
 *
 *        If no LF is detected on the last line due to a dropped connection
 *        or a full buffer, that's considered an error.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_rgetline_core</name><argument_list>(<argument>char **s</argument>, <argument>apr_size_t n</argument>,
                                          <argument>apr_size_t *read</argument>, <argument>request_rec *r</argument>,
                                          <argument>int flags</argument>, <argument>apr_bucket_brigade *bb</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_handled</name> <init>= <expr>0</expr></init>, <name>current_alloc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>pos</name></decl>, *<decl><type ref="prev"/><name>last_char</name> <init>= <expr>*<name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>do_alloc</name> <init>= <expr>(*<name>s</name> == <name>NULL</name>)</expr></init>, <name>saw_eos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fold</name> <init>= <expr><name>flags</name> &amp; <name>AP_GETLINE_FOLD</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>crlf</name> <init>= <expr><name>flags</name> &amp; <name>AP_GETLINE_CRLF</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Initialize last_char as otherwise a random value will be compared
     * against APR_ASCII_LF at the end of the loop if bb only contains
     * zero-length buckets.
     */</comment>
    <if>if <condition>(<expr><name>last_char</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>last_char</name> = '\0'</expr>;</expr_stmt></then></if>

    <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>proto_input_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>AP_MODE_GETLINE</name></expr></argument>,
                            <argument><expr><name>APR_BLOCK_READ</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Something horribly wrong happened.  Someone didn't block! 
         * (this also happens at the end of each keepalive connection)
         */</comment>
        <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
        }</block></then></if>

        <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

            <comment type="block">/* If we see an EOS, don't bother doing anything more. */</comment>
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>saw_eos</name> = 1</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
                <comment type="block">/* no use attempting a zero-byte alloc (hurts when
                 * using --with-efence --enable-pool-debug) or
                 * doing any of the other logic either
                 */</comment>
                <continue>continue;</continue>
            }</block></then></if>

            <comment type="block">/* Would this overrun our buffer?  If so, we'll die. */</comment>
            <if>if <condition>(<expr><name>n</name> &lt; <name>bytes_handled</name> + <name>len</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>read</name> = <name>bytes_handled</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>*<name>s</name></expr>)</condition><then> <block>{
                    <comment type="block">/* ensure this string is NUL terminated */</comment>
                    <if>if <condition>(<expr><name>bytes_handled</name> &gt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr>(*<name>s</name>)<index>[<expr><name>bytes_handled</name>-1</expr>]</index> = '\0'</expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr>(*<name>s</name>)<index>[<expr>0</expr>]</index> = '\0'</expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then></if>
                <return>return <expr><name>APR_ENOSPC</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Do we have to handle the allocation ourselves? */</comment>
            <if>if <condition>(<expr><name>do_alloc</name></expr>)</condition><then> <block>{
                <comment type="block">/* We'll assume the common case where one bucket is enough. */</comment>
                <if>if <condition>(<expr>!*<name>s</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>current_alloc</name> = <name>len</name></expr>;</expr_stmt>
                    <expr_stmt><expr>*<name>s</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>current_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>bytes_handled</name> + <name>len</name> &gt; <name>current_alloc</name></expr>)</condition><then> <block>{
                    <comment type="block">/* Increase the buffer size */</comment>
                    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>new_size</name> <init>= <expr><name>current_alloc</name> * 2</expr></init></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name> *</type><name>new_buffer</name></decl>;</decl_stmt>

                    <if>if <condition>(<expr><name>bytes_handled</name> + <name>len</name> &gt; <name>new_size</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>new_size</name> = (<name>bytes_handled</name> + <name>len</name>) * 2</expr>;</expr_stmt>
                    }</block></then></if>

                    <expr_stmt><expr><name>new_buffer</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* Copy what we already had. */</comment>
                    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_buffer</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>bytes_handled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>current_alloc</name> = <name>new_size</name></expr>;</expr_stmt>
                    <expr_stmt><expr>*<name>s</name> = <name>new_buffer</name></expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></then></if>

            <comment type="block">/* Just copy the rest of the data to the end of the old buffer. */</comment>
            <expr_stmt><expr><name>pos</name> = *<name>s</name> + <name>bytes_handled</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>last_char</name> = <name>pos</name> + <name>len</name> - 1</expr>;</expr_stmt>

            <comment type="block">/* We've now processed that new data - update accordingly. */</comment>
            <expr_stmt><expr><name>bytes_handled</name> += <name>len</name></expr>;</expr_stmt>
        }</block></for>

        <comment type="block">/* If we got a full line of input, stop reading */</comment>
        <if>if <condition>(<expr><name>last_char</name> &amp;&amp; (*<name>last_char</name> == <name>APR_ASCII_LF</name>)</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>crlf</name> &amp;&amp; (<name>last_char</name> &lt;= *<name>s</name> || <name><name>last_char</name><index>[<expr>-1</expr>]</index></name> != <name>APR_ASCII_CR</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>last_char</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name>bytes_handled</name> = <name>last_char</name> - *<name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>read</name> = <name>bytes_handled</name></expr>;</expr_stmt>
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Now NUL-terminate the string at the end of the line;
     * if the last-but-one character is a CR, terminate there */</comment>
    <if>if <condition>(<expr><name>last_char</name> &gt; *<name>s</name> &amp;&amp; <name><name>last_char</name><index>[<expr>-1</expr>]</index></name> == <name>APR_ASCII_CR</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>last_char</name>--</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>last_char</name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><name>bytes_handled</name> = <name>last_char</name> - *<name>s</name></expr>;</expr_stmt>

    <comment type="block">/* If we're folding, we have more work to do.
     *
     * Note that if an EOS was seen, we know we can't have another line.
     */</comment>
    <if>if <condition>(<expr><name>fold</name> &amp;&amp; <name>bytes_handled</name> &amp;&amp; !<name>saw_eos</name></expr>)</condition><then> <block>{
        <for>for (<init>;</init><condition>;</condition><incr/>) <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

            <comment type="block">/* Clear the temp brigade for this filter read. */</comment>
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* We only care about the first byte. */</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>proto_input_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>AP_MODE_SPECULATIVE</name></expr></argument>,
                                <argument><expr><name>APR_BLOCK_READ</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>

            <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* If we see an EOS, don't bother doing anything more. */</comment>
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>

            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Found one, so call ourselves again to get the next line.
             *
             * FIXME: If the folding line is completely blank, should we
             * stop folding?  Does that require also looking at the next
             * char?
             */</comment>
            <comment type="block">/* When we call destroy, the buckets are deleted, so save that
             * one character we need.  This simplifies our execution paths
             * at the cost of one character read.
             */</comment>
            <expr_stmt><expr><name>c</name> = *<name>str</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>c</name> == <name>APR_ASCII_BLANK</name> || <name>c</name> == <name>APR_ASCII_TAB</name></expr>)</condition><then> <block>{
                <comment type="block">/* Do we have enough space? We may be full now. */</comment>
                <if>if <condition>(<expr><name>bytes_handled</name> &gt;= <name>n</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr>*<name>read</name> = <name>n</name></expr>;</expr_stmt>
                    <comment type="block">/* ensure this string is terminated */</comment>
                    <expr_stmt><expr>(*<name>s</name>)<index>[<expr><name>n</name>-1</expr>]</index> = '\0'</expr>;</expr_stmt>
                    <return>return <expr><name>APR_ENOSPC</name></expr>;</return>
                }</block></then>
                <else>else <block>{
                    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>next_size</name></decl>, <decl><type ref="prev"/><name>next_len</name></decl>;</decl_stmt>
                    <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>

                    <comment type="block">/* If we're doing the allocations for them, we have to
                     * give ourselves a NULL and copy it on return.
                     */</comment>
                    <if>if <condition>(<expr><name>do_alloc</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>tmp</name> = <name>NULL</name></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <comment type="block">/* We're null terminated. */</comment>
                        <expr_stmt><expr><name>tmp</name> = <name>last_char</name></expr>;</expr_stmt>
                    }</block></else></if>

                    <expr_stmt><expr><name>next_size</name> = <name>n</name> - <name>bytes_handled</name></expr>;</expr_stmt>

                    <expr_stmt><expr><name>rv</name> = <call><name>ap_rgetline_core</name><argument_list>(<argument><expr>&amp;<name>tmp</name></expr></argument>, <argument><expr><name>next_size</name></expr></argument>,
                                          <argument><expr>&amp;<name>next_len</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <return>return <expr><name>rv</name></expr>;</return>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>do_alloc</name> &amp;&amp; <name>next_len</name> &gt; 0</expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>char</name> *</type><name>new_buffer</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>new_size</name> <init>= <expr><name>bytes_handled</name> + <name>next_len</name> + 1</expr></init></decl>;</decl_stmt>

                        <comment type="block">/* we need to alloc an extra byte for a null */</comment>
                        <expr_stmt><expr><name>new_buffer</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* Copy what we already had. */</comment>
                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_buffer</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>, <argument><expr><name>bytes_handled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <comment type="block">/* copy the new line, including the trailing null */</comment>
                        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_buffer</name> + <name>bytes_handled</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>next_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr>*<name>s</name> = <name>new_buffer</name></expr>;</expr_stmt>
                    }</block></then></if>

                    <expr_stmt><expr><name>last_char</name> += <name>next_len</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>bytes_handled</name> += <name>next_len</name></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then>
            <else>else <block>{ <comment type="block">/* next character is not tab or space */</comment>
                <break>break;</break>
            }</block></else></if>
        }</block></for>
    }</block></then></if>
    <expr_stmt><expr>*<name>read</name> = <name>bytes_handled</name></expr>;</expr_stmt>

    <comment type="block">/* PR#43039: We shouldn't accept NULL bytes within the line */</comment>
    <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call> &lt; <name>bytes_handled</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_rgetline</name><argument_list>(<argument>char **s</argument>, <argument>apr_size_t n</argument>,
                                     <argument>apr_size_t *read</argument>, <argument>request_rec *r</argument>,
                                     <argument>int fold</argument>, <argument>apr_bucket_brigade *bb</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* on ASCII boxes, ap_rgetline is a macro which simply invokes
     * ap_rgetline_core with the same parms
     *
     * on EBCDIC boxes, each complete http protocol input line needs to be
     * translated into the code page used by the compiler.  Since
     * ap_rgetline_core uses recursion, we do the translation in a wrapper
     * function to ensure that each input character gets translated only once.
     */</comment>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_rgetline_core</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>read</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>fold</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_xlate_proto_from_ascii</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>, <argument><expr>*<name>read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_getline</name><argument_list>(<argument>char *s</argument>, <argument>int n</argument>, <argument>request_rec *r</argument>, <argument>int flags</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>tmp_s</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmp_bb</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>tmp_bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>ap_rgetline</name><argument_list>(<argument><expr>&amp;<name>tmp_s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Map the out-of-space condition to the old API. */</comment>
    <if>if <condition>(<expr><name>rv</name> == <name>APR_ENOSPC</name></expr>)</condition><then> <block>{
        <return>return <expr><name>n</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Anything else is just bad. */</comment>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <return>return <expr>(<name>int</name>)<name>len</name></expr>;</return>
}</block>

<comment type="block">/* parse_uri: break apart the uri
 * Side Effects:
 * - sets r-&gt;args to rest after '?' (or NULL if no '?')
 * - sets r-&gt;uri to request uri (without r-&gt;args part)
 * - sets r-&gt;hostname (if not set already) from request (scheme://host:port)
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_parse_uri</name><argument_list>(<argument>request_rec *r</argument>, <argument>const char *uri</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>HTTP_OK</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>unparsed_uri</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* http://issues.apache.org/bugzilla/show_bug.cgi?id=31875
     * http://issues.apache.org/bugzilla/show_bug.cgi?id=28450
     *
     * This is not in fact a URI, it's a path.  That matters in the
     * case of a leading double-slash.  We need to resolve the issue
     * by normalizing that out before treating it as a URI.
     */</comment>
    <while>while <condition>(<expr>(<name><name>uri</name><index>[<expr>0</expr>]</index></name> == '/') &amp;&amp; (<name><name>uri</name><index>[<expr>1</expr>]</index></name> == '/')</expr>)</condition> <block>{
        <expr_stmt><expr>++<name>uri</name></expr> ;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_CONNECT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>apr_uri_parse_hostinfo</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr>&amp;<name><name>r</name>-&gt;<name>parsed_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>status</name> = <call><name>apr_uri_parse</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr>&amp;<name><name>r</name>-&gt;<name>parsed_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <comment type="block">/* if it has a scheme we may need to do absoluteURI vhost stuff */</comment>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>parsed_uri</name>.<name>scheme</name></name>
            &amp;&amp; !<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>parsed_uri</name>.<name>scheme</name></name></expr></argument>, <argument><expr><call><name>ap_http_scheme</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>hostname</name></name> = <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>hostname</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_CONNECT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>hostname</name></name> = <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>hostname</name></name></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <expr_stmt><expr><name><name>r</name>-&gt;<name>args</name></name> = <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>query</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>uri</name></name> = <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>path</name></name> ? <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>path</name></name>
                 : <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <comment type="block">/* Handle path translations for OS/2 and plug security hole.
         * This will prevent "http://www.wherever.com/..\..\/" from
         * returning a directory for the root drive.
         */</comment>
        <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>x</name></decl>;</decl_stmt>

            <for>for (<init><expr><name>x</name> = <name><name>r</name>-&gt;<name>uri</name></name></expr>;</init> <condition><expr>(<name>x</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>;</condition> <incr/>)
                <expr_stmt><expr>*<name>x</name> = '/'</expr>;</expr_stmt></for>
        }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* OS2 || WIN32 */</comment>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>args</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>hostname</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>             <comment type="block">/* set error status */</comment>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>uri</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block>

<comment type="block">/* get the length of the field name for logging, but no more than 80 bytes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_NAME_MAX_LEN</name></cpp:macro> <cpp:value>80</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type> <name>field_name_len</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>field</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>end</name> == <name>NULL</name> || <name>end</name> - <name>field</name> &gt; <name>LOG_NAME_MAX_LEN</name></expr>)</condition><then>
        <return>return <expr><name>LOG_NAME_MAX_LEN</name></expr>;</return></then></if>
    <return>return <expr><name>end</name> - <name>field</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_request_line</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <enum>enum <block>{
        <decl><name>rrl_none</name></decl>, <decl><name>rrl_badmethod</name></decl>, <decl><name>rrl_badwhitespace</name></decl>, <decl><name>rrl_excesswhitespace</name></decl>,
        <decl><name>rrl_missinguri</name></decl>, <decl><name>rrl_baduri</name></decl>, <decl><name>rrl_badprotocol</name></decl>, <decl><name>rrl_trailingtext</name></decl>,
        <decl><name>rrl_badmethod09</name></decl>, <decl><name>rrl_reject09</name></decl>
    }</block> <decl><name>deferred_error</name> <init>= <expr><name>rrl_none</name></expr></init></decl>;</enum>
    <decl_stmt><decl><type><name>char</name> *</type><name>ll</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_blank_lines</name> <init>= <expr><name>DEFAULT_LIMIT_BLANK_LINES</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>strict</name> <init>= <expr>(<name><name>conf</name>-&gt;<name>http_conformance</name></name> != <name>AP_HTTP_CONFORMANCE_UNSAFE</name>)</expr></init></decl>;</decl_stmt>

    <comment type="block">/* Read past empty lines until we get a real request line,
     * a read error, the connection closes (EOF), or we timeout.
     *
     * We skip empty lines because browsers have to tack a CRLF on to the end
     * of POSTs to support old CERN webservers.  But note that we may not
     * have flushed any previous response completely to the client yet.
     * We delay the flush as long as possible so that we can improve
     * performance for clients that are pipelining requests.  If a request
     * is pipelined then we won't block during the (implicit) read() below.
     * If the requests aren't pipelined, then the client is still waiting
     * for the final buffer flush from us, and we will block in the implicit
     * read().  B_SAFEREAD ensures that the BUFF layer flushes if it will
     * have to block during a read.
     */</comment>

    <do>do <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

        <comment type="block">/* ensure ap_rgetline allocates memory each time thru the loop
         * if there are empty lines
         */</comment>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>the_request</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ap_rgetline</name><argument_list>(<argument><expr>&amp;(<name><name>r</name>-&gt;<name>the_request</name></name>)</expr></argument>, <argument><expr><call>(<name>apr_size_t</name>)<argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_line</name></name> + 2</expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>strict</name> ? <name>AP_GETLINE_CRLF</name> : 0</expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>request_time</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* ap_rgetline returns APR_ENOSPC if it fills up the
             * buffer before finding the end-of-line.  This is only going to
             * happen if it exceeds the configured limit for a request-line.
             */</comment>
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOSPC</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_REQUEST_URI_TOO_LARGE</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_TIMEUP</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_REQUEST_TIME_OUT</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_EINVAL</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
            }</block></then></if></else></if></else></if>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>protocol</name></name>  = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"HTTP/1.0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
    }</block> while <condition>(<expr>(<name>len</name> &lt;= 0) &amp;&amp; (--<name>num_blank_lines</name> &gt;= 0)</expr>)</condition>;</do>

    <if>if <condition>(<expr><call><name>APLOGrtrace5</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE5</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                      <argument><expr>"Request received from client: %s"</expr></argument>,
                      <argument><expr><call><name>ap_escape_logitem</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>the_request</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>request_time</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>method</name></name> = <name><name>r</name>-&gt;<name>the_request</name></name></expr>;</expr_stmt>

    <comment type="block">/* If there is whitespace before a method, skip it and mark in error */</comment>
    <if>if <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badwhitespace</name></expr>;</expr_stmt> 
        <for>for ( <init>;</init> <condition><expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name><name>r</name>-&gt;<name>method</name></name></expr></incr>)
            <empty_stmt>;</empty_stmt></for> 
    }</block></then></if>

    <comment type="block">/* Scan the method up to the next whitespace, ensure it contains only
     * valid http-token characters, otherwise mark in error
     */</comment>
    <if>if <condition>(<expr><name>strict</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ll</name> = (<name>char</name>*) <call><name>ap_scan_http_token</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>ll</name> = (<name>char</name>*) <call><name>ap_scan_vchar_obstext</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr>((<name>ll</name> == <name><name>r</name>-&gt;<name>method</name></name>) || (*<name>ll</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ll</name></expr></argument>)</argument_list></call>))
            &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badmethod</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ll</name> = <call><name>strpbrk</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr>"\t\n\v\f\r "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Verify method terminated with a single SP, or mark as specific error */</comment>
    <if>if <condition>(<expr>!<name>ll</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then>
            <expr_stmt><expr><name>deferred_error</name> = <name>rrl_missinguri</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>protocol</name></name> = <name>uri</name> = ""</expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
        <goto>goto <name>rrl_done</name>;</goto>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>strict</name> &amp;&amp; <name><name>ll</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>ll</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>
             &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>deferred_error</name> = <name>rrl_excesswhitespace</name></expr>;</expr_stmt> 
    }</block></then></if></else></if>

    <comment type="block">/* Advance uri pointer over leading whitespace, NUL terminate the method
     * If non-SP whitespace is encountered, mark as specific error
     */</comment>
    <for>for (<init><expr><name>uri</name> = <name>ll</name></expr>;</init> <condition><expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>uri</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>uri</name></expr></incr>) 
        <if>if <condition>(<expr>*<name>uri</name> != ' ' &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then>
            <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badwhitespace</name></expr>;</expr_stmt></then></if></for> 
    <expr_stmt><expr>*<name>ll</name> = '\0'</expr>;</expr_stmt>

    <if>if <condition>(<expr>!*<name>uri</name> &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then>
        <expr_stmt><expr><name>deferred_error</name> = <name>rrl_missinguri</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* Scan the URI up to the next whitespace, ensure it contains no raw
     * control characters, otherwise mark in error
     */</comment>
    <expr_stmt><expr><name>ll</name> = (<name>char</name>*) <call><name>ap_scan_vchar_obstext</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ll</name> == <name>uri</name> || (*<name>ll</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ll</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>deferred_error</name> = <name>rrl_baduri</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ll</name> = <call><name>strpbrk</name><argument_list>(<argument><expr><name>ll</name></expr></argument>, <argument><expr>"\t\n\v\f\r "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Verify URI terminated with a single SP, or mark as specific error */</comment>
    <if>if <condition>(<expr>!<name>ll</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>protocol</name></name> = ""</expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
        <goto>goto <name>rrl_done</name>;</goto>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>strict</name> &amp;&amp; <name><name>ll</name><index>[<expr>0</expr>]</index></name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>ll</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>
             &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>deferred_error</name> = <name>rrl_excesswhitespace</name></expr>;</expr_stmt> 
    }</block></then></if></else></if>

    <comment type="block">/* Advance protocol pointer over leading whitespace, NUL terminate the uri
     * If non-SP whitespace is encountered, mark as specific error
     */</comment>
    <for>for (<init><expr><name><name>r</name>-&gt;<name>protocol</name></name> = <name>ll</name></expr>;</init> <condition><expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name><name>r</name>-&gt;<name>protocol</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name><name>r</name>-&gt;<name>protocol</name></name></expr></incr>) 
        <if>if <condition>(<expr>*<name><name>r</name>-&gt;<name>protocol</name></name> != ' ' &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then>
            <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badwhitespace</name></expr>;</expr_stmt></then></if></for> 
    <expr_stmt><expr>*<name>ll</name> = '\0'</expr>;</expr_stmt>

    <comment type="block">/* Scan the protocol up to the next whitespace, validation comes later */</comment>
    <if>if <condition>(<expr>!(<name>ll</name> = (<name>char</name>*) <call><name>ap_scan_vchar_obstext</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>rrl_done</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name>len</name> = <name>ll</name> - <name><name>r</name>-&gt;<name>protocol</name></name></expr>;</expr_stmt>

    <comment type="block">/* Advance over trailing whitespace, if found mark in error,
     * determine if trailing text is found, unconditionally mark in error,
     * finally NUL terminate the protocol string
     */</comment>
    <if>if <condition>(<expr>*<name>ll</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ll</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badprotocol</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>strict</name> &amp;&amp; *<name>ll</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>deferred_error</name> = <name>rrl_excesswhitespace</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <for>for ( <init>;</init> <condition><expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>ll</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>ll</name></expr></incr>)
            <if>if <condition>(<expr>*<name>ll</name> != ' ' &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then>
                <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badwhitespace</name></expr>;</expr_stmt></then></if></for> 
        <if>if <condition>(<expr>*<name>ll</name> &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then>
            <expr_stmt><expr><name>deferred_error</name> = <name>rrl_trailingtext</name></expr>;</expr_stmt></then></if>
    }</block></else></if></else></if>
    <expr_stmt><expr>*((<name>char</name> *)<name><name>r</name>-&gt;<name>protocol</name></name> + <name>len</name>) = '\0'</expr>;</expr_stmt>

<label><name>rrl_done</name>:</label>
    <comment type="block">/* For internal integrity and palloc efficiency, reconstruct the_request
     * in one palloc, using only single SP characters, per spec.
     */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>the_request</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr>*<name>uri</name> ? " " : <name>NULL</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>,
                                 <argument><expr>*<name><name>r</name>-&gt;<name>protocol</name></name> ? " " : <name>NULL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>protocol</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>len</name> == 8
            &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>0</expr>]</index></name> == 'H' &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>1</expr>]</index></name> == 'T'
            &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>2</expr>]</index></name> == 'T' &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>3</expr>]</index></name> == 'P'
            &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>4</expr>]</index></name> == '/' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>5</expr>]</index></name></expr></argument>)</argument_list></call>
            &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>6</expr>]</index></name> == '.' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>7</expr>]</index></name></expr></argument>)</argument_list></call>
            &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>5</expr>]</index></name> != '0'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>assbackwards</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>5</expr>]</index></name> - '0'</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>7</expr>]</index></name> - '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>len</name> == 8
                 &amp;&amp; (<name><name>r</name>-&gt;<name>protocol</name><index>[<expr>0</expr>]</index></name> == 'H' || <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>0</expr>]</index></name> == 'h')
                 &amp;&amp; (<name><name>r</name>-&gt;<name>protocol</name><index>[<expr>1</expr>]</index></name> == 'T' || <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>1</expr>]</index></name> == 't')
                 &amp;&amp; (<name><name>r</name>-&gt;<name>protocol</name><index>[<expr>2</expr>]</index></name> == 'T' || <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>2</expr>]</index></name> == 't')
                 &amp;&amp; (<name><name>r</name>-&gt;<name>protocol</name><index>[<expr>3</expr>]</index></name> == 'P' || <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>3</expr>]</index></name> == 'p')
                 &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>4</expr>]</index></name> == '/' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>5</expr>]</index></name></expr></argument>)</argument_list></call>
                 &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>6</expr>]</index></name> == '.' &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>7</expr>]</index></name></expr></argument>)</argument_list></call>
                 &amp;&amp; <name><name>r</name>-&gt;<name>protocol</name><index>[<expr>5</expr>]</index></name> != '0'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>assbackwards</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>5</expr>]</index></name> - '0'</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>7</expr>]</index></name> - '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>strict</name> &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then>
            <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badprotocol</name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name>*)<name><name>r</name>-&gt;<name>protocol</name></name></expr></argument>, <argument><expr>"HTTP"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>r</name>-&gt;<name>protocol</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Defer setting the r-&gt;protocol string till error msg is composed */</comment>
        <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then>
            <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badprotocol</name></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>assbackwards</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>protocol</name></name>  = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"HTTP/0.9"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>

    <comment type="block">/* Determine the method_number and parse the uri prior to invoking error
     * handling, such that these fields are available for substitution
     */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>method_number</name></name> = <call><name>ap_method_number_of</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_GET</name> &amp;&amp; <name><name>r</name>-&gt;<name>method</name><index>[<expr>0</expr>]</index></name> == 'H'</expr>)</condition><then>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>header_only</name></name> = 1</expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>ap_parse_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* With the request understood, we can consider HTTP/0.9 specific errors */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proto_num</name></name> == <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call> &amp;&amp; <name>deferred_error</name> == <name>rrl_none</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>http09_enable</name></name> == <name>AP_HTTP09_DISABLE</name></expr>)</condition><then>
            <expr_stmt><expr><name>deferred_error</name> = <name>rrl_reject09</name></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>strict</name> &amp;&amp; (<name><name>r</name>-&gt;<name>method_number</name></name> != <name>M_GET</name> || <name><name>r</name>-&gt;<name>header_only</name></name>)</expr>)</condition><then>
            <expr_stmt><expr><name>deferred_error</name> = <name>rrl_badmethod09</name></expr>;</expr_stmt></then></if></else></if>
    }</block></then></if>

    <comment type="block">/* Now that the method, uri and protocol are all processed,
     * we can safely resume any deferred error reporting
     */</comment>
    <if>if <condition>(<expr><name>deferred_error</name> != <name>rrl_none</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_badmethod</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03445</expr></argument>)</argument_list></call>
                          "HTTP Request Line; Invalid method token: '%.*s'"</expr></argument>,
                          <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_badmethod09</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03444</expr></argument>)</argument_list></call>
                          "HTTP Request Line; Invalid method token: '%.*s'"
                          " (only GET is allowed for HTTP/0.9 requests)"</expr></argument>,
                          <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_missinguri</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03446</expr></argument>)</argument_list></call>
                          "HTTP Request Line; Missing URI"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_baduri</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03454</expr></argument>)</argument_list></call>
                          "HTTP Request Line; URI incorrectly encoded: '%.*s'"</expr></argument>,
                          <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_badwhitespace</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03447</expr></argument>)</argument_list></call>
                          "HTTP Request Line; Invalid whitespace"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_excesswhitespace</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03448</expr></argument>)</argument_list></call>
                          "HTTP Request Line; Excess whitespace "
                          "(disallowed by HttpProtocolOptions Strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_trailingtext</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03449</expr></argument>)</argument_list></call>
                          "HTTP Request Line; Extraneous text found '%.*s' "
                          "(perhaps whitespace was injected?)"</expr></argument>,
                          <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_reject09</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02401</expr></argument>)</argument_list></call>
                          "HTTP Request Line; Rejected HTTP/0.9 request"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><name>deferred_error</name> == <name>rrl_badprotocol</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02418</expr></argument>)</argument_list></call>
                          "HTTP Request Line; Unrecognized protocol '%.*s' "
                          "(perhaps whitespace was injected?)"</expr></argument>,
                          <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>protocol</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>protocol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
        <goto>goto <name>rrl_failed</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>http_methods</name></name> == <name>AP_HTTP_METHODS_REGISTERED</name>
            &amp;&amp; <name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_INVALID</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02423</expr></argument>)</argument_list></call>
                      "HTTP Request Line; Unrecognized HTTP method: '%.*s' "
                      "(disallowed by RegisteredMethods)"</expr></argument>,
                      <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_NOT_IMPLEMENTED</name></expr>;</expr_stmt>
        <comment type="block">/* This can't happen in an HTTP/0.9 request, we verified GET above */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>status</name></name> != <name>HTTP_OK</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03450</expr></argument>)</argument_list></call>
                      "HTTP Request Line; Unable to parse URI: '%.*s'"</expr></argument>,
                      <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>rrl_failed</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr><name>strict</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>parsed_uri</name>.<name>fragment</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* RFC3986 3.5: no fragment */</comment>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02421</expr></argument>)</argument_list></call>
                          "HTTP Request Line; URI must not contain a fragment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
            <goto>goto <name>rrl_failed</name>;</goto>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>parsed_uri</name>.<name>user</name></name> || <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>password</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02422</expr></argument>)</argument_list></call>
                          "HTTP Request Line; URI must not contain a "
                          "username/password"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
            <goto>goto <name>rrl_failed</name>;</goto>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr>1</expr>;</return>

<label><name>rrl_failed</name>:</label>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proto_num</name></name> == <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Send all parsing and protocol error response with 1.x behavior,
         * and reserve 505 errors for actual HTTP protocols presented.
         * As called out in RFC7230 3.5, any errors parsing the protocol
         * from the request line are nearly always misencoded HTTP/1.x
         * requests. Only a valid 0.9 request with no parsing errors
         * at all may be treated as a simple request, if allowed.
         */</comment>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>assbackwards</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>protocol</name></name>  = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"HTTP/1.0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>table_do_fn_check_lengths</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>r_</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name>r_</name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>value</name> == <name>NULL</name> || <name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_fieldsize</name></name> &gt;= <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr> )</condition><then>
        <return>return <expr>1</expr>;</return></then></if>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                   <argument><expr>"Size of a request header field exceeds server limit."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00560</expr></argument>)</argument_list></call> "Request "
                  "header exceeds LimitRequestFieldSize after merging: %.*s"</expr></argument>,
                  <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_get_mime_headers_core</name><argument_list>(<argument>request_rec *r</argument>, <argument>apr_bucket_brigade *bb</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>last_field</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>last_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>alloc_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>field</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fields_read</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>tmp_field</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name> <init>= <expr><call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>strict</name> <init>= <expr>(<name><name>conf</name>-&gt;<name>http_conformance</name></name> != <name>AP_HTTP_CONFORMANCE_UNSAFE</name>)</expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Read header lines until we get the empty separator line, a read error,
     * the connection closes (EOF), reach the server limit, or we timeout.
     */</comment>
    <while>while<condition>(<expr>1</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>field</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ap_rgetline</name><argument_list>(<argument><expr>&amp;<name>field</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_fieldsize</name></name> + 2</expr></argument>,
                         <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>strict</name> ? <name>AP_GETLINE_CRLF</name> : 0</expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_TIMEUP</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_REQUEST_TIME_OUT</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, 
                              <argument><expr>"Failed to read request header line %s"</expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
            }</block></else></if>

            <comment type="block">/* ap_rgetline returns APR_ENOSPC if it fills up the buffer before
             * finding the end-of-line.  This is only going to happen if it
             * exceeds the configured limit for a field size.
             */</comment>
            <if>if <condition>(<expr><name>rv</name> == <name>APR_ENOSPC</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                               <argument><expr>"Size of a request header field "
                               "exceeds server limit."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00561</expr></argument>)</argument_list></call>
                              "Request header exceeds LimitRequestFieldSize%s"
                              "%.*s"</expr></argument>,
                              <argument><expr>(<name>field</name> &amp;&amp; *<name>field</name>) ? ": " : ""</expr></argument>,
                              <argument><expr>(<name>field</name>) ? <call><name>field_name_len</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call> : 0</expr></argument>,
                              <argument><expr>(<name>field</name>) ? <name>field</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return;</return>
        }</block></then></if>

        <comment type="block">/* For all header values, and all obs-fold lines, the presence of
         * additional whitespace is a no-op, so collapse trailing whitespace
         * to save buffer allocation and optimize copy operations.
         * Do not remove the last single whitespace under any condition.
         */</comment>
        <while>while <condition>(<expr><name>len</name> &gt; 1 &amp;&amp; (<name><name>field</name><index>[<expr><name>len</name>-1</expr>]</index></name> == '\t' || <name><name>field</name><index>[<expr><name>len</name>-1</expr>]</index></name> == ' ')</expr>)</condition> <block>{
            <expr_stmt><expr><name><name>field</name><index>[<expr>--<name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
        }</block></while> 

        <if>if <condition>(<expr>*<name>field</name> == '\t' || *<name>field</name> == ' '</expr>)</condition><then> <block>{

            <comment type="block">/* Append any newly-read obs-fold line onto the preceding
             * last_field line we are processing
             */</comment>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>fold_len</name></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>last_field</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03442</expr></argument>)</argument_list></call>
                              "Line folding encountered before first"
                              " header line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name><name>field</name><index>[<expr>1</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03443</expr></argument>)</argument_list></call>
                              "Empty folded line encountered"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <comment type="block">/* Leading whitespace on an obs-fold line can be
             * similarly discarded */</comment>
            <while>while <condition>(<expr><name><name>field</name><index>[<expr>1</expr>]</index></name> == '\t' || <name><name>field</name><index>[<expr>1</expr>]</index></name> == ' '</expr>)</condition> <block>{
                <expr_stmt><expr>++<name>field</name></expr>;</expr_stmt> <expr_stmt><expr>--<name>len</name></expr>;</expr_stmt>
            }</block></while>

            <comment type="block">/* This line is a continuation of the preceding line(s),
             * so append it to the line that we've set aside.
             * Note: this uses a power-of-two allocator to avoid
             * doing O(n) allocs and using O(n^2) space for
             * continuations that span many many lines.
             */</comment>
            <expr_stmt><expr><name>fold_len</name> = <name>last_len</name> + <name>len</name> + 1</expr>;</expr_stmt> <comment type="block">/* trailing null */</comment>

            <if>if <condition>(<expr><name>fold_len</name> &gt;= <call>(<name>apr_size_t</name>)<argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_fieldsize</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                <comment type="block">/* report what we have accumulated so far before the
                 * overflow (last_field) as the field with the problem
                 */</comment>
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                               <argument><expr>"Size of a request header field "
                               "exceeds server limit."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00562</expr></argument>)</argument_list></call>
                              "Request header exceeds LimitRequestFieldSize "
                              "after folding: %.*s"</expr></argument>,
                              <argument><expr><call><name>field_name_len</name><argument_list>(<argument><expr><name>last_field</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>last_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>fold_len</name> &gt; <name>alloc_len</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>fold_buf</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>alloc_len</name> += <name>alloc_len</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>fold_len</name> &gt; <name>alloc_len</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>alloc_len</name> = <name>fold_len</name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>fold_buf</name> = (<name>char</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>alloc_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fold_buf</name></expr></argument>, <argument><expr><name>last_field</name></expr></argument>, <argument><expr><name>last_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>last_field</name> = <name>fold_buf</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>last_field</name> + <name>last_len</name></expr></argument>, <argument><expr><name>field</name></expr></argument>, <argument><expr><name>len</name> +1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* +1 for nul */</comment>
            <comment type="block">/* Replace obs-fold w/ SP per RFC 7230 3.2.4 */</comment>
            <expr_stmt><expr><name><name>last_field</name><index>[<expr><name>last_len</name></expr>]</index></name> = ' '</expr>;</expr_stmt>
            <expr_stmt><expr><name>last_len</name> += <name>len</name></expr>;</expr_stmt>

            <comment type="block">/* We've appended this obs-fold line to last_len, proceed to
             * read the next input line
             */</comment>
            <continue>continue;</continue>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>last_field</name> != <name>NULL</name></expr>)</condition><then> <block>{

            <comment type="block">/* Process the previous last_field header line with all obs-folded
             * segments already concatenated (this is not operating on the
             * most recently read input line).
             */</comment>

            <if>if <condition>(<expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_fields</name></name>
                    &amp;&amp; (++<name>fields_read</name> &gt; <name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_fields</name></name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                               <argument><expr>"The number of request header fields "
                               "exceeds this server's limit."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00563</expr></argument>)</argument_list></call>
                              "Number of request headers exceeds "
                              "LimitRequestFields"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>

            <if>if <condition>(<expr>!<name>strict</name></expr>)</condition><then>
            <block>{
                <comment type="block">/* Not Strict ('Unsafe' mode), using the legacy parser */</comment>

                <if>if <condition>(<expr>!(<name>value</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>last_field</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{ <comment type="block">/* Find ':' or */</comment>
                    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>   <comment type="block">/* abort bad request */</comment>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00564</expr></argument>)</argument_list></call>
                                  "Request header field is missing ':' "
                                  "separator: %.*s"</expr></argument>, <argument><expr>(<name>int</name>)<name>LOG_NAME_MAX_LEN</name></expr></argument>,
                                  <argument><expr><name>last_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                }</block></then></if>

                <if>if <condition>(<expr><name>value</name> == <name>last_field</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03453</expr></argument>)</argument_list></call>
                                  "Request header field name was empty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                }</block></then></if>

                <expr_stmt><expr>*<name>value</name>++ = '\0'</expr>;</expr_stmt> <comment type="block">/* NUL-terminate at colon */</comment>

                <if>if <condition>(<expr><call><name>strpbrk</name><argument_list>(<argument><expr><name>last_field</name></expr></argument>, <argument><expr>"\t\n\v\f\r "</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03452</expr></argument>)</argument_list></call>
                                  "Request header field name presented"
                                  " invalid whitespace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                }</block></then></if>

                <while>while <condition>(<expr>*<name>value</name> == ' ' || *<name>value</name> == '\t'</expr>)</condition> <block>{
                     <expr_stmt><expr>++<name>value</name></expr>;</expr_stmt>            <comment type="block">/* Skip to start of value   */</comment>
                }</block></while>

                <if>if <condition>(<expr><call><name>strpbrk</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>"\n\v\f\r"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03451</expr></argument>)</argument_list></call>
                                  "Request header field value presented"
                                  " bad whitespace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                }</block></then></if>
            }</block></then>
            <else>else <comment type="block">/* Using strict RFC7230 parsing */</comment>
            <block>{
                <comment type="block">/* Ensure valid token chars before ':' per RFC 7230 3.2.4 */</comment>
                <expr_stmt><expr><name>value</name> = (<name>char</name> *)<call><name>ap_scan_http_token</name><argument_list>(<argument><expr><name>last_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>(<name>value</name> == <name>last_field</name>) || *<name>value</name> != ':'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02426</expr></argument>)</argument_list></call>
                                  "Request header field name is malformed: "
                                  "%.*s"</expr></argument>, <argument><expr>(<name>int</name>)<name>LOG_NAME_MAX_LEN</name></expr></argument>, <argument><expr><name>last_field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                }</block></then></if>

                <expr_stmt><expr>*<name>value</name>++ = '\0'</expr>;</expr_stmt> <comment type="block">/* NUL-terminate last_field name at ':' */</comment>

                <while>while <condition>(<expr>*<name>value</name> == ' ' || *<name>value</name> == '\t'</expr>)</condition> <block>{
                    <expr_stmt><expr>++<name>value</name></expr>;</expr_stmt>     <comment type="block">/* Skip LWS of value */</comment>
                }</block></while>

                <comment type="block">/* Find invalid, non-HT ctrl char, or the trailing NULL */</comment>
                <expr_stmt><expr><name>tmp_field</name> = (<name>char</name> *)<call><name>ap_scan_http_field_content</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Reject value for all garbage input (CTRLs excluding HT)
                 * e.g. only VCHAR / SP / HT / obs-text are allowed per
                 * RFC7230 3.2.6 - leave all more explicit rule enforcement
                 * for specific header handler logic later in the cycle
                 */</comment>
                <if>if <condition>(<expr>*<name>tmp_field</name> != '\0'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02427</expr></argument>)</argument_list></call>
                                  "Request header value is malformed: "
                                  "%.*s"</expr></argument>, <argument><expr>(<name>int</name>)<name>LOG_NAME_MAX_LEN</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return;</return>
                }</block></then></if>
            }</block></else></if>

            <expr_stmt><expr><call><name>apr_table_addn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>last_field</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* This last_field header is now stored in headers_in,
             * resume processing of the current input line.
             */</comment>
        }</block></then></if></else></if>

        <comment type="block">/* Found the terminating empty end-of-headers line, stop. */</comment>
        <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* Keep track of this new header line so that we can extend it across
         * any obs-fold or parse it on the next loop iteration. We referenced
         * our previously allocated buffer in r-&gt;headers_in,
         * so allocate a fresh buffer if required.
         */</comment>
        <expr_stmt><expr><name>alloc_len</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>last_field</name> = <name>field</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>last_len</name> = <name>len</name></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* Combine multiple message-header fields with the same
     * field-name, following RFC 2616, 4.2.
     */</comment>
    <expr_stmt><expr><call><name>apr_table_compress</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>APR_OVERLAP_TABLES_MERGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* enforce LimitRequestFieldSize for merged headers */</comment>
    <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>table_do_fn_check_lengths</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_get_mime_headers</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmp_bb</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>tmp_bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_get_mime_headers_core</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<function><type><name>request_rec</name> *</type><name>ap_read_request</name><parameter_list>(<param><decl><type><name>conn_rec</name> *</type><name>conn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expect</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>access_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmp_bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>csd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>cur_timeout</name></decl>;</decl_stmt>


    <expr_stmt><expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_tag</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>r</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>request_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>AP_READ_REQUEST_ENTRY</name><argument_list>(<argument><expr>(<name>intptr_t</name>)<name>r</name></expr></argument>, <argument><expr>(<name>uintptr_t</name>)<name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>pool</name></name>            = <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name></name>      = <name>conn</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>server</name></name>          = <name><name>conn</name>-&gt;<name>base_server</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>user</name></name>            = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>ap_auth_type</name></name>    = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>allowed_methods</name></name> = <call><name>ap_make_method_list</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>headers_in</name></name>      = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>25</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>trailers_in</name></name>     = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name>  = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>25</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>headers_out</name></name>     = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name> = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>trailers_out</name></name>    = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>notes</name></name>           = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>request_config</name></name>  = <call><name>ap_create_request_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Must be set before we run create request hook */</comment>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_output_filters</name></name> = <name><name>conn</name>-&gt;<name>output_filters</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>output_filters</name></name>  = <name><name>r</name>-&gt;<name>proto_output_filters</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_input_filters</name></name> = <name><name>conn</name>-&gt;<name>input_filters</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>input_filters</name></name>   = <name><name>r</name>-&gt;<name>proto_input_filters</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_run_create_request</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name>  = <name><name>r</name>-&gt;<name>server</name>-&gt;<name>lookup_defaults</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>sent_bodyct</name></name>     = 0</expr>;</expr_stmt>                      <comment type="block">/* bytect isn't for body */</comment>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>read_length</name></name>     = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>read_body</name></name>       = <name>REQUEST_NO_BODY</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name>          = <name>HTTP_OK</name></expr>;</expr_stmt>  <comment type="block">/* Until further notice */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>the_request</name></name>     = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Begin by presuming any module can make its own path_info assumptions,
     * until some module interjects and changes the value.
     */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>used_path_info</name></name> = <name>AP_REQ_DEFAULT_PATH_INFO</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>useragent_addr</name></name> = <name><name>conn</name>-&gt;<name>client_addr</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>useragent_ip</name></name> = <name><name>conn</name>-&gt;<name>client_ip</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>tmp_bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_run_pre_read_request</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get the request... */</comment>
    <if>if <condition>(<expr>!<call><name>read_request_line</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name><name>r</name>-&gt;<name>status</name></name></expr>)</condition> <block>{
        <case>case <expr><name>HTTP_REQUEST_URI_TOO_LARGE</name></expr>:
        </case><case>case <expr><name>HTTP_BAD_REQUEST</name></expr>:
        </case><case>case <expr><name>HTTP_VERSION_NOT_SUPPORTED</name></expr>:
        </case><case>case <expr><name>HTTP_NOT_IMPLEMENTED</name></expr>:
            <if>if <condition>(<expr><name><name>r</name>-&gt;<name>status</name></name> == <name>HTTP_REQUEST_URI_TOO_LARGE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00565</expr></argument>)</argument_list></call>
                              "request failed: client's request-line exceeds LimitRequestLine (longer than %d)"</expr></argument>,
                              <argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00566</expr></argument>)</argument_list></call>
                              "request failed: malformed request line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>
            <expr_stmt><expr><name>access_status</name> = <name><name>r</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_OK</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_die</name><argument_list>(<argument><expr><name>access_status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_update_child_status</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>sbh</name></name></expr></argument>, <argument><expr><name>SERVER_BUSY_LOG</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_run_log_transaction</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>traceout</name>;</goto>
        </case><case>case <expr><name>HTTP_REQUEST_TIME_OUT</name></expr>:
            <expr_stmt><expr><call><name>ap_update_child_status</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>sbh</name></name></expr></argument>, <argument><expr><name>SERVER_BUSY_LOG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalives</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name>ap_run_log_transaction</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>traceout</name>;</goto>
        </case><default>default:
            <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>r</name> = <name>NULL</name></expr>;</expr_stmt>
            <goto>goto <name>traceout</name>;</goto>
        </default>}</block></switch>
    }</block></then></if>

    <comment type="block">/* We may have been in keep_alive_timeout mode, so toggle back
     * to the normal timeout mode as we fetch the header lines,
     * as necessary.
     */</comment>
    <expr_stmt><expr><name>csd</name> = <call><name>ap_get_conn_socket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_socket_timeout_get</name><argument_list>(<argument><expr><name>csd</name></expr></argument>, <argument><expr>&amp;<name>cur_timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>cur_timeout</name> != <name><name>conn</name>-&gt;<name>base_server</name>-&gt;<name>timeout</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_socket_timeout_set</name><argument_list>(<argument><expr><name>csd</name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>base_server</name>-&gt;<name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur_timeout</name> = <name><name>conn</name>-&gt;<name>base_server</name>-&gt;<name>timeout</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>assbackwards</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tenc</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ap_get_mime_headers_core</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>status</name></name> != <name>HTTP_OK</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00567</expr></argument>)</argument_list></call>
                          "request failed: error reading the headers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_send_error_response</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_update_child_status</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>sbh</name></name></expr></argument>, <argument><expr><name>SERVER_BUSY_LOG</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_run_log_transaction</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>traceout</name>;</goto>
        }</block></then></if>

        <expr_stmt><expr><name>tenc</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>tenc</name></expr>)</condition><then> <block>{
            <comment type="block">/* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23
             * Section 3.3.3.3: "If a Transfer-Encoding header field is
             * present in a request and the chunked transfer coding is not
             * the final encoding ...; the server MUST respond with the 400
             * (Bad Request) status code and then close the connection".
             */</comment>
            <if>if <condition>(<expr>!(<call><name>strcasecmp</name><argument_list>(<argument><expr><name>tenc</name></expr></argument>, <argument><expr>"chunked"</expr></argument>)</argument_list></call> == 0 <comment type="block">/* fast path */</comment>
                    || <call><name>ap_find_last_token</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>tenc</name></expr></argument>, <argument><expr>"chunked"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02539</expr></argument>)</argument_list></call>
                              "client sent unknown Transfer-Encoding "
                              "(%s): %s"</expr></argument>, <argument><expr><name>tenc</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>conn</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_send_error_response</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_update_child_status</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>sbh</name></name></expr></argument>, <argument><expr><name>SERVER_BUSY_LOG</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_run_log_transaction</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>traceout</name>;</goto>
            }</block></then></if>

            <comment type="block">/* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23
             * Section 3.3.3.3: "If a message is received with both a
             * Transfer-Encoding and a Content-Length header field, the
             * Transfer-Encoding overrides the Content-Length. ... A sender
             * MUST remove the received Content-Length field".
             */</comment>
            <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* update what we think the virtual host is based on the headers we've
     * now read. may update status.
     */</comment>
    <expr_stmt><expr><call><name>ap_update_vhost_from_headers</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>access_status</name> = <name><name>r</name>-&gt;<name>status</name></name></expr>;</expr_stmt>

    <comment type="block">/* Toggle to the Host:-based vhost's timeout mode to fetch the
     * request body and send the response body, if needed.
     */</comment>
    <if>if <condition>(<expr><name>cur_timeout</name> != <name><name>r</name>-&gt;<name>server</name>-&gt;<name>timeout</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_socket_timeout_set</name><argument_list>(<argument><expr><name>csd</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur_timeout</name> = <name><name>r</name>-&gt;<name>server</name>-&gt;<name>timeout</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* we may have switched to another server */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name> = <name><name>r</name>-&gt;<name>server</name>-&gt;<name>lookup_defaults</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr>(!<name><name>r</name>-&gt;<name>hostname</name></name> &amp;&amp; (<name><name>r</name>-&gt;<name>proto_num</name></name> &gt;= <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>))
        || ((<name><name>r</name>-&gt;<name>proto_num</name></name> == <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>)
            &amp;&amp; !<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Host"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="block">/*
         * Client sent us an HTTP/1.1 or later request without telling us the
         * hostname, either with a full URL or a Host: header. We therefore
         * need to (as per the 1.1 spec) send an error.  As a special case,
         * HTTP/1.1 mentions twice (S9, S14.23) that a request MUST contain
         * a Host: header, and the server MUST respond with 400 if it doesn't.
         */</comment>
        <expr_stmt><expr><name>access_status</name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00569</expr></argument>)</argument_list></call>
                      "client sent HTTP/1.1 request without hostname "
                      "(see RFC2616 section 14.23): %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Add the HTTP_IN filter here to ensure that ap_discard_request_body
     * called by ap_die and by ap_send_error_response works correctly on
     * status codes that do not cause the connection to be dropped and
     * in situations where the connection should be kept alive.
     */</comment>

    <expr_stmt><expr><call><name>ap_add_input_filter_handle</name><argument_list>(<argument><expr><name>ap_http_input_filter_handle</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>access_status</name> != <name>HTTP_OK</name>
        || (<name>access_status</name> = <call><name>ap_run_post_read_request</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_die</name><argument_list>(<argument><expr><name>access_status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_update_child_status</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>sbh</name></name></expr></argument>, <argument><expr><name>SERVER_BUSY_LOG</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_run_log_transaction</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>r</name> = <name>NULL</name></expr>;</expr_stmt>
        <goto>goto <name>traceout</name>;</goto>
    }</block></then></if>

    <if>if <condition>(<expr>((<name>expect</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Expect"</expr></argument>)</argument_list></call>) != <name>NULL</name>)
        &amp;&amp; (<name><name>expect</name><index>[<expr>0</expr>]</index></name> != '\0')</expr>)</condition><then> <block>{
        <comment type="block">/*
         * The Expect header field was added to HTTP/1.1 after RFC 2068
         * as a means to signal when a 100 response is desired and,
         * unfortunately, to signal a poor man's mandatory extension that
         * the server must understand or return 417 Expectation Failed.
         */</comment>
        <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>expect</name></expr></argument>, <argument><expr>"100-continue"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>expecting_100</name></name> = 1</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_EXPECTATION_FAILED</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00570</expr></argument>)</argument_list></call>
                          "client sent an unrecognized expectation value of "
                          "Expect: %s"</expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_send_error_response</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_update_child_status</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>sbh</name></name></expr></argument>, <argument><expr><name>SERVER_BUSY_LOG</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_run_log_transaction</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>traceout</name>;</goto>
        }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>AP_READ_REQUEST_SUCCESS</name><argument_list>(<argument><expr>(<name>uintptr_t</name>)<name>r</name></expr></argument>, <argument><expr>(<name>char</name> *)<name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr>(<name>char</name> *)<name><name>r</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr>(<name>char</name> *)<name><name>r</name>-&gt;<name>server</name>-&gt;<name>defn_name</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>r</name></expr>;</return>
    <label><name>traceout</name>:</label>
    <expr_stmt><expr><call><name>AP_READ_REQUEST_FAILURE</name><argument_list>(<argument><expr>(<name>uintptr_t</name>)<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>r</name></expr>;</return>
}</block></function>

<comment type="block">/* if a request with a body creates a subrequest, remove original request's
 * input headers which pertain to the body which has already been read.
 * out-of-line helper function for ap_set_sub_req_protocol.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>strip_headers_request_body</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>rnew</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Encoding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Language"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Location"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-MD5"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Expires"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Last-Modified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * A couple of other functions which initialize some of the fields of
 * a request structure, as appropriate for adjuncts of one kind or another
 * to a request in progress.  Best here, rather than elsewhere, since
 * *someone* has to set the protocol-specific fields...
 */</comment>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_set_sub_req_protocol</name><argument_list>(<argument>request_rec *rnew</argument>,
                                         <argument>const request_rec *r</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>the_request</name></name>     = <name><name>r</name>-&gt;<name>the_request</name></name></expr>;</expr_stmt>  <comment type="block">/* Keep original request-line */</comment>

    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>assbackwards</name></name>    = 1</expr>;</expr_stmt>   <comment type="block">/* Don't send headers from this. */</comment>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>no_local_copy</name></name>   = 1</expr>;</expr_stmt>   <comment type="block">/* Don't try to send HTTP_NOT_MODIFIED for a
                                  * fragment. */</comment>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>method</name></name>          = "GET"</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>method_number</name></name>   = <name>M_GET</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>protocol</name></name>        = "INCLUDED"</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>status</name></name>          = <name>HTTP_OK</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>headers_in</name></name>      = <call><name>apr_table_copy</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>trailers_in</name></name>     = <call><name>apr_table_copy</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>trailers_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* did the original request have a body?  (e.g. POST w/SSI tags)
     * if so, make sure the subrequest doesn't inherit body headers
     */</comment>
    <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>kept_body</name></name> &amp;&amp; (<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call>
        || <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>strip_headers_request_body</name><argument_list>(<argument><expr><name>rnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>subprocess_env</name></name>  = <call><name>apr_table_copy</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>headers_out</name></name>     = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>err_headers_out</name></name> = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>trailers_out</name></name>    = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>notes</name></name>           = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>rnew</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>expecting_100</name></name>   = <name><name>r</name>-&gt;<name>expecting_100</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>read_length</name></name>     = <name><name>r</name>-&gt;<name>read_length</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rnew</name>-&gt;<name>read_body</name></name>       = <name>REQUEST_NO_BODY</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>rnew</name>-&gt;<name/></name>main = (<name>request_rec</name> *) <name>r</name></expr>;</expr_stmt>
}</block>

<function><type><specifier>static</specifier> <name>void</name></type> <name>end_output_stream</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_finalize_sub_req_protocol</name><argument_list>(<argument>request_rec *sub</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* tell the filter chain there is no more content coming */</comment>
    <if>if <condition>(<expr>!<name><name>sub</name>-&gt;<name>eos_sent</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>end_output_stream</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block>

<comment type="block">/* finalize_request_protocol is called at completion of sending the
 * response.  Its sole purpose is to send the terminating protocol
 * information for any wrappers around the response message body
 * (i.e., transfer encodings).  It should have been named finalize_response.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_finalize_request_protocol</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr>(<name>void</name>) <call><name>ap_discard_request_body</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* tell the filter chain there is no more content coming */</comment>
    <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>eos_sent</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>end_output_stream</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block>

<comment type="block">/*
 * Support for the Basic authentication protocol, and a bit for Digest.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_note_auth_failure</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type</name> <init>= <expr><call><name>ap_auth_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>type</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_run_note_auth_failure</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00571</expr></argument>)</argument_list></call>
                      "need AuthType to note auth failure: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_note_basic_auth_failure</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>ap_note_auth_failure</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_note_digest_auth_failure</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>ap_note_auth_failure</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_get_basic_auth_pw</name><argument_list>(<argument>request_rec *r</argument>, <argument>const char **pw</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>auth_line</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>,
                                          <argument><expr>(<name>PROXYREQ_PROXY</name> == <name><name>r</name>-&gt;<name>proxyreq</name></name>)
                                              ? "Proxy-Authorization"
                                              : "Authorization"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!(<name>t</name> = <call><name>ap_auth_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>) || <call><name>strcasecmp</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr>"Basic"</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>DECLINED</name></expr>;</return></then></if>

    <if>if <condition>(<expr>!<call><name>ap_auth_name</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00572</expr></argument>)</argument_list></call> 
                      "need AuthName: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>auth_line</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_note_auth_failure</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_UNAUTHORIZED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><call><name>ap_getword</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>auth_line</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"Basic"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Client tried to authenticate using wrong auth scheme */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00573</expr></argument>)</argument_list></call>
                      "client used wrong authentication scheme: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_note_auth_failure</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_UNAUTHORIZED</name></expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr>*<name>auth_line</name> == ' ' || *<name>auth_line</name> == '\t'</expr>)</condition> <block>{
        <expr_stmt><expr><name>auth_line</name>++</expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>t</name> = <call><name>ap_pbase64decode</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>auth_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>user</name></name> = <call><name>ap_getword_nulls</name> <argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>AP_GET_BASIC_AUTH_PW_NOTE</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>ap_auth_type</name></name> = "Basic"</expr>;</expr_stmt>

    <expr_stmt><expr>*<name>pw</name> = <name>t</name></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_get_basic_auth_components</name><argument_list>(<argument>const request_rec *r</argument>,
                                                      <argument>const char **username</argument>,
                                                      <argument>const char **password</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>auth_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>credentials</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>decoded</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>auth_header</name> = (<name>PROXYREQ_PROXY</name> == <name><name>r</name>-&gt;<name>proxyreq</name></name>) ? "Proxy-Authorization"
                                                  : "Authorization"</expr>;</expr_stmt>
    <expr_stmt><expr><name>credentials</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>auth_header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>credentials</name></expr>)</condition><then> <block>{
        <comment type="block">/* No auth header. */</comment>
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><call><name>ap_getword</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>credentials</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"Basic"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* These aren't Basic credentials. */</comment>
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr>*<name>credentials</name> == ' ' || *<name>credentials</name> == '\t'</expr>)</condition> <block>{
        <expr_stmt><expr><name>credentials</name>++</expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* XXX Our base64 decoding functions don't actually error out if the string
     * we give it isn't base64; they'll just silently stop and hand us whatever
     * they've parsed up to that point.
     *
     * Since this function is supposed to be a drop-in replacement for the
     * deprecated ap_get_basic_auth_pw(), don't fix this for 2.4.x.
     */</comment>
    <expr_stmt><expr><name>decoded</name> = <call><name>ap_pbase64decode</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>credentials</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>user</name> = <call><name>ap_getword_nulls</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>decoded</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>username</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>username</name> = <name>user</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>password</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>password</name> = <name>decoded</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<struct>struct <name>content_length_ctx</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>data_sent</name></decl>;</decl_stmt>  <comment type="block">/* true if the C-L filter has already sent at
                     * least one bucket on to the next output filter
                     * for this request
                     */</comment>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmpbb</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* This filter computes the content length, but it also computes the number
 * of bytes sent to the client.  This means that this filter will always run
 * through all of the buckets in all brigades
 */</comment>
<macro><name>AP_CORE_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_content_length_filter</name><argument_list>(
    <argument>ap_filter_t *f</argument>,
    <argument>apr_bucket_brigade *b</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>content_length_ctx</name> *</type><name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>eos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_read_type_e</name></type> <name>eblock</name> <init>= <expr><name>APR_NONBLOCK_READ</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>ctx</name> = <name><name>f</name>-&gt;<name>ctx</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>f</name>-&gt;<name>ctx</name></name> = <name>ctx</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>data_sent</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Loop through the brigade to count the length. To avoid
     * arbitrary memory consumption with morphing bucket types, this
     * loop will stop and pass on the brigade when necessary. */</comment>
    <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>eos</name> = 1</expr>;</expr_stmt>
            <break>break;</break>
        }</block></then>
        <comment type="block">/* For a flush bucket, fall through to pass the brigade and
         * flush now. */</comment>
        <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FLUSH</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <comment type="block">/* For metadata bucket types other than FLUSH, loop. */</comment>
        <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then>
        <comment type="block">/* For determinate length data buckets, count the length and
         * continue. */</comment>
        <else>else <if>if <condition>(<expr><name><name>e</name>-&gt;<name>length</name></name> != (<name>apr_size_t</name>)-1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>bytes_sent</name></name> += <name><name>e</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then>
        <comment type="block">/* For indeterminate length data buckets, perform one read. */</comment>
        <else>else <comment type="block">/* e-&gt;length == (apr_size_t)-1 */</comment> <block>{
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ignored</name></decl>;</decl_stmt>
        
            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>ignored</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>eblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>rv</name> != <name>APR_SUCCESS</name>) &amp;&amp; !<call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00574</expr></argument>)</argument_list></call>
                              "ap_content_length_filter: "
                              "apr_bucket_read() failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>eblock</name> = <name>APR_NONBLOCK_READ</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>bytes_sent</name></name> += <name>len</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>flush</name></decl>;</decl_stmt>

                <comment type="block">/* Next read must block. */</comment>
                <expr_stmt><expr><name>eblock</name> = <name>APR_BLOCK_READ</name></expr>;</expr_stmt>

                <comment type="block">/* Ensure the last bucket to pass down is a flush if
                 * the next read will block. */</comment>
                <expr_stmt><expr><name>flush</name> = <call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></else></if></else></if></else></if></else></if>

        <comment type="block">/* Optimization: if the next bucket is EOS (directly after a
         * bucket morphed to the heap, or a flush), short-cut to
         * handle EOS straight away - allowing C-L to be determined
         * for content which is already entirely in memory. */</comment>
        <if>if <condition>(<expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* On reaching here, pass on everything in the brigade up to
         * this point. */</comment>
        <expr_stmt><expr><call><name>apr_brigade_split_ex</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
            <return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
        }</block></then></if></else></if>
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>data_sent</name></name> = 1</expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* If we've now seen the entire response and it's otherwise
     * okay to set the C-L in the response header, then do so now.
     *
     * We can only set a C-L in the response header if we haven't already
     * sent any buckets on to the next output filter for this request.
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>data_sent</name></name> == 0 &amp;&amp; <name>eos</name> &amp;&amp;
        <comment type="block">/* don't whack the C-L if it has already been set for a HEAD
         * by something like proxy.  the brigade only has an EOS bucket
         * in this case, making r-&gt;bytes_sent zero.
         *
         * if r-&gt;bytes_sent &gt; 0 we have a (temporary) body whose length may
         * have been changed by a filter.  the C-L header might not have been
         * updated so we do it here.  long term it would be cleaner to have
         * such filters update or remove the C-L header, and just use it
         * if present.
         */</comment>
        !(<name><name>r</name>-&gt;<name>header_only</name></name> &amp;&amp; <name><name>r</name>-&gt;<name>bytes_sent</name></name> == 0 &amp;&amp;
            <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_set_content_length</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>bytes_sent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>data_sent</name></name> = 1</expr>;</expr_stmt>
    <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/*
 * Send the body of a response to the client.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_send_fd</name><argument_list>(<argument>apr_file_t *fd</argument>, <argument>request_rec *r</argument>,
                                    <argument>apr_off_t offset</argument>, <argument>apr_size_t len</argument>,
                                    <argument>apr_size_t *nbytes</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_brigade_insert_file</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>nbytes</name> = 0</expr>;</expr_stmt> <comment type="block">/* no way to tell how many were actually sent */</comment>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr>*<name>nbytes</name> = <name>len</name></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_MMAP</name></expr></cpp:if>
<comment type="block">/* send data from an in-memory buffer */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_size_t</argument>)</argument_list></macro> <macro><name>ap_send_mmap</name><argument_list>(<argument>apr_mmap_t *mm</argument>,
                                    <argument>request_rec *r</argument>,
                                    <argument>apr_size_t offset</argument>,
                                    <argument>apr_size_t length</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_mmap_create</name><argument_list>(<argument><expr><name>mm</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name><name>mm</name>-&gt;<name>size</name></name></expr>;</return> <comment type="block">/* XXX - change API to report apr_status_t? */</comment>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* APR_HAS_MMAP */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmpbb</name></decl>;</decl_stmt>
}</block></struct></type> <name>old_write_filter_ctx</name>;</typedef>

<macro><name>AP_CORE_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_old_write_filter</name><argument_list>(
    <argument>ap_filter_t *f</argument>, <argument>apr_bucket_brigade *bb</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>old_write_filter_ctx</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>bb</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* whatever is coming down the pipe (we don't care), we
         * can simply insert our buffered data at the front and
         * pass the whole bundle down the chain.
         */</comment>
        <expr_stmt><expr><call><name>APR_BRIGADE_PREPEND</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<function><type><specifier>static</specifier> <name>ap_filter_t</name> *</type><name>insert_old_write_filter</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>old_write_filter_ctx</name> *</type><name>ctx</name></decl>;</decl_stmt>

    <comment type="block">/* future optimization: record some flags in the request_rec to
     * say whether we've added our filter, and whether it is first.
     */</comment>

    <comment type="block">/* this will typically exit on the first test */</comment>
    <for>for (<init><expr><name>f</name> = <name><name>r</name>-&gt;<name>output_filters</name></name></expr>;</init> <condition><expr><name>f</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>f</name> = <name><name>f</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><name>ap_old_write_func</name> == <name><name>f</name>-&gt;<name>frec</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* our filter hasn't been added yet */</comment>
        <expr_stmt><expr><name>ctx</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ap_add_output_filter</name><argument_list>(<argument><expr>"OLD_WRITE"</expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>f</name> = <name><name>r</name>-&gt;<name>output_filters</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>f</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>buffer_output</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>old_write_filter_ctx</name> *</type><name>ctx</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return></then></if>

    <expr_stmt><expr><name>f</name> = <call><name>insert_old_write_filter</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name> = <name><name>f</name>-&gt;<name>ctx</name></name></expr>;</expr_stmt>

    <comment type="block">/* if the first filter is not our buffering filter, then we have to
     * deliver the content through the normal filter chain
     */</comment>
    <if>if <condition>(<expr><name>f</name> != <name><name>r</name>-&gt;<name>output_filters</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_transient_create</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>bb</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>ap_fwrite</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rputc</name><argument_list>(<argument>int c</argument>, <argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name>c2</name> <init>= <expr>(<name>char</name>)<name>c</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>buffer_output</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>c2</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <return>return <expr><name>c</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rwrite</name><argument_list>(<argument>const void *buf</argument>, <argument>int nbyte</argument>, <argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>aborted</name></name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <if>if <condition>(<expr><call><name>buffer_output</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbyte</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <return>return <expr><name>nbyte</name></expr>;</return>
}</block>

<struct>struct <name>ap_vrprintf_data</name> <block>{
    <decl_stmt><decl><type><name>apr_vformatter_buff_t</name></type> <name>vbuff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>buff</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Flush callback for apr_vformatter; returns -1 on error. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>r_flush</name><parameter_list>(<param><decl><type><name>apr_vformatter_buff_t</name> *</type><name>buff</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* callback function passed to ap_vformatter to be called when
     * vformatter needs to write into buff and buff.curpos &gt; buff.endpos */</comment>

    <comment type="block">/* ap_vrprintf_data passed as a apr_vformatter_buff_t, which is then
     * "downcast" to an ap_vrprintf_data */</comment>
    <decl_stmt><decl><type>struct <name>ap_vrprintf_data</name> *</type><name>vd</name> <init>= <expr>(struct <name>ap_vrprintf_data</name>*)<name>buff</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>vd</name>-&gt;<name>r</name>-&gt;<name>connection</name>-&gt;<name>aborted</name></name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <comment type="block">/* r_flush is called when vbuff is completely full */</comment>
    <if>if <condition>(<expr><call><name>buffer_output</name><argument_list>(<argument><expr><name><name>vd</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><name><name>vd</name>-&gt;<name>buff</name></name></expr></argument>, <argument><expr><name>AP_IOBUFSIZE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* reset the buffer position */</comment>
    <expr_stmt><expr><name><name>vd</name>-&gt;<name>vbuff</name>.<name>curpos</name></name> = <name><name>vd</name>-&gt;<name>buff</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vd</name>-&gt;<name>vbuff</name>.<name>endpos</name></name> = <name><name>vd</name>-&gt;<name>buff</name></name> + <name>AP_IOBUFSIZE</name></expr>;</expr_stmt>

    <return>return <expr>0</expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_vrprintf</name><argument_list>(<argument>request_rec *r</argument>, <argument>const char *fmt</argument>, <argument>va_list va</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>written</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>ap_vrprintf_data</name></type> <name>vd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>vrprintf_buf</name><index>[<expr><name>AP_IOBUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>vd</name>.<name>vbuff</name>.<name>curpos</name></name> = <name>vrprintf_buf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vd</name>.<name>vbuff</name>.<name>endpos</name></name> = <name>vrprintf_buf</name> + <name>AP_IOBUFSIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vd</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vd</name>.<name>buff</name></name> = <name>vrprintf_buf</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>aborted</name></name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <expr_stmt><expr><name>written</name> = <call><name>apr_vformatter</name><argument_list>(<argument><expr><name>r_flush</name></expr></argument>, <argument><expr>&amp;<name><name>vd</name>.<name>vbuff</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>written</name> != -1</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>vd</name>.<name>vbuff</name>.<name>curpos</name></name> - <name>vrprintf_buf</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* last call to buffer_output, to finish clearing the buffer */</comment>
        <if>if <condition>(<expr><call><name>buffer_output</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>vrprintf_buf</name></expr></argument>,<argument><expr><name>n</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>

        <expr_stmt><expr><name>written</name> += <name>n</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>written</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rprintf</name><argument_list>(<argument>request_rec *r</argument>, <argument>const char *fmt</argument>, <argument>...</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>aborted</name></name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> = <call><name>ap_vrprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>n</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rvputs</name><argument_list>(<argument>request_rec *r</argument>, <argument>...</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>written</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>aborted</name></name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <comment type="block">/* ### TODO: if the total output is large, put all the strings
     * ### into a single brigade, rather than flushing each time we
     * ### fill the buffer
     */</comment>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr>1</expr>)</condition> <block>{
        <expr_stmt><expr><name>s</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
            <break>break;</break></then></if>

        <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>buffer_output</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>written</name> += <name>len</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>written</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_rflush</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>old_write_filter_ctx</name> *</type><name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>f</name> = <call><name>insert_old_write_filter</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ctx</name> = <name><name>f</name>-&gt;<name>ctx</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <return>return <expr>0</expr>;</return>
}</block>

<comment type="block">/*
 * This function sets the Last-Modified output header field to the value
 * of the mtime field in the request structure - rationalized to keep it from
 * being in the future.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_set_last_modified</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>assbackwards</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_time_t</name></type> <name>mod_time</name> <init>= <expr><call><name>ap_rationalize_mtime</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>mtime</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>datestr</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>APR_RFC822_DATE_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>apr_rfc822_date</name><argument_list>(<argument><expr><name>datestr</name></expr></argument>, <argument><expr><name>mod_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Last-Modified"</expr></argument>, <argument><expr><name>datestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block>

<typedef>typedef <type><struct>struct <name>hdr_ptr</name> <block>{
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
}</block></struct></type> <name>hdr_ptr</name>;</typedef>
 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>send_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>header_line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>hdr_ptr</name> *</type><name>hdr</name> <init>= <expr>(<name>hdr_ptr</name>*)<name>data</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>header_line</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>hdr</name>-&gt;<name>bb</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>": "</expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>header_line</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>header_line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name><name>hdr</name>-&gt;<name>f</name></name></expr></argument>, <argument><expr><name><name>hdr</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>header_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type> <name>send_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
     <expr_stmt><expr><call><name>ap_fputstrs</name><argument_list>(<argument><expr>((<name>hdr_ptr</name>*)<name>data</name>)-&gt;<name>f</name></expr></argument>, <argument><expr>((<name>hdr_ptr</name>*)<name>data</name>)-&gt;<name>bb</name></expr></argument>,
                 <argument><expr><name>key</name></expr></argument>, <argument><expr>": "</expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <return>return <expr>1</expr>;</return>
 }</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_send_interim_response</name><argument_list>(<argument>request_rec *r</argument>, <argument>int send_headers</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>hdr_ptr</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>status_line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>rr</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proto_num</name></name> &lt; <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* don't send interim response to HTTP/1.0 Client */</comment>
        <return>return;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>ap_is_HTTP_INFO</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00575</expr></argument>)</argument_list></call>
                      "Status is %d - not sending interim response"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name><name>r</name>-&gt;<name>status</name></name> == <name>HTTP_CONTINUE</name>) &amp;&amp; !<name><name>r</name>-&gt;<name>expecting_100</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Don't send 100-Continue when there was no Expect: 100-continue
         * in the request headers. For origin servers this is a SHOULD NOT
         * for proxies it is a MUST NOT according to RFC 2616 8.2.3
         */</comment>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* if we send an interim response, we're no longer in a state of
     * expecting one.  Also, this could feasibly be in a subrequest,
     * so we need to propagate the fact that we responded.
     */</comment>
    <for>for (<init><expr><name>rr</name> = <name>r</name></expr>;</init> <condition><expr><name>rr</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>rr</name> = <name><name>rr</name>-&gt;<name/></name>main</expr></incr>) <block>{
        <expr_stmt><expr><name><name>rr</name>-&gt;<name>expecting_100</name></name> = 0</expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><name>status_line</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>AP_SERVER_PROTOCOL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>status_line</name></name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>status_line</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>status_line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>x</name>.<name>f</name></name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>output_filters</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name>.<name>bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name><name>x</name>.<name>f</name></name></expr></argument>, <argument><expr><name><name>x</name>.<name>bb</name></name></expr></argument>, <argument><expr><name>status_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>send_headers</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>send_header</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_clear</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name><name>x</name>.<name>f</name></name></expr></argument>, <argument><expr><name><name>x</name>.<name>bb</name></name></expr></argument>, <argument><expr><name>CRLF_ASCII</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_fflush</name><argument_list>(<argument><expr><name><name>x</name>.<name>f</name></name></expr></argument>, <argument><expr><name><name>x</name>.<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name><name>x</name>.<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<comment type="block">/*
 * Compare two protocol identifier. Result is similar to strcmp():
 * 0 gives same precedence, &gt;0 means proto1 is preferred.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>protocol_cmp</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>preferences</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proto1</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proto2</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>preferences</name> &amp;&amp; <name><name>preferences</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>index1</name> <init>= <expr><call><name>ap_array_str_index</name><argument_list>(<argument><expr><name>preferences</name></expr></argument>, <argument><expr><name>proto1</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>index2</name> <init>= <expr><call><name>ap_array_str_index</name><argument_list>(<argument><expr><name>preferences</name></expr></argument>, <argument><expr><name>proto2</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>index2</name> &gt; <name>index1</name></expr>)</condition><then> <block>{
            <return>return <expr>(<name>index1</name> &gt;= 0) ? 1 : -1</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>index1</name> &gt; <name>index2</name></expr>)</condition><then> <block>{
            <return>return <expr>(<name>index2</name> &gt;= 0) ? -1 : 1</expr>;</return>
        }</block></then></if></else></if>
    }</block></then></if>
    <comment type="block">/* both have the same index (mabye -1 or no pref configured) and we compare
     * the names so that spdy3 gets precedence over spdy2. That makes
     * the outcome at least deterministic. */</comment>
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>proto1</name></expr></argument>, <argument><expr><name>proto2</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_get_protocol</name><argument_list>(<argument>conn_rec *c</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>protocol</name> <init>= <expr><call><name>ap_run_protocol_get</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><name>protocol</name>? <name>protocol</name> : <name>AP_PROTOCOL_HTTP1</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_get_protocol_upgrades</name><argument_list>(<argument>conn_rec *c</argument>, <argument>request_rec *r</argument>, 
                                                  <argument>server_rec *s</argument>, <argument>int report_all</argument>, 
                                                  <argument>const apr_array_header_t **pupgrades</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name>r</name>? <name><name>r</name>-&gt;<name>pool</name></name> : <name><name>c</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>existing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>upgrades</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>s</name> = (<name>r</name>? <name><name>r</name>-&gt;<name>server</name></name> : <name><name>c</name>-&gt;<name>base_server</name></name>)</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>protocols</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>existing</name> = <call><name>ap_get_protocol</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>protocols</name>-&gt;<name>nelts</name></name> &gt; 1 
            || !<call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name><name>conf</name>-&gt;<name>protocols</name></name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            
            <comment type="block">/* possibly more than one choice or one, but not the
             * existing. (TODO: maybe 426 and Upgrade then?) */</comment>
            <expr_stmt><expr><name>upgrades</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>protocols</name>-&gt;<name>nelts</name></name> + 1</expr></argument>, 
                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>conf</name>-&gt;<name>protocols</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>conf</name>-&gt;<name>protocols</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>existing</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="block">/* not the one we have and possible, add in this order */</comment>
                    <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>upgrades</name></expr></argument>, <argument><expr>const <name>char</name>*</expr></argument>)</argument_list></call> = <name>p</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<name>report_all</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if></else></if>
            }</block></for>
        }</block></then></if>
    }</block></then></if>
    
    <expr_stmt><expr>*<name>pupgrades</name> = <name>upgrades</name></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_select_protocol</name><argument_list>(<argument>conn_rec *c</argument>, <argument>request_rec *r</argument>, 
                                            <argument>server_rec *s</argument>,
                                            <argument>const apr_array_header_t *choices</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name>r</name>? <name><name>r</name>-&gt;<name>pool</name></name> : <name><name>c</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>protocol</name> <init>= <expr><name>NULL</name></expr></init>, *<name>existing</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>proposals</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>s</name> = (<name>r</name>? <name><name>r</name>-&gt;<name>server</name></name> : <name><name>c</name>-&gt;<name>base_server</name></name>)</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><call><name>APLOGcdebug</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>protocols</name></name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03155</expr></argument>)</argument_list></call> 
                      "select protocol from %s, choices=%s for server %s"</expr></argument>, 
                      <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>choices</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name><name>s</name>-&gt;<name>server_hostname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>protocols</name>-&gt;<name>nelts</name></name> &lt;= 0</expr>)</condition><then> <block>{
        <comment type="block">/* nothing configured, by default, we only allow http/1.1 here.
         * For now...
         */</comment>
        <if>if <condition>(<expr><call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name>choices</name></expr></argument>, <argument><expr><name>AP_PROTOCOL_HTTP1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>AP_PROTOCOL_HTTP1</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>proposals</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>choices</name>-&gt;<name>nelts</name></name> + 1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_run_protocol_propose</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>choices</name></expr></argument>, <argument><expr><name>proposals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If the existing protocol has not been proposed, but is a choice,
     * add it to the proposals implicitly.
     */</comment>
    <expr_stmt><expr><name>existing</name> = <call><name>ap_get_protocol</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name>proposals</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call>
        &amp;&amp; <call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name>choices</name></expr></argument>, <argument><expr><name>existing</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>proposals</name></expr></argument>, <argument><expr>const <name>char</name>*</expr></argument>)</argument_list></call> = <name>existing</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>proposals</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>prefs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Default for protocols_honor_order is 'on' or != 0 */</comment>
        <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>protocols_honor_order</name></name> == 0 &amp;&amp; <name><name>choices</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>prefs</name> = <name>choices</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>prefs</name> = <name><name>conf</name>-&gt;<name>protocols</name></name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/* Select the most preferred protocol */</comment>
        <if>if <condition>(<expr><call><name>APLOGcdebug</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03156</expr></argument>)</argument_list></call> 
                          "select protocol, proposals=%s preferences=%s configured=%s"</expr></argument>, 
                          <argument><expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>proposals</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>prefs</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>protocols</name></name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>proposals</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>proposals</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name><name>conf</name>-&gt;<name>protocols</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* not a configured protocol here */</comment>
                <continue>continue;</continue>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<name>protocol</name> 
                     || (<call><name>protocol_cmp</name><argument_list>(<argument><expr><name>prefs</name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> &lt; 0)</expr>)</condition><then> <block>{
                <comment type="block">/* none selected yet or this one has preference */</comment>
                <expr_stmt><expr><name>protocol</name> = <name>p</name></expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></for>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>APLOGcdebug</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03157</expr></argument>)</argument_list></call>
                      "selected protocol=%s"</expr></argument>, 
                      <argument><expr><name>protocol</name>? <name>protocol</name> : "(none)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>protocol</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_switch_protocol</name><argument_list>(<argument>conn_rec *c</argument>, <argument>request_rec *r</argument>, 
                                            <argument>server_rec *s</argument>,
                                            <argument>const char *protocol</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current</name> <init>= <expr><call><name>ap_get_protocol</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02906</expr></argument>)</argument_list></call>
                      "already at it, protocol_switch to %s"</expr></argument>, 
                      <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>
    
    <expr_stmt><expr><name>rc</name> = <call><name>ap_run_protocol_switch</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>rc</name></expr>)</condition> <block>{
        <case>case <expr><name>DECLINED</name></expr>:
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02907</expr></argument>)</argument_list></call>
                          "no implementation for protocol_switch to %s"</expr></argument>, 
                          <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_ENOTIMPL</name></expr>;</return>
        </case><case>case <expr><name>OK</name></expr>:
        </case><case>case <expr><name>DONE</name></expr>:
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        </case><default>default:
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02905</expr></argument>)</argument_list></call>
                          "unexpected return code %d from protocol_switch to %s"</expr></argument>
                          , <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_EOF</name></expr>;</return>
    </default>}</block></switch>    
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_is_allowed_protocol</name><argument_list>(<argument>conn_rec *c</argument>, <argument>request_rec *r</argument>,
                                       <argument>server_rec *s</argument>, <argument>const char *protocol</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>s</name> = (<name>r</name>? <name><name>r</name>-&gt;<name>server</name></name> : <name><name>c</name>-&gt;<name>base_server</name></name>)</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>protocols</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
        <return>return <expr><call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name><name>conf</name>-&gt;<name>protocols</name></name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>AP_PROTOCOL_HTTP1</name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>


<macro><name>AP_IMPLEMENT_HOOK_VOID</name><argument_list>(<argument>pre_read_request</argument>,
                       <argument>(request_rec *r, conn_rec *c)</argument>,
                       <argument>(r, c)</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_ALL</name><argument_list>(<argument>int</argument>,<argument>post_read_request</argument>,
                          <argument>(request_rec *r)</argument>, <argument>(r)</argument>, <argument>OK</argument>, <argument>DECLINED</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_ALL</name><argument_list>(<argument>int</argument>,<argument>log_transaction</argument>,
                          <argument>(request_rec *r)</argument>, <argument>(r)</argument>, <argument>OK</argument>, <argument>DECLINED</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>const char *</argument>,<argument>http_scheme</argument>,
                            <argument>(const request_rec *r)</argument>, <argument>(r)</argument>, <argument>NULL</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>unsigned short</argument>,<argument>default_port</argument>,
                            <argument>(const request_rec *r)</argument>, <argument>(r)</argument>, <argument>0</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>int</argument>, <argument>note_auth_failure</argument>,
                            <argument>(request_rec *r, const char *auth_type)</argument>,
                            <argument>(r, auth_type)</argument>, <argument>DECLINED</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_ALL</name><argument_list>(<argument>int</argument>,<argument>protocol_propose</argument>,
                          <argument>(conn_rec *c, request_rec *r, server_rec *s,
                           const apr_array_header_t *offers,
                           apr_array_header_t *proposals)</argument>, 
                          <argument>(c, r, s, offers, proposals)</argument>, <argument>OK</argument>, <argument>DECLINED</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>int</argument>,<argument>protocol_switch</argument>,
                            <argument>(conn_rec *c, request_rec *r, server_rec *s,
                             const char *protocol)</argument>, 
                            <argument>(c, r, s, protocol)</argument>, <argument>DECLINED</argument>)</argument_list></macro>
<macro><name>AP_IMPLEMENT_HOOK_RUN_FIRST</name><argument_list>(<argument>const char *</argument>,<argument>protocol_get</argument>,
                            <argument>(const conn_rec *c)</argument>, <argument>(c)</argument>, <argument>NULL</argument>)</argument_list></macro>
</unit>
