<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/server/mpm_unix.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/* The purpose of this file is to store the code that MOST mpm's will need
 * this does not mean a function only goes into this file if every MPM needs
 * it.  It means that if a function is needed by more than one MPM, and
 * future maintenance would be served by making the code common, then the
 * function belongs here.
 *
 * This is going in src/main because it is not platform specific, it is
 * specific to multi-process servers, but NOT to Unix.  Which is why it
 * does not belong in src/os/unix
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_signal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_getopt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_allocator.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mpm_common.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_listen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_mutex.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_PWD_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pwd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GRP_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;grp.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* we know core's module_index is 0 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>APLOG_MODULE_INDEX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_MODULE_INDEX</name></cpp:macro> <cpp:value>AP_CORE_MODULE_INDEX</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>DO_NOTHING</name></decl>,
    <decl><name>SEND_SIGTERM</name></decl>,
    <decl><name>SEND_SIGTERM_NOLOG</name></decl>,
    <decl><name>SEND_SIGKILL</name></decl>,
    <decl><name>GIVEUP</name></decl>
}</block></enum></type> <name>action_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>extra_process_t</name> <block>{
    <decl_stmt><decl><type>struct <name>extra_process_t</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_generation_t</name></type> <name>gen</name></decl>;</decl_stmt>
}</block></struct></type> <name>extra_process_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>extra_process_t</name> *</type><name>extras</name></decl>;</decl_stmt>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_register_extra_mpm_process</name><argument_list>(<argument>pid_t pid</argument>, <argument>ap_generation_t gen</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>extra_process_t</name> *</type><name>p</name> <init>= <expr>(<name>extra_process_t</name> *)<call><name>ap_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>extra_process_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>p</name>-&gt;<name>next</name></name> = <name>extras</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name>-&gt;<name>pid</name></name> = <name>pid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name>-&gt;<name>gen</name></name> = <name>gen</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>extras</name> = <name>p</name></expr>;</expr_stmt>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unregister_extra_mpm_process</name><argument_list>(<argument>pid_t pid</argument>, <argument>ap_generation_t *old_gen</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>extra_process_t</name> *</type><name>cur</name> <init>= <expr><name>extras</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>extra_process_t</name> *</type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>cur</name> &amp;&amp; <name><name>cur</name>-&gt;<name>pid</name></name> != <name>pid</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>prev</name> = <name>cur</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>cur</name> = <name><name>cur</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name>cur</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>prev</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>prev</name>-&gt;<name>next</name></name> = <name><name>cur</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>extras</name> = <name><name>cur</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr>*<name>old_gen</name> = <name><name>cur</name>-&gt;<name>gen</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return> <comment type="block">/* found */</comment>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* we don't know about any such process */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></else></if>
}</block>

<function><type><specifier>static</specifier> <name>int</name></type> <name>reclaim_one_pid</name><parameter_list>(<param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>, <param><decl><type><name>action_t</name></type> <name>action</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_proc_t</name></type> <name>proc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>waitret</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_exit_why_e</name></type> <name>why</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <comment type="block">/* Ensure pid sanity. */</comment>
    <if>if <condition>(<expr><name>pid</name> &lt; 1</expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>proc</name>.<name>pid</name></name> = <name>pid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>waitret</name> = <call><name>apr_proc_wait</name><argument_list>(<argument><expr>&amp;<name>proc</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr>&amp;<name>why</name></expr></argument>, <argument><expr><name>APR_NOWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>waitret</name> != <name>APR_CHILD_NOTDONE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>waitret</name> == <name>APR_CHILD_DONE</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_process_child_status</name><argument_list>(<argument><expr>&amp;<name>proc</name></expr></argument>, <argument><expr><name>why</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <switch>switch<condition>(<expr><name>action</name></expr>)</condition> <block>{
    <case>case <expr><name>DO_NOTHING</name></expr>:
        <break>break;</break>

    </case><case>case <expr><name>SEND_SIGTERM</name></expr>:
        <comment type="block">/* ok, now it's being annoying */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>,
                     <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00045</expr></argument>)</argument_list></call>
                     "child process %" <name>APR_PID_T_FMT</name>
                     " still did not exit, "
                     "sending a SIGTERM"</expr></argument>,
                     <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* FALLTHROUGH */</comment>
    </case><case>case <expr><name>SEND_SIGTERM_NOLOG</name></expr>:
        <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr><name>SEND_SIGKILL</name></expr>:
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>,
                     <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00046</expr></argument>)</argument_list></call>
                     "child process %" <name>APR_PID_T_FMT</name>
                     " still did not exit, "
                     "sending a SIGKILL"</expr></argument>,
                     <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>SIGKILL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr><name>GIVEUP</name></expr>:
        <comment type="block">/* gave it our best shot, but alas...  If this really
         * is a child we are trying to kill and it really hasn't
         * exited, we will likely fail to bind to the port
         * after the restart.
         */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>,
                     <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00047</expr></argument>)</argument_list></call>
                     "could not make child process %" <name>APR_PID_T_FMT</name>
                     " exit, "
                     "attempting to continue anyway"</expr></argument>,
                     <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case>}</block></switch>

    <return>return <expr>0</expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_reclaim_child_processes</name><argument_list>(<argument>int terminate</argument>,
                                            <argument>ap_reclaim_callback_fn_t *mpm_callback</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>waittime</name> <init>= <expr>1024 * 16</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>extra_process_t</name> *</type><name>cur_extra</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>not_dead_yet</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_daemons</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>starttime</name> <init>= <expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* this table of actions and elapsed times tells what action is taken
     * at which elapsed time from starting the reclaim
     */</comment>
    <struct>struct <block>{
        <decl_stmt><decl><type><name>action_t</name></type> <name>action</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_time_t</name></type> <name>action_time</name></decl>;</decl_stmt>
    }</block> <decl><name><name>action_table</name><index>[]</index></name> <init>= <expr><block>{
        <expr><block>{<expr><name>DO_NOTHING</name></expr>, <expr>0</expr>}</block></expr>, <comment type="block">/* dummy entry for iterations where we reap
                          * children but take no action against
                          * stragglers
                          */</comment>
        <expr><block>{<expr><name>SEND_SIGTERM_NOLOG</name></expr>, <expr>0</expr>}</block></expr>, <comment type="block">/* skipped if terminate == 0 */</comment>
        <expr><block>{<expr><name>SEND_SIGTERM</name></expr>, <macro><name>apr_time_from_sec</name><argument_list>(<argument>3</argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>SEND_SIGTERM</name></expr>, <macro><name>apr_time_from_sec</name><argument_list>(<argument>5</argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>SEND_SIGTERM</name></expr>, <macro><name>apr_time_from_sec</name><argument_list>(<argument>7</argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>SEND_SIGKILL</name></expr>, <macro><name>apr_time_from_sec</name><argument_list>(<argument>9</argument>)</argument_list></macro>}</block></expr>,
        <expr><block>{<expr><name>GIVEUP</name></expr>,       <macro><name>apr_time_from_sec</name><argument_list>(<argument>10</argument>)</argument_list></macro>}</block></expr>
    }</block></expr></init></decl>;</struct>
    <decl_stmt><decl><type><name>int</name></type> <name>cur_action</name></decl>;</decl_stmt>      <comment type="block">/* index of action we decided to take this
                          * iteration
                          */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>next_action</name> <init>= <expr><name>terminate</name> ? 1 : 2</expr></init></decl>;</decl_stmt> <comment type="block">/* index of first real action */</comment>

    <expr_stmt><expr><call><name>ap_mpm_query</name><argument_list>(<argument><expr><name>AP_MPMQ_MAX_DAEMON_USED</name></expr></argument>, <argument><expr>&amp;<name>max_daemons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do <block>{
        <if>if <condition>(<expr><name><name>action_table</name><index>[<expr><name>next_action</name></expr>]</index></name>.<name>action_time</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>waittime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* don't let waittime get longer than 1 second; otherwise, we don't
             * react quickly to the last child exiting, and taking action can
             * be delayed
             */</comment>
            <expr_stmt><expr><name>waittime</name> = <name>waittime</name> * 4</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>waittime</name> &gt; <call><name>apr_time_from_sec</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>waittime</name> = <call><name>apr_time_from_sec</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/* see what action to take, if any */</comment>
        <if>if <condition>(<expr><name><name>action_table</name><index>[<expr><name>next_action</name></expr>]</index></name>.<name>action_time</name> &lt;= <call><name>apr_time_now</name><argument_list>()</argument_list></call> - <name>starttime</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cur_action</name> = <name>next_action</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>next_action</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>cur_action</name> = 0</expr>;</expr_stmt> <comment type="block">/* nothing to do */</comment>
        }</block></else></if>

        <comment type="block">/* now see who is done */</comment>
        <expr_stmt><expr><name>not_dead_yet</name> = 0</expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>max_daemons</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>process_score</name> *</type><name>ps</name> <init>= <expr><call><name>ap_get_scoreboard_process</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><name><name>ps</name>-&gt;<name>pid</name></name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then> <block>{
                <continue>continue;</continue> <comment type="block">/* not every scoreboard entry is in use */</comment>
            }</block></then></if>

            <if>if <condition>(<expr><call><name>reclaim_one_pid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name><name>action_table</name><index>[<expr><name>cur_action</name></expr>]</index></name>.<name>action</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>mpm_callback</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr>++<name>not_dead_yet</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

        <expr_stmt><expr><name>cur_extra</name> = <name>extras</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>cur_extra</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>ap_generation_t</name></type> <name>old_gen</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>extra_process_t</name> *</type><name>next</name> <init>= <expr><name><name>cur_extra</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>reclaim_one_pid</name><argument_list>(<argument><expr><name><name>cur_extra</name>-&gt;<name>pid</name></name></expr></argument>, <argument><expr><name><name>action_table</name><index>[<expr><name>cur_action</name></expr>]</index></name>.<name>action</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>ap_unregister_extra_mpm_process</name><argument_list>(<argument><expr><name><name>cur_extra</name>-&gt;<name>pid</name></name></expr></argument>, <argument><expr>&amp;<name>old_gen</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>mpm_callback</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><name><name>cur_extra</name>-&gt;<name>pid</name></name></expr></argument>, <argument><expr><name>old_gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr>1 == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr>++<name>not_dead_yet</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name>cur_extra</name> = <name>next</name></expr>;</expr_stmt>
        }</block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_OTHER_CHILD</name></expr></cpp:if>
        <expr_stmt><expr><call><name>apr_proc_other_child_refresh_all</name><argument_list>(<argument><expr><name>APR_OC_REASON_RESTART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    }</block> while <condition>(<expr><name>not_dead_yet</name> &gt; 0 &amp;&amp;
             <name><name>action_table</name><index>[<expr><name>cur_action</name></expr>]</index></name>.<name>action</name> != <name>GIVEUP</name></expr>)</condition>;</do>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_relieve_child_processes</name><argument_list>(<argument>ap_reclaim_callback_fn_t *mpm_callback</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>extra_process_t</name> *</type><name>cur_extra</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_daemons</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_mpm_query</name><argument_list>(<argument><expr><name>AP_MPMQ_MAX_DAEMON_USED</name></expr></argument>, <argument><expr>&amp;<name>max_daemons</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* now see who is done */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>max_daemons</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>process_score</name> *</type><name>ps</name> <init>= <expr><call><name>ap_get_scoreboard_process</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>pid_t</name></type> <name>pid</name> <init>= <expr><name><name>ps</name>-&gt;<name>pid</name></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>pid</name> == 0</expr>)</condition><then> <block>{
            <continue>continue;</continue> <comment type="block">/* not every scoreboard entry is in use */</comment>
        }</block></then></if>

        <if>if <condition>(<expr><call><name>reclaim_one_pid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>DO_NOTHING</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>mpm_callback</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <expr_stmt><expr><name>cur_extra</name> = <name>extras</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>cur_extra</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>ap_generation_t</name></type> <name>old_gen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>extra_process_t</name> *</type><name>next</name> <init>= <expr><name><name>cur_extra</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>reclaim_one_pid</name><argument_list>(<argument><expr><name><name>cur_extra</name>-&gt;<name>pid</name></name></expr></argument>, <argument><expr><name>DO_NOTHING</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>ap_unregister_extra_mpm_process</name><argument_list>(<argument><expr><name><name>cur_extra</name>-&gt;<name>pid</name></name></expr></argument>, <argument><expr>&amp;<name>old_gen</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>mpm_callback</name><argument_list>(<argument><expr>-1</expr></argument>, <argument><expr><name><name>cur_extra</name>-&gt;<name>pid</name></name></expr></argument>, <argument><expr><name>old_gen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr>1 == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
        <expr_stmt><expr><name>cur_extra</name> = <name>next</name></expr>;</expr_stmt>
    }</block></while>
}</block>

<comment type="block">/* Before sending the signal to the pid this function verifies that
 * the pid is a member of the current process group; either using
 * apr_proc_wait(), where waitpid() guarantees to fail for non-child
 * processes; or by using getpgid() directly, if available. */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_safe_kill</name><argument_list>(<argument>pid_t pid</argument>, <argument>int sig</argument>)</argument_list></macro>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_GETPGID</name></cpp:ifndef>
    <decl_stmt><decl><type><name>apr_proc_t</name></type> <name>proc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_exit_why_e</name></type> <name>why</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <comment type="block">/* Ensure pid sanity */</comment>
    <if>if <condition>(<expr><name>pid</name> &lt; 1</expr>)</condition><then> <block>{
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>proc</name>.<name>pid</name></name> = <name>pid</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_proc_wait</name><argument_list>(<argument><expr>&amp;<name>proc</name></expr></argument>, <argument><expr>&amp;<name>status</name></expr></argument>, <argument><expr>&amp;<name>why</name></expr></argument>, <argument><expr><name>APR_NOWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> == <name>APR_CHILD_DONE</name></expr>)</condition><then> <block>{
        <comment type="block">/* The child already died - log the termination status if
         * necessary: */</comment>
        <expr_stmt><expr><call><name>ap_process_child_status</name><argument_list>(<argument><expr>&amp;<name>proc</name></expr></argument>, <argument><expr><name>why</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>rv</name> != <name>APR_CHILD_NOTDONE</name></expr>)</condition><then> <block>{
        <comment type="block">/* The child is already dead and reaped, or was a bogus pid -
         * log this either way. */</comment>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00048</expr></argument>)</argument_list></call>
                     "cannot send signal %d to pid %ld (non-child or "
                     "already dead)"</expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr>(<name>long</name>)<name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>pg</name></decl>;</decl_stmt>

    <comment type="block">/* Ensure pid sanity. */</comment>
    <if>if <condition>(<expr><name>pid</name> &lt; 1</expr>)</condition><then> <block>{
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>pg</name> = <call><name>getpgid</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>pg</name> == -1</expr>)</condition><then> <block>{
        <comment type="block">/* Process already dead... */</comment>
        <return>return <expr><name>errno</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>pg</name> != <call><name>getpgrp</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00049</expr></argument>)</argument_list></call>
                     "refusing to send signal %d to pid %ld outside "
                     "process group"</expr></argument>, <argument><expr><name>sig</name></expr></argument>, <argument><expr>(<name>long</name>)<name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> ? <name>errno</name> : <name>APR_SUCCESS</name></expr>;</return>
}</block>


<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_process_child_status</name><argument_list>(<argument>apr_proc_t *pid</argument>, <argument>apr_exit_why_e why</argument>,
                                        <argument>int status</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>signum</name> <init>= <expr><name>status</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sigdesc</name></decl>;</decl_stmt>

    <comment type="block">/* Child died... if it died due to a fatal error,
     * we should simply bail out.  The caller needs to
     * check for bad rc from us and exit, running any
     * appropriate cleanups.
     *
     * If the child died due to a resource shortage,
     * the parent should limit the rate of forking
     */</comment>
    <if>if <condition>(<expr><call><name>APR_PROC_CHECK_EXIT</name><argument_list>(<argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>status</name> == <name>APEXIT_CHILDSICK</name></expr>)</condition><then> <block>{
            <return>return <expr><name>status</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>status</name> == <name>APEXIT_CHILDFATAL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ALERT</name></expr></argument>,
                         <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00050</expr></argument>)</argument_list></call>
                         "Child %" <name>APR_PID_T_FMT</name>
                         " returned a Fatal error... Apache is exiting!"</expr></argument>,
                         <argument><expr><name><name>pid</name>-&gt;<name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APEXIT_CHILDFATAL</name></expr>;</return>
        }</block></then></if>

        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>APR_PROC_CHECK_SIGNALED</name><argument_list>(<argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sigdesc</name> = <call><name>apr_signal_description_get</name><argument_list>(<argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>signum</name></expr>)</condition> <block>{
        <case>case <expr><name>SIGTERM</name></expr>:
        </case><case>case <expr><name>SIGHUP</name></expr>:
        </case><case>case <expr><name>AP_SIG_GRACEFUL</name></expr>:
        </case><case>case <expr><name>SIGKILL</name></expr>:
            <break>break;</break>

        </case><default>default:
            <if>if <condition>(<expr><call><name>APR_PROC_CHECK_CORE_DUMP</name><argument_list>(<argument><expr><name>why</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>,
                             <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00051</expr></argument>)</argument_list></call>
                             "child pid %ld exit signal %s (%d), "
                             "possible coredump in %s"</expr></argument>,
                             <argument><expr>(<name>long</name>)<name><name>pid</name>-&gt;<name>pid</name></name></expr></argument>, <argument><expr><name>sigdesc</name></expr></argument>, <argument><expr><name>signum</name></expr></argument>,
                             <argument><expr><name>ap_coredump_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>,
                             <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00052</expr></argument>)</argument_list></call>
                             "child pid %ld exit signal %s (%d)"</expr></argument>,
                             <argument><expr>(<name>long</name>)<name><name>pid</name>-&gt;<name>pid</name></name></expr></argument>, <argument><expr><name>sigdesc</name></expr></argument>, <argument><expr><name>signum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        </default>}</block></switch>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_pod_open</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>ap_pod_t **pod</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>pod</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>**<name>pod</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_pipe_create_ex</name><argument_list>(<argument><expr>&amp;(<name>(*<name>pod</name>)-&gt;<name>pod_in</name></name>)</expr></argument>, <argument><expr>&amp;(<name>(*<name>pod</name>)-&gt;<name>pod_out</name></name>)</expr></argument>,
                                 <argument><expr><name>APR_WRITE_BLOCK</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_file_pipe_timeout_set</name><argument_list>(<argument><expr><name>(*<name>pod</name>)-&gt;<name>pod_in</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>(*<name>pod</name>)-&gt;<name>p</name></name> = <name>p</name></expr>;</expr_stmt>

    <comment type="block">/* close these before exec. */</comment>
    <expr_stmt><expr><call><name>apr_file_inherit_unset</name><argument_list>(<argument><expr><name>(*<name>pod</name>)-&gt;<name>pod_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_file_inherit_unset</name><argument_list>(<argument><expr><name>(*<name>pod</name>)-&gt;<name>pod_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_pod_check</name><argument_list>(<argument>ap_pod_t *pod</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_read</name><argument_list>(<argument><expr><name><name>pod</name>-&gt;<name>pod_in</name></name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>rv</name> == <name>APR_SUCCESS</name>) &amp;&amp; (<name>len</name> == 1)</expr>)</condition><then> <block>{
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>AP_NORESTART</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_pod_close</name><argument_list>(<argument>ap_pod_t *pod</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_close</name><argument_list>(<argument><expr><name><name>pod</name>-&gt;<name>pod_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_close</name><argument_list>(<argument><expr><name><name>pod</name>-&gt;<name>pod_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>pod_signal_internal</name><parameter_list>(<param><decl><type><name>ap_pod_t</name> *</type><name>pod</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>char_of_death</name> <init>= <expr>'!'</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_write</name><argument_list>(<argument><expr><name><name>pod</name>-&gt;<name>pod_out</name></name></expr></argument>, <argument><expr>&amp;<name>char_of_death</name></expr></argument>, <argument><expr>&amp;<name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00053</expr></argument>)</argument_list></call>
                     "write pipe_of_death"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_podx_open</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>ap_pod_t **pod</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>pod</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>**<name>pod</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_pipe_create</name><argument_list>(<argument><expr>&amp;(<name>(*<name>pod</name>)-&gt;<name>pod_in</name></name>)</expr></argument>, <argument><expr>&amp;(<name>(*<name>pod</name>)-&gt;<name>pod_out</name></name>)</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/*
     apr_file_pipe_timeout_set((*pod)-&gt;pod_in, 0);
     */</comment>
    <expr_stmt><expr><name>(*<name>pod</name>)-&gt;<name>p</name></name> = <name>p</name></expr>;</expr_stmt>

    <comment type="block">/* close these before exec. */</comment>
    <expr_stmt><expr><call><name>apr_file_inherit_unset</name><argument_list>(<argument><expr><name>(*<name>pod</name>)-&gt;<name>pod_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_file_inherit_unset</name><argument_list>(<argument><expr><name>(*<name>pod</name>)-&gt;<name>pod_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_mpm_podx_check</name><argument_list>(<argument>ap_pod_t *pod</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_os_file_t</name></type> <name>fd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <comment type="block">/* we need to surface EINTR so we'll have to grab the
     * native file descriptor and do the OS read() ourselves
     */</comment>
    <expr_stmt><expr><call><name>apr_os_file_get</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr><name><name>pod</name>-&gt;<name>pod_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rc</name> = <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rc</name> == 1</expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
            <case>case <expr><name>AP_MPM_PODX_RESTART_CHAR</name></expr>:
                <return>return <expr><name>AP_MPM_PODX_RESTART</name></expr>;</return>
            </case><case>case <expr><name>AP_MPM_PODX_GRACEFUL_CHAR</name></expr>:
                <return>return <expr><name>AP_MPM_PODX_GRACEFUL</name></expr>;</return>
        </case>}</block></switch>
    }</block></then></if>
    <return>return <expr><name>AP_MPM_PODX_NORESTART</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_podx_close</name><argument_list>(<argument>ap_pod_t *pod</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_close</name><argument_list>(<argument><expr><name><name>pod</name>-&gt;<name>pod_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_close</name><argument_list>(<argument><expr><name><name>pod</name>-&gt;<name>pod_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>podx_signal_internal</name><parameter_list>(<param><decl><type><name>ap_pod_t</name> *</type><name>pod</name></decl></param>,
                                        <param><decl><type><name>ap_podx_restart_t</name></type> <name>graceful</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>char_of_death</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
    <switch>switch <condition>(<expr><name>graceful</name></expr>)</condition> <block>{
        <case>case <expr><name>AP_MPM_PODX_RESTART</name></expr>:
            <expr_stmt><expr><name>char_of_death</name> = <name>AP_MPM_PODX_RESTART_CHAR</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPM_PODX_GRACEFUL</name></expr>:
            <expr_stmt><expr><name>char_of_death</name> = <name>AP_MPM_PODX_GRACEFUL_CHAR</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>AP_MPM_PODX_NORESTART</name></expr>:
            <break>break;</break>
    </case>}</block></switch>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_write</name><argument_list>(<argument><expr><name><name>pod</name>-&gt;<name>pod_out</name></name></expr></argument>, <argument><expr>&amp;<name>char_of_death</name></expr></argument>, <argument><expr>&amp;<name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02404</expr></argument>)</argument_list></call>
                     "write pipe_of_death"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_podx_signal</name><argument_list>(<argument>ap_pod_t * pod</argument>,
                                            <argument>ap_podx_restart_t graceful</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>podx_signal_internal</name><argument_list>(<argument><expr><name>pod</name></expr></argument>, <argument><expr><name>graceful</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_mpm_podx_killpg</name><argument_list>(<argument>ap_pod_t * pod</argument>, <argument>int num</argument>,
                                    <argument>ap_podx_restart_t graceful</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num</name> &amp;&amp; <name>rv</name> == <name>APR_SUCCESS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>podx_signal_internal</name><argument_list>(<argument><expr><name>pod</name></expr></argument>, <argument><expr><name>graceful</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block>

<comment type="block">/* This function connects to the server and sends enough data to
 * ensure the child wakes up and processes a new connection.  This
 * permits the MPM to skip the poll when there is only one listening
 * socket, because it provides a alternate way to unblock an accept()
 * when the pod is used.  */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>dummy_connection</name><parameter_list>(<param><decl><type><name>ap_pod_t</name> *</type><name>pod</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>sock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_listen_rec</name> *</type><name>lp</name></decl>;</decl_stmt>

    <comment type="block">/* create a temporary pool for the socket.  pconf stays around too long */</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name><name>pod</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If possible, find a listener which is configured for
     * plain-HTTP, not SSL; using an SSL port would either be
     * expensive to do correctly (performing a complete SSL handshake)
     * or cause log spam by doing incorrectly (simply sending EOF). */</comment>
    <expr_stmt><expr><name>lp</name> = <name>ap_listeners</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>lp</name> &amp;&amp; <name><name>lp</name>-&gt;<name>protocol</name></name> &amp;&amp; <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>lp</name>-&gt;<name>protocol</name></name></expr></argument>, <argument><expr>"http"</expr></argument>)</argument_list></call> != 0</expr>)</condition> <block>{
        <expr_stmt><expr><name>lp</name> = <name><name>lp</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr>!<name>lp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>lp</name> = <name>ap_listeners</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_socket_create</name><argument_list>(<argument><expr>&amp;<name>sock</name></expr></argument>, <argument><expr><name><name>lp</name>-&gt;<name>bind_addr</name>-&gt;<name>family</name></name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00054</expr></argument>)</argument_list></call>
                     "get socket to connect to listener"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* on some platforms (e.g., FreeBSD), the kernel won't accept many
     * queued connections before it starts blocking local connects...
     * we need to keep from blocking too long and instead return an error,
     * because the MPM won't want to hold up a graceful restart for a
     * long time
     */</comment>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_socket_timeout_set</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00055</expr></argument>)</argument_list></call>
                     "set timeout on socket to connect to listener"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_socket_connect</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name><name>lp</name>-&gt;<name>bind_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>log_level</name> <init>= <expr><name>APLOG_WARNING</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>APR_STATUS_IS_TIMEUP</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* probably some server processes bailed out already and there
             * is nobody around to call accept and clear out the kernel
             * connection queue; usually this is not worth logging
             */</comment>
            <expr_stmt><expr><name>log_level</name> = <name>APLOG_DEBUG</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>log_level</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00056</expr></argument>)</argument_list></call>
                     "connect to listener on %pI"</expr></argument>, <argument><expr><name><name>lp</name>-&gt;<name>bind_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>lp</name>-&gt;<name>protocol</name></name> &amp;&amp; <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>lp</name>-&gt;<name>protocol</name></name></expr></argument>, <argument><expr>"https"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* Send a TLS 1.0 close_notify alert.  This is perhaps the
         * "least wrong" way to open and cleanly terminate an SSL
         * connection.  It should "work" without noisy error logs if
         * the server actually expects SSLv3/TLSv1.  With
         * SSLv23_server_method() OpenSSL's SSL_accept() fails
         * ungracefully on receipt of this message, since it requires
         * an 11-byte ClientHello message and this is too short. */</comment>
        <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>tls10_close_notify</name><index>[<expr>7</expr>]</index></name> <init>= <expr><block>{
            <expr>'\x15'</expr>,         <comment type="block">/* TLSPlainText.type = Alert (21) */</comment>
            <expr>'\x03'</expr>, <expr>'\x01'</expr>, <comment type="block">/* TLSPlainText.version = {3, 1} */</comment>
            <expr>'\x00'</expr>, <expr>'\x02'</expr>, <comment type="block">/* TLSPlainText.length = 2 */</comment>
            <expr>'\x01'</expr>,         <comment type="block">/* Alert.level = warning (1) */</comment>
            <expr>'\x00'</expr>          <comment type="block">/* Alert.description = close_notify (0) */</comment>
        }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>data</name> = (const <name>char</name> *)<name>tls10_close_notify</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>tls10_close_notify</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    }</block></then>
    <else>else <comment type="block">/* ... XXX other request types here? */</comment> <block>{
        <comment type="block">/* Create an HTTP request string.  We include a User-Agent so
         * that adminstrators can track down the cause of the
         * odd-looking requests in their logs.  A complete request is
         * used since kernel-level filtering may require that much
         * data before returning from accept(). */</comment>
        <expr_stmt><expr><name>data</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"OPTIONS * HTTP/1.0\r\nUser-Agent: "</expr></argument>,
                           <argument><expr><call><name>ap_get_server_description</name><argument_list>()</argument_list></call></expr></argument>,
                           <argument><expr>" (internal dummy connection)\r\n\r\n"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>apr_socket_send</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_socket_close</name><argument_list>(<argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_pod_signal</name><argument_list>(<argument>ap_pod_t *pod</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>pod_signal_internal</name><argument_list>(<argument><expr><name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>dummy_connection</name><argument_list>(<argument><expr><name>pod</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<function><type><name>void</name></type> <name>ap_mpm_pod_killpg</name><parameter_list>(<param><decl><type><name>ap_pod_t</name> *</type><name>pod</name></decl></param>, <param><decl><type><name>int</name></type> <name>num</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* we don't write anything to the pod here...  we assume
     * that the would-be reader of the pod has another way to
     * see that it is time to die once we wake it up
     *
     * writing lots of things to the pod at once is very
     * problematic... we can fill the kernel pipe buffer and
     * be blocked until somebody consumes some bytes or
     * we hit a timeout...  if we hit a timeout we can't just
     * keep trying because maybe we'll never successfully
     * write again...  but then maybe we'll leave would-be
     * readers stranded (a number of them could be tied up for
     * a while serving time-consuming requests)
     */</comment>
    <comment type="block">/* Recall: we only worry about IDLE child processes here */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num</name> &amp;&amp; <name>rv</name> == <name>APR_SUCCESS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name>.<name>status</name> != <name>SERVER_READY</name> ||
            <name><name>ap_scoreboard_image</name>-&gt;<name>servers</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name>.<name>pid</name> == 0</expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>
        <expr_stmt><expr><name>rv</name> = <call><name>dummy_connection</name><argument_list>(<argument><expr><name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>dash_k_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>dash_k_arg_noarg</name> <init>= <expr>"noarg"</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>send_signal</name><parameter_list>(<param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>, <param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00057</expr></argument>)</argument_list></call>
                     "sending signal to server"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>ap_signal_server</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>exit_status</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pid_t</name></type> <name>otherpid</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>running</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>status</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>exit_status</name> = 0</expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_read_pid</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>, <argument><expr>&amp;<name>otherpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00058</expr></argument>)</argument_list></call>
                         "Error retrieving pid file %s"</expr></argument>, <argument><expr><name>ap_pid_fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00059</expr></argument>)</argument_list></call>
                         "Remove it before continuing if it is corrupted."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>exit_status</name> = 1</expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>status</name> = "httpd (no pid file) not running"</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* With containerization, httpd may get the same PID at each startup,
         * handle it as if it were not running (it obviously can't).
         */</comment>
        <if>if <condition>(<expr><name>otherpid</name> != <call><name>getpid</name><argument_list>()</argument_list></call> &amp;&amp; <call><name>kill</name><argument_list>(<argument><expr><name>otherpid</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>running</name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>,
                                  <argument><expr>"httpd (pid %" <name>APR_PID_T_FMT</name> ") already "
                                  "running"</expr></argument>, <argument><expr><name>otherpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>status</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>,
                                  <argument><expr>"httpd (pid %" <name>APR_PID_T_FMT</name> "?) not running"</expr></argument>,
                                  <argument><expr><name>otherpid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>

    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>dash_k_arg</name></expr></argument>, <argument><expr>"start"</expr></argument>)</argument_list></call> || <name>dash_k_arg</name> == <name>dash_k_arg_noarg</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>running</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s\n"</expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>dash_k_arg</name></expr></argument>, <argument><expr>"stop"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>running</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s\n"</expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>send_signal</name><argument_list>(<argument><expr><name>otherpid</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>dash_k_arg</name></expr></argument>, <argument><expr>"restart"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>running</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"httpd not running, trying to start\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>exit_status</name> = <call><name>send_signal</name><argument_list>(<argument><expr><name>otherpid</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></else></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>dash_k_arg</name></expr></argument>, <argument><expr>"graceful"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>running</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"httpd not running, trying to start\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>exit_status</name> = <call><name>send_signal</name><argument_list>(<argument><expr><name>otherpid</name></expr></argument>, <argument><expr><name>AP_SIG_GRACEFUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></else></if>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>dash_k_arg</name></expr></argument>, <argument><expr>"graceful-stop"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>running</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%s\n"</expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>exit_status</name> = <call><name>send_signal</name><argument_list>(<argument><expr><name>otherpid</name></expr></argument>, <argument><expr><name>AP_SIG_GRACEFUL_STOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>ap_mpm_rewrite_args</name><parameter_list>(<param><decl><type><name>process_rec</name> *</type><name>process</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>mpm_new_argv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_getopt_t</name> *</type><name>opt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>optbuf</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>optarg</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>mpm_new_argv</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>argc</name></name></expr></argument>,
                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> **</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> = <name><name>process</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_getopt_init</name><argument_list>(<argument><expr>&amp;<name>opt</name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>argc</name></name></expr></argument>, <argument><expr><name><name>process</name>-&gt;<name>argv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>opt</name>-&gt;<name>errfn</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>optbuf</name><index>[<expr>0</expr>]</index></name> = '-'</expr>;</expr_stmt>
    <comment type="block">/* option char returned by apr_getopt() will be stored in optbuf[1] */</comment>
    <expr_stmt><expr><name><name>optbuf</name><index>[<expr>2</expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <while>while <condition>(<expr>(<name>rv</name> = <call><name>apr_getopt</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr>"k:" <name>AP_SERVER_BASEARGS</name></expr></argument>,
                            <argument><expr><name>optbuf</name> + 1</expr></argument>, <argument><expr>&amp;<name>optarg</name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition> <block>{
        <switch>switch<condition>(<expr><name><name>optbuf</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{
        <case>case <expr>'k'</expr>:
            <if>if <condition>(<expr>!<name>dash_k_arg</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr>"start"</expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr>"stop"</expr></argument>)</argument_list></call> ||
                    !<call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr>"restart"</expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr>"graceful"</expr></argument>)</argument_list></call> ||
                    !<call><name>strcmp</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr>"graceful-stop"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>dash_k_arg</name> = <name>optarg</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></then></if>
        </case><default>default:
            <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> =
                <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>optbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>optarg</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> = <name>optarg</name></expr>;</expr_stmt>
            }</block></then></if>
        </default>}</block></switch>
    }</block></while>

    <comment type="block">/* back up to capture the bad argument */</comment>
    <if>if <condition>(<expr><name>rv</name> == <name>APR_BADCH</name> || <name>rv</name> == <name>APR_BADARG</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>opt</name>-&gt;<name>ind</name></name>--</expr>;</expr_stmt>
    }</block></then></if>

    <while>while <condition>(<expr><name><name>opt</name>-&gt;<name>ind</name></name> &lt; <name><name>opt</name>-&gt;<name>argc</name></name></expr>)</condition> <block>{
        <expr_stmt><expr>*(const <name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>mpm_new_argv</name></expr></argument>)</argument_list></call> =
            <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>process</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>opt</name>-&gt;<name>argv</name><index>[<expr><name><name>opt</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name><name>process</name>-&gt;<name>argc</name></name> = <name><name>mpm_new_argv</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>process</name>-&gt;<name>argv</name></name> = (const <name>char</name> * const *)<name><name>mpm_new_argv</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>NULL</name> == <name>dash_k_arg</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dash_k_arg</name> = <name>dash_k_arg_noarg</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>APR_REGISTER_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_signal_server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>parent_pid</name></decl>, <decl><type ref="prev"/><name>my_pid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_pool_t</name> *</type><name>pconf</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>AP_ENABLE_EXCEPTION_HOOK</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>exception_hook_enabled</name></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>char</name> *</type><name>ap_mpm_set_exception_hook</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name> <init>= <expr><call><name>ap_check_cmd_context</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>GLOBAL_ONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>is_virtual</name></name></expr>)</condition><then> <block>{
        <return>return <expr>"EnableExceptionHook directive not allowed in &lt;VirtualHost&gt;"</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"on"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>exception_hook_enabled</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>"off"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>exception_hook_enabled</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <return>return <expr>"parameter must be 'on' or 'off'"</expr>;</return>
    }</block></else></if></else></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_fatal_exception_hook</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ap_exception_info_t</name></type> <name>ei</name> <init>= <expr><block>{<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>exception_hook_enabled</name> &amp;&amp;
        <call><name>geteuid</name><argument_list>()</argument_list></call> != 0 &amp;&amp;
        <name>my_pid</name> != <name>parent_pid</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ei</name>.<name>sig</name></name> = <name>sig</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ei</name>.<name>pid</name></name> = <name>my_pid</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_run_fatal_exception</name><argument_list>(<argument><expr>&amp;<name>ei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_ENABLE_EXCEPTION_HOOK */</comment>

<comment type="block">/* handle all varieties of core dumping signals */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sig_coredump</name><parameter_list>(<param><decl><type><name>int</name></type> <name>sig</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>apr_filepath_set</name><argument_list>(<argument><expr><name>ap_coredump_dir</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>sig</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>AP_ENABLE_EXCEPTION_HOOK</name></expr></cpp:if>
    <expr_stmt><expr><call><name>run_fatal_exception_hook</name><argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* linuxthreads issue calling getpid() here:
     *   This comparison won't match if the crashing thread is
     *   some module's thread that runs in the parent process.
     *   The fallout, which is limited to linuxthreads:
     *   The special log message won't be written when such a
     *   thread in the parent causes the parent to crash.
     */</comment>
    <if>if <condition>(<expr><call><name>getpid</name><argument_list>()</argument_list></call> == <name>parent_pid</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>,
                     <argument><expr>0</expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00060</expr></argument>)</argument_list></call>
                     "seg fault or similar nasty error detected "
                     "in the parent process"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* XXX we can probably add some rudimentary cleanup code here,
         * like getting rid of the pid file.  If any additional bad stuff
         * happens, we are protected from recursive errors taking down the
         * system since this function is no longer the signal handler   GLA
         */</comment>
    }</block></then></if>
    <expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* At this point we've got sig blocked, because we're still inside
     * the signal handler.  When we leave the signal handler it will
     * be unblocked, and we'll take the signal... and coredump or whatever
     * is appropriate for this particular Unix.  In addition the parent
     * will see the real signal we received -- whereas if we called
     * abort() here, the parent would only see SIGABRT.
     */</comment>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_fatal_signal_child_setup</name><argument_list>(<argument>server_rec *s</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><name>my_pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_fatal_signal_setup</name><argument_list>(<argument>server_rec *s</argument>,
                                               <argument>apr_pool_t *in_pconf</argument>)</argument_list></macro>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_USE_SIGACTION</name></cpp:ifndef>
    <decl_stmt><decl><type>struct <name>sigaction</name></type> <name>sa</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>sizeof <name>sa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr>&amp;<name><name>sa</name>.<name>sa_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SA_ONESHOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><name><name>sa</name>.<name>sa_flags</name></name> = <name>SA_ONESHOT</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SA_RESETHAND</name></expr></argument>)</argument_list></call></expr></cpp:elif>
    <expr_stmt><expr><name><name>sa</name>.<name>sa_flags</name></name> = <name>SA_RESETHAND</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>sa</name>.<name>sa_handler</name></name> = <name>sig_coredump</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00061</expr></argument>)</argument_list></call> "sigaction(SIGSEGV)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00062</expr></argument>)</argument_list></call> "sigaction(SIGBUS)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGABORT</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGABORT</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00063</expr></argument>)</argument_list></call> "sigaction(SIGABORT)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGABRT</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGABRT</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00064</expr></argument>)</argument_list></call> "sigaction(SIGABRT)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00065</expr></argument>)</argument_list></call> "sigaction(SIGILL)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGFPE</name></cpp:ifdef>
    <if>if <condition>(<expr><call><name>sigaction</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr>&amp;<name>sa</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00066</expr></argument>)</argument_list></call> "sigaction(SIGFPE)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* NO_USE_SIGACTION */</comment>

    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr><name>sig_coredump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr><name>sig_coredump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGBUS */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGABORT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGABORT</name></expr></argument>, <argument><expr><name>sig_coredump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGABORT */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGABRT</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGABRT</name></expr></argument>, <argument><expr><name>sig_coredump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGABRT */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>, <argument><expr><name>sig_coredump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGILL */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGFPE</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_signal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>sig_coredump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SIGFPE */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NO_USE_SIGACTION */</comment>

    <expr_stmt><expr><name>pconf</name> = <name>in_pconf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>parent_pid</name> = <name>my_pid</name> = <call><name>getpid</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 */</comment>
</unit>
