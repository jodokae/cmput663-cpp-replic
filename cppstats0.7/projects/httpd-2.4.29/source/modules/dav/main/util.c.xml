<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/dav/main/util.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
** DAV extension module for Apache 2.0.*
**  - various utilities, repository-independent
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_dav.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <macro><name>dav_new_error</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int status</argument>, <argument>int error_id</argument>,
                                      <argument>apr_status_t aprerr</argument>, <argument>const char *desc</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>err</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* DBG3("dav_new_error: %d %d %s", status, error_id, desc ? desc : "(no desc)"); */</comment>

    <expr_stmt><expr><name><name>err</name>-&gt;<name>status</name></name> = <name>status</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>err</name>-&gt;<name>error_id</name></name> = <name>error_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>err</name>-&gt;<name>desc</name></name> = <name>desc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>err</name>-&gt;<name>aprerr</name></name> = <name>aprerr</name></expr>;</expr_stmt>

    <return>return <expr><name>err</name></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <macro><name>dav_new_error_tag</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int status</argument>,
                                          <argument>int error_id</argument>, <argument>apr_status_t aprerr</argument>,
                                          <argument>const char *desc</argument>,
                                          <argument>const char *namespace</argument>,
                                          <argument>const char *tagname</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name> <init>= <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>error_id</name></expr></argument>, <argument><expr><name>aprerr</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>err</name>-&gt;<name>tagname</name></name> = <name>tagname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>err</name>-&gt;<name>namespace</name></name> = <name>namespace</name></expr>;</expr_stmt>

    <return>return <expr><name>err</name></expr>;</return>
}</block>


<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <macro><name>dav_push_error</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int status</argument>,
                                       <argument>int error_id</argument>, <argument>const char *desc</argument>,
                                       <argument>dav_error *prev</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>err</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>err</name>-&gt;<name>status</name></name> = <name>status</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>err</name>-&gt;<name>error_id</name></name> = <name>error_id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>err</name>-&gt;<name>desc</name></name> = <name>desc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>err</name>-&gt;<name>prev</name></name> = <name>prev</name></expr>;</expr_stmt>

    <return>return <expr><name>err</name></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <macro><name>dav_join_error</name><argument_list>(<argument>dav_error *dest</argument>, <argument>dav_error *src</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>curr</name> <init>= <expr><name>dest</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* src error doesn't exist so nothing to join just return dest */</comment>
    <if>if <condition>(<expr><name>src</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>dest</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* dest error doesn't exist so nothing to join just return src */</comment>
    <if>if <condition>(<expr><name>curr</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>src</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* find last error in dest stack */</comment>
    <while>while <condition>(<expr><name><name>curr</name>-&gt;<name>prev</name></name> != <name>NULL</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>curr</name> = <name><name>curr</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* add the src error onto end of dest stack and return it */</comment>
    <expr_stmt><expr><name><name>curr</name>-&gt;<name>prev</name></name> = <name>src</name></expr>;</expr_stmt>
    <return>return <expr><name>dest</name></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_check_bufsize</name><argument_list>(<argument>apr_pool_t * p</argument>, <argument>dav_buffer *pbuf</argument>,
                                    <argument>apr_size_t extra_needed</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* grow the buffer if necessary */</comment>
    <if>if <condition>(<expr><name><name>pbuf</name>-&gt;<name>cur_len</name></name> + <name>extra_needed</name> &gt; <name><name>pbuf</name>-&gt;<name>alloc_len</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>newbuf</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>alloc_len</name></name> += <name>extra_needed</name> + <name>DAV_BUFFER_PAD</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>newbuf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pbuf</name>-&gt;<name>alloc_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name><name>pbuf</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name><name>pbuf</name>-&gt;<name>cur_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>buf</name></name> = <name>newbuf</name></expr>;</expr_stmt>
    }</block></then></if>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_set_bufsize</name><argument_list>(<argument>apr_pool_t * p</argument>, <argument>dav_buffer *pbuf</argument>,
                                  <argument>apr_size_t size</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* NOTE: this does not retain prior contents */</comment>

    <comment type="block">/* NOTE: this function is used to init the first pointer, too, since
       the PAD will be larger than alloc_len (0) for zeroed structures */</comment>

    <comment type="block">/* grow if we don't have enough for the requested size plus padding */</comment>
    <if>if <condition>(<expr><name>size</name> + <name>DAV_BUFFER_PAD</name> &gt; <name><name>pbuf</name>-&gt;<name>alloc_len</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* set the new length; min of MINSIZE */</comment>
        <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>alloc_len</name></name> = <name>size</name> + <name>DAV_BUFFER_PAD</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>pbuf</name>-&gt;<name>alloc_len</name></name> &lt; <name>DAV_BUFFER_MINSIZE</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>alloc_len</name></name> = <name>DAV_BUFFER_MINSIZE</name></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>buf</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>pbuf</name>-&gt;<name>alloc_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>cur_len</name></name> = <name>size</name></expr>;</expr_stmt>
}</block>


<comment type="block">/* initialize a buffer and copy the specified (null-term'd) string into it */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_buffer_init</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>dav_buffer *pbuf</argument>,
                                  <argument>const char *str</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>dav_set_bufsize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pbuf</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>pbuf</name>-&gt;<name>cur_len</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<comment type="block">/* append a string to the end of the buffer, adjust length */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_buffer_append</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>dav_buffer *pbuf</argument>,
                                    <argument>const char *str</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>dav_check_bufsize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pbuf</name>-&gt;<name>buf</name></name> + <name><name>pbuf</name>-&gt;<name>cur_len</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>cur_len</name></name> += <name>len</name></expr>;</expr_stmt>
}</block>

<comment type="block">/* place a string on the end of the buffer, do NOT adjust length */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_buffer_place</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>dav_buffer *pbuf</argument>,
                                   <argument>const char *str</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>dav_check_bufsize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pbuf</name>-&gt;<name>buf</name></name> + <name><name>pbuf</name>-&gt;<name>cur_len</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<comment type="block">/* place some memory on the end of a buffer; do NOT adjust length */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_buffer_place_mem</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>dav_buffer *pbuf</argument>,
                                       <argument>const void *mem</argument>, <argument>apr_size_t amt</argument>,
                                       <argument>apr_size_t pad</argument>)</argument_list></macro>
<block>{
    <expr_stmt><expr><call><name>dav_check_bufsize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>amt</name> + <name>pad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pbuf</name>-&gt;<name>buf</name></name> + <name><name>pbuf</name>-&gt;<name>cur_len</name></name></expr></argument>, <argument><expr><name>mem</name></expr></argument>, <argument><expr><name>amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<comment type="block">/*
** dav_lookup_uri()
**
** Extension for ap_sub_req_lookup_uri() which can't handle absolute
** URIs properly.
**
** If NULL is returned, then an error occurred with parsing the URI or
** the URI does not match the current server.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_lookup_result</argument>)</argument_list></macro> <macro><name>dav_lookup_uri</name><argument_list>(<argument>const char *uri</argument>,
                                              <argument>request_rec * r</argument>,
                                              <argument>int must_be_absolute</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_lookup_result</name></type> <name>result</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_port_t</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>comp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>new_file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>domain</name></decl>;</decl_stmt>

    <comment type="block">/* first thing to do is parse the URI into various components */</comment>
    <if>if <condition>(<expr><call><name>apr_uri_parse</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr>&amp;<name>comp</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>desc</name></name> = "Invalid syntax in Destination URI."</expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* the URI must be an absoluteURI (WEBDAV S9.3) */</comment>
    <if>if <condition>(<expr><name><name>comp</name>.<name>scheme</name></name> == <name>NULL</name> &amp;&amp; <name>must_be_absolute</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>desc</name></name> = "Destination URI must be an absolute URI."</expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* the URI must not have a query (args) or a fragment */</comment>
    <if>if <condition>(<expr><name><name>comp</name>.<name>query</name></name> != <name>NULL</name> || <name><name>comp</name>.<name>fragment</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>status</name></name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>desc</name></name> =
            "Destination URI contains invalid components "
            "(a query or a fragment)."</expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If the scheme or port was provided, then make sure that it matches
       the scheme/port of this request. If the request must be absolute,
       then require the (explicit/implicit) scheme/port be matching.

       ### hmm. if a port wasn't provided (does the parse return port==0?),
       ### but we're on a non-standard port, then we won't detect that the
       ### URI's port implies the wrong one.
    */</comment>
    <if>if <condition>(<expr><name><name>comp</name>.<name>scheme</name></name> != <name>NULL</name> || <name><name>comp</name>.<name>port</name></name> != 0 || <name>must_be_absolute</name></expr>)</condition><then>
    <block>{
        <comment type="block">/* ### not sure this works if the current request came in via https: */</comment>
        <expr_stmt><expr><name>scheme</name> = <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>scheme</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>scheme</name> == <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name>scheme</name> = <call><name>ap_http_scheme</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/* insert a port if the URI did not contain one */</comment>
        <if>if <condition>(<expr><name><name>comp</name>.<name>port</name></name> == 0</expr>)</condition><then>
            <expr_stmt><expr><name><name>comp</name>.<name>port</name></name> = <call><name>apr_uri_port_of_scheme</name><argument_list>(<argument><expr><name><name>comp</name>.<name>scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/* now, verify that the URI uses the same scheme as the current.
           request. the port must match our port.
        */</comment>
        <expr_stmt><expr><name>port</name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>local_addr</name>-&gt;<name>port</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>comp</name>.<name>scheme</name></name></expr></argument>, <argument><expr><name>scheme</name></expr></argument>)</argument_list></call> != 0
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>APACHE_PORT_HANDLING_IS_BUSTED</name></cpp:ifdef>
            || <name><name>comp</name>.<name>port</name></name> != <name>port</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            )</condition><then> <block>{
            <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>status</name></name> = <name>HTTP_BAD_GATEWAY</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>desc</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                           <argument><expr>"Destination URI refers to "
                                           "different scheme or port "
                                           "(%s://hostname:%d)" <name>APR_EOL_STR</name>
                                           "(want: %s://hostname:%d)"</expr></argument>,
                                           <argument><expr><name><name>comp</name>.<name>scheme</name></name> ? <name><name>comp</name>.<name>scheme</name></name> : <name>scheme</name></expr></argument>,
                                           <argument><expr><name><name>comp</name>.<name>port</name></name> ? <name><name>comp</name>.<name>port</name></name> : <name>port</name></expr></argument>,
                                           <argument><expr><name>scheme</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>result</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* we have verified the scheme, port, and general structure */</comment>

    <comment type="block">/*
    ** Hrm.  IE5 will pass unqualified hostnames for both the
    ** Host: and Destination: headers.  This breaks the
    ** http_vhost.c::matches_aliases function.
    **
    ** For now, qualify unqualified comp.hostnames with
    ** r-&gt;server-&gt;server_hostname.
    **
    ** ### this is a big hack. Apache should provide a better way.
    ** ### maybe the admin should list the unqualified hosts in a
    ** ### &lt;ServerAlias&gt; block?
    */</comment>
    <if>if <condition>(<expr><name><name>comp</name>.<name>hostname</name></name> != <name>NULL</name>
        &amp;&amp; <call><name>strrchr</name><argument_list>(<argument><expr><name><name>comp</name>.<name>hostname</name></name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call> == <name>NULL</name>
        &amp;&amp; (<name>domain</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>server_hostname</name></name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>comp</name>.<name>hostname</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>comp</name>.<name>hostname</name></name></expr></argument>, <argument><expr><name>domain</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* now, if a hostname was provided, then verify that it represents the
       same server as the current connection. note that we just use our
       port, since we've verified the URI matches ours */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>APACHE_PORT_HANDLING_IS_BUSTED</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>comp</name>.<name>hostname</name></name> != <name>NULL</name> &amp;&amp;
        !<call><name>ap_matches_request_vhost</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>comp</name>.<name>hostname</name></name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>status</name></name> = <name>HTTP_BAD_GATEWAY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>result</name>.<name>err</name>.<name>desc</name></name> = "Destination URI refers to a different server."</expr>;</expr_stmt>
        <return>return <expr><name>result</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* we have verified that the requested URI denotes the same server as
       the current request. Therefore, we can use ap_sub_req_lookup_uri() */</comment>

    <comment type="block">/* reconstruct a URI as just the path */</comment>
    <expr_stmt><expr><name>new_file</name> = <call><name>apr_uri_unparse</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>comp</name></expr></argument>, <argument><expr><name>APR_URI_UNP_OMITSITEPART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Lookup the URI and return the sub-request. Note that we use the
     * same HTTP method on the destination. This allows the destination
     * to apply appropriate restrictions (e.g. readonly).
     */</comment>
    <expr_stmt><expr><name><name>result</name>.<name>rnew</name></name> = <call><name>ap_sub_req_method_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr><name>new_file</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block>

<comment type="block">/* ---------------------------------------------------------------
**
** XML UTILITY FUNCTIONS
*/</comment>

<comment type="block">/* validate that the root element uses a given DAV: tagname (TRUE==valid) */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>dav_validate_root</name><argument_list>(<argument>const apr_xml_doc *doc</argument>,
                                   <argument>const char *tagname</argument>)</argument_list></macro>
<block>{
    <return>return <expr><name><name>doc</name>-&gt;<name>root</name></name> &amp;&amp;
        <name><name>doc</name>-&gt;<name>root</name>-&gt;<name>ns</name></name> == <name>APR_XML_NS_DAV_ID</name> &amp;&amp;
        <call><name>strcmp</name><argument_list>(<argument><expr><name><name>doc</name>-&gt;<name>root</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>tagname</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
}</block>

<comment type="block">/* find and return the (unique) child with a given DAV: tagname */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>apr_xml_elem *</argument>)</argument_list></macro> <macro><name>dav_find_child</name><argument_list>(<argument>const apr_xml_elem *elem</argument>,
                                           <argument>const char *tagname</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_xml_elem</name> *</type><name>child</name> <init>= <expr><name><name>elem</name>-&gt;<name>first_child</name></name></expr></init></decl>;</decl_stmt>

    <for>for (<init>;</init> <condition><expr><name>child</name></expr>;</condition> <incr><expr><name>child</name> = <name><name>child</name>-&gt;<name>next</name></name></expr></incr>)
        <if>if <condition>(<expr><name><name>child</name>-&gt;<name>ns</name></name> == <name>APR_XML_NS_DAV_ID</name> &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>tagname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>child</name></expr>;</return></then></if></for>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block>

<comment type="block">/* gather up all the CDATA into a single string */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>dav_xml_get_cdata</name><argument_list>(<argument>const apr_xml_elem *elem</argument>, <argument>apr_pool_t *pool</argument>,
                              <argument>int strip_white</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_text</name> *</type><name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_xml_elem</name> *</type><name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>cdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>tlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>found_text</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* initialize to avoid gcc warning */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>found_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <for>for (<init><expr><name>scan</name> = <name><name>elem</name>-&gt;<name>first_cdata</name>.<name>first</name></name></expr>;</init> <condition><expr><name>scan</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>scan</name> = <name><name>scan</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <expr_stmt><expr><name>found_text</name> = <name><name>scan</name>-&gt;<name>text</name></name></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>found_count</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>found_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <for>for (<init><expr><name>child</name> = <name><name>elem</name>-&gt;<name>first_child</name></name></expr>;</init> <condition><expr><name>child</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> = <name><name>child</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <for>for (<init><expr><name>scan</name> = <name><name>child</name>-&gt;<name>following_cdata</name>.<name>first</name></name></expr>;</init>
             <condition><expr><name>scan</name> != <name>NULL</name></expr>;</condition>
             <incr><expr><name>scan</name> = <name><name>scan</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><name>found_text</name> = <name><name>scan</name>-&gt;<name>text</name></name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>found_count</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>found_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></for>

    <comment type="block">/* some fast-path cases:
     * 1) zero-length cdata
     * 2) a single piece of cdata with no whitespace to strip
     */</comment>
    <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
        <return>return <expr>""</expr>;</return></then></if>
    <if>if <condition>(<expr><name>found_count</name> == 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>strip_white</name>
            || (!<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>found_text</name></expr></argument>)</argument_list></call>
                &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>found_text</name><index>[<expr><name>len</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <return>return <expr><name>found_text</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>cdata</name> = <name>s</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>scan</name> = <name><name>elem</name>-&gt;<name>first_cdata</name>.<name>first</name></name></expr>;</init> <condition><expr><name>scan</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>scan</name> = <name><name>scan</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <expr_stmt><expr><name>tlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>scan</name>-&gt;<name>text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>scan</name>-&gt;<name>text</name></name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>s</name> += <name>tlen</name></expr>;</expr_stmt>
    }</block></for>

    <for>for (<init><expr><name>child</name> = <name><name>elem</name>-&gt;<name>first_child</name></name></expr>;</init> <condition><expr><name>child</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>child</name> = <name><name>child</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <for>for (<init><expr><name>scan</name> = <name><name>child</name>-&gt;<name>following_cdata</name>.<name>first</name></name></expr>;</init>
             <condition><expr><name>scan</name> != <name>NULL</name></expr>;</condition>
             <incr><expr><name>scan</name> = <name><name>scan</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <expr_stmt><expr><name>tlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>scan</name>-&gt;<name>text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>scan</name>-&gt;<name>text</name></name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>s</name> += <name>tlen</name></expr>;</expr_stmt>
        }</block></for>
    }</block></for>

    <expr_stmt><expr>*<name>s</name> = '\0'</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>strip_white</name></expr>)</condition><then> <block>{
        <comment type="block">/* trim leading whitespace */</comment>
        <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>cdata</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{     <comment type="block">/* assume: return false for '\0' */</comment>
            <expr_stmt><expr>++<name>cdata</name></expr>;</expr_stmt>
            <expr_stmt><expr>--<name>len</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* trim trailing whitespace */</comment>
        <while>while <condition>(<expr><name>len</name>-- &gt; 0 &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>cdata</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
            <continue>continue;</continue></while>
        <expr_stmt><expr><name><name>cdata</name><index>[<expr><name>len</name> + 1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>cdata</name></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_xmlns_info *</argument>)</argument_list></macro> <macro><name>dav_xmlns_create</name><argument_list>(<argument>apr_pool_t *pool</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_xmlns_info</name> *</type><name>xi</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>xi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>xi</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xi</name>-&gt;<name>uri_prefix</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>xi</name>-&gt;<name>prefix_uri</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>xi</name></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_xmlns_add</name><argument_list>(<argument>dav_xmlns_info *xi</argument>,
                                <argument>const char *prefix</argument>, <argument>const char *uri</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* this "should" not overwrite a prefix mapping */</comment>
    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>prefix_uri</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* note: this may overwrite an existing URI-&gt;prefix mapping, but it
       doesn't matter -- any prefix is usable to specify the URI. */</comment>
    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>uri_prefix</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>dav_xmlns_add_uri</name><argument_list>(<argument>dav_xmlns_info *xi</argument>,
                                            <argument>const char *uri</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>prefix</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>uri_prefix</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>,
                               <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>prefix</name></expr>;</return></then></if>

    <expr_stmt><expr><name>prefix</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"g%d"</expr></argument>, <argument><expr><name><name>xi</name>-&gt;<name>count</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>dav_xmlns_add</name><argument_list>(<argument><expr><name>xi</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>prefix</name></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>dav_xmlns_get_uri</name><argument_list>(<argument>dav_xmlns_info *xi</argument>,
                                            <argument>const char *prefix</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>prefix_uri</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>dav_xmlns_get_prefix</name><argument_list>(<argument>dav_xmlns_info *xi</argument>,
                                               <argument>const char *uri</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>uri_prefix</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_xmlns_generate</name><argument_list>(<argument>dav_xmlns_info *xi</argument>,
                                     <argument>apr_text_header *phdr</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name> <init>= <expr><call><name>apr_hash_first</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>xi</name>-&gt;<name>prefix_uri</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for (<init>;</init> <condition><expr><name>hi</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>prefix</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>uri</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>prefix</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>s</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>" xmlns:%s=\"%s\""</expr></argument>,
                         <argument><expr>(const <name>char</name> *)<name>prefix</name></expr></argument>, <argument><expr>(const <name>char</name> *)<name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_text_append</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block>

<comment type="block">/* ---------------------------------------------------------------
**
** Timeout header processing
**
*/</comment>

<comment type="block">/* dav_get_timeout:  If the Timeout: header exists, return a time_t
 *    when this lock is expected to expire.  Otherwise, return
 *    a time_t of DAV_TIMEOUT_INFINITE.
 *
 *    It's unclear if DAV clients are required to understand
 *    Seconds-xxx and Infinity time values.  We assume that they do.
 *    In addition, for now, that's all we understand, too.
 */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>time_t</argument>)</argument_list></macro> <macro><name>dav_get_timeout</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>time_t</name></type> <name>now</name></decl>, <decl><type ref="prev"/><name>expires</name> <init>= <expr><name>DAV_TIMEOUT_INFINITE</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>timeout_const</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Timeout"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>timeout</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>timeout_const</name></expr></argument>)</argument_list></call></expr></init>, *<name>val</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>timeout</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>DAV_TIMEOUT_INFINITE</name></expr>;</return></then></if>

    <comment type="block">/* Use the first thing we understand, or infinity if
     * we don't understand anything.
     */</comment>

    <while>while <condition>(<expr>(<name>val</name> = <call><name>ap_getword_white</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>timeout</name></expr></argument>)</argument_list></call>) &amp;&amp; <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"Infinite"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>DAV_TIMEOUT_INFINITE</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"Second-"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>val</name> += 7</expr>;</expr_stmt>
            <comment type="block">/* ### We need to handle overflow better:
             * ### timeout will be &lt;= 2^32 - 1
             */</comment>
            <expr_stmt><expr><name>expires</name> = <call><name>atol</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>now</name>     = <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>now</name> + <name>expires</name></expr>;</return>
        }</block></then></if>
    }</block></while>

    <return>return <expr><name>DAV_TIMEOUT_INFINITE</name></expr>;</return>
}</block>

<comment type="block">/* ---------------------------------------------------------------
**
** If Header processing
**
*/</comment>

<comment type="block">/* add_if_resource returns a new if_header, linking it to next_ih.
 */</comment>
<function><type><specifier>static</specifier> <name>dav_if_header</name> *</type><name>dav_add_if_resource</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>dav_if_header</name> *</type><name>next_ih</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>uri_len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_if_header</name> *</type><name>ih</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>ih</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ih</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>ih</name>-&gt;<name>uri</name></name> = <name>uri</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ih</name>-&gt;<name>uri_len</name></name> = <name>uri_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ih</name>-&gt;<name>next</name></name> = <name>next_ih</name></expr>;</expr_stmt>

    <return>return <expr><name>ih</name></expr>;</return>
}</block></function>

<comment type="block">/* add_if_state adds a condition to an if_header.
 */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_add_if_state</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>dav_if_header</name> *</type><name>ih</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>state_token</name></decl></param>,
                                    <param><decl><type><name>dav_if_state_type</name></type> <name>t</name></decl></param>, <param><decl><type><name>int</name></type> <name>condition</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>locks_hooks</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_if_state_list</name> *</type><name>new_sl</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>new_sl</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_sl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>new_sl</name>-&gt;<name>condition</name></name> = <name>condition</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_sl</name>-&gt;<name>type</name></name>      = <name>t</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>t</name> == <name>dav_if_opaquelock</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>locks_hooks</name>-&gt;<name>parse_locktoken</name></name>)<argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>state_token</name></expr></argument>,
                                                   <argument><expr>&amp;<name><name>new_sl</name>-&gt;<name>locktoken</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* If the state token cannot be parsed, treat it as an
             * unknown state; this will evaluate to "false" later
             * during If header validation. */</comment>
            <if>if <condition>(<expr><name><name>err</name>-&gt;<name>error_id</name></name> == <name>DAV_ERR_LOCK_UNK_STATE_TOKEN</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>new_sl</name>-&gt;<name>type</name></name> = <name>dav_if_unknown</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* ### maybe add a higher-level description */</comment>
                <return>return <expr><name>err</name></expr>;</return>
            }</block></else></if>
        }</block></then></if>
    }</block></then>
    <else>else
        <expr_stmt><expr><name><name>new_sl</name>-&gt;<name>etag</name></name> = <name>state_token</name></expr>;</expr_stmt></else></if>

    <expr_stmt><expr><name><name>new_sl</name>-&gt;<name>next</name></name> = <name><name>ih</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ih</name>-&gt;<name>state</name></name> = <name>new_sl</name></expr>;</expr_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* fetch_next_token returns the substring from str+1
 * to the next occurrence of char term, or \0, whichever
 * occurs first.  Leading whitespace is ignored.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>dav_fetch_next_token</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>str</name></decl></param>, <param><decl><type><name>char</name></type> <name>term</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>sp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>token</name> = *<name>str</name> + 1</expr>;</expr_stmt>

    <while>while <condition>(<expr>*<name>token</name> &amp;&amp; (*<name>token</name> == ' ' || *<name>token</name> == '\t')</expr>)</condition>
        <expr_stmt><expr><name>token</name>++</expr>;</expr_stmt></while>

    <if>if <condition>(<expr>(<name>sp</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>term</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr>*<name>sp</name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>str</name> = <name>sp</name></expr>;</expr_stmt>
    <return>return <expr><name>token</name></expr>;</return>
}</block></function>

<comment type="block">/* dav_process_if_header:
 *
 *   If NULL (no error) is returned, then **if_header points to the
 *   "If" productions structure (or NULL if "If" is not present).
 *
 *   ### this part is bogus:
 *   If an error is encountered, the error is logged.  Parent should
 *   return err-&gt;status.
 */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_process_if_header</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>dav_if_header</name> **</type><name>p_ih</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>state_token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>        <comment type="block">/* scope of current production; NULL=no-tag */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>uri_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_if_header</name> *</type><name>ih</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>parsed_uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>locks_hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_LOCKS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <enum>enum <block>{<decl><name>no_tagged</name></decl>, <decl><name>tagged</name></decl>, <decl><name>unknown</name></decl>}</block> <decl><name>list_type</name> <init>= <expr><name>unknown</name></expr></init></decl>;</enum>
    <decl_stmt><decl><type><name>int</name></type> <name>condition</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>p_ih</name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>str</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"If"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <while>while <condition>(<expr>*<name>str</name></expr>)</condition> <block>{
        <switch>switch<condition>(<expr>*<name>str</name></expr>)</condition> <block>{
        <case>case <expr>'&lt;'</expr>:
            <comment type="block">/* Tagged-list production - following states apply to this uri */</comment>
            <if>if <condition>(<expr><name>list_type</name> == <name>no_tagged</name>
                || ((<name>uri</name> = <call><name>dav_fetch_next_token</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>'&gt;'</expr></argument>)</argument_list></call>) == <name>NULL</name>)</expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                     <argument><expr><name>DAV_ERR_IF_TAGGED</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr>"Invalid If-header: unclosed \"&lt;\" or "
                                     "unexpected tagged-list production."</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <comment type="block">/* 2518 specifies this must be an absolute URI; just take the
             * relative part for later comparison against r-&gt;uri */</comment>
            <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_uri_parse</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr>&amp;<name>parsed_uri</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name>
                || !<name><name>parsed_uri</name>.<name>path</name></name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                     <argument><expr><name>DAV_ERR_IF_TAGGED</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                                     <argument><expr>"Invalid URI in tagged If-header."</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <comment type="block">/* note that parsed_uri.path is allocated; we can trash it */</comment>

            <comment type="block">/* clean up the URI a bit */</comment>
            <expr_stmt><expr><call><name>ap_getparents</name><argument_list>(<argument><expr><name><name>parsed_uri</name>.<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* the resources we will compare to have unencoded paths */</comment>
            <if>if <condition>(<expr><call><name>ap_unescape_url</name><argument_list>(<argument><expr><name><name>parsed_uri</name>.<name>path</name></name></expr></argument>)</argument_list></call> != <name>OK</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                     <argument><expr><name>DAV_ERR_IF_TAGGED</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>,
                                     <argument><expr>"Invalid percent encoded URI in "
                                     "tagged If-header."</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>uri_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>parsed_uri</name>.<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>uri_len</name> &gt; 1 &amp;&amp; <name><name>parsed_uri</name>.<name>path</name><index>[<expr><name>uri_len</name> - 1</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>parsed_uri</name>.<name>path</name><index>[<expr>--<name>uri_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>uri</name> = <name><name>parsed_uri</name>.<name>path</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>list_type</name> = <name>tagged</name></expr>;</expr_stmt>
            <break>break;</break>

        </case><case>case <expr>'('</expr>:
            <comment type="block">/* List production */</comment>

            <comment type="block">/* If a uri has not been encountered, this is a No-Tagged-List */</comment>
            <if>if <condition>(<expr><name>list_type</name> == <name>unknown</name></expr>)</condition><then>
                <expr_stmt><expr><name>list_type</name> = <name>no_tagged</name></expr>;</expr_stmt></then></if>

            <if>if <condition>(<expr>(<name>list</name> = <call><name>dav_fetch_next_token</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>')'</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                     <argument><expr><name>DAV_ERR_IF_UNCLOSED_PAREN</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr>"Invalid If-header: unclosed \"(\"."</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr>(<name>ih</name> = <call><name>dav_add_if_resource</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>ih</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>uri_len</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
                <comment type="block">/* ### dav_add_if_resource() should return an error for us! */</comment>
                <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                     <argument><expr><name>DAV_ERR_IF_PARSE</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr>"Internal server error parsing \"If:\" "
                                     "header."</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>condition</name> = <name>DAV_IF_COND_NORMAL</name></expr>;</expr_stmt>

            <while>while <condition>(<expr>*<name>list</name></expr>)</condition> <block>{
                <comment type="block">/* List is the entire production (in a uri scope) */</comment>

                <switch>switch <condition>(<expr>*<name>list</name></expr>)</condition> <block>{
                <case>case <expr>'&lt;'</expr>:
                    <if>if <condition>(<expr>(<name>state_token</name> = <call><name>dav_fetch_next_token</name><argument_list>(<argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>'&gt;'</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
                        <comment type="block">/* ### add a description to this error */</comment>
                        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                             <argument><expr><name>DAV_ERR_IF_PARSE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
                    }</block></then></if>

                    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_add_if_state</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>ih</name></expr></argument>, <argument><expr><name>state_token</name></expr></argument>, <argument><expr><name>dav_if_opaquelock</name></expr></argument>,
                                                <argument><expr><name>condition</name></expr></argument>, <argument><expr><name>locks_hooks</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                        <comment type="block">/* ### maybe add a higher level description */</comment>
                        <return>return <expr><name>err</name></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name>condition</name> = <name>DAV_IF_COND_NORMAL</name></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr>'['</expr>:
                    <if>if <condition>(<expr>(<name>state_token</name> = <call><name>dav_fetch_next_token</name><argument_list>(<argument><expr>&amp;<name>list</name></expr></argument>, <argument><expr>']'</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
                        <comment type="block">/* ### add a description to this error */</comment>
                        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                             <argument><expr><name>DAV_ERR_IF_PARSE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
                    }</block></then></if>

                    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_add_if_state</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>ih</name></expr></argument>, <argument><expr><name>state_token</name></expr></argument>, <argument><expr><name>dav_if_etag</name></expr></argument>,
                                                <argument><expr><name>condition</name></expr></argument>, <argument><expr><name>locks_hooks</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                        <comment type="block">/* ### maybe add a higher level description */</comment>
                        <return>return <expr><name>err</name></expr>;</return>
                    }</block></then></if>
                    <expr_stmt><expr><name>condition</name> = <name>DAV_IF_COND_NORMAL</name></expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr>'N'</expr>:
                    <if>if <condition>(<expr><name><name>list</name><index>[<expr>1</expr>]</index></name> == 'o' &amp;&amp; <name><name>list</name><index>[<expr>2</expr>]</index></name> == 't'</expr>)</condition><then> <block>{
                        <if>if <condition>(<expr><name>condition</name> != <name>DAV_IF_COND_NORMAL</name></expr>)</condition><then> <block>{
                            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                                 <argument><expr><name>DAV_ERR_IF_MULTIPLE_NOT</name></expr></argument>, <argument><expr>0</expr></argument>,
                                                 <argument><expr>"Invalid \"If:\" header: "
                                                 "Multiple \"not\" entries "
                                                 "for the same state."</expr></argument>)</argument_list></call></expr>;</return>
                        }</block></then></if>
                        <expr_stmt><expr><name>condition</name> = <name>DAV_IF_COND_NOT</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><name>list</name> += 2</expr>;</expr_stmt>
                    <break>break;</break>

                </case><case>case <expr>' '</expr>:
                </case><case>case <expr>'\t'</expr>:
                    <break>break;</break>

                </case><default>default:
                    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                         <argument><expr><name>DAV_ERR_IF_UNK_CHAR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                         <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                     <argument><expr>"Invalid \"If:\" "
                                                     "header: Unexpected "
                                                     "character encountered "
                                                     "(0x%02x, '%c')."</expr></argument>,
                                                     <argument><expr>*<name>list</name></expr></argument>, <argument><expr>*<name>list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                </default>}</block></switch>

                <expr_stmt><expr><name>list</name>++</expr>;</expr_stmt>
            }</block></while>
            <break>break;</break>

        </case><case>case <expr>' '</expr>:
        </case><case>case <expr>'\t'</expr>:
            <break>break;</break>

        </case><default>default:
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                                 <argument><expr><name>DAV_ERR_IF_UNK_CHAR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                             <argument><expr>"Invalid \"If:\" header: "
                                             "Unexpected character "
                                             "encountered (0x%02x, '%c')."</expr></argument>,
                                             <argument><expr>*<name>str</name></expr></argument>, <argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        </default>}</block></switch>

        <expr_stmt><expr><name>str</name>++</expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr>*<name>p_ih</name> = <name>ih</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dav_find_submitted_locktoken</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_if_header</name> *</type><name>if_header</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>dav_lock</name> *</type><name>lock_list</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>locks_hooks</name></decl></param>)</parameter_list>
<block>{
    <for>for (<init>;</init> <condition><expr><name>if_header</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>if_header</name> = <name><name>if_header</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>dav_if_state_list</name> *</type><name>state_list</name></decl>;</decl_stmt>

        <for>for (<init><expr><name>state_list</name> = <name><name>if_header</name>-&gt;<name>state</name></name></expr>;</init>
             <condition><expr><name>state_list</name> != <name>NULL</name></expr>;</condition>
             <incr><expr><name>state_list</name> = <name><name>state_list</name>-&gt;<name>next</name></name></expr></incr>) <block>{

            <if>if <condition>(<expr><name><name>state_list</name>-&gt;<name>type</name></name> == <name>dav_if_opaquelock</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>dav_lock</name> *</type><name>lock</name></decl>;</decl_stmt>

                <comment type="block">/* given state_list-&gt;locktoken, match it */</comment>

                <comment type="block">/*
                ** The resource will have one or more lock tokens. We only
                ** need to match one of them against any token in the
                ** If: header.
                **
                ** One token case: It is an exclusive or shared lock. Either
                **                 way, we must find it.
                **
                ** N token case: They are shared locks. By policy, we need
                **               to match only one. The resource's other
                **               tokens may belong to somebody else (so we
                **               shouldn't see them in the If: header anyway)
                */</comment>
                <for>for (<init><expr><name>lock</name> = <name>lock_list</name></expr>;</init> <condition><expr><name>lock</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>lock</name> = <name><name>lock</name>-&gt;<name>next</name></name></expr></incr>) <block>{

                    <if>if <condition>(<expr>!<call>(*<name><name>locks_hooks</name>-&gt;<name>compare_locktoken</name></name>)<argument_list>(<argument><expr><name><name>state_list</name>-&gt;<name>locktoken</name></name></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>locktoken</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <return>return <expr>1</expr>;</return>
                    }</block></then></if>
                }</block></for>
            }</block></then></if>
        }</block></for>
    }</block></for>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* dav_validate_resource_state:
 *    Returns NULL if path/uri meets if-header and lock requirements
 */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_validate_resource_state</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                               <param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>dav_if_header</name> *</type><name>if_header</name></decl></param>,
                                               <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
                                               <param><decl><type><name>dav_buffer</name> *</type><name>pbuf</name></decl></param>,
                                               <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>etag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>locks_hooks</name> <init>= <expr>(<name>lockdb</name> ? <name><name>lockdb</name>-&gt;<name>hooks</name></name> : <name>NULL</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_if_header</name> *</type><name>ifhdr_scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_if_state_list</name> *</type><name>state_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lock</name> *</type><name>lock_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lock</name> *</type><name>lock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_matched</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>num_that_apply</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>seen_locktoken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>uri_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* DBG1("validate: &lt;%s&gt;", resource-&gt;uri); */</comment>

    <comment type="block">/*
    ** The resource will have one of three states:
    **
    ** 1) No locks. We have no special requirements that the user supply
    **    specific locktokens. One of the state lists must match, and
    **    we're done.
    **
    ** 2) One exclusive lock. The locktoken must appear *anywhere* in the
    **    If: header. Of course, asserting the token in a "Not" term will
    **    quickly fail that state list :-). If the locktoken appears in
    **    one of the state lists *and* one state list matches, then we're
    **    done.
    **
    ** 3) One or more shared locks. One of the locktokens must appear
    **    *anywhere* in the If: header. If one of the locktokens appears,
    **    and we match one state list, then we are done.
    **
    ** The &lt;seen_locktoken&gt; variable determines whether we have seen one
    ** of this resource's locktokens in the If: header.
    */</comment>

    <comment type="block">/*
    ** If this is a new lock request, &lt;flags&gt; will contain the requested
    ** lock scope.  Three rules apply:
    **
    ** 1) Do not require a (shared) locktoken to be seen (when we are
    **    applying another shared lock)
    ** 2) If the scope is exclusive and we see any locks, fail.
    ** 3) If the scope is shared and we see an exclusive lock, fail.
    */</comment>

    <if>if <condition>(<expr><name>lockdb</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* we're in State 1. no locks. */</comment>
        <expr_stmt><expr><name>lock_list</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/*
        ** ### hrm... we don't need to have these fully
        ** ### resolved since we're only looking at the
        ** ### locktokens...
        **
        ** ### use get_locks w/ calltype=PARTIAL
        */</comment>
        <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_lock_query</name><argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr>&amp;<name>lock_list</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                  <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                  <argument><expr>"The locks could not be queried for "
                                  "verification against a possible \"If:\" "
                                  "header."</expr></argument>,
                                  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="block">/* lock_list now determines whether we're in State 1, 2, or 3. */</comment>
    }</block></else></if>

    <comment type="block">/*
    ** For a new, exclusive lock: if any locks exist, fail.
    ** For a new, shared lock:    if an exclusive lock exists, fail.
    **                            else, do not require a token to be seen.
    */</comment>
    <if>if <condition>(<expr><name>flags</name> &amp; <name>DAV_LOCKSCOPE_EXCLUSIVE</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>lock_list</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_LOCKED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"Existing lock(s) on the requested resource "
                                 "prevent an exclusive lock."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="block">/*
        ** There are no locks, so we can pretend that we've already met
        ** any requirement to find the resource's locks in an If: header.
        */</comment>
        <expr_stmt><expr><name>seen_locktoken</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>DAV_LOCKSCOPE_SHARED</name></expr>)</condition><then> <block>{
        <comment type="block">/*
        ** Strictly speaking, we don't need this loop. Either the first
        ** (and only) lock will be EXCLUSIVE, or none of them will be.
        */</comment>
        <for>for (<init><expr><name>lock</name> = <name>lock_list</name></expr>;</init> <condition><expr><name>lock</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>lock</name> = <name><name>lock</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>scope</name></name> == <name>DAV_LOCKSCOPE_EXCLUSIVE</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_LOCKED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr>"The requested resource is already "
                                     "locked exclusively."</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></for>

        <comment type="block">/*
        ** The locks on the resource (if any) are all shared. Set the
        ** &lt;seen_locktoken&gt; flag to indicate that we do not need to find
        ** the locks in an If: header.
        */</comment>
        <expr_stmt><expr><name>seen_locktoken</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/*
        ** For methods other than LOCK:
        **
        ** If we have no locks or if the resource is not being modified
        ** (per RFC 4918 the lock token is not required on resources
        ** we are not changing), then &lt;seen_locktoken&gt; can be set to true --
        ** pretending that we've already met the requirement of seeing one
        ** of the resource's locks in the If: header.
        **
        ** Otherwise, it must be cleared and we'll look for one.
        */</comment>
        <expr_stmt><expr><name>seen_locktoken</name> = (<name>lock_list</name> == <name>NULL</name>
                          || <name>flags</name> &amp; <name>DAV_VALIDATE_NO_MODIFY</name>)</expr>;</expr_stmt>
    }</block></else></if></else></if>

    <comment type="block">/*
    ** If there is no If: header, then we can shortcut some logic:
    **
    ** 1) if we do not need to find a locktoken in the (non-existent) If:
    **    header, then we are successful.
    **
    ** 2) if we must find a locktoken in the (non-existent) If: header, then
    **    we fail.
    */</comment>
    <if>if <condition>(<expr><name>if_header</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>seen_locktoken</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>

        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_LOCKED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"This resource is locked and an \"If:\" header "
                             "was not supplied to allow access to the "
                             "resource."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <comment type="block">/* the If: header is present */</comment>

    <comment type="block">/*
    ** If a dummy header is present (because of a Lock-Token: header), then
    ** we are required to find that token in this resource's set of locks.
    ** If we have no locks, then we immediately fail.
    **
    ** This is a 400 (Bad Request) since they should only submit a locktoken
    ** that actually exists.
    **
    ** Don't issue this response if we're talking about the parent resource.
    ** It is okay for that resource to NOT have this locktoken.
    ** (in fact, it certainly will not: a dummy_header only occurs for the
    **  UNLOCK method, the parent is checked only for locknull resources,
    **  and the parent certainly does not have the (locknull's) locktoken)
    */</comment>
    <if>if <condition>(<expr><name>lock_list</name> == <name>NULL</name> &amp;&amp; <name><name>if_header</name>-&gt;<name>dummy_header</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>flags</name> &amp; <name>DAV_VALIDATE_IS_PARENT</name></expr>)</condition><then>
            <return>return <expr><name>NULL</name></expr>;</return></then></if>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"The locktoken specified in the \"Lock-Token:\" "
                             "header is invalid because this resource has no "
                             "outstanding locks."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
    ** Prepare the input URI. We want the URI to never have a trailing slash.
    **
    ** When URIs are placed into the dav_if_header structure, they are
    ** guaranteed to never have a trailing slash. If the URIs are equivalent,
    ** then it doesn't matter if they both lack a trailing slash -- they're
    ** still equivalent.
    **
    ** Note: we could also ensure that a trailing slash is present on both
    ** URIs, but the majority of URIs provided to us via a resource walk
    ** will not contain that trailing slash.
    */</comment>
    <expr_stmt><expr><name>uri</name> = <name><name>resource</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>uri_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>uri</name><index>[<expr><name>uri_len</name> - 1</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>dav_set_bufsize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>uri_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pbuf</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>uri_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>buf</name><index>[<expr>--<name>uri_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name>uri</name> = <name><name>pbuf</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* get the resource's etag; we may need it during the checks */</comment>
    <expr_stmt><expr><name>etag</name> = <call>(*<name><name>resource</name>-&gt;<name>hooks</name>-&gt;<name>getetag</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* how many state_lists apply to this URI? */</comment>
    <expr_stmt><expr><name>num_that_apply</name> = 0</expr>;</expr_stmt>

    <comment type="block">/* If there are if-headers, fail if this resource
     * does not match at least one state_list.
     */</comment>
    <for>for (<init><expr><name>ifhdr_scan</name> = <name>if_header</name></expr>;</init>
         <condition><expr><name>ifhdr_scan</name> != <name>NULL</name></expr>;</condition>
         <incr><expr><name>ifhdr_scan</name> = <name><name>ifhdr_scan</name>-&gt;<name>next</name></name></expr></incr>) <block>{

        <comment type="block">/* DBG2("uri=&lt;%s&gt;  if_uri=&lt;%s&gt;", uri, ifhdr_scan-&gt;uri ? ifhdr_scan-&gt;uri : "(no uri)"); */</comment>

        <if>if <condition>(<expr><name><name>ifhdr_scan</name>-&gt;<name>uri</name></name> != <name>NULL</name>
            &amp;&amp; (<name>uri_len</name> != <name><name>ifhdr_scan</name>-&gt;<name>uri_len</name></name>
                || <call><name>memcmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name><name>ifhdr_scan</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name>uri_len</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then> <block>{
            <comment type="block">/*
            ** A tagged-list's URI doesn't match this resource's URI.
            ** Skip to the next state_list to see if it will match.
            */</comment>
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* this state_list applies to this resource */</comment>

        <comment type="block">/*
        ** ### only one state_list should ever apply! a no-tag, or a tagged
        ** ### where S9.4.2 states only one can match.
        **
        ** ### revamp this code to loop thru ifhdr_scan until we find the
        ** ### matching state_list. process it. stop.
        */</comment>
        <expr_stmt><expr>++<name>num_that_apply</name></expr>;</expr_stmt>

        <comment type="block">/* To succeed, resource must match *all* of the states
         * specified in the state_list.
         */</comment>
        <for>for (<init><expr><name>state_list</name> = <name><name>ifhdr_scan</name>-&gt;<name>state</name></name></expr>;</init>
             <condition><expr><name>state_list</name> != <name>NULL</name></expr>;</condition>
             <incr><expr><name>state_list</name> = <name><name>state_list</name>-&gt;<name>next</name></name></expr></incr>) <block>{

            <switch>switch<condition>(<expr><name><name>state_list</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
            <case>case <expr><name>dav_if_etag</name></expr>:
            <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>given_etag</name></decl>, *<decl><type ref="prev"/><name>current_etag</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>mismatch</name></decl>;</decl_stmt>

                <comment type="block">/* Do a weak entity comparison function as defined in
                 * RFC 2616 13.3.3.
                 */</comment>
                <if>if <condition>(<expr><name><name>state_list</name>-&gt;<name>etag</name><index>[<expr>0</expr>]</index></name> == 'W' &amp;&amp;
                    <name><name>state_list</name>-&gt;<name>etag</name><index>[<expr>1</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>given_etag</name> = <name><name>state_list</name>-&gt;<name>etag</name></name> + 2</expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><name>given_etag</name> = <name><name>state_list</name>-&gt;<name>etag</name></name></expr>;</expr_stmt>
                }</block></else></if>
                <if>if <condition>(<expr><name><name>etag</name><index>[<expr>0</expr>]</index></name> == 'W' &amp;&amp;
                    <name><name>etag</name><index>[<expr>1</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>current_etag</name> = <name>etag</name> + 2</expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><name>current_etag</name> = <name>etag</name></expr>;</expr_stmt>
                }</block></else></if>

                <expr_stmt><expr><name>mismatch</name> = <call><name>strcmp</name><argument_list>(<argument><expr><name>given_etag</name></expr></argument>, <argument><expr><name>current_etag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name><name>state_list</name>-&gt;<name>condition</name></name> == <name>DAV_IF_COND_NORMAL</name> &amp;&amp; <name>mismatch</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                    ** The specified entity-tag does not match the
                    ** entity-tag on the resource. This state_list is
                    ** not going to match. Bust outta here.
                    */</comment>
                    <expr_stmt><expr><name>reason</name> =
                        "an entity-tag was specified, but the resource's "
                        "actual ETag does not match."</expr>;</expr_stmt>
                    <goto>goto <name>state_list_failed</name>;</goto>
                }</block></then>
                <else>else <if>if <condition>(<expr><name><name>state_list</name>-&gt;<name>condition</name></name> == <name>DAV_IF_COND_NOT</name>
                         &amp;&amp; !<name>mismatch</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                    ** The specified entity-tag DOES match the
                    ** entity-tag on the resource. This state_list is
                    ** not going to match. Bust outta here.
                    */</comment>
                    <expr_stmt><expr><name>reason</name> =
                        "an entity-tag was specified using the \"Not\" form, "
                        "but the resource's actual ETag matches the provided "
                        "entity-tag."</expr>;</expr_stmt>
                    <goto>goto <name>state_list_failed</name>;</goto>
                }</block></then></if></else></if>
                <break>break;</break>
            }</block>

            </case><case>case <expr><name>dav_if_opaquelock</name></expr>:
                <if>if <condition>(<expr><name>lockdb</name> == <name>NULL</name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>state_list</name>-&gt;<name>condition</name></name> == <name>DAV_IF_COND_NOT</name></expr>)</condition><then> <block>{
                        <comment type="block">/* the locktoken is definitely not there! (success) */</comment>
                        <continue>continue;</continue>
                    }</block></then></if>

                    <comment type="block">/* condition == DAV_IF_COND_NORMAL */</comment>

                    <comment type="block">/*
                    ** If no lockdb is provided, then validation fails for
                    ** this state_list (NORMAL means we were supposed to
                    ** find the token, which we obviously cannot do without
                    ** a lock database).
                    **
                    ** Go and try the next state list.
                    */</comment>
                    <expr_stmt><expr><name>reason</name> =
                        "a State-token was supplied, but a lock database "
                        "is not available for to provide the required lock."</expr>;</expr_stmt>
                    <goto>goto <name>state_list_failed</name>;</goto>
                }</block></then></if>

                <comment type="block">/* Resource validation 'fails' if:
                 *    ANY  of the lock-&gt;locktokens match
                 *         a NOT state_list-&gt;locktoken,
                 * OR
                 *    NONE of the lock-&gt;locktokens match
                 *         a NORMAL state_list-&gt;locktoken.
                 */</comment>
                <expr_stmt><expr><name>num_matched</name> = 0</expr>;</expr_stmt>
                <for>for (<init><expr><name>lock</name> = <name>lock_list</name></expr>;</init> <condition><expr><name>lock</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>lock</name> = <name><name>lock</name>-&gt;<name>next</name></name></expr></incr>) <block>{

                    <comment type="block">/*
                    DBG2("compare: rsrc=%s  ifhdr=%s",
                         (*locks_hooks-&gt;format_locktoken)(p, lock-&gt;locktoken),
                         (*locks_hooks-&gt;format_locktoken)(p, state_list-&gt;locktoken));
                    */</comment>

                    <comment type="block">/* nothing to do if the locktokens do not match. */</comment>
                    <if>if <condition>(<expr><call>(*<name><name>locks_hooks</name>-&gt;<name>compare_locktoken</name></name>)<argument_list>(<argument><expr><name><name>state_list</name>-&gt;<name>locktoken</name></name></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>locktoken</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <continue>continue;</continue>
                    }</block></then></if>

                    <comment type="block">/*
                    ** We have now matched up one of the resource's locktokens
                    ** to a locktoken in a State-token in the If: header.
                    ** Note this fact, so that we can pass the overall
                    ** requirement of seeing at least one of the resource's
                    ** locktokens.
                    */</comment>
                    <expr_stmt><expr><name>seen_locktoken</name> = 1</expr>;</expr_stmt>

                    <if>if <condition>(<expr><name><name>state_list</name>-&gt;<name>condition</name></name> == <name>DAV_IF_COND_NOT</name></expr>)</condition><then> <block>{
                        <comment type="block">/*
                        ** This state requires that the specified locktoken
                        ** is NOT present on the resource. But we just found
                        ** it. There is no way this state-list can now
                        ** succeed, so go try another one.
                        */</comment>
                        <expr_stmt><expr><name>reason</name> =
                            "a State-token was supplied, which used a "
                            "\"Not\" condition. The State-token was found "
                            "in the locks on this resource"</expr>;</expr_stmt>
                        <goto>goto <name>state_list_failed</name>;</goto>
                    }</block></then></if>

                    <comment type="block">/* condition == DAV_IF_COND_NORMAL */</comment>

                    <comment type="block">/* Validate auth_user:  If an authenticated user created
                    ** the lock, only the same user may submit that locktoken
                    ** to manipulate a resource.
                    */</comment>
                    <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>auth_user</name></name> &amp;&amp;
                        (!<name><name>r</name>-&gt;<name>user</name></name> ||
                         <call><name>strcmp</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>auth_user</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>user</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name></decl>;</decl_stmt>

                        <expr_stmt><expr><name>errmsg</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"User \""</expr></argument>,
                                            <argument><expr><name><name>r</name>-&gt;<name>user</name></name></expr></argument>,
                                            <argument><expr>"\" submitted a locktoken created "
                                            "by user \""</expr></argument>,
                                            <argument><expr><name><name>lock</name>-&gt;<name>auth_user</name></name></expr></argument>, <argument><expr>"\"."</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>)</argument_list></call></expr>;</return>
                    }</block></then></if>

                    <comment type="block">/*
                    ** We just matched a specified State-Token to one of the
                    ** resource's locktokens.
                    **
                    ** Break out of the lock scan -- we only needed to find
                    ** one match (actually, there shouldn't be any other
                    ** matches in the lock list).
                    */</comment>
                    <expr_stmt><expr><name>num_matched</name> = 1</expr>;</expr_stmt>
                    <break>break;</break>
                }</block></for>

                <if>if <condition>(<expr><name>num_matched</name> == 0
                    &amp;&amp; <name><name>state_list</name>-&gt;<name>condition</name></name> == <name>DAV_IF_COND_NORMAL</name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                    ** We had a NORMAL state, meaning that we should have
                    ** found the State-Token within the locks on this
                    ** resource. We didn't, so this state_list must fail.
                    */</comment>
                    <expr_stmt><expr><name>reason</name> =
                        "a State-token was supplied, but it was not found "
                        "in the locks on this resource."</expr>;</expr_stmt>
                    <goto>goto <name>state_list_failed</name>;</goto>
                }</block></then></if>

                <break>break;</break>

            </case><case>case <expr><name>dav_if_unknown</name></expr>:
                <comment type="block">/* Request is predicated on some unknown state token,
                 * which must be presumed to *not* match, so fail
                 * unless this is a Not condition. */</comment>

                <if>if <condition>(<expr><name><name>state_list</name>-&gt;<name>condition</name></name> == <name>DAV_IF_COND_NORMAL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>reason</name> =
                        "an unknown state token was supplied"</expr>;</expr_stmt>
                    <goto>goto <name>state_list_failed</name>;</goto>
                }</block></then></if>
                <break>break;</break>

            </case>}</block></switch> <comment type="block">/* switch */</comment>
        }</block></for> <comment type="block">/* foreach ( state_list ) */</comment>

        <comment type="block">/*
        ** We've checked every state in this state_list and none of them
        ** have failed. Since all of them succeeded, then we have a matching
        ** state list and we may be done.
        **
        ** The next requirement is that we have seen one of the resource's
        ** locktokens (if any). If we have, then we can just exit. If we
        ** haven't, then we need to keep looking.
        */</comment>
        <if>if <condition>(<expr><name>seen_locktoken</name></expr>)</condition><then> <block>{
            <comment type="block">/* woo hoo! */</comment>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/*
        ** Haven't seen one. Let's break out of the search and just look
        ** for a matching locktoken.
        */</comment>
        <break>break;</break>

        <comment type="block">/*
        ** This label is used when we detect that a state_list is not
        ** going to match this resource. We bust out and try the next
        ** state_list.
        */</comment>
      <label><name>state_list_failed</name>:</label>
        <empty_stmt>;</empty_stmt>

    }</block></for> <comment type="block">/* foreach ( ifhdr_scan ) */</comment>

    <comment type="block">/*
    ** The above loop exits for one of two reasons:
    **   1) a state_list matched and seen_locktoken is false.
    **   2) all if_header structures were scanned, without (1) occurring
    */</comment>

    <if>if <condition>(<expr><name>ifhdr_scan</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/*
        ** We finished the loop without finding any matching state lists.
        */</comment>

        <comment type="block">/*
        ** If none of the state_lists apply to this resource, then we
        ** may have succeeded. Note that this scenario implies a
        ** tagged-list with no matching state_lists. If the If: header
        ** was a no-tag-list, then it would have applied to this resource.
        **
        ** S9.4.2 states that when no state_lists apply, then the header
        ** should be ignored.
        **
        ** If we saw one of the resource's locktokens, then we're done.
        ** If we did not see a locktoken, then we fail.
        */</comment>
        <if>if <condition>(<expr><name>num_that_apply</name> == 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>seen_locktoken</name></expr>)</condition><then>
                <return>return <expr><name>NULL</name></expr>;</return></then></if>

            <comment type="block">/*
            ** We may have aborted the scan before seeing the locktoken.
            ** Rescan the If: header to see if we can find the locktoken
            ** somewhere.
            **
            ** Note that seen_locktoken == 0 implies lock_list != NULL
            ** which implies locks_hooks != NULL.
            */</comment>
            <if>if <condition>(<expr><call><name>dav_find_submitted_locktoken</name><argument_list>(<argument><expr><name>if_header</name></expr></argument>, <argument><expr><name>lock_list</name></expr></argument>,
                                             <argument><expr><name>locks_hooks</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/*
                ** We found a match! We're set... none of the If: header
                ** assertions apply (implicit success), and the If: header
                ** specified the locktoken somewhere. We're done.
                */</comment>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_LOCKED</name></expr></argument>, <argument><expr>0</expr></argument> <comment type="block">/* error_id */</comment>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"This resource is locked and the \"If:\" "
                                 "header did not specify one of the "
                                 "locktokens for this resource's lock(s)."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <comment type="block">/* else: one or more state_lists were applicable, but failed. */</comment>

        <comment type="block">/*
        ** If the dummy_header did not match, then they specified an
        ** incorrect token in the Lock-Token header. Forget whether the
        ** If: statement matched or not... we'll tell them about the
        ** bad Lock-Token first. That is considered a 400 (Bad Request).
        */</comment>
        <if>if <condition>(<expr><name><name>if_header</name>-&gt;<name>dummy_header</name></name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"The locktoken specified in the "
                                 "\"Lock-Token:\" header did not specify one "
                                 "of this resource's locktoken(s)."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>reason</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_PRECONDITION_FAILED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"The preconditions specified by the \"If:\" "
                                 "header did not match this resource."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_PRECONDITION_FAILED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                         <argument><expr>"The precondition(s) specified by "
                                         "the \"If:\" header did not match "
                                         "this resource. At least one "
                                         "failure is because: %s"</expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* assert seen_locktoken == 0 */</comment>

    <comment type="block">/*
    ** ifhdr_scan != NULL implies we found a matching state_list.
    **
    ** Since we're still here, it also means that we have not yet found
    ** one the resource's locktokens in the If: header.
    **
    ** Scan all the if_headers and states looking for one of this
    ** resource's locktokens. Note that we need to go back and scan them
    ** all -- we may have aborted a scan with a failure before we saw a
    ** matching token.
    **
    ** Note that seen_locktoken == 0 implies lock_list != NULL which implies
    ** locks_hooks != NULL.
    */</comment>
    <if>if <condition>(<expr><call><name>dav_find_submitted_locktoken</name><argument_list>(<argument><expr><name>if_header</name></expr></argument>, <argument><expr><name>lock_list</name></expr></argument>, <argument><expr><name>locks_hooks</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/*
        ** We found a match! We're set... we have a matching state list,
        ** and the If: header specified the locktoken somewhere. We're done.
        */</comment>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
    ** We had a matching state list, but the user agent did not specify one
    ** of this resource's locktokens. Tell them so.
    **
    ** Note that we need to special-case the message on whether a "dummy"
    ** header exists. If it exists, yet we didn't see a needed locktoken,
    ** then that implies the dummy header (Lock-Token header) did NOT
    ** specify one of this resource's locktokens. (this implies something
    ** in the real If: header matched)
    **
    ** We want to note the 400 (Bad Request) in favor of a 423 (Locked).
    */</comment>
    <if>if <condition>(<expr><name><name>if_header</name>-&gt;<name>dummy_header</name></name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"The locktoken specified in the "
                             "\"Lock-Token:\" header did not specify one "
                             "of this resource's locktoken(s)."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_LOCKED</name></expr></argument>, <argument><expr>1</expr></argument> <comment type="block">/* error_id */</comment>, <argument><expr>0</expr></argument>,
                         <argument><expr>"This resource is locked and the \"If:\" header "
                         "did not specify one of the "
                         "locktokens for this resource's lock(s)."</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* dav_validate_walker:  Walker callback function to validate resource state */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_validate_walker</name><parameter_list>(<param><decl><type><name>dav_walk_resource</name> *</type><name>wres</name></decl></param>, <param><decl><type><name>int</name></type> <name>calltype</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_walker_ctx</name> *</type><name>ctx</name> <init>= <expr><name><name>wres</name>-&gt;<name>walk_ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_validate_resource_state</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>w</name>.<name>pool</name></name></expr></argument>, <argument><expr><name><name>wres</name>-&gt;<name>resource</name></name></expr></argument>,
                                           <argument><expr><name><name>ctx</name>-&gt;<name>w</name>.<name>lockdb</name></name></expr></argument>,
                                           <argument><expr><name><name>ctx</name>-&gt;<name>if_header</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>flags</name></name></expr></argument>,
                                           <argument><expr>&amp;<name><name>ctx</name>-&gt;<name>work_buf</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* There was no error, so just bug out. */</comment>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
    ** If we have a serious server error, or if the request itself failed,
    ** then just return error (not a multistatus).
    */</comment>
    <if>if <condition>(<expr><call><name>ap_is_HTTP_SERVER_ERROR</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call>
        || <call>(*<name><name>wres</name>-&gt;<name>resource</name>-&gt;<name>hooks</name>-&gt;<name>is_same_resource</name></name>)<argument_list>(<argument><expr><name><name>wres</name>-&gt;<name>resource</name></name></expr></argument>,
                                                      <argument><expr><name><name>ctx</name>-&gt;<name>w</name>.<name>root</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* ### maybe push a higher-level description? */</comment>
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* associate the error with the current URI */</comment>
    <expr_stmt><expr><call><name>dav_add_response</name><argument_list>(<argument><expr><name>wres</name></expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* If-* header checking */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>dav_meets_conditions</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name></type> <name>resource_state</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>if_match</name></decl>, *<decl><type ref="prev"/><name>if_none_match</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>retVal</name></decl>;</decl_stmt>

    <comment type="block">/* If-Match '*' fix. Resource existence not checked by ap_meets_conditions.
     * If-Match '*' request should succeed only if the resource exists. */</comment>
    <if>if <condition>(<expr>(<name>if_match</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"If-Match"</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>if_match</name><index>[<expr>0</expr>]</index></name> == '*' &amp;&amp; <name>resource_state</name> != <name>DAV_RESOURCE_EXISTS</name></expr>)</condition><then>
            <return>return <expr><name>HTTP_PRECONDITION_FAILED</name></expr>;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name>retVal</name> = <call><name>ap_meets_conditions</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If-None-Match '*' fix. If-None-Match '*' request should succeed
     * if the resource does not exist. */</comment>
    <if>if <condition>(<expr><name>retVal</name> == <name>HTTP_PRECONDITION_FAILED</name></expr>)</condition><then> <block>{
        <comment type="block">/* Note. If if_none_match != NULL, if_none_match is the culprit.
         * Since, in presence of If-None-Match,
         * other If-* headers are undefined. */</comment>
        <if>if <condition>(<expr>(<name>if_none_match</name> =
            <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"If-None-Match"</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>if_none_match</name><index>[<expr>0</expr>]</index></name> == '*'
                &amp;&amp; <name>resource_state</name> != <name>DAV_RESOURCE_EXISTS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>OK</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>retVal</name></expr>;</return>
}</block></function>

<comment type="block">/*
** dav_validate_request:  Validate if-headers (and check for locks) on:
**    (1) r-&gt;filename @ depth;
**    (2) Parent of r-&gt;filename if check_parent == 1
**
** The check of parent should be done when it is necessary to verify that
** the parent collection will accept a new member (ie current resource
** state is null).
**
** Return OK on successful validation.
** On error, return appropriate HTTP_* code, and log error. If a multi-stat
** error is necessary, response will point to it, else NULL.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_validate_request</name><argument_list>(<argument>request_rec *r</argument>,
                                              <argument>dav_resource *resource</argument>,
                                              <argument>int depth</argument>,
                                              <argument>dav_locktoken *locktoken</argument>,
                                              <argument>dav_response **response</argument>,
                                              <argument>int flags</argument>,
                                              <argument>dav_lockdb *lockdb</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_if_header</name> *</type><name>if_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lock_db_opened_locally</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>locks_hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_LOCKS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_repository</name> *</type><name>repos_hooks</name> <init>= <expr><name><name>resource</name>-&gt;<name>hooks</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_buffer</name></type> <name>work_buf</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_response</name> *</type><name>new_response</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>resource_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>etag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>set_etag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DAV_DEBUG</name></expr></cpp:if>
    <if>if <condition>(<expr><name>depth</name> &amp;&amp; <name>response</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/*
        ** ### bleck. we can't return errors for other URIs unless we have
        ** ### a "response" ptr.
        */</comment>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"DESIGN ERROR: dav_validate_request called "
                             "with depth&gt;0, but no response ptr."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>response</name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>response</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* Set the ETag header required by dav_meets_conditions() */</comment>
    <expr_stmt><expr><name>etag</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"ETag"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>etag</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>etag</name> = <call>(*<name><name>resource</name>-&gt;<name>hooks</name>-&gt;<name>getetag</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>etag</name> &amp;&amp; *<name>etag</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_table_set</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"ETag"</expr></argument>, <argument><expr><name>etag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>set_etag</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <comment type="block">/* Do the standard checks for conditional requests using
     * If-..-Since, If-Match etc */</comment>
    <expr_stmt><expr><name>resource_state</name> = <call><name>dav_get_resource_state</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <call><name>dav_meets_conditions</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>resource_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>set_etag</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * If we have set an ETag to headers out above for
         * dav_meets_conditions() revert this here as we do not want to set
         * the ETag in responses to requests with methods where this might not
         * be desired.
         */</comment>
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"ETag"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>result</name> != <name>OK</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* always parse (and later process) the If: header */</comment>
    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_process_if_header</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>if_header</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### maybe add higher-level description */</comment>
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If a locktoken was specified, create a dummy if_header with which
     * to validate resources.  In the interim, figure out why DAV uses
     * locktokens in an if-header without a Lock-Token header to refresh
     * locks, but a Lock-Token header without an if-header to remove them.
     */</comment>
    <if>if <condition>(<expr><name>locktoken</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_if_header</name> *</type><name>ifhdr_new</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>ifhdr_new</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ifhdr_new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ifhdr_new</name>-&gt;<name>uri</name></name> = <name><name>resource</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ifhdr_new</name>-&gt;<name>uri_len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ifhdr_new</name>-&gt;<name>dummy_header</name></name> = 1</expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ifhdr_new</name>-&gt;<name>state</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name><name>ifhdr_new</name>-&gt;<name>state</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ifhdr_new</name>-&gt;<name>state</name>-&gt;<name>type</name></name> = <name>dav_if_opaquelock</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ifhdr_new</name>-&gt;<name>state</name>-&gt;<name>condition</name></name> = <name>DAV_IF_COND_NORMAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ifhdr_new</name>-&gt;<name>state</name>-&gt;<name>locktoken</name></name> = <name>locktoken</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ifhdr_new</name>-&gt;<name>next</name></name> = <name>if_header</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>if_header</name> = <name>ifhdr_new</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
    ** If necessary, open the lock database (read-only, lazily);
    ** the validation process may need to retrieve or update lock info.
    ** Otherwise, assume provided lockdb is valid and opened rw.
    */</comment>
    <if>if <condition>(<expr><name>lockdb</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>locks_hooks</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>locks_hooks</name>-&gt;<name>open_lockdb</name></name>)<argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>lockdb</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                <comment type="block">/* ### maybe insert higher-level comment */</comment>
                <return>return <expr><name>err</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>lock_db_opened_locally</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* (1) Validate the specified resource, at the specified depth.
     * Avoid the walk there is no if_header and we aren't planning
     * to modify this resource. */</comment>
    <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>exists</name></name> &amp;&amp; <name>depth</name> &gt; 0 &amp;&amp; !(!<name>if_header</name> &amp;&amp; <name>flags</name> &amp; <name>DAV_VALIDATE_NO_MODIFY</name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_walker_ctx</name></type> <name>ctx</name> <init>= <expr><block>{ <expr><block>{ <expr>0</expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dav_response</name> *</type><name>multi_status</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_type</name></name> = <name>DAV_WALKTYPE_NORMAL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>func</name></name> = <name>dav_validate_walker</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_ctx</name></name> = &amp;<name>ctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>root</name></name> = <name>resource</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ctx</name>.<name>if_header</name></name> = <name>if_header</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>flags</name></name> = <name>flags</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>lockdb</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>lockdb</name></name> = <name>lockdb</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_type</name></name> |= <name>DAV_WALKTYPE_LOCKNULL</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>err</name> = <call>(*<name><name>repos_hooks</name>-&gt;<name>walk</name></name>)<argument_list>(<argument><expr>&amp;<name><name>ctx</name>.<name>w</name></name></expr></argument>, <argument><expr><name>DAV_INFINITY</name></expr></argument>, <argument><expr>&amp;<name>multi_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>response</name> = <name>multi_status</name></expr>;</expr_stmt>
        }</block></then></if>
        <comment type="block">/* else: implies a 5xx status code occurred. */</comment>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>err</name> = <call><name>dav_validate_resource_state</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr><name>lockdb</name></expr></argument>,
                                          <argument><expr><name>if_header</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>work_buf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* (2) Validate the parent resource if requested */</comment>
    <if>if <condition>(<expr><name>err</name> == <name>NULL</name> &amp;&amp; (<name>flags</name> &amp; <name>DAV_VALIDATE_PARENT</name>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_resource</name> *</type><name>parent_resource</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>err</name> = <call>(*<name><name>repos_hooks</name>-&gt;<name>get_parent_resource</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr>&amp;<name>parent_resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>err</name> == <name>NULL</name> &amp;&amp; <name>parent_resource</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>err</name> = <call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                <argument><expr>"Cannot access parent of repository root."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>err</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>err</name> = <call><name>dav_validate_resource_state</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>parent_resource</name></expr></argument>, <argument><expr><name>lockdb</name></expr></argument>,
                                              <argument><expr><name>if_header</name></expr></argument>,
                                              <argument><expr><name>flags</name> | <name>DAV_VALIDATE_IS_PARENT</name></expr></argument>,
                                              <argument><expr>&amp;<name>work_buf</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
            ** This error occurred on the parent resource. This implies that
            ** we have to create a multistatus response (to report the error
            ** against a URI other than the Request-URI). "Convert" this error
            ** into a multistatus response.
            */</comment>
            <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>new_response</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_response</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>new_response</name>-&gt;<name>href</name></name> = <name><name>parent_resource</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>new_response</name>-&gt;<name>status</name></name> = <name><name>err</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>new_response</name>-&gt;<name>desc</name></name> =
                    "A validation error has occurred on the parent resource, "
                    "preventing the operation on the resource specified by "
                    "the Request-URI."</expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>err</name>-&gt;<name>desc</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>new_response</name>-&gt;<name>desc</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                    <argument><expr><name><name>new_response</name>-&gt;<name>desc</name></name></expr></argument>,
                                                    <argument><expr>" The error was: "</expr></argument>,
                                                    <argument><expr><name><name>err</name>-&gt;<name>desc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/* assert: DAV_VALIDATE_PARENT implies response != NULL */</comment>
                <expr_stmt><expr><name><name>new_response</name>-&gt;<name>next</name></name> = *<name>response</name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>response</name> = <name>new_response</name></expr>;</expr_stmt>

                <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if>
    }</block></then></if>

    <if>if <condition>(<expr><name>lock_db_opened_locally</name></expr>)</condition><then>
        <expr_stmt><expr><call>(*<name><name>locks_hooks</name>-&gt;<name>close_lockdb</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/*
    ** If we don't have a (serious) error, and we have multistatus responses,
    ** then we need to construct an "error". This error will be the overall
    ** status returned, and the multistatus responses will go into its body.
    **
    ** For certain methods, the overall error will be a 424. The default is
    ** to construct a standard 207 response.
    */</comment>
    <if>if <condition>(<expr><name>err</name> == <name>NULL</name> &amp;&amp; <name>response</name> != <name>NULL</name> &amp;&amp; *<name>response</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_text</name> *</type><name>propstat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>(<name>flags</name> &amp; <name>DAV_VALIDATE_USE_424</name>) != 0</expr>)</condition><then> <block>{
            <comment type="block">/* manufacture a 424 error to hold the multistatus response(s) */</comment>
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FAILED_DEPENDENCY</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"An error occurred on another resource, "
                                 "preventing the requested operation on "
                                 "this resource."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="block">/*
        ** Whatever caused the error, the Request-URI should have a 424
        ** associated with it since we cannot complete the method.
        **
        ** For a LOCK operation, insert an empty DAV:lockdiscovery property.
        ** For other methods, return a simple 424.
        */</comment>
        <if>if <condition>(<expr>(<name>flags</name> &amp; <name>DAV_VALIDATE_ADD_LD</name>) != 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>propstat</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>propstat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>propstat</name>-&gt;<name>text</name></name> =
                "&lt;D:propstat&gt;" <name>DEBUG_CR</name>
                "&lt;D:prop&gt;&lt;D:lockdiscovery/&gt;&lt;/D:prop&gt;" <name>DEBUG_CR</name>
                "&lt;D:status&gt;HTTP/1.1 424 Failed Dependency&lt;/D:status&gt;" <name>DEBUG_CR</name>
                "&lt;/D:propstat&gt;" <name>DEBUG_CR</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* create the 424 response */</comment>
        <expr_stmt><expr><name>new_response</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_response</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_response</name>-&gt;<name>href</name></name> = <name><name>resource</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_response</name>-&gt;<name>status</name></name> = <name>HTTP_FAILED_DEPENDENCY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_response</name>-&gt;<name>propresult</name>.<name>propstats</name></name> = <name>propstat</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_response</name>-&gt;<name>desc</name></name> =
            "An error occurred on another resource, preventing the "
            "requested operation on this resource."</expr>;</expr_stmt>

        <expr_stmt><expr><name><name>new_response</name>-&gt;<name>next</name></name> = *<name>response</name></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>response</name> = <name>new_response</name></expr>;</expr_stmt>

        <comment type="block">/* manufacture a 207 error for the multistatus response(s) */</comment>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_MULTI_STATUS</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"Error(s) occurred on resources during the "
                             "validation process."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>err</name></expr>;</return>
}</block>

<comment type="block">/* dav_get_locktoken_list:
 *
 * Sets ltl to a locktoken_list of all positive locktokens in header,
 * else NULL if no If-header, or no positive locktokens.
 */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_get_locktoken_list</name><argument_list>(<argument>request_rec *r</argument>,
                                                <argument>dav_locktoken_list **ltl</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_if_header</name> *</type><name>if_header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_if_state_list</name> *</type><name>if_state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_locktoken_list</name> *</type><name>lock_token</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>ltl</name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_process_if_header</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>if_header</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### add a higher-level description? */</comment>
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr><name>if_header</name> != <name>NULL</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>if_state</name> = <name><name>if_header</name>-&gt;<name>state</name></name></expr>;</expr_stmt>        <comment type="block">/* Beginning of the if_state linked list */</comment>
        <while>while <condition>(<expr><name>if_state</name> != <name>NULL</name></expr>)</condition>        <block>{
            <if>if <condition>(<expr><name><name>if_state</name>-&gt;<name>condition</name></name> == <name>DAV_IF_COND_NORMAL</name>
                &amp;&amp; <name><name>if_state</name>-&gt;<name>type</name></name> == <name>dav_if_opaquelock</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>lock_token</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dav_locktoken_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lock_token</name>-&gt;<name>locktoken</name></name> = <name><name>if_state</name>-&gt;<name>locktoken</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>lock_token</name>-&gt;<name>next</name></name> = *<name>ltl</name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>ltl</name> = <name>lock_token</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>if_state</name> = <name><name>if_state</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name>if_header</name> = <name><name>if_header</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr>*<name>ltl</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* No nodes added */</comment>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr><name>DAV_ERR_IF_ABSENT</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"No locktokens were specified in the \"If:\" "
                             "header, so the refresh could not be performed."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if> <comment type="block">/* not needed right now... */</comment>

static const char *strip_white(const char *s, apr_pool_t *pool)
{
    apr_size_t idx;

    <comment type="block">/* trim leading whitespace */</comment>
    while (apr_isspace(*s))     <comment type="block">/* assume: return false for '\0' */</comment>
        ++s;

    <comment type="block">/* trim trailing whitespace */</comment>
    idx = strlen(s) - 1;
    if (apr_isspace(s[idx])) {
        char *s2 = apr_pstrdup(pool, s);

        while (apr_isspace(s2[idx]) &amp;&amp; idx &gt; 0)
            --idx;
        s2[idx + 1] = '\0';
        return s2;
    }

    return s;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_LABEL_HDR</name></cpp:macro> <cpp:value>"Label"</cpp:value></cpp:define>

<comment type="block">/* dav_add_vary_header
 *
 * If there were any headers in the request which require a Vary header
 * in the response, add it.
 */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_add_vary_header</name><argument_list>(<argument>request_rec *in_req</argument>,
                                      <argument>request_rec *out_req</argument>,
                                      <argument>const dav_resource *resource</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_vsn</name> *</type><name>vsn_hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_VSN</name><argument_list>(<argument><expr><name>in_req</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* ### this is probably all wrong... I think there is a function in
       ### the Apache API to add things to the Vary header. need to check */</comment>

    <comment type="block">/* Only versioning headers require a Vary response header,
     * so only do this check if there is a versioning provider */</comment>
    <if>if <condition>(<expr><name>vsn_hooks</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>in_req</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>DAV_LABEL_HDR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* If Target-Selector specified, add it to the Vary header */</comment>
        <if>if <condition>(<expr><name>target</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>vary</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>out_req</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>vary</name> == <name>NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name>vary</name> = <name>DAV_LABEL_HDR</name></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name>vary</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>out_req</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>vary</name></expr></argument>, <argument><expr>"," <name>DAV_LABEL_HDR</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>out_req</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>, <argument><expr><name>vary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block>

<comment type="block">/* dav_can_auto_checkout
 *
 * Determine whether auto-checkout is enabled for a resource.
 * r - the request_rec
 * resource - the resource
 * auto_version - the value of the auto_versionable hook for the resource
 * lockdb - pointer to lock database (opened if necessary)
 * auto_checkout - set to 1 if auto-checkout enabled
 */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_can_auto_checkout</name><parameter_list>(
    <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
    <param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
    <param><decl><type><name>dav_auto_version</name></type> <name>auto_version</name></decl></param>,
    <param><decl><type><name>dav_lockdb</name> **</type><name>lockdb</name></decl></param>,
    <param><decl><type><name>int</name> *</type><name>auto_checkout</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lock</name> *</type><name>lock_list</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>auto_checkout</name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>auto_version</name> == <name>DAV_AUTO_VERSION_ALWAYS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>auto_checkout</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>auto_version</name> == <name>DAV_AUTO_VERSION_LOCKED</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>*<name>lockdb</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>locks_hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_LOCKS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>locks_hooks</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr>"Auto-checkout is only enabled for locked resources, "
                                     "but there is no lock provider."</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>locks_hooks</name>-&gt;<name>open_lockdb</name></name>)<argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>lockdb</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                      <argument><expr>"Cannot open lock database to determine "
                                      "auto-versioning behavior."</expr></argument>,
                                      <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_lock_query</name><argument_list>(<argument><expr>*<name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr>&amp;<name>lock_list</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                  <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                  <argument><expr>"The locks could not be queried for "
                                  "determining auto-versioning behavior."</expr></argument>,
                                  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>lock_list</name> != <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>auto_checkout</name> = 1</expr>;</expr_stmt></then></if>
    }</block></then></if></else></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* see mod_dav.h for docco */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_auto_checkout</name><argument_list>(
    <argument>request_rec *r</argument>,
    <argument>dav_resource *resource</argument>,
    <argument>int parent_only</argument>,
    <argument>dav_auto_version_info *av_info</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_vsn</name> *</type><name>vsn_hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_VSN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Initialize results */</comment>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>av_info</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>av_info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if no versioning provider, just return */</comment>
    <if>if <condition>(<expr><name>vsn_hooks</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* check parent resource if requested or if resource must be created */</comment>
    <if>if <condition>(<expr>!<name><name>resource</name>-&gt;<name>exists</name></name> || <name>parent_only</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_resource</name> *</type><name>parent</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>resource</name>-&gt;<name>hooks</name>-&gt;<name>get_parent_resource</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>,
                                                           <argument><expr>&amp;<name>parent</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
            <goto>goto <name>done</name>;</goto></then></if>

        <if>if <condition>(<expr><name>parent</name> == <name>NULL</name> || !<name><name>parent</name>-&gt;<name>exists</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>err</name> = <call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                            <argument><expr>"Missing one or more intermediate "
                                            "collections. Cannot create resource %s."</expr></argument>,
                                            <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>done</name>;</goto>
        }</block></then></if>

        <expr_stmt><expr><name><name>av_info</name>-&gt;<name>parent_resource</name></name> = <name>parent</name></expr>;</expr_stmt>

        <comment type="block">/* if parent versioned and not checked out, see if it can be */</comment>
        <if>if <condition>(<expr><name><name>parent</name>-&gt;<name>versioned</name></name> &amp;&amp; !<name><name>parent</name>-&gt;<name>working</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>checkout_parent</name></decl>;</decl_stmt>

            <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_can_auto_checkout</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
                                             <argument><expr><call>(*<name><name>vsn_hooks</name>-&gt;<name>auto_versionable</name></name>)<argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr>&amp;<name>lockdb</name></expr></argument>, <argument><expr>&amp;<name>checkout_parent</name></expr></argument>)</argument_list></call>)
                != <name>NULL</name></expr>)</condition><then> <block>{
                <goto>goto <name>done</name>;</goto>
            }</block></then></if>

            <if>if <condition>(<expr>!<name>checkout_parent</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>err</name> = <call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                    <argument><expr>"&lt;DAV:cannot-modify-checked-in-parent&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>done</name>;</goto>
            }</block></then></if>

            <comment type="block">/* Try to checkout the parent collection.
             * Note that auto-versioning can only be applied to a version selector,
             * so no separate working resource will be created.
             */</comment>
            <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>checkout</name></name>)<argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr>1</expr></argument> <comment type="block">/*auto_checkout*/</comment>,
                                              <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)
                != <name>NULL</name></expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>err</name> = <call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                 <argument><expr>"Unable to auto-checkout parent collection. "
                                                 "Cannot create resource %s."</expr></argument>,
                                                 <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <goto>goto <name>done</name>;</goto>
            }</block></then></if>

            <comment type="block">/* remember that parent was checked out */</comment>
            <expr_stmt><expr><name><name>av_info</name>-&gt;<name>parent_checkedout</name></name> = 1</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* if only checking parent, we're done */</comment>
    <if>if <condition>(<expr><name>parent_only</name></expr>)</condition><then>
        <goto>goto <name>done</name>;</goto></then></if>

    <comment type="block">/* if creating a new resource, see if it should be version-controlled */</comment>
    <if>if <condition>(<expr>!<name><name>resource</name>-&gt;<name>exists</name></name>
        &amp;&amp; <call>(*<name><name>vsn_hooks</name>-&gt;<name>auto_versionable</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call> == <name>DAV_AUTO_VERSION_ALWAYS</name></expr>)</condition><then> <block>{

        <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>vsn_control</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>err</name> = <call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                             <argument><expr>"Unable to create versioned resource %s."</expr></argument>,
                                             <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>done</name>;</goto>
        }</block></then></if>

        <comment type="block">/* remember that resource was created */</comment>
        <expr_stmt><expr><name><name>av_info</name>-&gt;<name>resource_versioned</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* if resource is versioned, make sure it is checked out */</comment>
    <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>versioned</name></name> &amp;&amp; !<name><name>resource</name>-&gt;<name>working</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>checkout_resource</name></decl>;</decl_stmt>

        <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_can_auto_checkout</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>,
                                         <argument><expr><call>(*<name><name>vsn_hooks</name>-&gt;<name>auto_versionable</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr>&amp;<name>lockdb</name></expr></argument>, <argument><expr>&amp;<name>checkout_resource</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <goto>goto <name>done</name>;</goto>
        }</block></then></if>

        <if>if <condition>(<expr>!<name>checkout_resource</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>err</name> = <call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                <argument><expr>"&lt;DAV:cannot-modify-version-controlled-content&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>done</name>;</goto>
        }</block></then></if>

        <comment type="block">/* Auto-versioning can only be applied to version selectors, so
         * no separate working resource will be created. */</comment>
        <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>checkout</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr>1</expr></argument> <comment type="block">/*auto_checkout*/</comment>,
                                          <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)
            != <name>NULL</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>err</name> = <call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                             <argument><expr>"Unable to checkout resource %s."</expr></argument>,
                                             <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>done</name>;</goto>
        }</block></then></if>

        <comment type="block">/* remember that resource was checked out */</comment>
        <expr_stmt><expr><name><name>av_info</name>-&gt;<name>resource_checkedout</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>

<label><name>done</name>:</label>

    <comment type="block">/* make sure lock database is closed */</comment>
    <if>if <condition>(<expr><name>lockdb</name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call>(*<name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>close_lockdb</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <comment type="block">/* if an error occurred, undo any auto-versioning operations already done */</comment>
    <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>dav_auto_checkin</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr>1</expr></argument> <comment type="block">/*undo*/</comment>, <argument><expr>0</expr></argument> <comment type="block">/*unlock*/</comment>, <argument><expr><name>av_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block>

<comment type="block">/* see mod_dav.h for docco */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_auto_checkin</name><argument_list>(
    <argument>request_rec *r</argument>,
    <argument>dav_resource *resource</argument>,
    <argument>int undo</argument>,
    <argument>int unlock</argument>,
    <argument>dav_auto_version_info *av_info</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_vsn</name> *</type><name>vsn_hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_VSN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_auto_version</name></type> <name>auto_version</name></decl>;</decl_stmt>

    <comment type="block">/* If no versioning provider, this is a no-op */</comment>
    <if>if <condition>(<expr><name>vsn_hooks</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <comment type="block">/* If undoing auto-checkouts, then do uncheckouts */</comment>
    <if>if <condition>(<expr><name>undo</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>resource</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>av_info</name>-&gt;<name>resource_checkedout</name></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>uncheckout</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                    <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                          <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                      <argument><expr>"Unable to undo auto-checkout "
                                                      "of resource %s."</expr></argument>,
                                                      <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
            }</block></then></if>

            <if>if <condition>(<expr><name><name>av_info</name>-&gt;<name>resource_versioned</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>dav_response</name> *</type><name>response</name></decl>;</decl_stmt>

                <comment type="block">/* ### should we do anything with the response? */</comment>
                <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>resource</name>-&gt;<name>hooks</name>-&gt;<name>remove_resource</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>,
                                                               <argument><expr>&amp;<name>response</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                    <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                          <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                      <argument><expr>"Unable to undo auto-version-control "
                                                      "of resource %s."</expr></argument>,
                                                      <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>av_info</name>-&gt;<name>parent_resource</name></name> != <name>NULL</name> &amp;&amp; <name><name>av_info</name>-&gt;<name>parent_checkedout</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>uncheckout</name></name>)<argument_list>(<argument><expr><name><name>av_info</name>-&gt;<name>parent_resource</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                      <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                  <argument><expr>"Unable to undo auto-checkout "
                                                  "of parent collection %s."</expr></argument>,
                                                  <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>av_info</name>-&gt;<name>parent_resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If the resource was checked out, and auto-checkin is enabled,
     * then check it in.
     */</comment>
    <if>if <condition>(<expr><name>resource</name> != <name>NULL</name> &amp;&amp; <name><name>resource</name>-&gt;<name>working</name></name>
        &amp;&amp; (<name>unlock</name> || <name><name>av_info</name>-&gt;<name>resource_checkedout</name></name>)</expr>)</condition><then> <block>{

        <expr_stmt><expr><name>auto_version</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>auto_versionable</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>auto_version</name> == <name>DAV_AUTO_VERSION_ALWAYS</name> ||
            (<name>unlock</name> &amp;&amp; (<name>auto_version</name> == <name>DAV_AUTO_VERSION_LOCKED</name>))</expr>)</condition><then> <block>{

            <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>checkin</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>,
                                             <argument><expr>0</expr></argument> <comment type="block">/*keep_checked_out*/</comment>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)
                != <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                      <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                  <argument><expr>"Unable to auto-checkin resource %s."</expr></argument>,
                                                  <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If parent resource was checked out, and auto-checkin is enabled,
     * then check it in.
     */</comment>
    <if>if <condition>(<expr>!<name>unlock</name>
        &amp;&amp; <name><name>av_info</name>-&gt;<name>parent_checkedout</name></name>
        &amp;&amp; <name><name>av_info</name>-&gt;<name>parent_resource</name></name> != <name>NULL</name>
        &amp;&amp; <name><name>av_info</name>-&gt;<name>parent_resource</name>-&gt;<name>working</name></name></expr>)</condition><then> <block>{

        <expr_stmt><expr><name>auto_version</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>auto_versionable</name></name>)<argument_list>(<argument><expr><name><name>av_info</name>-&gt;<name>parent_resource</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>auto_version</name> == <name>DAV_AUTO_VERSION_ALWAYS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>vsn_hooks</name>-&gt;<name>checkin</name></name>)<argument_list>(<argument><expr><name><name>av_info</name>-&gt;<name>parent_resource</name></name></expr></argument>,
                                             <argument><expr>0</expr></argument> <comment type="block">/*keep_checked_out*/</comment>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)
                != <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                      <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                  <argument><expr>"Unable to auto-checkin parent collection %s."</expr></argument>,
                                                  <argument><expr><call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>av_info</name>-&gt;<name>parent_resource</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block>
</unit>
