<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/dav/main/mod_dav.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file  mod_dav.h
 * @brief DAV extension module for Apache 2.0.*
 *
 * @defgroup MOD_DAV mod_dav
 * @ingroup APACHE_MODS
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_MOD_DAV_H_</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_MOD_DAV_H_</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hooks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_dbm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_tables.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_xml.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>     <comment type="block">/* for INT_MAX */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>       <comment type="block">/* for time_t */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_VERSION</name></cpp:macro>             <cpp:value>AP_SERVER_BASEREVISION</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_XML_HEADER</name></cpp:macro>          <cpp:value>"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_XML_CONTENT_TYPE</name></cpp:macro>    <cpp:value>"text/xml; charset=\"utf-8\""</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_READ_BLOCKSIZE</name></cpp:macro>      <cpp:value>2048</cpp:value></cpp:define>    <comment type="block">/* used for reading input blocks */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESPONSE_BODY_1</name></cpp:macro>     <cpp:value>"&lt;!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\"&gt;\n&lt;html&gt;&lt;head&gt;\n&lt;title&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESPONSE_BODY_2</name></cpp:macro>     <cpp:value>"&lt;/title&gt;\n&lt;/head&gt;&lt;body&gt;\n&lt;h1&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESPONSE_BODY_3</name></cpp:macro>     <cpp:value>"&lt;/h1&gt;\n&lt;p&gt;"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESPONSE_BODY_4</name></cpp:macro>     <cpp:value>"&lt;/p&gt;\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESPONSE_BODY_5</name></cpp:macro>     <cpp:value>"&lt;/body&gt;&lt;/html&gt;\n"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DO_COPY</name></cpp:macro>             <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DO_MOVE</name></cpp:macro>             <cpp:value>1</cpp:value></cpp:define>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr>1</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DEBUG</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_CR</name></cpp:macro>         <cpp:value>"\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBG0</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro>          <cpp:value>ap_log_error(APLOG_MARK, \
                                APLOG_ERR, 0, NULL, (f))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBG1</name><parameter_list>(<param><type><name>f</name></type></param>,<param><type><name>a1</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>ap_log_error(APLOG_MARK, \
                                APLOG_ERR, 0, NULL, f, a1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBG2</name><parameter_list>(<param><type><name>f</name></type></param>,<param><type><name>a1</name></type></param>,<param><type><name>a2</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>ap_log_error(APLOG_MARK, \
                                APLOG_ERR, 0, NULL, f, a1, a2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DBG3</name><parameter_list>(<param><type><name>f</name></type></param>,<param><type><name>a1</name></type></param>,<param><type><name>a2</name></type></param>,<param><type><name>a3</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_log_error(APLOG_MARK, \
                                APLOG_ERR, 0, NULL, f, a1, a2, a3)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DAV_DEBUG</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_CR</name></cpp:macro>        <cpp:value>""</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_INFINITY</name></cpp:macro>    <cpp:value>INT_MAX</cpp:value></cpp:define>    <comment type="block">/* for the Depth: header */</comment>

<comment type="block">/* Create a set of DAV_DECLARE(type), DAV_DECLARE_NONSTD(type) and
 * DAV_DECLARE_DATA with appropriate export and import tags for the platform
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DAV_DECLARE_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DAV_DECLARE_EXPORT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>__declspec(dllexport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__declspec(dllexport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE_DATA</name></cpp:macro>             <cpp:value>__declspec(dllexport)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>__declspec(dllimport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__declspec(dllimport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DECLARE_DATA</name></cpp:macro>             <cpp:value>__declspec(dllimport)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* --------------------------------------------------------------------
**
** ERROR MANAGEMENT
*/</comment>

<comment type="block">/*
** dav_error structure.
**
** In most cases, mod_dav uses a pointer to a dav_error structure. If the
** pointer is NULL, then no error has occurred.
**
** In certain cases, a dav_error structure is directly used. In these cases,
** a status value of 0 means that an error has not occurred.
**
** Note: this implies that status != 0 whenever an error occurs.
**
** The desc field is optional (it may be NULL). When NULL, it typically
** implies that Apache has a proper description for the specified status.
*/</comment>
<typedef>typedef <type><struct>struct <name>dav_error</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>                 <comment type="block">/* suggested HTTP status (0 for no error) */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>error_id</name></decl>;</decl_stmt>               <comment type="block">/* DAV-specific error ID */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>desc</name></decl>;</decl_stmt>           <comment type="block">/* DAV:responsedescription and error log */</comment>

    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>aprerr</name></decl>;</decl_stmt>        <comment type="block">/* APR error if any, or 0/APR_SUCCESS */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>namespace</name></decl>;</decl_stmt>      <comment type="block">/* [optional] namespace of error */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tagname</name></decl>;</decl_stmt>        <comment type="block">/* name of error-tag */</comment>

    <decl_stmt><decl><type>struct <name>dav_error</name> *</type><name>prev</name></decl>;</decl_stmt>     <comment type="block">/* previous error (in stack) */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>childtags</name></decl>;</decl_stmt>      <comment type="block">/* error-tag may have children */</comment>

}</block></struct></type> <name>dav_error</name>;</typedef>

<comment type="block">/*
** Create a new error structure. save_errno will be filled with the current
** errno value.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <macro><name>dav_new_error</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int status</argument>,
                                      <argument>int error_id</argument>, <argument>apr_status_t aprerr</argument>,
                                      <argument>const char *desc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/*
** Create a new error structure with tagname and (optional) namespace;
** namespace may be NULL, which means "DAV:".
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <macro><name>dav_new_error_tag</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int status</argument>,
                                          <argument>int error_id</argument>, <argument>apr_status_t aprerr</argument>,
                                          <argument>const char *desc</argument>,
                                          <argument>const char *namespace</argument>,
                                          <argument>const char *tagname</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/*
** Push a new error description onto the stack of errors.
**
** This function is used to provide an additional description to an existing
** error.
**
** &lt;status&gt; should contain the caller's view of what the current status is,
** given the underlying error. If it doesn't have a better idea, then the
** caller should pass prev-&gt;status.
**
** &lt;error_id&gt; can specify a new error_id since the topmost description has
** changed.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <macro><name>dav_push_error</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int status</argument>, <argument>int error_id</argument>,
                                       <argument>const char *desc</argument>, <argument>dav_error *prev</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/*
** Join two errors together.
**
** This function is used to add a new error stack onto an existing error so
** that subsequent errors can be reported after the first error.  It returns
** the correct error stack to use so that the caller can blindly call it
** without checking that both dest and src are not NULL.
** 
** &lt;dest&gt; is the error stack that the error will be added to.
**
** &lt;src&gt; is the error stack that will be appended.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_join_error</name><argument_list>(<argument><expr><name>dav_error</name>* <name>dest</name></expr></argument>, <argument><expr><name>dav_error</name>* <name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<typedef>typedef <type>struct <name>dav_response</name></type> <name>dav_response</name>;</typedef>

<comment type="block">/*
** dav_handle_err()
**
** Handle the standard error processing. &lt;err&gt; must be non-NULL.
**
** &lt;response&gt; is set by the following:
**   - dav_validate_request()
**   - dav_add_lock()
**   - repos_hooks-&gt;remove_resource
**   - repos_hooks-&gt;move_resource
**   - repos_hooks-&gt;copy_resource
**   - vsn_hooks-&gt;update
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_handle_err</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr><name>dav_error</name> *<name>err</name></expr></argument>,
                                <argument><expr><name>dav_response</name> *<name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* error ID values... */</comment>

<comment type="block">/* IF: header errors */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_IF_PARSE</name></cpp:macro>                <cpp:value>100</cpp:value></cpp:define>    <comment type="block">/* general parsing error */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_IF_MULTIPLE_NOT</name></cpp:macro>         <cpp:value>101</cpp:value></cpp:define>    <comment type="block">/* multiple "Not" found */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_IF_UNK_CHAR</name></cpp:macro>             <cpp:value>102</cpp:value></cpp:define>    <comment type="block">/* unknown char in header */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_IF_ABSENT</name></cpp:macro>               <cpp:value>103</cpp:value></cpp:define>    <comment type="block">/* no locktokens given */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_IF_TAGGED</name></cpp:macro>               <cpp:value>104</cpp:value></cpp:define>    <comment type="block">/* in parsing tagged-list */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_IF_UNCLOSED_PAREN</name></cpp:macro>       <cpp:value>105</cpp:value></cpp:define>    <comment type="block">/* in no-tagged-list */</comment>

<comment type="block">/* Prop DB errors */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_PROP_BAD_MAJOR</name></cpp:macro>          <cpp:value>200</cpp:value></cpp:define>    <comment type="block">/* major version was wrong */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_PROP_READONLY</name></cpp:macro>           <cpp:value>201</cpp:value></cpp:define>    <comment type="block">/* prop is read-only */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_PROP_NO_DATABASE</name></cpp:macro>        <cpp:value>202</cpp:value></cpp:define>    <comment type="block">/* writable db not avail */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_PROP_NOT_FOUND</name></cpp:macro>          <cpp:value>203</cpp:value></cpp:define>    <comment type="block">/* prop not found */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_PROP_BAD_LOCKDB</name></cpp:macro>         <cpp:value>204</cpp:value></cpp:define>    <comment type="block">/* could not open lockdb */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_PROP_OPENING</name></cpp:macro>            <cpp:value>205</cpp:value></cpp:define>    <comment type="block">/* problem opening propdb */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_PROP_EXEC</name></cpp:macro>               <cpp:value>206</cpp:value></cpp:define>    <comment type="block">/* problem exec'ing patch */</comment>

<comment type="block">/* Predefined DB errors */</comment>
<comment type="block">/* ### any to define?? */</comment>

<comment type="block">/* Predefined locking system errors */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_LOCK_OPENDB</name></cpp:macro>             <cpp:value>400</cpp:value></cpp:define>    <comment type="block">/* could not open lockdb */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_LOCK_NO_DB</name></cpp:macro>              <cpp:value>401</cpp:value></cpp:define>    <comment type="block">/* no database defined */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_LOCK_CORRUPT_DB</name></cpp:macro>         <cpp:value>402</cpp:value></cpp:define>    <comment type="block">/* DB is corrupt */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_LOCK_UNK_STATE_TOKEN</name></cpp:macro>    <cpp:value>403</cpp:value></cpp:define>    <comment type="block">/* unknown State-token */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_LOCK_PARSE_TOKEN</name></cpp:macro>        <cpp:value>404</cpp:value></cpp:define>    <comment type="block">/* bad opaquelocktoken */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_ERR_LOCK_SAVE_LOCK</name></cpp:macro>          <cpp:value>405</cpp:value></cpp:define>    <comment type="block">/* err saving locks */</comment>

<comment type="block">/*
** Some comments on Error ID values:
**
** The numbers do not necessarily need to be unique. Uniqueness simply means
** that two errors that have not been predefined above can be distinguished
** from each other. At the moment, mod_dav does not use this distinguishing
** feature, but it could be used in the future to collapse &lt;response&gt; elements
** into groups based on the error ID (and associated responsedescription).
**
** If a compute_desc is provided, then the error ID should be unique within
** the context of the compute_desc function (so the function can figure out
** what to filled into the desc).
**
** Basically, subsystems can ignore defining new error ID values if they want
** to. The subsystems *do* need to return the predefined errors when
** appropriate, so that mod_dav can figure out what to do. Subsystems can
** simply leave the error ID field unfilled (zero) if there isn't an error
** that must be placed there.
*/</comment>


<comment type="block">/* --------------------------------------------------------------------
**
** HOOK STRUCTURES
**
** These are here for forward-declaration purposes. For more info, see
** the section title "HOOK HANDLING" for more information, plus each
** structure definition.
*/</comment>

<comment type="block">/* forward-declare this structure */</comment>
<typedef>typedef <type>struct <name>dav_hooks_propdb</name></type> <name>dav_hooks_propdb</name>;</typedef>
<typedef>typedef <type>struct <name>dav_hooks_locks</name></type> <name>dav_hooks_locks</name>;</typedef>
<typedef>typedef <type>struct <name>dav_hooks_vsn</name></type> <name>dav_hooks_vsn</name>;</typedef>
<typedef>typedef <type>struct <name>dav_hooks_repository</name></type> <name>dav_hooks_repository</name>;</typedef>
<typedef>typedef <type>struct <name>dav_hooks_liveprop</name></type> <name>dav_hooks_liveprop</name>;</typedef>
<typedef>typedef <type>struct <name>dav_hooks_binding</name></type> <name>dav_hooks_binding</name>;</typedef>
<typedef>typedef <type>struct <name>dav_hooks_search</name></type> <name>dav_hooks_search</name>;</typedef>

<comment type="block">/* ### deprecated name */</comment>
<typedef>typedef <type><name>dav_hooks_propdb</name></type> <name>dav_hooks_db</name>;</typedef>


<comment type="block">/* --------------------------------------------------------------------
**
** RESOURCE HANDLING
*/</comment>

<comment type="block">/*
** Resource Types:
** The base protocol defines only file and collection resources.
** The versioning protocol defines several additional resource types
** to represent artifacts of a version control system.
**
** This enumeration identifies the type of URL used to identify the
** resource. Since the same resource may have more than one type of
** URL which can identify it, dav_resource_type cannot be used
** alone to determine the type of the resource; attributes of the
** dav_resource object must also be consulted.
*/</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>DAV_RESOURCE_TYPE_UNKNOWN</name></decl>,

    <decl><name>DAV_RESOURCE_TYPE_REGULAR</name></decl>,          <comment type="block">/* file or collection; could be
                                         * unversioned, or version selector,
                                         * or baseline selector */</comment>

    <decl><name>DAV_RESOURCE_TYPE_VERSION</name></decl>,          <comment type="block">/* version or baseline URL */</comment>

    <decl><name>DAV_RESOURCE_TYPE_HISTORY</name></decl>,          <comment type="block">/* version or baseline history URL */</comment>

    <decl><name>DAV_RESOURCE_TYPE_WORKING</name></decl>,          <comment type="block">/* working resource URL */</comment>

    <decl><name>DAV_RESOURCE_TYPE_WORKSPACE</name></decl>,        <comment type="block">/* workspace URL */</comment>

    <decl><name>DAV_RESOURCE_TYPE_ACTIVITY</name></decl>,         <comment type="block">/* activity URL */</comment>

    <decl><name>DAV_RESOURCE_TYPE_PRIVATE</name></decl>           <comment type="block">/* repository-private type */</comment>

}</block></enum></type> <name>dav_resource_type</name>;</typedef>

<comment type="block">/*
** Opaque, repository-specific information for a resource.
*/</comment>
<typedef>typedef <type>struct <name>dav_resource_private</name></type> <name>dav_resource_private</name>;</typedef>

<comment type="block">/*
** Resource descriptor, generated by a repository provider.
**
** Note: the lock-null state is not explicitly represented here,
** since it may be expensive to compute. Use dav_get_resource_state()
** to determine whether a non-existent resource is a lock-null resource.
**
** A quick explanation of how the flags can apply to different resources:
**
** unversioned file or collection:
**     type       = DAV_RESOURCE_TYPE_REGULAR
**     exists     = ? (1 if exists)
**     collection = ? (1 if collection)
**     versioned  = 0
**     baselined  = 0
**     working    = 0
**
** version-controlled resource or configuration:
**     type       = DAV_RESOURCE_TYPE_REGULAR
**     exists     = 1
**     collection = ? (1 if collection)
**     versioned  = 1
**     baselined  = ? (1 if configuration)
**     working    = ? (1 if checked out)
**
** version/baseline history:
**     type       = DAV_RESOURCE_TYPE_HISTORY
**     exists     = 1
**     collection = 0
**     versioned  = 0
**     baselined  = 0
**     working    = 0
**
** version/baseline:
**     type       = DAV_RESOURCE_TYPE_VERSION
**     exists     = 1
**     collection = ? (1 if collection)
**     versioned  = 1
**     baselined  = ? (1 if baseline)
**     working    = 0
**
** working resource:
**     type       = DAV_RESOURCE_TYPE_WORKING
**     exists     = 1
**     collection = ? (1 if collection)
**     versioned  = 1
**     baselined  = 0
**     working    = 1
**
** workspace:
**     type       = DAV_RESOURCE_TYPE_WORKSPACE
**     exists     = ? (1 if exists)
**     collection = 1
**     versioned  = ? (1 if version-controlled)
**     baselined  = ? (1 if baseline-controlled)
**     working    = ? (1 if checked out)
**
** activity:
**     type       = DAV_RESOURCE_TYPE_ACTIVITY
**     exists     = ? (1 if exists)
**     collection = 0
**     versioned  = 0
**     baselined  = 0
**     working    = 0
*/</comment>
<typedef>typedef <type><struct>struct <name>dav_resource</name> <block>{
    <decl_stmt><decl><type><name>dav_resource_type</name></type> <name>type</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>         <comment type="block">/* 0 =&gt; null resource */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>collection</name></decl>;</decl_stmt>     <comment type="block">/* 0 =&gt; file; can be 1 for
                         * REGULAR, VERSION, and WORKING resources,
                         * and is always 1 for WORKSPACE */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>versioned</name></decl>;</decl_stmt>      <comment type="block">/* 0 =&gt; unversioned; can be 1 for
                         * REGULAR and WORKSPACE resources,
                         * and is always 1 for VERSION and WORKING */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>baselined</name></decl>;</decl_stmt>      <comment type="block">/* 0 =&gt; not baselined; can be 1 for
                         * REGULAR, VERSION, and WORKSPACE resources;
                         * versioned == 1 when baselined == 1 */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>working</name></decl>;</decl_stmt>        <comment type="block">/* 0 =&gt; not checked out; can be 1 for
                         * REGULAR and WORKSPACE resources,
                         * and is always 1 for WORKING */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl>;</decl_stmt>    <comment type="block">/* the URI for this resource;
                         * currently has an ABI flaw where sometimes it is
                         * assumed to be encoded and sometimes not */</comment>

    <decl_stmt><decl><type><name>dav_resource_private</name> *</type><name>info</name></decl>;</decl_stmt>         <comment type="block">/* the provider's private info */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_repository</name> *</type><name>hooks</name></decl>;</decl_stmt>  <comment type="block">/* hooks used for this resource */</comment>

    <comment type="block">/* When allocating items related specifically to this resource, the
       following pool should be used. Its lifetime will be at least as
       long as the dav_resource structure. */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_resource</name>;</typedef>

<comment type="block">/*
** Lock token type. Lock providers define the details of a lock token.
** However, all providers are expected to at least be able to parse
** the "opaquelocktoken" scheme, which is represented by a uuid_t.
*/</comment>
<typedef>typedef <type>struct <name>dav_locktoken</name></type> <name>dav_locktoken</name>;</typedef>


<comment type="block">/* --------------------------------------------------------------------
**
** BUFFER HANDLING
**
** These buffers are used as a lightweight buffer reuse mechanism. Apache
** provides sub-pool creation and destruction to much the same effect, but
** the sub-pools are a bit more general and heavyweight than these buffers.
*/</comment>

<comment type="block">/* buffer for reuse; can grow to accommodate needed size */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>alloc_len</name></decl>;</decl_stmt>       <comment type="block">/* how much has been allocated */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>cur_len</name></decl>;</decl_stmt>         <comment type="block">/* how much is currently being used */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>                  <comment type="block">/* buffer contents */</comment>
}</block></struct></type> <name>dav_buffer</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_BUFFER_MINSIZE</name></cpp:macro>      <cpp:value>256</cpp:value></cpp:define>    <comment type="block">/* minimum size for buffer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_BUFFER_PAD</name></cpp:macro>          <cpp:value>64</cpp:value></cpp:define>     <comment type="block">/* amount of pad when growing */</comment>

<comment type="block">/* set the cur_len to the given size and ensure space is available */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_set_bufsize</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>dav_buffer *pbuf</argument>,
                                  <argument>apr_size_t size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* initialize a buffer and copy the specified (null-term'd) string into it */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_buffer_init</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>dav_buffer</name> *<name>pbuf</name></expr></argument>,
                                  <argument><expr>const <name>char</name> *<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* check that the buffer can accommodate &lt;extra_needed&gt; more bytes */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_check_bufsize</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>dav_buffer *pbuf</argument>,
                                    <argument>apr_size_t extra_needed</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* append a string to the end of the buffer, adjust length */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>dav_buffer</name> *<name>pbuf</name></expr></argument>,
                                    <argument><expr>const <name>char</name> *<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* place a string on the end of the buffer, do NOT adjust length */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_buffer_place</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>dav_buffer</name> *<name>pbuf</name></expr></argument>,
                                   <argument><expr>const <name>char</name> *<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* place some memory on the end of a buffer; do NOT adjust length */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_buffer_place_mem</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>dav_buffer *pbuf</argument>,
                                       <argument>const void *mem</argument>, <argument>apr_size_t amt</argument>,
                                       <argument>apr_size_t pad</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/* --------------------------------------------------------------------
**
** HANDY UTILITIES
*/</comment>

<comment type="block">/* contains results from one of the getprop functions */</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>apr_text</name> *</type> <name>propstats</name></decl>;</decl_stmt>       <comment type="block">/* &lt;propstat&gt; element text */</comment>
    <decl_stmt><decl><type><name>apr_text</name> *</type> <name>xmlns</name></decl>;</decl_stmt>           <comment type="block">/* namespace decls for &lt;response&gt; elem */</comment>
}</block></struct></type> <name>dav_get_props_result</name>;</typedef>

<comment type="block">/* holds the contents of a &lt;response&gt; element */</comment>
<struct>struct <name>dav_response</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>href</name></decl>;</decl_stmt>           <comment type="block">/* always */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>desc</name></decl>;</decl_stmt>           <comment type="block">/* optional description at &lt;response&gt; level */</comment>

    <comment type="block">/* use status if propresult.propstats is NULL. */</comment>
    <decl_stmt><decl><type><name>dav_get_props_result</name></type> <name>propresult</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

    <decl_stmt><decl><type>struct <name>dav_response</name> *</type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>rnew</name></decl>;</decl_stmt>          <comment type="block">/* new subrequest */</comment>
    <decl_stmt><decl><type><name>dav_error</name></type> <name>err</name></decl>;</decl_stmt>              <comment type="block">/* potential error response */</comment>
}</block></struct></type> <name>dav_lookup_result</name>;</typedef>


<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_lookup_result</argument>)</argument_list></macro> <macro><name>dav_lookup_uri</name><argument_list>(<argument>const char *uri</argument>, <argument>request_rec *r</argument>,
                                              <argument>int must_be_absolute</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* defines type of property info a provider is to return */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>DAV_PROP_INSERT_NOTDEF</name></decl>,     <comment type="block">/* property is defined by this provider,
                                   but nothing was inserted because the
                                   (live) property is not defined for this
                                   resource (it may be present as a dead
                                   property). */</comment>
    <decl><name>DAV_PROP_INSERT_NOTSUPP</name></decl>,    <comment type="block">/* property is recognized by this provider,
                                   but it is not supported, and cannot be
                                   treated as a dead property */</comment>
    <decl><name>DAV_PROP_INSERT_NAME</name></decl>,       <comment type="block">/* a property name (empty elem) was
                                   inserted into the text block */</comment>
    <decl><name>DAV_PROP_INSERT_VALUE</name></decl>,      <comment type="block">/* a property name/value pair was inserted
                                   into the text block */</comment>
    <decl><name>DAV_PROP_INSERT_SUPPORTED</name></decl>   <comment type="block">/* a supported live property was added to
                                   the text block as a
                                   &lt;DAV:supported-live-property&gt; element */</comment>
}</block></enum></type> <name>dav_prop_insert</name>;</typedef>

<comment type="block">/* ### this stuff is private to dav/fs/repos.c; move it... */</comment>
<comment type="block">/* format a time string (buf must be at least DAV_TIMEBUF_SIZE chars) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_STYLE_ISO8601</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_STYLE_RFC822</name></cpp:macro>        <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_TIMEBUF_SIZE</name></cpp:macro>        <cpp:value>30</cpp:value></cpp:define>

<comment type="block">/* Write a complete RESPONSE object out as a &lt;DAV:response&gt; xml
 * element.  Data is sent into brigade BB, which is auto-flushed into
 * the output filter stack for request R.  Use POOL for any temporary
 * allocations.
 *
 * [Presumably the &lt;multistatus&gt; tag has already been written;  this
 * routine is shared by dav_send_multistatus and dav_stream_response.]
 */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_send_one_response</name><argument_list>(<argument><expr><name>dav_response</name> *<name>response</name></expr></argument>,
                                        <argument><expr><name>apr_bucket_brigade</name> *<name>bb</name></expr></argument>,
                                        <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                        <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Factorized helper function: prep request_rec R for a multistatus
 * response and write &lt;multistatus&gt; tag into BB, destined for
 * R-&gt;output_filters.  Use xml NAMESPACES in initial tag, if
 * non-NULL.
 */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_begin_multistatus</name><argument_list>(<argument>apr_bucket_brigade *bb</argument>,
                                        <argument>request_rec *r</argument>, <argument>int status</argument>,
                                        <argument>apr_array_header_t *namespaces</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Finish a multistatus response started by dav_begin_multistatus: */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_finish_multistatus</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                                 <argument><expr><name>apr_bucket_brigade</name> *<name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Send a multistatus response */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_send_multistatus</name><argument_list>(<argument>request_rec *r</argument>, <argument>int status</argument>,
                                       <argument>dav_response *first</argument>,
                                       <argument>apr_array_header_t *namespaces</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>apr_text *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_failed_proppatch</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                             <argument><expr><name>apr_array_header_t</name> *<name>prop_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>apr_text *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_success_proppatch</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                              <argument><expr><name>apr_array_header_t</name> *<name>prop_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>dav_get_depth</name><argument_list>(<argument>request_rec *r</argument>, <argument>int def_depth</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_validate_root</name><argument_list>(<argument><expr>const <name>apr_xml_doc</name> *<name>doc</name></expr></argument>,
                                   <argument><expr>const <name>char</name> *<name>tagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>apr_xml_elem *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_find_child</name><argument_list>(<argument><expr>const <name>apr_xml_elem</name> *<name>elem</name></expr></argument>,
                                           <argument><expr>const <name>char</name> *<name>tagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* gather up all the CDATA into a single string */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>dav_xml_get_cdata</name><argument_list>(<argument>const apr_xml_elem *elem</argument>, <argument>apr_pool_t *pool</argument>,
                              <argument>int strip_white</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/*
** XML namespace handling
**
** This structure tracks namespace declarations (xmlns:prefix="URI").
** It maintains a one-to-many relationship of URIs-to-prefixes. In other
** words, one URI may be defined by many prefixes, but any specific
** prefix will specify only one URI.
**
** Prefixes using the "g###" pattern can be generated automatically if
** the caller does not have specific prefix requirements.
*/</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>uri_prefix</name></decl>;</decl_stmt>     <comment type="block">/* map URIs to an available prefix */</comment>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>prefix_uri</name></decl>;</decl_stmt>     <comment type="block">/* map all prefixes to their URIs */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>                  <comment type="block">/* counter for "g###" prefixes */</comment>
}</block></struct></type> <name>dav_xmlns_info</name>;</typedef>

<comment type="block">/* create an empty dav_xmlns_info structure */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_xmlns_info *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_xmlns_create</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* add a specific prefix/URI pair. the prefix/uri should have a lifetime
   at least that of xmlns-&gt;pool */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_xmlns_add</name><argument_list>(<argument><expr><name>dav_xmlns_info</name> *<name>xi</name></expr></argument>,
                                <argument><expr>const <name>char</name> *<name>prefix</name></expr></argument>, <argument><expr>const <name>char</name> *<name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* add a URI (if not present); any prefix is acceptable and is returned.
   the uri should have a lifetime at least that xmlns-&gt;pool */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_xmlns_add_uri</name><argument_list>(<argument><expr><name>dav_xmlns_info</name> *<name>xi</name></expr></argument>,
                                            <argument><expr>const <name>char</name> *<name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* return the URI for a specified prefix (or NULL if the prefix is unknown) */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_xmlns_get_uri</name><argument_list>(<argument><expr><name>dav_xmlns_info</name> *<name>xi</name></expr></argument>,
                                            <argument><expr>const <name>char</name> *<name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* return an available prefix for a specified URI (or NULL if the URI
   is unknown) */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_xmlns_get_prefix</name><argument_list>(<argument><expr><name>dav_xmlns_info</name> *<name>xi</name></expr></argument>,
                                               <argument><expr>const <name>char</name> *<name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* generate xmlns declarations (appending into the given text) */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_xmlns_generate</name><argument_list>(<argument><expr><name>dav_xmlns_info</name> *<name>xi</name></expr></argument>,
                                     <argument><expr><name>apr_text_header</name> *<name>phdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* --------------------------------------------------------------------
**
** DAV PLUGINS
*/</comment>

<comment type="block">/* ### docco ... */</comment>

<comment type="block">/*
** dav_provider
**
** This structure wraps up all of the hooks that a mod_dav provider can
** supply. The provider MUST supply &lt;repos&gt; and &lt;propdb&gt;. The rest are
** optional and should contain NULL if that feature is not supplied.
**
** Note that a provider cannot pick and choose portions from various
** underlying implementations (which was theoretically possible in
** mod_dav 1.0). There are too many dependencies between a dav_resource
** (defined by &lt;repos&gt;) and the other functionality.
**
** Live properties are not part of the dav_provider structure because they
** are handled through the APR_HOOK interface (to allow for multiple liveprop
** providers). The core always provides some properties, and then a given
** provider will add more properties.
**
** Some providers may need to associate a context with the dav_provider
** structure -- the ctx field is available for storing this context. Just
** leave it NULL if it isn't required.
*/</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_repository</name> *</type><name>repos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_propdb</name> *</type><name>propdb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>locks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_vsn</name> *</type><name>vsn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_binding</name> *</type><name>binding</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_search</name> *</type><name>search</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>dav_provider</name>;</typedef>

<comment type="block">/*
** gather_propsets: gather all live property propset-URIs
**
** The hook implementor should push one or more URIs into the specified
** array. These URIs are returned in the DAV: header to let clients know
** what sets of live properties are supported by the installation. mod_dav
** will place open/close angle brackets around each value (much like
** a Coded-URL); quotes and brackets should not be in the value.
**
** Example:    http://apache.org/dav/props/
**
** (of course, use your own domain to ensure a unique value)
*/</comment>
<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>dav</argument>, <argument>DAV</argument>, <argument>void</argument>, <argument>gather_propsets</argument>,
                         <argument>(apr_array_header_t *uris)</argument>)</argument_list></macro>

<comment type="block">/*
** find_liveprop: find a live property, returning a non-zero, unique,
**                opaque identifier.
**
** If the hook implementor determines the specified URI/name refers to
** one of its properties, then it should fill in HOOKS and return a
** non-zero value. The returned value is the "property ID" and will
** be passed to the various liveprop hook functions.
**
** Return 0 if the property is not defined by the hook implementor.
*/</comment>
<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>dav</argument>, <argument>DAV</argument>, <argument>int</argument>, <argument>find_liveprop</argument>,
                         <argument>(const dav_resource *resource,
                          const char *ns_uri, const char *name,
                          const dav_hooks_liveprop **hooks)</argument>)</argument_list></macro>

<comment type="block">/*
** insert_all_liveprops: insert all (known) live property names/values.
**
** The hook implementor should append XML text to PHDR, containing liveprop
** names. If INSVALUE is true, then the property values should also be
** inserted into the output XML stream.
**
** The liveprop provider should insert *all* known and *defined* live
** properties on the specified resource. If a particular liveprop is
** not defined for this resource, then it should not be inserted.
*/</comment>
<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>dav</argument>, <argument>DAV</argument>, <argument>void</argument>, <argument>insert_all_liveprops</argument>,
                         <argument>(request_rec *r, const dav_resource *resource,
                          dav_prop_insert what, apr_text_header *phdr)</argument>)</argument_list></macro>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>const dav_hooks_locks *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_lock_hooks</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const dav_hooks_propdb *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_propdb_hooks</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const dav_hooks_vsn *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_vsn_hooks</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const dav_hooks_binding *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_binding_hooks</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const dav_hooks_search *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_search_hooks</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_register_provider</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>name</name></expr></argument>,
                                        <argument><expr>const <name>dav_provider</name> *<name>hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const dav_provider *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_lookup_provider</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_provider_name</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* ### deprecated */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GET_HOOKS_PROPDB</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>dav_get_propdb_hooks(r)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GET_HOOKS_LOCKS</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>          <cpp:value>dav_get_lock_hooks(r)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GET_HOOKS_VSN</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>dav_get_vsn_hooks(r)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GET_HOOKS_BINDING</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>dav_get_binding_hooks(r)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GET_HOOKS_SEARCH</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>         <cpp:value>dav_get_search_hooks(r)</cpp:value></cpp:define>


<comment type="block">/* --------------------------------------------------------------------
**
** IF HEADER PROCESSING
**
** Here is the definition of the If: header from RFC 2518, S9.4:
**
**    If = "If" ":" (1*No-tag-list | 1*Tagged-list)
**    No-tag-list = List
**    Tagged-list = Resource 1*List
**    Resource = Coded-URL
**    List = "(" 1*(["Not"](State-token | "[" entity-tag "]")) ")"
**    State-token = Coded-URL
**    Coded-URL = "&lt;" absoluteURI "&gt;"        ; absoluteURI from RFC 2616
**
** List corresponds to dav_if_state_list. No-tag-list corresponds to
** dav_if_header with uri==NULL. Tagged-list corresponds to a sequence of
** dav_if_header structures with (duplicate) uri==Resource -- one
** dav_if_header per state_list. A second Tagged-list will start a new
** sequence of dav_if_header structures with the new URI.
**
** A summary of the semantics, mapped into our structures:
**    - Chained dav_if_headers: OR
**    - Chained dav_if_state_lists: AND
**    - NULL uri matches all resources
*/</comment>

<typedef>typedef <type><enum>enum
<block>{
    <decl><name>dav_if_etag</name></decl>,
    <decl><name>dav_if_opaquelock</name></decl>,
    <decl><name>dav_if_unknown</name></decl> <comment type="block">/* the "unknown" state type; always matches false. */</comment>
}</block></enum></type> <name>dav_if_state_type</name>;</typedef>

<typedef>typedef <type><struct>struct <name>dav_if_state_list</name>
<block>{
    <decl_stmt><decl><type><name>dav_if_state_type</name></type> <name>type</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>condition</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_IF_COND_NORMAL</name></cpp:macro>      <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_IF_COND_NOT</name></cpp:macro>         <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* "Not" was applied */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>etag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_locktoken</name> *</type><name>locktoken</name></decl>;</decl_stmt>

    <decl_stmt><decl><type>struct <name>dav_if_state_list</name> *</type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>dav_if_state_list</name>;</typedef>

<typedef>typedef <type><struct>struct <name>dav_if_header</name>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>uri_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>dav_if_state_list</name> *</type><name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>dav_if_header</name> *</type><name>next</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>dummy_header</name></decl>;</decl_stmt>   <comment type="block">/* used internally by the lock/etag validation */</comment>
}</block></struct></type> <name>dav_if_header</name>;</typedef>

<typedef>typedef <type><struct>struct <name>dav_locktoken_list</name>
<block>{
    <decl_stmt><decl><type><name>dav_locktoken</name> *</type><name>locktoken</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>dav_locktoken_list</name> *</type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>dav_locktoken_list</name>;</typedef>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_locktoken_list</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                                <argument><expr><name>dav_locktoken_list</name> **<name>ltl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/* --------------------------------------------------------------------
**
** LIVE PROPERTY HANDLING
*/</comment>

<comment type="block">/* opaque type for PROPPATCH rollback information */</comment>
<typedef>typedef <type>struct <name>dav_liveprop_rollback</name></type> <name>dav_liveprop_rollback</name>;</typedef>

<struct>struct <name>dav_hooks_liveprop</name>
<block>{
    <comment type="block">/*
    ** Insert property information into a text block. The property to
    ** insert is identified by the propid value. The information to insert
    ** is identified by the "what" argument, as follows:
    **   DAV_PROP_INSERT_NAME
    **      property name, as an empty XML element
    **   DAV_PROP_INSERT_VALUE
    **      property name/value, as an XML element
    **   DAV_PROP_INSERT_SUPPORTED
    **      if the property is defined on the resource, then
    **      a DAV:supported-live-property element, as defined
    **      by the DeltaV extensions to RFC2518.
    **
    ** Providers should return DAV_PROP_INSERT_NOTDEF if the property is
    ** known and not defined for this resource, so should be handled as a
    ** dead property. If a provider recognizes, but does not support, a
    ** property, and does not want it handled as a dead property, it should
    ** return DAV_PROP_INSERT_NOTSUPP.
    **
    ** Returns one of DAV_PROP_INSERT_* based on what happened.
    **
    ** ### we may need more context... ie. the lock database
    */</comment>
    <function_decl><type><name>dav_prop_insert</name></type> (*<name>insert_prop</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                   <param><decl><type><name>int</name></type> <name>propid</name></decl></param>, <param><decl><type><name>dav_prop_insert</name></type> <name>what</name></decl></param>,
                                   <param><decl><type><name>apr_text_header</name> *</type><name>phdr</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Determine whether a given property is writable.
    **
    ** ### we may want a different semantic. i.e. maybe it should be
    ** ### "can we write &lt;value&gt; into this property?"
    **
    ** Returns 1 if the live property can be written, 0 if read-only.
    */</comment>
    <function_decl><type><name>int</name></type> (*<name>is_writable</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>int</name></type> <name>propid</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** This member defines the set of namespace URIs that the provider
    ** uses for its properties. When insert_all is called, it will be
    ** passed a list of integers that map from indices into this list
    ** to namespace IDs for output generation.
    **
    ** The last entry in this list should be a NULL value (sentinel).
    */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type> <name>namespace_uris</name></decl>;</decl_stmt>

    <comment type="block">/*
    ** ### this is not the final design. we want an open-ended way for
    ** ### liveprop providers to attach *new* properties. To this end,
    ** ### we'll have a "give me a list of the props you define", a way
    ** ### to check for a prop's existence, a way to validate a set/remove
    ** ### of a prop, and a way to execute/commit/rollback that change.
    */</comment>

    <comment type="block">/*
    ** Validate that the live property can be assigned a value, and that
    ** the provided value is valid.
    **
    ** elem will point to the XML element that names the property. For
    ** example:
    **     &lt;lp1:executable&gt;T&lt;/lp1:executable&gt;
    **
    ** The provider can access the cdata fields and the child elements
    ** to extract the relevant pieces.
    **
    ** operation is one of DAV_PROP_OP_SET or _DELETE.
    **
    ** The provider may return a value in *context which will be passed
    ** to each of the exec/commit/rollback functions. For example, this
    ** may contain an internal value which has been processed from the
    ** input element.
    **
    ** The provider must set defer_to_dead to true (non-zero) or false.
    ** If true, then the set/remove is deferred to the dead property
    ** database. Note: it will be set to zero on entry.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>patch_validate</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>apr_xml_elem</name> *</type><name>elem</name></decl></param>,
                                  <param><decl><type><name>int</name></type> <name>operation</name></decl></param>,
                                  <param><decl><type><name>void</name> **</type><name>context</name></decl></param>,
                                  <param><decl><type><name>int</name> *</type><name>defer_to_dead</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* ### doc... */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>patch_exec</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>apr_xml_elem</name> *</type><name>elem</name></decl></param>,
                              <param><decl><type><name>int</name></type> <name>operation</name></decl></param>,
                              <param><decl><type><name>void</name> *</type><name>context</name></decl></param>,
                              <param><decl><type><name>dav_liveprop_rollback</name> **</type><name>rollback_ctx</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* ### doc... */</comment>
    <function_decl><type><name>void</name></type> (*<name>patch_commit</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                         <param><decl><type><name>int</name></type> <name>operation</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>context</name></decl></param>,
                         <param><decl><type><name>dav_liveprop_rollback</name> *</type><name>rollback_ctx</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* ### doc... */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>patch_rollback</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                  <param><decl><type><name>int</name></type> <name>operation</name></decl></param>,
                                  <param><decl><type><name>void</name> *</type><name>context</name></decl></param>,
                                  <param><decl><type><name>dav_liveprop_rollback</name> *</type><name>rollback_ctx</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** If a provider needs a context to associate with this hooks structure,
    ** then this field may be used. In most cases, it will just be NULL.
    */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** dav_liveprop_spec: specify a live property
**
** This structure is used as a standard way to determine if a particular
** property is a live property. Its use is not part of the mandated liveprop
** interface, but can be used by liveprop providers in conjunction with the
** utility routines below.
**
** spec-&gt;name == NULL is the defined end-sentinel for a list of specs.
*/</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ns</name></decl>;</decl_stmt>             <comment type="block">/* provider-local namespace index */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>   <comment type="block">/* name of the property */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>propid</name></decl>;</decl_stmt>         <comment type="block">/* provider-local property ID */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>is_writable</name></decl>;</decl_stmt>    <comment type="block">/* is the property writable? */</comment>

}</block></struct></type> <name>dav_liveprop_spec</name>;</typedef>

<comment type="block">/*
** dav_liveprop_group: specify a group of liveprops
**
** This structure specifies a group of live properties, their namespaces,
** and how to handle them.
*/</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_liveprop_spec</name> *</type><name>specs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type><name>namespace_uris</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_liveprop</name> *</type><name>hooks</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_liveprop_group</name>;</typedef>

<comment type="block">/* ### docco */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_do_find_liveprop</name><argument_list>(<argument><expr>const <name>char</name> *<name>ns_uri</name></expr></argument>, <argument><expr>const <name>char</name> *<name>name</name></expr></argument>,
                                      <argument><expr>const <name>dav_liveprop_group</name> *<name>group</name></expr></argument>,
                                      <argument><expr>const <name>dav_hooks_liveprop</name> **<name>hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ### docco */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>long</argument>)</argument_list></macro> <macro><name>dav_get_liveprop_info</name><argument_list>(<argument>int propid</argument>,
                                        <argument>const dav_liveprop_group *group</argument>,
                                        <argument>const dav_liveprop_spec **info</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* ### docco */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_register_liveprop_group</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                                              <argument><expr>const <name>dav_liveprop_group</name> *<name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ### docco */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>long</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_liveprop_ns_index</name><argument_list>(<argument><expr>const <name>char</name> *<name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ### docco */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>long</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_liveprop_ns_count</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ### docco */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_add_all_liveprop_xmlns</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                             <argument><expr><name>apr_text_header</name> *<name>phdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** The following three functions are part of mod_dav's internal handling
** for the core WebDAV properties. They are not part of mod_dav's API.
*/</comment>
<macro><name>DAV_DECLARE_NONSTD</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_core_find_liveprop</name><argument_list>(
    <argument><expr>const <name>dav_resource</name> *<name>resource</name></expr></argument>,
    <argument><expr>const <name>char</name> *<name>ns_uri</name></expr></argument>,
    <argument><expr>const <name>char</name> *<name>name</name></expr></argument>,
    <argument><expr>const <name>dav_hooks_liveprop</name> **<name>hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE_NONSTD</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_core_insert_all_liveprops</name><argument_list>(
    <argument>request_rec *r</argument>,
    <argument>const dav_resource *resource</argument>,
    <argument>dav_prop_insert what</argument>,
    <argument>apr_text_header *phdr</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>DAV_DECLARE_NONSTD</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_core_register_uris</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/*
** Standard WebDAV Property Identifiers
**
** A live property provider does not need to use these; they are simply
** provided for convenience.
**
** Property identifiers need to be unique within a given provider, but not
** *across* providers (note: this uniqueness constraint was different in
** older versions of mod_dav).
**
** The identifiers start at 20000 to make it easier for providers to avoid
** conflicts with the standard properties. The properties are arranged
** alphabetically, and may be reordered from time to time (as properties
** are introduced).
**
** NOTE: there is no problem with reordering (e.g. binary compat) since the
** identifiers are only used within a given provider, which would pick up
** the entire set of changes upon a recompile.
*/</comment>
<enum>enum <block>{
    <decl><name>DAV_PROPID_BEGIN</name> <init>= <expr>20000</expr></init></decl>,

    <comment type="block">/* Standard WebDAV properties (RFC 2518) */</comment>
    <decl><name>DAV_PROPID_creationdate</name></decl>,
    <decl><name>DAV_PROPID_displayname</name></decl>,
    <decl><name>DAV_PROPID_getcontentlanguage</name></decl>,
    <decl><name>DAV_PROPID_getcontentlength</name></decl>,
    <decl><name>DAV_PROPID_getcontenttype</name></decl>,
    <decl><name>DAV_PROPID_getetag</name></decl>,
    <decl><name>DAV_PROPID_getlastmodified</name></decl>,
    <decl><name>DAV_PROPID_lockdiscovery</name></decl>,
    <decl><name>DAV_PROPID_resourcetype</name></decl>,
    <decl><name>DAV_PROPID_source</name></decl>,
    <decl><name>DAV_PROPID_supportedlock</name></decl>,

    <comment type="block">/* DeltaV properties (from the I-D (#14)) */</comment>
    <decl><name>DAV_PROPID_activity_checkout_set</name></decl>,
    <decl><name>DAV_PROPID_activity_set</name></decl>,
    <decl><name>DAV_PROPID_activity_version_set</name></decl>,
    <decl><name>DAV_PROPID_auto_merge_set</name></decl>,
    <decl><name>DAV_PROPID_auto_version</name></decl>,
    <decl><name>DAV_PROPID_baseline_collection</name></decl>,
    <decl><name>DAV_PROPID_baseline_controlled_collection</name></decl>,
    <decl><name>DAV_PROPID_baseline_controlled_collection_set</name></decl>,
    <decl><name>DAV_PROPID_checked_in</name></decl>,
    <decl><name>DAV_PROPID_checked_out</name></decl>,
    <decl><name>DAV_PROPID_checkin_fork</name></decl>,
    <decl><name>DAV_PROPID_checkout_fork</name></decl>,
    <decl><name>DAV_PROPID_checkout_set</name></decl>,
    <decl><name>DAV_PROPID_comment</name></decl>,
    <decl><name>DAV_PROPID_creator_displayname</name></decl>,
    <decl><name>DAV_PROPID_current_activity_set</name></decl>,
    <decl><name>DAV_PROPID_current_workspace_set</name></decl>,
    <decl><name>DAV_PROPID_default_variant</name></decl>,
    <decl><name>DAV_PROPID_eclipsed_set</name></decl>,
    <decl><name>DAV_PROPID_label_name_set</name></decl>,
    <decl><name>DAV_PROPID_merge_set</name></decl>,
    <decl><name>DAV_PROPID_precursor_set</name></decl>,
    <decl><name>DAV_PROPID_predecessor_set</name></decl>,
    <decl><name>DAV_PROPID_root_version</name></decl>,
    <decl><name>DAV_PROPID_subactivity_set</name></decl>,
    <decl><name>DAV_PROPID_subbaseline_set</name></decl>,
    <decl><name>DAV_PROPID_successor_set</name></decl>,
    <decl><name>DAV_PROPID_supported_method_set</name></decl>,
    <decl><name>DAV_PROPID_supported_live_property_set</name></decl>,
    <decl><name>DAV_PROPID_supported_report_set</name></decl>,
    <decl><name>DAV_PROPID_unreserved</name></decl>,
    <decl><name>DAV_PROPID_variant_set</name></decl>,
    <decl><name>DAV_PROPID_version_controlled_binding_set</name></decl>,
    <decl><name>DAV_PROPID_version_controlled_configuration</name></decl>,
    <decl><name>DAV_PROPID_version_history</name></decl>,
    <decl><name>DAV_PROPID_version_name</name></decl>,
    <decl><name>DAV_PROPID_workspace</name></decl>,
    <decl><name>DAV_PROPID_workspace_checkout_set</name></decl>,

    <decl><name>DAV_PROPID_END</name></decl>
}</block>;</enum>

<comment type="block">/*
** Property Identifier Registration
**
** At the moment, mod_dav requires live property providers to ensure that
** each property returned has a unique value. For now, this is done through
** central registration (there are no known providers other than the default,
** so this remains manageable).
**
** WARNING: the TEST ranges should never be "shipped".
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROPID_CORE</name></cpp:macro>         <cpp:value>10000</cpp:value></cpp:define>   <comment type="block">/* ..10099. defined by mod_dav */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROPID_FS</name></cpp:macro>           <cpp:value>10100</cpp:value></cpp:define>   <comment type="block">/* ..10299.
                                           mod_dav filesystem provider. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROPID_TEST1</name></cpp:macro>        <cpp:value>10300</cpp:value></cpp:define>   <comment type="block">/* ..10399 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROPID_TEST2</name></cpp:macro>        <cpp:value>10400</cpp:value></cpp:define>   <comment type="block">/* ..10499 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROPID_TEST3</name></cpp:macro>        <cpp:value>10500</cpp:value></cpp:define>   <comment type="block">/* ..10599 */</comment>
<comment type="block">/* Next: 10600 */</comment>


<comment type="block">/* --------------------------------------------------------------------
**
** DATABASE FUNCTIONS
*/</comment>

<typedef>typedef <type>struct <name>dav_db</name></type> <name>dav_db</name>;</typedef>
<typedef>typedef <type>struct <name>dav_namespace_map</name></type> <name>dav_namespace_map</name>;</typedef>
<typedef>typedef <type>struct <name>dav_deadprop_rollback</name></type> <name>dav_deadprop_rollback</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ns</name></decl>;</decl_stmt>     <comment type="block">/* "" signals "no namespace" */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
}</block></struct></type> <name>dav_prop_name</name>;</typedef>

<comment type="block">/* hook functions to enable pluggable databases */</comment>
<struct>struct <name>dav_hooks_propdb</name>
<block>{
    <function_decl><type><name>dav_error</name> *</type> (*<name>open</name>)<parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>int</name></type> <name>ro</name></decl></param>,
                        <param><decl><type><name>dav_db</name> **</type><name>pdb</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>void</name></type> (*<name>close</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** In bulk, define any namespaces that the values and their name
    ** elements may need.
    **
    ** Note: sometimes mod_dav will defer calling this until output_value
    ** returns found==1. If the output process needs the dav_xmlns_info
    ** filled for its work, then it will need to fill it on demand rather
    ** than depending upon this hook to fill in the structure.
    **
    ** Note: this will *always* be called during an output sequence. Thus,
    ** the provider may rely solely on using this to fill the xmlns info.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>define_namespaces</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>dav_xmlns_info</name> *</type><name>xi</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Output the value from the database (i.e. add an element name and
    ** the value into *phdr). Set *found based on whether the name/value
    ** was found in the propdb.
    **
    ** Note: it is NOT an error for the key/value pair to not exist.
    **
    ** The dav_xmlns_info passed to define_namespaces() is also passed to
    ** each output_value() call so that namespaces can be added on-demand.
    ** It can also be used to look up prefixes or URIs during the output
    ** process.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>output_value</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>,
                                <param><decl><type><name>dav_xmlns_info</name> *</type><name>xi</name></decl></param>,
                                <param><decl><type><name>apr_text_header</name> *</type><name>phdr</name></decl></param>, <param><decl><type><name>int</name> *</type><name>found</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Build a mapping from "global" namespaces (stored in apr_xml_*)
    ** into provider-local namespace identifiers.
    **
    ** This mapping should be done once per set of namespaces, and the
    ** resulting mapping should be passed into the store() hook function.
    **
    ** Note: usually, there is just a single document/namespaces for all
    ** elements passed. However, the generality of creating multiple
    ** mappings and passing them to store() is provided here.
    **
    ** Note: this is only in preparation for a series of store() calls.
    ** As a result, the propdb must be open for read/write access when
    ** this function is called.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>map_namespaces</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>namespaces</name></decl></param>,
                                  <param><decl><type><name>dav_namespace_map</name> **</type><name>mapping</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Store a property value for a given name. The value-&gt;combined field
    ** MUST be set for this call.
    **
    ** ### WARNING: current providers will quote the text within ELEM.
    ** ### this implies you can call this function only once with a given
    ** ### element structure (a second time will quote it again).
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>store</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>apr_xml_elem</name> *</type><name>elem</name></decl></param>,
                         <param><decl><type><name>dav_namespace_map</name> *</type><name>mapping</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* remove a given property */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>remove</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* returns 1 if the record specified by "key" exists; 0 otherwise */</comment>
    <function_decl><type><name>int</name></type> (*<name>exists</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Iterate over the property names in the database.
    **
    ** iter-&gt;name.ns == iter-&gt;name.name == NULL when there are no more names.
    **
    ** Note: only one iteration may occur over the propdb at a time.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>first_name</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>dav_prop_name</name> *</type><name>pname</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>dav_error</name> *</type> (*<name>next_name</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>dav_prop_name</name> *</type><name>pname</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Rollback support: get rollback context, and apply it.
    **
    ** struct dav_deadprop_rollback is a provider-private structure; it
    ** should remember the name, and the name's old value (or the fact that
    ** the value was not present, and should be deleted if a rollback occurs).
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>get_rollback</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>,
                                <param><decl><type><name>dav_deadprop_rollback</name> **</type><name>prollback</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>dav_error</name> *</type> (*<name>apply_rollback</name>)<parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>,
                                  <param><decl><type><name>dav_deadprop_rollback</name> *</type><name>rollback</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** If a provider needs a context to associate with this hooks structure,
    ** then this field may be used. In most cases, it will just be NULL.
    */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* --------------------------------------------------------------------
**
** LOCK FUNCTIONS
*/</comment>

<comment type="block">/* Used to represent a Timeout header of "Infinity" */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_TIMEOUT_INFINITE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>time_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_timeout</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** Opaque, provider-specific information for a lock database.
*/</comment>
<typedef>typedef <type>struct <name>dav_lockdb_private</name></type> <name>dav_lockdb_private</name>;</typedef>

<comment type="block">/*
** Opaque, provider-specific information for a lock record.
*/</comment>
<typedef>typedef <type>struct <name>dav_lock_private</name></type> <name>dav_lock_private</name>;</typedef>

<comment type="block">/*
** Lock database type. Lock providers are urged to implement a "lazy" open, so
** doing an "open" is cheap until something is actually needed from the DB.
*/</comment>
<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>hooks</name></decl>;</decl_stmt>   <comment type="block">/* the hooks used for this lockdb */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ro</name></decl>;</decl_stmt>                         <comment type="block">/* was it opened readonly? */</comment>

    <decl_stmt><decl><type><name>dav_lockdb_private</name> *</type><name>info</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_lockdb</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>DAV_LOCKSCOPE_UNKNOWN</name></decl>,
    <decl><name>DAV_LOCKSCOPE_EXCLUSIVE</name></decl>,
    <decl><name>DAV_LOCKSCOPE_SHARED</name></decl>
}</block></enum></type> <name>dav_lock_scope</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>DAV_LOCKTYPE_UNKNOWN</name></decl>,
    <decl><name>DAV_LOCKTYPE_WRITE</name></decl>
}</block></enum></type> <name>dav_lock_type</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>DAV_LOCKREC_DIRECT</name></decl>,             <comment type="block">/* lock asserted on this resource */</comment>
    <decl><name>DAV_LOCKREC_INDIRECT</name></decl>,           <comment type="block">/* lock inherited from a parent */</comment>
    <decl><name>DAV_LOCKREC_INDIRECT_PARTIAL</name></decl>    <comment type="block">/* most info is not filled in */</comment>
}</block></enum></type> <name>dav_lock_rectype</name>;</typedef>

<comment type="block">/*
** dav_lock: hold information about a lock on a resource.
**
** This structure is used for both direct and indirect locks. A direct lock
** is a lock applied to a specific resource by the client. An indirect lock
** is one that is inherited from a parent resource by virtue of a non-zero
** Depth: header when the lock was applied.
**
** mod_dav records both types of locks in the lock database, managing their
** addition/removal as resources are moved about the namespace.
**
** Note that the lockdb is free to marshal this structure in any form that
** it likes.
**
** For a "partial" lock, the &lt;rectype&gt; and &lt;locktoken&gt; fields must be filled
** in. All other (user) fields should be zeroed. The lock provider will
** usually fill in the &lt;info&gt; field, and the &lt;next&gt; field may be used to
** construct a list of partial locks.
**
** The lock provider MUST use the info field to store a value such that a
** dav_lock structure can locate itself in the underlying lock database.
** This requirement is needed for refreshing: when an indirect dav_lock is
** refreshed, its reference to the direct lock does not specify the direct's
** resource, so the only way to locate the (refreshed, direct) lock in the
** database is to use the info field.
**
** Note that &lt;is_locknull&gt; only refers to the resource where this lock was
** found.
** ### hrm. that says the abstraction is wrong. is_locknull may disappear.
*/</comment>
<typedef>typedef <type><struct>struct <name>dav_lock</name>
<block>{
    <decl_stmt><decl><type><name>dav_lock_rectype</name></type> <name>rectype</name></decl>;</decl_stmt>   <comment type="block">/* type of lock record */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>is_locknull</name></decl>;</decl_stmt>            <comment type="block">/* lock establishes a locknull resource */</comment>

    <comment type="block">/* ### put the resource in here? */</comment>

    <decl_stmt><decl><type><name>dav_lock_scope</name></type> <name>scope</name></decl>;</decl_stmt>       <comment type="block">/* scope of the lock */</comment>
    <decl_stmt><decl><type><name>dav_lock_type</name></type> <name>type</name></decl>;</decl_stmt>         <comment type="block">/* type of lock */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>                  <comment type="block">/* depth of the lock */</comment>
    <decl_stmt><decl><type><name>time_t</name></type> <name>timeout</name></decl>;</decl_stmt>             <comment type="block">/* when the lock will timeout */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl>;</decl_stmt>  <comment type="block">/* the token that was issued */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>owner</name></decl>;</decl_stmt>          <comment type="block">/* (XML) owner of the lock */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>auth_user</name></decl>;</decl_stmt>      <comment type="block">/* auth'd username owning lock */</comment>

    <decl_stmt><decl><type><name>dav_lock_private</name> *</type><name>info</name></decl>;</decl_stmt>     <comment type="block">/* private to the lockdb */</comment>

    <decl_stmt><decl><type>struct <name>dav_lock</name> *</type><name>next</name></decl>;</decl_stmt>      <comment type="block">/* for managing a list of locks */</comment>
}</block></struct></type> <name>dav_lock</name>;</typedef>

<comment type="block">/* Property-related public lock functions */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro><expr_stmt><expr><call><name>dav_lock_get_activelock</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                                 <argument><expr><name>dav_lock</name> *<name>locks</name></expr></argument>,
                                                 <argument><expr><name>dav_buffer</name> *<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* LockDB-related public lock functions */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_lock_parse_lockinfo</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                                 <argument><expr>const <name>dav_resource</name> *<name>resrouce</name></expr></argument>,
                                                 <argument><expr><name>dav_lockdb</name> *<name>lockdb</name></expr></argument>,
                                                 <argument><expr>const <name>apr_xml_doc</name> *<name>doc</name></expr></argument>,
                                                 <argument><expr><name>dav_lock</name> **<name>lock_request</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_unlock</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                            <argument><expr>const <name>dav_resource</name> *<name>resource</name></expr></argument>,
                            <argument><expr>const <name>dav_locktoken</name> *<name>locktoken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_add_lock</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                      <argument><expr>const <name>dav_resource</name> *<name>resource</name></expr></argument>,
                                      <argument><expr><name>dav_lockdb</name> *<name>lockdb</name></expr></argument>, <argument><expr><name>dav_lock</name> *<name>request</name></expr></argument>,
                                      <argument><expr><name>dav_response</name> **<name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_notify_created</name><argument_list>(<argument>request_rec *r</argument>,
                                            <argument>dav_lockdb *lockdb</argument>,
                                            <argument>const dav_resource *resource</argument>,
                                            <argument>int resource_state</argument>,
                                            <argument>int depth</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_lock_query</name><argument_list>(<argument><expr><name>dav_lockdb</name> *<name>lockdb</name></expr></argument>,
                                       <argument><expr>const <name>dav_resource</name> *<name>resource</name></expr></argument>,
                                       <argument><expr><name>dav_lock</name> **<name>locks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_validate_request</name><argument_list>(<argument>request_rec *r</argument>,
                                              <argument>dav_resource *resource</argument>,
                                              <argument>int depth</argument>,
                                              <argument>dav_locktoken *locktoken</argument>,
                                              <argument>dav_response **response</argument>,
                                              <argument>int flags</argument>,
                                              <argument>dav_lockdb *lockdb</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<comment type="block">/*
** flags:
**    0x0F -- reserved for &lt;dav_lock_scope&gt; values
**
**    other flags, detailed below
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_VALIDATE_RESOURCE</name></cpp:macro>   <cpp:value>0x0010</cpp:value></cpp:define>  <comment type="block">/* validate just the resource */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_VALIDATE_PARENT</name></cpp:macro>     <cpp:value>0x0020</cpp:value></cpp:define>  <comment type="block">/* validate resource AND its parent */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_VALIDATE_ADD_LD</name></cpp:macro>     <cpp:value>0x0040</cpp:value></cpp:define>  <comment type="block">/* add DAV:lockdiscovery into
                                           the 424 DAV:response */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_VALIDATE_USE_424</name></cpp:macro>    <cpp:value>0x0080</cpp:value></cpp:define>  <comment type="block">/* return 424 status, not 207 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_VALIDATE_IS_PARENT</name></cpp:macro>  <cpp:value>0x0100</cpp:value></cpp:define>  <comment type="block">/* for internal use */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_VALIDATE_NO_MODIFY</name></cpp:macro>  <cpp:value>0x0200</cpp:value></cpp:define>  <comment type="block">/* resource is not being modified
                                           so allow even if lock token
                                           is not provided */</comment>

<comment type="block">/* Lock-null related public lock functions */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_resource_state</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                        <argument><expr>const <name>dav_resource</name> *<name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Lock provider hooks. Locking is optional, so there may be no
 * lock provider for a given repository.
 */</comment>
<struct>struct <name>dav_hooks_locks</name>
<block>{
    <comment type="block">/* Return the supportedlock property for a resource */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type> (*<name>get_supportedlock</name>)<parameter_list>(
        <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Parse a lock token URI, returning a lock token object allocated
     * in the given pool.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>parse_locktoken</name>)<parameter_list>(
        <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>char_token</name></decl></param>,
        <param><decl><type><name>dav_locktoken</name> **</type><name>locktoken_p</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Format a lock token object into a URI string, allocated in
     * the given pool.
     *
     * Always returns non-NULL.
     */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type> (*<name>format_locktoken</name>)<parameter_list>(
        <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Compare two lock tokens.
     *
     * Result &lt; 0  =&gt; lt1 &lt; lt2
     * Result == 0 =&gt; lt1 == lt2
     * Result &gt; 0  =&gt; lt1 &gt; lt2
     */</comment>
    <function_decl><type><name>int</name></type> (*<name>compare_locktoken</name>)<parameter_list>(
        <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>lt1</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>lt2</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Open the provider's lock database.
     *
     * The provider may or may not use a "real" database for locks
     * (a lock could be an attribute on a resource, for example).
     *
     * The provider may choose to use the value of the DAVLockDB directive
     * (as returned by dav_get_lockdb_path()) to decide where to place
     * any storage it may need.
     *
     * The request storage pool should be associated with the lockdb,
     * so it can be used in subsequent operations.
     *
     * If ro != 0, only readonly operations will be performed.
     * If force == 0, the open can be "lazy"; no subsequent locking operations
     * may occur.
     * If force != 0, locking operations will definitely occur.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>open_lockdb</name>)<parameter_list>(
        <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
        <param><decl><type><name>int</name></type> <name>ro</name></decl></param>,
        <param><decl><type><name>int</name></type> <name>force</name></decl></param>,
        <param><decl><type><name>dav_lockdb</name> **</type><name>lockdb</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Indicates completion of locking operations */</comment>
    <function_decl><type><name>void</name></type> (*<name>close_lockdb</name>)<parameter_list>(
        <param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Take a resource out of the lock-null state. */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>remove_locknull_state</name>)<parameter_list>(
        <param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Create a (direct) lock structure for the given resource. A locktoken
    ** will be created.
    **
    ** The lock provider may store private information into lock-&gt;info.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>create_lock</name>)<parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                               <param><decl><type><name>dav_lock</name> **</type><name>lock</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Get the locks associated with the specified resource.
    **
    ** If resolve_locks is true (non-zero), then any indirect locks are
    ** resolved to their actual, direct lock (i.e. the reference to followed
    ** to the original lock).
    **
    ** The locks, if any, are returned as a linked list in no particular
    ** order. If no locks are present, then *locks will be NULL.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>get_locks</name>)<parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                             <param><decl><type><name>int</name></type> <name>calltype</name></decl></param>,
                             <param><decl><type><name>dav_lock</name> **</type><name>locks</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GETLOCKS_RESOLVED</name></cpp:macro>   <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* resolve indirects to directs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GETLOCKS_PARTIAL</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* leave indirects partially filled */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GETLOCKS_COMPLETE</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* fill out indirect locks */</comment>

    <comment type="block">/*
    ** Find a particular lock on a resource (specified by its locktoken).
    **
    ** *lock will be set to NULL if the lock is not found.
    **
    ** Note that the provider can optimize the unmarshalling -- only one
    ** lock (or none) must be constructed and returned.
    **
    ** If partial_ok is true (non-zero), then an indirect lock can be
    ** partially filled in. Otherwise, another lookup is done and the
    ** lock structure will be filled out as a DAV_LOCKREC_INDIRECT.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>find_lock</name>)<parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl></param>,
                             <param><decl><type><name>int</name></type> <name>partial_ok</name></decl></param>,
                             <param><decl><type><name>dav_lock</name> **</type><name>lock</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Quick test to see if the resource has *any* locks on it.
    **
    ** This is typically used to determine if a non-existent resource
    ** has a lock and is (therefore) a locknull resource.
    **
    ** WARNING: this function may return TRUE even when timed-out locks
    **          exist (i.e. it may not perform timeout checks).
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>has_locks</name>)<parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                             <param><decl><type><name>int</name> *</type><name>locks_present</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Append the specified lock(s) to the set of locks on this resource.
    **
    ** If "make_indirect" is true (non-zero), then the specified lock(s)
    ** should be converted to an indirect lock (if it is a direct lock)
    ** before appending. Note that the conversion to an indirect lock does
    ** not alter the passed-in lock -- the change is internal the
    ** append_locks function.
    **
    ** Multiple locks are specified using the lock-&gt;next links.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>append_locks</name>)<parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                <param><decl><type><name>int</name></type> <name>make_indirect</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>dav_lock</name> *</type><name>lock</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Remove any lock that has the specified locktoken.
    **
    ** If locktoken == NULL, then ALL locks are removed.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>remove_lock</name>)<parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Refresh all locks, found on the specified resource, which has a
    ** locktoken in the provided list.
    **
    ** If the lock is indirect, then the direct lock is referenced and
    ** refreshed.
    **
    ** Each lock that is updated is returned in the &lt;locks&gt; argument.
    ** Note that the locks will be fully resolved.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>refresh_locks</name>)<parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>dav_locktoken_list</name> *</type><name>ltl</name></decl></param>,
                                 <param><decl><type><name>time_t</name></type> <name>new_time</name></decl></param>,
                                 <param><decl><type><name>dav_lock</name> **</type><name>locks</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Look up the resource associated with a particular locktoken.
    **
    ** The search begins at the specified &lt;start_resource&gt; and the lock
    ** specified by &lt;locktoken&gt;.
    **
    ** If the resource/token specifies an indirect lock, then the direct
    ** lock will be looked up, and THAT resource will be returned. In other
    ** words, this function always returns the resource where a particular
    ** lock (token) was asserted.
    **
    ** NOTE: this function pointer is allowed to be NULL, indicating that
    **       the provider does not support this type of functionality. The
    **       caller should then traverse up the repository hierarchy looking
    **       for the resource defining a lock with this locktoken.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>lookup_resource</name>)<parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>start_resource</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>dav_resource</name> **</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** If a provider needs a context to associate with this hooks structure,
    ** then this field may be used. In most cases, it will just be NULL.
    */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* what types of resources can be discovered by dav_get_resource_state() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESOURCE_LOCK_NULL</name></cpp:macro>  <cpp:value>10</cpp:value></cpp:define>    <comment type="block">/* resource lock-null */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESOURCE_NULL</name></cpp:macro>       <cpp:value>11</cpp:value></cpp:define>    <comment type="block">/* resource null */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESOURCE_EXISTS</name></cpp:macro>     <cpp:value>12</cpp:value></cpp:define>    <comment type="block">/* resource exists */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESOURCE_ERROR</name></cpp:macro>      <cpp:value>13</cpp:value></cpp:define>    <comment type="block">/* an error occurred */</comment>


<comment type="block">/* --------------------------------------------------------------------
**
** PROPERTY HANDLING
*/</comment>

<typedef>typedef <type>struct <name>dav_propdb</name></type> <name>dav_propdb</name>;</typedef>


<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_open_propdb</name><argument_list>(
    <argument>request_rec *r</argument>,
    <argument>dav_lockdb *lockdb</argument>,
    <argument>const dav_resource *resource</argument>,
    <argument>int ro</argument>,
    <argument>apr_array_header_t *ns_xlate</argument>,
    <argument>dav_propdb **propdb</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_close_propdb</name><argument_list>(<argument><expr><name>dav_propdb</name> *<name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_get_props_result</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_props</name><argument_list>(
    <argument><expr><name>dav_propdb</name> *<name>db</name></expr></argument>,
    <argument><expr><name>apr_xml_doc</name> *<name>doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_get_props_result</argument>)</argument_list></macro> <macro><name>dav_get_allprops</name><argument_list>(
    <argument>dav_propdb *db</argument>,
    <argument>dav_prop_insert what</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_liveprop_supported</name><argument_list>(
    <argument><expr><name>dav_propdb</name> *<name>propdb</name></expr></argument>,
    <argument><expr>const <name>char</name> *<name>ns_uri</name></expr></argument>,
    <argument><expr>const <name>char</name> *<name>propname</name></expr></argument>,
    <argument><expr><name>apr_text_header</name> *<name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** 3-phase property modification.
**
**   1) validate props. readable? unlocked? ACLs allow access?
**   2) execute operation (set/delete)
**   3) commit or rollback
**
** ### eventually, auth must be available. a ref to the request_rec (which
** ### contains the auth info) should be in the shared context struct.
**
** Each function may alter the error values and information contained within
** the context record. This should be done as an "increasing" level of
** error, rather than overwriting any previous error.
**
** Note that commit() cannot generate errors. It should simply free the
** rollback information.
**
** rollback() may generate additional errors because the rollback operation
** can sometimes fail(!).
**
** The caller should allocate an array of these, one per operation. It should
** be zero-initialized, then the db, operation, and prop fields should be
** filled in before calling dav_prop_validate. Note that the set/delete
** operations are order-dependent. For a given (logical) context, the same
** pointer must be passed to each phase.
**
** error_type is an internal value, but will have the same numeric value
** for each possible "desc" value. This allows the caller to group the
** descriptions via the error_type variable, rather than through string
** comparisons. Note that "status" does not provide enough granularity to
** differentiate/group the "desc" values.
**
** Note that the propdb will maintain some (global) context across all
** of the property change contexts. This implies that you can have only
** one open transaction per propdb.
*/</comment>
<typedef>typedef <type><struct>struct <name>dav_prop_ctx</name>
<block>{
    <decl_stmt><decl><type><name>dav_propdb</name> *</type><name>propdb</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>apr_xml_elem</name> *</type><name>prop</name></decl>;</decl_stmt>             <comment type="block">/* property to affect */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>operation</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROP_OP_SET</name></cpp:macro>        <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* set a property value */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROP_OP_DELETE</name></cpp:macro>     <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* delete a prop value */</comment>
<comment type="block">/* ### add a GET? */</comment>

    <comment type="block">/* private items to the propdb */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>is_liveprop</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>liveprop_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>dav_rollback_item</name> *</type><name>rollback</name></decl>;</decl_stmt>  <comment type="block">/* optional rollback info */</comment>

    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>                 <comment type="block">/* error (if any) */</comment>

    <comment type="block">/* private to mod_dav.c */</comment>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_prop_ctx</name>;</typedef>

<macro><name>DAV_DECLARE_NONSTD</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_prop_validate</name><argument_list>(<argument><expr><name>dav_prop_ctx</name> *<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE_NONSTD</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_prop_exec</name><argument_list>(<argument><expr><name>dav_prop_ctx</name> *<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE_NONSTD</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_prop_commit</name><argument_list>(<argument><expr><name>dav_prop_ctx</name> *<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DAV_DECLARE_NONSTD</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_prop_rollback</name><argument_list>(<argument><expr><name>dav_prop_ctx</name> *<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROP_CTX_HAS_ERR</name><parameter_list>(<param><type><name>dpc</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>((dpc).err &amp;&amp; (dpc).err-&gt;status &gt;= 300)</cpp:value></cpp:define>


<comment type="block">/* --------------------------------------------------------------------
**
** WALKER STRUCTURE
*/</comment>

<enum>enum <block>{
    <decl><name>DAV_CALLTYPE_MEMBER</name> <init>= <expr>1</expr></init></decl>,    <comment type="block">/* called for a member resource */</comment>
    <decl><name>DAV_CALLTYPE_COLLECTION</name></decl>,    <comment type="block">/* called for a collection */</comment>
    <decl><name>DAV_CALLTYPE_LOCKNULL</name></decl>       <comment type="block">/* called for a locknull resource */</comment>
}</block>;</enum>

<typedef>typedef <type><struct>struct
<block>{
    <comment type="block">/* the client-provided context */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>walk_ctx</name></decl>;</decl_stmt>

    <comment type="block">/* pool to use for allocations in the callback */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

    <comment type="block">/* the current resource */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl>;</decl_stmt>

    <comment type="block">/* OUTPUT: add responses to this */</comment>
    <decl_stmt><decl><type><name>dav_response</name> *</type><name>response</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_walk_resource</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>walk_type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_WALKTYPE_AUTH</name></cpp:macro>       <cpp:value>0x0001</cpp:value></cpp:define>  <comment type="block">/* limit to authorized files */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_WALKTYPE_NORMAL</name></cpp:macro>     <cpp:value>0x0002</cpp:value></cpp:define>  <comment type="block">/* walk normal files */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_WALKTYPE_LOCKNULL</name></cpp:macro>   <cpp:value>0x0004</cpp:value></cpp:define>  <comment type="block">/* walk locknull resources */</comment>

    <comment type="block">/* callback function and a client context for the walk */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>dav_walk_resource</name> *</type><name>wres</name></decl></param>, <param><decl><type><name>int</name></type> <name>calltype</name></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name> *</type><name>walk_ctx</name></decl>;</decl_stmt>

    <comment type="block">/* what pool to use for allocations needed by walk logic */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

    <comment type="block">/* beginning root of the walk */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>root</name></decl>;</decl_stmt>

    <comment type="block">/* lock database to enable walking LOCKNULL resources */</comment>
    <decl_stmt><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_walk_params</name>;</typedef>

<comment type="block">/* directory tree walking context */</comment>
<typedef>typedef <type><struct>struct <name>dav_walker_ctx</name>
<block>{
    <comment type="block">/* input: */</comment>
    <decl_stmt><decl><type><name>dav_walk_params</name></type> <name>w</name></decl>;</decl_stmt>


    <comment type="block">/* ### client data... phasing out this big glom */</comment>

    <comment type="block">/* this brigade buffers data being sent to r-&gt;output_filters */</comment>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>

    <comment type="block">/* a scratch pool, used to stream responses and iteratively cleared. */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>scratchpool</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>                 <comment type="block">/* original request */</comment>

    <comment type="block">/* for PROPFIND operations */</comment>
    <decl_stmt><decl><type><name>apr_xml_doc</name> *</type><name>doc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>propfind_type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROPFIND_IS_ALLPROP</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROPFIND_IS_PROPNAME</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_PROPFIND_IS_PROP</name></cpp:macro>        <cpp:value>3</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>apr_text</name> *</type><name>propstat_404</name></decl>;</decl_stmt>         <comment type="block">/* (cached) propstat giving a 404 error */</comment>

    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_if_header</name> *</type><name>if_header</name></decl>;</decl_stmt> <comment type="block">/* for validation */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl>;</decl_stmt> <comment type="block">/* for UNLOCK */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_lock</name> *</type><name>lock</name></decl>;</decl_stmt>           <comment type="block">/* for LOCK */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>skip_root</name></decl>;</decl_stmt>                  <comment type="block">/* for dav_inherit_locks() */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>dav_buffer</name></type> <name>work_buf</name></decl>;</decl_stmt>            <comment type="block">/* for dav_validate_request() */</comment>

}</block></struct></type> <name>dav_walker_ctx</name>;</typedef>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_add_response</name><argument_list>(<argument>dav_walk_resource *wres</argument>,
                                   <argument>int status</argument>,
                                   <argument>dav_get_props_result *propstats</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/* --------------------------------------------------------------------
**
** "STREAM" STRUCTURE
**
** mod_dav uses this abstraction for interacting with the repository
** while fetching/storing resources. mod_dav views resources as a stream
** of bytes.
**
** Note that the structure is opaque -- it is private to the repository
** that created the stream in the repository's "open" function.
**
** ### THIS STUFF IS GOING AWAY ... GET/read requests are handled by
** ### having the provider jam stuff straight into the filter stack.
** ### this is only left for handling PUT/write requests.
*/</comment>

<typedef>typedef <type>struct <name>dav_stream</name></type> <name>dav_stream</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>DAV_MODE_WRITE_TRUNC</name></decl>,      <comment type="block">/* truncate and open for writing */</comment>
    <decl><name>DAV_MODE_WRITE_SEEKABLE</name></decl>    <comment type="block">/* open for writing; random access */</comment>
}</block></enum></type> <name>dav_stream_mode</name>;</typedef>


<comment type="block">/* --------------------------------------------------------------------
**
** REPOSITORY FUNCTIONS
*/</comment>

<comment type="block">/* Repository provider hooks */</comment>
<struct>struct <name>dav_hooks_repository</name>
<block>{
    <comment type="block">/* Flag for whether repository requires special GET handling.
     * If resources in the repository are not visible in the
     * filesystem location which URLs map to, then special handling
     * is required to first fetch a resource from the repository,
     * respond to the GET request, then free the resource copy.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>handle_get</name></decl>;</decl_stmt>

    <comment type="block">/* Get a resource descriptor for the URI in a request. A descriptor
     * should always be returned even if the resource does not exist. This
     * repository has been identified as handling the resource given by
     * the URI, so an answer must be given. If there is a problem with the
     * URI or accessing the resource or whatever, then an error should be
     * returned.
     *
     * root_dir:
     *   the root of the directory for which this repository is configured.
     *
     * label:
     *   if a Label: header is present (and allowed), this is the label
     *   to use to identify a version resource from the resource's
     *   corresponding version history. Otherwise, it will be NULL.
     *
     * use_checked_in:
     *   use the DAV:checked-in property of the resource identified by the
     *   Request-URI to identify and return a version resource
     *
     * The provider may associate the request storage pool with the resource
     * (in the resource-&gt;pool field), to use in other operations on that
     * resource.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>get_resource</name>)<parameter_list>(
        <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_dir</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
        <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>,
        <param><decl><type><name>dav_resource</name> **</type><name>resource</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Get a resource descriptor for the parent of the given resource.
     * The resources need not exist.  NULL is returned if the resource
     * is the root collection.
     *
     * An error should be returned only if there is a fatal error in
     * fetching information about the parent resource.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>get_parent_resource</name>)<parameter_list>(
        <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
        <param><decl><type><name>dav_resource</name> **</type><name>parent_resource</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Determine whether two resource descriptors refer to the same resource.
    *
     * Result != 0 =&gt; the resources are the same.
     */</comment>
    <function_decl><type><name>int</name></type> (*<name>is_same_resource</name>)<parameter_list>(
        <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res1</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res2</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Determine whether one resource is a parent (immediate or otherwise)
     * of another.
     *
     * Result != 0 =&gt; res1 is a parent of res2.
     */</comment>
    <function_decl><type><name>int</name></type> (*<name>is_parent_resource</name>)<parameter_list>(
        <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res1</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res2</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Open a stream for this resource, using the specified mode. The
    ** stream will be returned in *stream.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>open_stream</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                               <param><decl><type><name>dav_stream_mode</name></type> <name>mode</name></decl></param>,
                               <param><decl><type><name>dav_stream</name> **</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Close the specified stream.
    **
    ** mod_dav will (ideally) make sure to call this. For safety purposes,
    ** a provider should (ideally) register a cleanup function with the
    ** request pool to get this closed and cleaned up.
    **
    ** Note the possibility of an error from the close -- it is entirely
    ** feasible that the close does a "commit" of some kind, which can
    ** produce an error.
    **
    ** commit should be TRUE (non-zero) or FALSE (0) if the stream was
    ** opened for writing. This flag states whether to retain the file
    ** or not.
    ** Note: the commit flag is ignored for streams opened for reading.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>close_stream</name>)<parameter_list>(<param><decl><type><name>dav_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>int</name></type> <name>commit</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Write data to the stream.
    **
    ** All of the bytes must be written, or an error should be returned.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>write_stream</name>)<parameter_list>(<param><decl><type><name>dav_stream</name> *</type><name>stream</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bufsize</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Seek to an absolute position in the stream. This is used to support
    ** Content-Range in a GET/PUT.
    **
    ** NOTE: if this function is NULL (which is allowed), then any
    **       operations using Content-Range will be refused.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>seek_stream</name>)<parameter_list>(<param><decl><type><name>dav_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>abs_position</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** If a GET is processed using a stream (open_stream, read_stream)
    ** rather than via a sub-request (on get_pathname), then this function
    ** is used to provide the repository with a way to set the headers
    ** in the response.
    **
    ** This function may be called without a following deliver(), to
    ** handle a HEAD request.
    **
    ** This may be NULL if handle_get is FALSE.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>set_headers</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** The provider should deliver the resource into the specified filter.
    ** Basically, this is the response to the GET method.
    **
    ** Note that this is called for all resources, including collections.
    ** The provider should determine what has content to deliver or not.
    **
    ** set_headers will be called prior to this function, allowing the
    ** provider to set the appropriate response headers.
    **
    ** This may be NULL if handle_get is FALSE.
    ** ### maybe toss handle_get and just use this function as the marker
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>deliver</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                           <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Create a collection resource. The resource must not already exist.
     *
     * Result == NULL if the collection was created successfully. Also, the
     * resource object is updated to reflect that the resource exists, and
     * is a collection.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>create_collection</name>)<parameter_list>(
        <param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Copy one resource to another. The destination may exist, if it is
     * versioned.
     * Handles both files and collections. Properties are copied as well.
     * If the destination exists and is versioned, the provider must update
     * the destination to have identical content to the source,
     * recursively for collections.
     * The depth argument is ignored for a file, and can be either 0 or
     * DAV_INFINITY for a collection.
     * If an error occurs in a child resource, then the return value is
     * non-NULL, and *response is set to a multistatus response.
     * If the copy is successful, the dst resource object is
     * updated to reflect that the resource exists.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>copy_resource</name>)<parameter_list>(
        <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>src</name></decl></param>,
        <param><decl><type><name>dav_resource</name> *</type><name>dst</name></decl></param>,
        <param><decl><type><name>int</name></type> <name>depth</name></decl></param>,
        <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Move one resource to another. The destination must not exist.
     * Handles both files and collections. Properties are moved as well.
     * If an error occurs in a child resource, then the return value is
     * non-NULL, and *response is set to a multistatus response.
     * If the move is successful, the src and dst resource objects are
     * updated to reflect that the source no longer exists, and the
     * destination does.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>move_resource</name>)<parameter_list>(
        <param><decl><type><name>dav_resource</name> *</type><name>src</name></decl></param>,
        <param><decl><type><name>dav_resource</name> *</type><name>dst</name></decl></param>,
        <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Remove a resource. Handles both files and collections.
     * Removes any associated properties as well.
     * If an error occurs in a child resource, then the return value is
     * non-NULL, and *response is set to a multistatus response.
     * If the delete is successful, the resource object is updated to
     * reflect that the resource no longer exists.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>remove_resource</name>)<parameter_list>(
        <param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
        <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>
    )</parameter_list>;</function_decl>

    <comment type="block">/* Walk a resource hierarchy.
     *
     * Iterates over the resource hierarchy specified by params-&gt;root.
     * Control of the walk and the callback are specified by 'params'.
     *
     * An error may be returned. *response will contain multistatus
     * responses (if any) suitable for the body of the error. It is also
     * possible to return NULL, yet still have multistatus responses.
     * In this case, typically the caller should return a 207 (Multistatus)
     * and the responses (in the body) as the HTTP response.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>walk</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_walk_params</name> *</type><name>params</name></decl></param>, <param><decl><type><name>int</name></type> <name>depth</name></decl></param>,
                        <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Get the entity tag for a resource */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type> (*<name>getetag</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** If a provider needs a context to associate with this hooks structure,
    ** then this field may be used. In most cases, it will just be NULL.
    */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>

    <comment type="block">/* Get the request rec for a resource */</comment>
    <function_decl><type><name>request_rec</name> *</type> (*<name>get_request_rec</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Get the pathname for a resource */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type> (*<name>get_pathname</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>
}</block>;</struct>


<comment type="block">/* --------------------------------------------------------------------
**
** VERSIONING FUNCTIONS
*/</comment>


<comment type="block">/* dav_add_vary_header
 *
 * If there were any headers in the request which require a Vary header
 * in the response, add it.
 */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_add_vary_header</name><argument_list>(<argument><expr><name>request_rec</name> *<name>in_req</name></expr></argument>,
                                      <argument><expr><name>request_rec</name> *<name>out_req</name></expr></argument>,
                                      <argument><expr>const <name>dav_resource</name> *<name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
** Flags specifying auto-versioning behavior, returned by
** the auto_versionable hook. The value returned depends
** on both the state of the resource and the value of the
** DAV:auto-versioning property for the resource.
**
** If the resource does not exist (null or lock-null),
** DAV_AUTO_VERSION_ALWAYS causes creation of a new version-controlled resource
**
** If the resource is checked in,
** DAV_AUTO_VERSION_ALWAYS causes it to be checked out always,
** DAV_AUTO_VERSION_LOCKED causes it to be checked out only when locked
**
** If the resource is checked out,
** DAV_AUTO_VERSION_ALWAYS causes it to be checked in always,
** DAV_AUTO_VERSION_LOCKED causes it to be checked in when unlocked
** (note: a provider should allow auto-checkin only for resources which
** were automatically checked out)
**
** In all cases, DAV_AUTO_VERSION_NEVER results in no auto-versioning behavior.
*/</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>DAV_AUTO_VERSION_NEVER</name></decl>,
    <decl><name>DAV_AUTO_VERSION_ALWAYS</name></decl>,
    <decl><name>DAV_AUTO_VERSION_LOCKED</name></decl>
}</block></enum></type> <name>dav_auto_version</name>;</typedef>

<comment type="block">/*
** This structure is used to record what auto-versioning operations
** were done to make a resource writable, so that they can be undone
** at the end of a request.
*/</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>resource_versioned</name></decl>;</decl_stmt>             <comment type="block">/* 1 =&gt; resource was auto-version-controlled */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>resource_checkedout</name></decl>;</decl_stmt>            <comment type="block">/* 1 =&gt; resource was auto-checked-out */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>parent_checkedout</name></decl>;</decl_stmt>              <comment type="block">/* 1 =&gt; parent was auto-checked-out */</comment>
    <decl_stmt><decl><type><name>dav_resource</name> *</type><name>parent_resource</name></decl>;</decl_stmt>      <comment type="block">/* parent resource, if it was needed */</comment>
}</block></struct></type> <name>dav_auto_version_info</name>;</typedef>

<comment type="block">/* Ensure that a resource is writable. If there is no versioning
 * provider, then this is essentially a no-op. Versioning repositories
 * require explicit resource creation and checkout before they can
 * be written to. If a new resource is to be created, or an existing
 * resource deleted, the parent collection must be checked out as well.
 *
 * Set the parent_only flag to only make the parent collection writable.
 * Otherwise, both parent and child are made writable as needed. If the
 * child does not exist, then a new versioned resource is created and
 * checked out.
 *
 * If auto-versioning is not enabled for a versioned resource, then an error is
 * returned, since the resource cannot be modified.
 *
 * The dav_auto_version_info structure is filled in with enough information
 * to restore both parent and child resources to the state they were in
 * before the auto-versioning operations occurred.
 */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_auto_checkout</name><argument_list>(
    <argument>request_rec *r</argument>,
    <argument>dav_resource *resource</argument>,
    <argument>int parent_only</argument>,
    <argument>dav_auto_version_info *av_info</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/* Revert the writability of resources back to what they were
 * before they were modified. If undo == 0, then the resource
 * modifications are maintained (i.e. they are checked in).
 * If undo != 0, then resource modifications are discarded
 * (i.e. they are unchecked out).
 *
 * Set the unlock flag to indicate that the resource is about
 * to be unlocked; it will be checked in if the resource
 * auto-versioning property indicates it should be. In this case,
 * av_info is ignored, so it can be NULL.
 *
 * The resource argument may be NULL if only the parent resource
 * was checked out (i.e. the parent_only was != 0 in the
 * dav_auto_checkout call).
 */</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_auto_checkin</name><argument_list>(
    <argument>request_rec *r</argument>,
    <argument>dav_resource *resource</argument>,
    <argument>int undo</argument>,
    <argument>int unlock</argument>,
    <argument>dav_auto_version_info *av_info</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/*
** This structure is used to describe available reports
**
** "nmspace" should be valid XML and URL-quoted. mod_dav will place
** double-quotes around it and use it in an xmlns declaration.
*/</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>nmspace</name></decl>;</decl_stmt>        <comment type="block">/* namespace of the XML report element */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>           <comment type="block">/* element name for the XML report */</comment>
}</block></struct></type> <name>dav_report_elem</name>;</typedef>


<comment type="block">/* Versioning provider hooks */</comment>
<struct>struct <name>dav_hooks_vsn</name>
<block>{
    <comment type="block">/*
    ** MANDATORY HOOKS
    ** The following hooks are mandatory for all versioning providers;
    ** they define the functionality needed to implement "core" versioning.
    */</comment>

    <comment type="block">/* Return supported versioning options.
     * Each dav_text item in the list will be returned as a separate
     * DAV header. Providers are advised to limit the length of an
     * individual text item to 63 characters, to conform to the limit
     * used by MS Web Folders.
     */</comment>
    <function_decl><type><name>void</name></type> (*<name>get_vsn_options</name>)<parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_text_header</name> *</type><name>phdr</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Get the value of a specific option for an OPTIONS request.
     * The option being requested is given by the parsed XML
     * element object "elem". The value of the option should be
     * appended to the "option" text object.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>get_option</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>apr_xml_elem</name> *</type><name>elem</name></decl></param>,
                              <param><decl><type><name>apr_text_header</name> *</type><name>option</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Determine whether a non-versioned (or non-existent) resource
     * is versionable. Returns != 0 if resource can be versioned.
     */</comment>
    <function_decl><type><name>int</name></type> (*<name>versionable</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Determine whether auto-versioning is enabled for a resource
     * (which may not exist, or may not be versioned). If the resource
     * is a checked-out resource, the provider must only enable
     * auto-checkin if the resource was automatically checked out.
     *
     * The value returned depends on both the state of the resource
     * and the value of its DAV:auto-version property. See the description
     * of the dav_auto_version enumeration above for the details.
     */</comment>
    <function_decl><type><name>dav_auto_version</name></type> (*<name>auto_versionable</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Put a resource under version control. If the resource already
     * exists unversioned, then it becomes the initial version of the
     * new version history, and it is replaced by a version selector
     * which targets the new version.
     *
     * If the resource does not exist, then a new version-controlled
     * resource is created which either targets an existing version (if the
     * "target" argument is not NULL), or the initial, empty version
     * in a new history resource (if the "target" argument is NULL).
     *
     * If successful, the resource object state is updated appropriately
     * (that is, changed to refer to the new version-controlled resource).
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>vsn_control</name>)<parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Checkout a resource. If successful, the resource
     * object state is updated appropriately.
     *
     * The auto_checkout flag will be set if this checkout is being
     * done automatically, as part of some method which modifies
     * the resource. The provider must remember that the resource
     * was automatically checked out, so it can determine whether it
     * can be automatically checked in. (Auto-checkin should only be
     * enabled for resources which were automatically checked out.)
     *
     * If the working resource has a different URL from the
     * target resource, a dav_resource descriptor is returned
     * for the new working resource. Otherwise, the original
     * resource descriptor will refer to the working resource.
     * The working_resource argument can be NULL if the caller
     * is not interested in the working resource.
     *
     * If the client has specified DAV:unreserved or DAV:fork-ok in the
     * checkout request, then the corresponding flags are set. If
     * DAV:activity-set has been specified, then create_activity is set
     * if DAV:new was specified; otherwise, the DAV:href elements' CDATA
     * (the actual href text) is passed in the "activities" array (each
     * element of the array is a const char *). activities will be NULL
     * no DAV:activity-set was provided or when create_activity is set.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>checkout</name>)<parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
                            <param><decl><type><name>int</name></type> <name>auto_checkout</name></decl></param>,
                            <param><decl><type><name>int</name></type> <name>is_unreserved</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_fork_ok</name></decl></param>,
                            <param><decl><type><name>int</name></type> <name>create_activity</name></decl></param>,
                            <param><decl><type><name>apr_array_header_t</name> *</type><name>activities</name></decl></param>,
                            <param><decl><type><name>dav_resource</name> **</type><name>working_resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Uncheckout a checked-out resource. If successful, the resource
     * object state is updated appropriately.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>uncheckout</name>)<parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Checkin a checked-out resource. If successful, the resource
     * object state is updated appropriately, and the
     * version_resource descriptor will refer to the new version.
     * The version_resource argument can be NULL if the caller
     * is not interested in the new version resource.
     *
     * If the client has specified DAV:keep-checked-out in the checkin
     * request, then the keep_checked_out flag is set. The provider
     * should create a new version, but keep the resource in the
     * checked-out state.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>checkin</name>)<parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
                           <param><decl><type><name>int</name></type> <name>keep_checked_out</name></decl></param>,
                           <param><decl><type><name>dav_resource</name> **</type><name>version_resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Return the set of reports available at this resource.
    **
    ** An array of report elements should be returned, with an end-marker
    ** element containing namespace==NULL. The value of the
    ** DAV:supported-report-set property will be constructed and
    ** returned.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>avail_reports</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>dav_report_elem</name> **</type><name>reports</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Determine whether a Label header can be used
    ** with a particular report. The dav_xml_doc structure
    ** contains the parsed report request body.
    ** Returns 0 if the Label header is not allowed.
    */</comment>
    <function_decl><type><name>int</name></type> (*<name>report_label_header_allowed</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Generate a report on a resource. Since a provider is free
    ** to define its own reports, and the value of request headers
    ** may affect the interpretation of a report, the request record
    ** must be passed to this routine.
    **
    ** The dav_xml_doc structure contains the parsed report request
    ** body. The report response should be generated into the specified
    ** output filter.
    **
    ** If an error occurs, and a response has not yet been generated,
    ** then an error can be returned from this function. mod_dav will
    ** construct an appropriate error response. Once some output has
    ** been placed into the filter, however, the provider should not
    ** return an error -- there is no way that mod_dav can deliver it
    ** properly.
    **
    ** ### maybe we need a way to signal an error anyways, and then
    ** ### apache can abort the connection?
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>deliver_report</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                                  <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** OPTIONAL HOOKS
    ** The following hooks are optional; if not defined, then the
    ** corresponding protocol methods will be unsupported.
    */</comment>

    <comment type="block">/*
    ** Set the state of a checked-in version-controlled resource.
    **
    ** If the request specified a version, the version resource
    ** represents that version. If the request specified a label,
    ** then "version" is NULL, and "label" is the label.
    **
    ** The depth argument is ignored for a file, and can be 0, 1, or
    ** DAV_INFINITY for a collection. The depth argument only applies
    ** with a label, not a version.
    **
    ** If an error occurs in a child resource, then the return value is
    ** non-NULL, and *response is set to a multistatus response.
    **
    ** This hook is optional; if not defined, then the UPDATE method
    ** will not be supported.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>update</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>version</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                          <param><decl><type><name>int</name></type> <name>depth</name></decl></param>,
                          <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Add a label to a version. The resource is either a specific
    ** version, or a version selector, in which case the label should
    ** be added to the current target of the version selector. The
    ** version selector cannot be checked out.
    **
    ** If replace != 0, any existing label by the same name is
    ** effectively deleted first. Otherwise, it is an error to
    ** attempt to add a label which already exists on some version
    ** of the same history resource.
    **
    ** This hook is optional; if not defined, then the LABEL method
    ** will not be supported. If it is defined, then the remove_label
    ** hook must be defined also.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>add_label</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                             <param><decl><type><name>int</name></type> <name>replace</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Remove a label from a version. The resource is either a specific
    ** version, or a version selector, in which case the label should
    ** be added to the current target of the version selector. The
    ** version selector cannot be checked out.
    **
    ** It is an error if no such label exists on the specified version.
    **
    ** This hook is optional, but if defined, the add_label hook
    ** must be defined also.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>remove_label</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Determine whether a null resource can be created as a workspace.
    ** The provider may restrict workspaces to certain locations.
    ** Returns 0 if the resource cannot be a workspace.
    **
    ** This hook is optional; if the provider does not support workspaces,
    ** it should be set to NULL.
    */</comment>
    <function_decl><type><name>int</name></type> (*<name>can_be_workspace</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Create a workspace resource. The resource must not already
    ** exist. Any &lt;DAV:mkworkspace&gt; element is passed to the provider
    ** in the "doc" structure; it may be empty.
    **
    ** If workspace creation is successful, the state of the resource
    ** object is updated appropriately.
    **
    ** This hook is optional; if the provider does not support workspaces,
    ** it should be set to NULL.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>make_workspace</name>)<parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                  <param><decl><type><name>apr_xml_doc</name> *</type><name>doc</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Determine whether a null resource can be created as an activity.
    ** The provider may restrict activities to certain locations.
    ** Returns 0 if the resource cannot be an activity.
    **
    ** This hook is optional; if the provider does not support activities,
    ** it should be set to NULL.
    */</comment>
    <function_decl><type><name>int</name></type> (*<name>can_be_activity</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Create an activity resource. The resource must not already
    ** exist.
    **
    ** If activity creation is successful, the state of the resource
    ** object is updated appropriately.
    **
    ** This hook is optional; if the provider does not support activities,
    ** it should be set to NULL.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>make_activity</name>)<parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** Merge a resource (tree) into target resource (tree).
    **
    ** ### more doc...
    **
    ** This hook is optional; if the provider does not support merging,
    ** then this should be set to NULL.
    */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>merge</name>)<parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>target</name></decl></param>, <param><decl><type><name>dav_resource</name> *</type><name>source</name></decl></param>,
                         <param><decl><type><name>int</name></type> <name>no_auto_merge</name></decl></param>, <param><decl><type><name>int</name></type> <name>no_checkout</name></decl></param>,
                         <param><decl><type><name>apr_xml_elem</name> *</type><name>prop_elem</name></decl></param>,
                         <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** If a provider needs a context to associate with this hooks structure,
    ** then this field may be used. In most cases, it will just be NULL.
    */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* --------------------------------------------------------------------
**
** BINDING FUNCTIONS
*/</comment>

<comment type="block">/* binding provider hooks */</comment>
<struct>struct <name>dav_hooks_binding</name> <block>{

    <comment type="block">/* Determine whether a resource can be the target of a binding.
     * Returns 0 if the resource cannot be a binding target.
     */</comment>
    <function_decl><type><name>int</name></type> (*<name>is_bindable</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Create a binding to a resource.
     * The resource argument is the target of the binding;
     * the binding argument must be a resource which does not already
     * exist.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>bind_resource</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                 <param><decl><type><name>dav_resource</name> *</type><name>binding</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** If a provider needs a context to associate with this hooks structure,
    ** then this field may be used. In most cases, it will just be NULL.
    */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>

}</block>;</struct>


<comment type="block">/* --------------------------------------------------------------------
**
** SEARCH(DASL) FUNCTIONS
*/</comment>

<comment type="block">/* search provider hooks */</comment>
<struct>struct <name>dav_hooks_search</name> <block>{
    <comment type="block">/* Set header for a OPTION method
     * An error may be returned.
     * To set a hadder, this function might call
     * apr_table_setn(r-&gt;headers_out, "DASL", dasl_optin1);
     *
     * Examples:
     * DASL: &lt;DAV:basicsearch&gt;
     * DASL: &lt;http://foo.bar.com/syntax1&gt;
     * DASL: &lt;http://akuma.com/syntax2&gt;
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>set_option_head</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/* Search resources
     * An error may be returned. *response will contain multistatus
     * responses (if any) suitable for the body of the error. It is also
     * possible to return NULL, yet still have multistatus responses.
     * In this case, typically the caller should return a 207 (Multistatus)
     * and the responses (in the body) as the HTTP response.
     */</comment>
    <function_decl><type><name>dav_error</name> *</type> (*<name>search_resource</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                   <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/*
    ** If a provider needs a context to associate with this hooks structure,
    ** then this field may be used. In most cases, it will just be NULL.
    */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>

}</block>;</struct>


<comment type="block">/* --------------------------------------------------------------------
**
** MISCELLANEOUS STUFF
*/</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>propid</name></decl>;</decl_stmt>                          <comment type="block">/* live property ID */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_liveprop</name> *</type><name>provider</name></decl>;</decl_stmt>  <comment type="block">/* the provider defining this prop */</comment>
}</block></struct></type> <name>dav_elem_private</name>;</typedef>

<comment type="block">/* --------------------------------------------------------------------
**
** DAV OPTIONS
*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_OPTIONS_EXTENSION_GROUP</name></cpp:macro> <cpp:value>"dav_options"</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>dav_options_provider</name>
<block>{
    <function_decl><type><name>dav_error</name>*</type> (*<name>dav_header</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                             <param><decl><type><name>apr_text_header</name> *</type><name>phdr</name></decl></param>)</parameter_list>;</function_decl>

    <function_decl><type><name>dav_error</name>*</type> (*<name>dav_method</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                             <param><decl><type><name>apr_text_header</name> *</type><name>phdr</name></decl></param>)</parameter_list>;</function_decl>

    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>dav_options_provider</name>;</typedef>

<extern>extern DAV_DECLARE(const dav_options_provider *</extern>)</block> <expr_stmt><expr><call><name>dav_get_options_providers</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></extern>

<extern>extern DAV_DECLARE(void</extern>) <expr_stmt><expr><call><name>dav_options_provider_register</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                               <argument><expr>const <name>char</name> *<name>name</name></expr></argument>,
                               <argument><expr>const <name>dav_options_provider</name> *<name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* --------------------------------------------------------------------
**
** DAV RESOURCE TYPE HOOKS
*/</comment>

<typedef>typedef <type><struct>struct <name>dav_resource_type_provider</name>
<block>{
    <function_decl><type><name>int</name></type> (*<name>get_resource_type</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>name</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>uri</name></decl></param>)</parameter_list>;</function_decl>
}</block></struct></type> <name>dav_resource_type_provider</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_RESOURCE_TYPE_GROUP</name></cpp:macro> <cpp:value>"dav_resource_type"</cpp:value></cpp:define>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_resource_type_provider_register</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                        <argument><expr>const <name>char</name> *<name>name</name></expr></argument>,
                                    <argument><expr>const <name>dav_resource_type_provider</name> *<name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>const dav_resource_type_provider *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>dav_get_resource_type_providers</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* _MOD_DAV_H_ */</comment>
<comment type="block">/** @} */</comment>

</unit>
