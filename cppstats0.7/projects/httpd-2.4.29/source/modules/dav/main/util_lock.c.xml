<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/dav/main/util_lock.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
** DAV repository-independent lock functions
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_dav.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>APLOG_USE_MODULE</name><argument_list>(<argument><expr><name>dav</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ---------------------------------------------------------------
**
** Property-related lock functions
**
*/</comment>

<comment type="block">/*
** dav_lock_get_activelock:  Returns a &lt;lockdiscovery&gt; containing
**    an activelock element for every item in the lock_discovery tree
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>dav_lock_get_activelock</name><argument_list>(<argument>request_rec *r</argument>,
                                                  <argument>dav_lock *lock</argument>,
                                                  <argument>dav_buffer *pbuf</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_lock</name> *</type><name>lock_scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_LOCKS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_buffer</name></type> <name>work_buf</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name> <init>= <expr><name><name>r</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If no locks or no lock provider, there are no locks */</comment>
    <if>if <condition>(<expr><name>lock</name> == <name>NULL</name> || <name>hooks</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/*
        ** Since resourcediscovery is defined with (activelock)*,
        ** &lt;D:activelock/&gt; shouldn't be necessary for an empty lock.
        */</comment>
        <return>return <expr>""</expr>;</return>
    }</block></then></if>

    <comment type="block">/*
    ** Note: it could be interesting to sum the lengths of the owners
    **       and locktokens during this loop. However, the buffer
    **       mechanism provides some rough padding so that we don't
    **       really need to have an exact size. Further, constructing
    **       locktoken strings could be relatively expensive.
    */</comment>
    <for>for (<init><expr><name>lock_scan</name> = <name>lock</name></expr>;</init> <condition><expr><name>lock_scan</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>lock_scan</name> = <name><name>lock_scan</name>-&gt;<name>next</name></name></expr></incr>)
        <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></for>

    <comment type="block">/* if a buffer was not provided, then use an internal buffer */</comment>
    <if>if <condition>(<expr><name>pbuf</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>pbuf</name> = &amp;<name>work_buf</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* reset the length before we start appending stuff */</comment>
    <expr_stmt><expr><name><name>pbuf</name>-&gt;<name>cur_len</name></name> = 0</expr>;</expr_stmt>

    <comment type="block">/* prep the buffer with a "good" size */</comment>
    <expr_stmt><expr><call><name>dav_check_bufsize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>count</name> * 300</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init>;</init> <condition><expr><name>lock</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>lock</name> = <name><name>lock</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DAV_DEBUG</name></expr></cpp:if>
        <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>rectype</name></name> == <name>DAV_LOCKREC_INDIRECT_PARTIAL</name></expr>)</condition><then> <block>{
            <comment type="block">/* ### crap. design error */</comment>
            <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>,
                              <argument><expr>"DESIGN ERROR: attempted to product an "
                              "activelock element from a partial, indirect "
                              "lock record. Creating an XML parsing error "
                              "to ease detection of this situation: &lt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"&lt;D:activelock&gt;" <name>DEBUG_CR</name> "&lt;D:locktype&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>lock</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
        <case>case <expr><name>DAV_LOCKTYPE_WRITE</name></expr>:
            <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"&lt;D:write/&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <comment type="block">/* ### internal error. log something? */</comment>
            <break>break;</break>
        </default>}</block></switch>
        <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"&lt;/D:locktype&gt;" <name>DEBUG_CR</name> "&lt;D:lockscope&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <switch>switch <condition>(<expr><name><name>lock</name>-&gt;<name>scope</name></name></expr>)</condition> <block>{
        <case>case <expr><name>DAV_LOCKSCOPE_EXCLUSIVE</name></expr>:
            <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"&lt;D:exclusive/&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>DAV_LOCKSCOPE_SHARED</name></expr>:
            <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"&lt;D:shared/&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        </case><default>default:
            <comment type="block">/* ### internal error. log something? */</comment>
            <break>break;</break>
        </default>}</block></switch>
        <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"&lt;/D:lockscope&gt;" <name>DEBUG_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"&lt;D:depth&gt;%s&lt;/D:depth&gt;" <name>DEBUG_CR</name></expr></argument>,
                     <argument><expr><name><name>lock</name>-&gt;<name>depth</name></name> == <name>DAV_INFINITY</name> ? "infinity" : "0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>owner</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
            ** This contains a complete, self-contained &lt;DAV:owner&gt; element,
            ** with namespace declarations and xml:lang handling. Just drop
            ** it in.
            */</comment>
            <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"&lt;D:timeout&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>timeout</name></name> == <name>DAV_TIMEOUT_INFINITE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"Infinite"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>time_t</name></type> <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <comment type="block">/*
            ** Check if the timeout is not, for any reason, already elapsed.
            ** (e.g., because of a large collection, or disk under heavy load...)
             */</comment>
            <if>if <condition>(<expr><name>now</name> &gt;= <name><name>lock</name>-&gt;<name>timeout</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr>"Second-0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"Second-%lu"</expr></argument>, <argument><expr><call>(<name>long</name> <name>unsigned</name> <name>int</name>)<argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>timeout</name></name> - <name>now</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if>

        <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>,
                          <argument><expr>"&lt;/D:timeout&gt;" <name>DEBUG_CR</name>
                          "&lt;D:locktoken&gt;" <name>DEBUG_CR</name>
                          "&lt;D:href&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>,
                          <argument><expr><call>(*<name><name>hooks</name>-&gt;<name>format_locktoken</name></name>)<argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>locktoken</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dav_buffer_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>,
                          <argument><expr>"&lt;/D:href&gt;" <name>DEBUG_CR</name>
                          "&lt;/D:locktoken&gt;" <name>DEBUG_CR</name>
                          "&lt;/D:activelock&gt;" <name>DEBUG_CR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name><name>pbuf</name>-&gt;<name>buf</name></name></expr>;</return>
}</block>

<comment type="block">/*
** dav_lock_parse_lockinfo:  Validates the given xml_doc to contain a
**    lockinfo XML element, then populates a dav_lock structure
**    with its contents.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_lock_parse_lockinfo</name><argument_list>(<argument>request_rec *r</argument>,
                                                 <argument>const dav_resource *resource</argument>,
                                                 <argument>dav_lockdb *lockdb</argument>,
                                                 <argument>const apr_xml_doc *doc</argument>,
                                                 <argument>dav_lock **lock_request</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name> <init>= <expr><name><name>r</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_xml_elem</name> *</type><name>child</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lock</name> *</type><name>lock</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>dav_validate_root</name><argument_list>(<argument><expr><name>doc</name></expr></argument>, <argument><expr>"lockinfo"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"The request body contains an unexpected "
                             "XML root element."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>create_lock</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>,
                                             <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>dav_push_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                              <argument><expr>"Could not parse the lockinfo due to an "
                              "internal problem creating a lock structure."</expr></argument>,
                              <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>lock</name>-&gt;<name>depth</name></name> = <call><name>dav_get_depth</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>DAV_INFINITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>depth</name></name> == -1</expr>)</condition><then> <block>{
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"An invalid Depth header was specified."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>timeout</name></name> = <call><name>dav_get_timeout</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Parse elements in the XML body */</comment>
    <for>for (<init><expr><name>child</name> = <name><name>doc</name>-&gt;<name>root</name>-&gt;<name>first_child</name></name></expr>;</init> <condition><expr><name>child</name></expr>;</condition> <incr><expr><name>child</name> = <name><name>child</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"locktype"</expr></argument>)</argument_list></call> == 0
            &amp;&amp; <name><name>child</name>-&gt;<name>first_child</name></name>
            &amp;&amp; <name><name>lock</name>-&gt;<name>type</name></name> == <name>DAV_LOCKTYPE_UNKNOWN</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>first_child</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"write"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>lock</name>-&gt;<name>type</name></name> = <name>DAV_LOCKTYPE_WRITE</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"lockscope"</expr></argument>)</argument_list></call> == 0
            &amp;&amp; <name><name>child</name>-&gt;<name>first_child</name></name>
            &amp;&amp; <name><name>lock</name>-&gt;<name>scope</name></name> == <name>DAV_LOCKSCOPE_UNKNOWN</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>first_child</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"exclusive"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <expr_stmt><expr><name><name>lock</name>-&gt;<name>scope</name></name> = <name>DAV_LOCKSCOPE_EXCLUSIVE</name></expr>;</expr_stmt></then>
            <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>first_child</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"shared"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <expr_stmt><expr><name><name>lock</name>-&gt;<name>scope</name></name> = <name>DAV_LOCKSCOPE_SHARED</name></expr>;</expr_stmt></then></if></else></if>
            <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>scope</name></name> != <name>DAV_LOCKSCOPE_UNKNOWN</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>
        }</block></then></if>

        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"owner"</expr></argument>)</argument_list></call> == 0 &amp;&amp; <name><name>lock</name>-&gt;<name>owner</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text</name></decl>;</decl_stmt>

            <comment type="block">/* quote all the values in the &lt;DAV:owner&gt; element */</comment>
            <expr_stmt><expr><call><name>apr_xml_quote_elem</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
            ** Store a full &lt;DAV:owner&gt; element with namespace definitions
            ** and an xml:lang definition, if applicable.
            */</comment>
            <expr_stmt><expr><call><name>apr_xml_to_text</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>APR_XML_X2T_FULL_NS_LANG</name></expr></argument>, <argument><expr><name><name>doc</name>-&gt;<name>namespaces</name></name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>text</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>lock</name>-&gt;<name>owner</name></name> = <name>text</name></expr>;</expr_stmt>

            <continue>continue;</continue>
        }</block></then></if>

        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_PRECONDITION_FAILED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                         <argument><expr>"The server cannot satisfy the "
                                         "LOCK request due to an unknown XML "
                                         "element (\"%s\") within the "
                                         "DAV:lockinfo element."</expr></argument>,
                                         <argument><expr><name><name>child</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></for>

    <expr_stmt><expr>*<name>lock_request</name> = <name>lock</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block>

<comment type="block">/* ---------------------------------------------------------------
**
** General lock functions
**
*/</comment>

<comment type="block">/* dav_lock_walker:  Walker callback function to record indirect locks */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_lock_walker</name><parameter_list>(<param><decl><type><name>dav_walk_resource</name> *</type><name>wres</name></decl></param>, <param><decl><type><name>int</name></type> <name>calltype</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_walker_ctx</name> *</type><name>ctx</name> <init>= <expr><name><name>wres</name>-&gt;<name>walk_ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <comment type="block">/* We don't want to set indirects on the target */</comment>
    <if>if <condition>(<expr><call>(*<name><name>wres</name>-&gt;<name>resource</name>-&gt;<name>hooks</name>-&gt;<name>is_same_resource</name></name>)<argument_list>(<argument><expr><name><name>wres</name>-&gt;<name>resource</name></name></expr></argument>,
                                                   <argument><expr><name><name>ctx</name>-&gt;<name>w</name>.<name>root</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>ctx</name>-&gt;<name>w</name>.<name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>append_locks</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>w</name>.<name>lockdb</name></name></expr></argument>,
                                                     <argument><expr><name><name>wres</name>-&gt;<name>resource</name></name></expr></argument>, <argument><expr>1</expr></argument>,
                                                     <argument><expr><name><name>ctx</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>ap_is_HTTP_SERVER_ERROR</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* ### add a higher-level description? */</comment>
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* add to the multistatus response */</comment>
        <expr_stmt><expr><call><name>dav_add_response</name><argument_list>(<argument><expr><name>wres</name></expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
        ** ### actually, this is probably wrong: we want to fail the whole
        ** ### LOCK process if something goes bad. maybe the caller should
        ** ### do a dav_unlock() (e.g. a rollback) if any errors occurred.
        */</comment>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
** dav_add_lock:  Add a direct lock for resource, and indirect locks for
**    all children, bounded by depth.
**    ### assume request only contains one lock
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_add_lock</name><argument_list>(<argument>request_rec *r</argument>,
                                      <argument>const dav_resource *resource</argument>,
                                      <argument>dav_lockdb *lockdb</argument>, <argument>dav_lock *lock</argument>,
                                      <argument>dav_response **response</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><name><name>lock</name>-&gt;<name>depth</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>response</name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Requested lock can be:
     *   Depth: 0   for null resource, existing resource, or existing collection
     *   Depth: Inf for existing collection
     */</comment>

    <comment type="block">/*
    ** 2518 9.2 says to ignore depth if target is not a collection (it has
    **   no internal children); pretend the client gave the correct depth.
    */</comment>
    <if>if <condition>(<expr>!<name><name>resource</name>-&gt;<name>collection</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>depth</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* In all cases, first add direct entry in lockdb */</comment>

    <comment type="block">/*
    ** Append the new (direct) lock to the resource's existing locks.
    **
    ** Note: this also handles locknull resources
    */</comment>
    <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>append_locks</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr>0</expr></argument>,
                                              <argument><expr><name>lock</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### maybe add a higher-level description */</comment>
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>depth</name> &gt; 0</expr>)</condition><then> <block>{
        <comment type="block">/* Walk existing collection and set indirect locks */</comment>
        <decl_stmt><decl><type><name>dav_walker_ctx</name></type> <name>ctx</name> <init>= <expr><block>{ <expr><block>{ <expr>0</expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dav_response</name> *</type><name>multi_status</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_type</name></name> = <name>DAV_WALKTYPE_NORMAL</name> | <name>DAV_WALKTYPE_AUTH</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>func</name></name> = <name>dav_lock_walker</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_ctx</name></name> = &amp;<name>ctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>root</name></name> = <name>resource</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>lockdb</name></name> = <name>lockdb</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>ctx</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>.<name>lock</name></name> = <name>lock</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>err</name> = <call>(*<name><name>resource</name>-&gt;<name>hooks</name>-&gt;<name>walk</name></name>)<argument_list>(<argument><expr>&amp;<name><name>ctx</name>.<name>w</name></name></expr></argument>, <argument><expr><name>DAV_INFINITY</name></expr></argument>, <argument><expr>&amp;<name>multi_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* implies a 5xx status code occurred. screw the multistatus */</comment>
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>multi_status</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* manufacture a 207 error for the multistatus response */</comment>
            <expr_stmt><expr>*<name>response</name> = <name>multi_status</name></expr>;</expr_stmt>
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_MULTI_STATUS</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"Error(s) occurred on resources during the "
                                 "addition of a depth lock."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block>

<comment type="block">/*
** dav_lock_query:  Opens the lock database. Returns a linked list of
**    dav_lock structures for all direct locks on path.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error*</argument>)</argument_list></macro> <macro><name>dav_lock_query</name><argument_list>(<argument>dav_lockdb *lockdb</argument>,
                                       <argument>const dav_resource *resource</argument>,
                                       <argument>dav_lock **locks</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* If no lock database, return empty result */</comment>
    <if>if <condition>(<expr><name>lockdb</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>locks</name> = <name>NULL</name></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* ### insert a higher-level description? */</comment>
    <return>return <expr><call>(*<name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>get_locks</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>,
                                       <argument><expr><name>DAV_GETLOCKS_RESOLVED</name></expr></argument>,
                                       <argument><expr><name>locks</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/* dav_unlock_walker:  Walker callback function to remove indirect locks */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_unlock_walker</name><parameter_list>(<param><decl><type><name>dav_walk_resource</name> *</type><name>wres</name></decl></param>, <param><decl><type><name>int</name></type> <name>calltype</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_walker_ctx</name> *</type><name>ctx</name> <init>= <expr><name><name>wres</name>-&gt;<name>walk_ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <comment type="block">/* Before removing the lock, do any auto-checkin required */</comment>
    <if>if <condition>(<expr><name><name>wres</name>-&gt;<name>resource</name>-&gt;<name>working</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* ### get rid of this typecast */</comment>
        <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_auto_checkin</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr>(<name>dav_resource</name> *) <name><name>wres</name>-&gt;<name>resource</name></name></expr></argument>,
                                    <argument><expr>0</expr></argument> <comment type="block">/*undo*/</comment>, <argument><expr>1</expr></argument> <comment type="block">/*unlock*/</comment>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)
            != <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>ctx</name>-&gt;<name>w</name>.<name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>remove_lock</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>w</name>.<name>lockdb</name></name></expr></argument>,
                                                    <argument><expr><name><name>wres</name>-&gt;<name>resource</name></name></expr></argument>,
                                                    <argument><expr><name><name>ctx</name>-&gt;<name>locktoken</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### should we stop or return a multistatus? looks like STOP */</comment>
        <comment type="block">/* ### add a higher-level description? */</comment>
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
** dav_get_direct_resource:
**
** Find a lock on the specified resource, then return the resource the
** lock was applied to (in other words, given a (possibly) indirect lock,
** return the direct lock's corresponding resource).
**
** If the lock is an indirect lock, this usually means traversing up the
** namespace [repository] hierarchy. Note that some lock providers may be
** able to return this information with a traversal.
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_get_direct_resource</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                           <param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>dav_resource</name> **</type><name>direct_resource</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>lookup_resource</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><call>(*<name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>lookup_resource</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>locktoken</name></expr></argument>,
                                                 <argument><expr><name>resource</name></expr></argument>, <argument><expr><name>direct_resource</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>direct_resource</name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* Find the top of this lock-
     * If r-&gt;filename's direct   locks include locktoken, use r-&gt;filename.
     * If r-&gt;filename's indirect locks include locktoken, retry r-&gt;filename/..
     * Else fail.
     */</comment>
    <while>while <condition>(<expr><name>resource</name> != <name>NULL</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dav_lock</name> *</type><name>lock</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dav_resource</name> *</type><name>parent</name></decl>;</decl_stmt>

        <comment type="block">/*
        ** Find the lock specified by &lt;locktoken&gt; on &lt;resource&gt;. If it is
        ** an indirect lock, then partial results are okay. We're just
        ** trying to find the thing and know whether it is a direct or
        ** an indirect lock.
        */</comment>
        <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>find_lock</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr><name>locktoken</name></expr></argument>,
                                               <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>lock</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* ### add a higher-level desc? */</comment>
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* not found! that's an error. */</comment>
        <if>if <condition>(<expr><name>lock</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"The specified locktoken does not correspond "
                                 "to an existing lock on this resource."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>rectype</name></name> == <name>DAV_LOCKREC_DIRECT</name></expr>)</condition><then> <block>{
            <comment type="block">/* we found the direct lock. return this resource. */</comment>

            <expr_stmt><expr>*<name>direct_resource</name> = <name>resource</name></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* the lock was indirect. move up a level in the URL namespace */</comment>
        <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>resource</name>-&gt;<name>hooks</name>-&gt;<name>get_parent_resource</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>,
                                                           <argument><expr>&amp;<name>parent</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* ### add a higher-level desc? */</comment>
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>resource</name> = <name>parent</name></expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr>"The lock database is corrupt. A direct lock could "
                         "not be found for the corresponding indirect lock "
                         "on this resource."</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** dav_unlock:  Removes all direct and indirect locks for r-&gt;filename,
**    with given locktoken.  If locktoken == null_locktoken, all locks
**    are removed.  If r-&gt;filename represents an indirect lock,
**    we must unlock the appropriate direct lock.
**    Returns OK or appropriate HTTP_* response and logs any errors.
**
** ### We've already crawled the tree to ensure everything was locked
**     by us; there should be no need to incorporate a rollback.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>dav_unlock</name><argument_list>(<argument>request_rec *r</argument>, <argument>const dav_resource *resource</argument>,
                            <argument>const dav_locktoken *locktoken</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>lock_resource</name> <init>= <expr><name>resource</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_LOCKS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_repository</name> *</type><name>repos_hooks</name> <init>= <expr><name><name>resource</name>-&gt;<name>hooks</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_walker_ctx</name></type> <name>ctx</name> <init>= <expr><block>{ <expr><block>{ <expr>0</expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_response</name> *</type><name>multi_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <comment type="block">/* If no locks provider, then there is nothing to unlock. */</comment>
    <if>if <condition>(<expr><name>hooks</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* 2518 requires the entire lock to be removed if resource/locktoken
     * point to an indirect lock.  We need resource of the _direct_
     * lock in order to walk down the tree and remove the locks.  So,
     * If locktoken != null_locktoken,
     *    Walk up the resource hierarchy until we see a direct lock.
     *    Or, we could get the direct lock's db/key, pick out the URL
     *    and do a subrequest.  I think walking up is faster and will work
     *    all the time.
     * Else
     *    Just start removing all locks at and below resource.
     */</comment>

    <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>hooks</name>-&gt;<name>open_lockdb</name></name>)<argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>lockdb</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### return err! maybe add a higher-level desc */</comment>
        <comment type="block">/* ### map result to something nice; log an error */</comment>
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>locktoken</name> != <name>NULL</name>
        &amp;&amp; (<name>err</name> = <call><name>dav_get_direct_resource</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>lockdb</name></expr></argument>,
                                          <argument><expr><name>locktoken</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>,
                                          <argument><expr>&amp;<name>lock_resource</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### add a higher-level desc? */</comment>
        <comment type="block">/* ### should return err! */</comment>
        <return>return <expr><name><name>err</name>-&gt;<name>status</name></name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* At this point, lock_resource/locktoken refers to a direct lock (key), ie
     * the root of a depth &gt; 0 lock, or locktoken is null.
     */</comment>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_type</name></name> = <name>DAV_WALKTYPE_NORMAL</name> | <name>DAV_WALKTYPE_LOCKNULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>func</name></name> = <name>dav_unlock_walker</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_ctx</name></name> = &amp;<name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>root</name></name> = <name>lock_resource</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>lockdb</name></name> = <name>lockdb</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ctx</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>locktoken</name></name> = <name>locktoken</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>err</name> = <call>(*<name><name>repos_hooks</name>-&gt;<name>walk</name></name>)<argument_list>(<argument><expr>&amp;<name><name>ctx</name>.<name>w</name></name></expr></argument>, <argument><expr><name>DAV_INFINITY</name></expr></argument>, <argument><expr>&amp;<name>multi_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ### fix this! */</comment>
    <comment type="block">/* ### do something with multi_status */</comment>
    <expr_stmt><expr><name>result</name> = <name>err</name> == <name>NULL</name> ? <name>OK</name> : <name><name>err</name>-&gt;<name>status</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call>(*<name><name>hooks</name>-&gt;<name>close_lockdb</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block>

<comment type="block">/* dav_inherit_walker:  Walker callback function to inherit locks */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_inherit_walker</name><parameter_list>(<param><decl><type><name>dav_walk_resource</name> *</type><name>wres</name></decl></param>, <param><decl><type><name>int</name></type> <name>calltype</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_walker_ctx</name> *</type><name>ctx</name> <init>= <expr><name><name>wres</name>-&gt;<name>walk_ctx</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>skip_root</name></name>
        &amp;&amp; <call>(*<name><name>wres</name>-&gt;<name>resource</name>-&gt;<name>hooks</name>-&gt;<name>is_same_resource</name></name>)<argument_list>(<argument><expr><name><name>wres</name>-&gt;<name>resource</name></name></expr></argument>,
                                                      <argument><expr><name><name>ctx</name>-&gt;<name>w</name>.<name>root</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* ### maybe add a higher-level desc */</comment>
    <return>return <expr><call>(*<name><name>ctx</name>-&gt;<name>w</name>.<name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>append_locks</name></name>)<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>w</name>.<name>lockdb</name></name></expr></argument>,
                                                 <argument><expr><name><name>wres</name>-&gt;<name>resource</name></name></expr></argument>, <argument><expr>1</expr></argument>,
                                                 <argument><expr><name><name>ctx</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
** dav_inherit_locks:  When a resource or collection is added to a collection,
**    locks on the collection should be inherited to the resource/collection.
**    (MOVE, MKCOL, etc) Here we propagate any direct or indirect locks from
**    parent of resource to resource and below.
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_inherit_locks</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                     <param><decl><type><name>int</name></type> <name>use_parent</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>which_resource</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lock</name> *</type><name>locks</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lock</name> *</type><name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_lock</name> *</type><name>prev</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_walker_ctx</name></type> <name>ctx</name> <init>= <expr><block>{ <expr><block>{ <expr>0</expr> }</block></expr> }</block></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_repository</name> *</type><name>repos_hooks</name> <init>= <expr><name><name>resource</name>-&gt;<name>hooks</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_response</name> *</type><name>multi_status</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>use_parent</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_resource</name> *</type><name>parent</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>repos_hooks</name>-&gt;<name>get_parent_resource</name></name>)<argument_list>(<argument><expr><name>resource</name></expr></argument>,
                                                       <argument><expr>&amp;<name>parent</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* ### add a higher-level desc? */</comment>
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name>parent</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* ### map result to something nice; log an error */</comment>
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"Could not fetch parent resource. Unable to "
                                 "inherit locks from the parent and apply "
                                 "them to this resource."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>which_resource</name> = <name>parent</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>which_resource</name> = <name>resource</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>get_locks</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>which_resource</name></expr></argument>,
                                           <argument><expr><name>DAV_GETLOCKS_PARTIAL</name></expr></argument>,
                                           <argument><expr>&amp;<name>locks</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### maybe add a higher-level desc */</comment>
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>locks</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* No locks to propagate, just return */</comment>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
    ** (1) Copy all indirect locks from our parent;
    ** (2) Create indirect locks for the depth infinity, direct locks
    **     in our parent.
    **
    ** The append_locks call in the walker callback will do the indirect
    ** conversion, but we need to remove any direct locks that are NOT
    ** depth "infinity".
    */</comment>
    <for>for (<init><expr><name>scan</name> = <name>locks</name></expr>, <expr><name>prev</name> = <name>NULL</name></expr>;</init>
         <condition><expr><name>scan</name> != <name>NULL</name></expr>;</condition>
         <incr><expr><name>prev</name> = <name>scan</name></expr>, <expr><name>scan</name> = <name><name>scan</name>-&gt;<name>next</name></name></expr></incr>) <block>{

        <if>if <condition>(<expr><name><name>scan</name>-&gt;<name>rectype</name></name> == <name>DAV_LOCKREC_DIRECT</name>
            &amp;&amp; <name><name>scan</name>-&gt;<name>depth</name></name> != <name>DAV_INFINITY</name></expr>)</condition><then> <block>{

            <if>if <condition>(<expr><name>prev</name> == <name>NULL</name></expr>)</condition><then>
                <expr_stmt><expr><name>locks</name> = <name><name>scan</name>-&gt;<name>next</name></name></expr>;</expr_stmt></then>
            <else>else
                <expr_stmt><expr><name><name>prev</name>-&gt;<name>next</name></name> = <name><name>scan</name>-&gt;<name>next</name></name></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* &lt;locks&gt; has all our new locks.  Walk down and propagate them. */</comment>

    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_type</name></name> = <name>DAV_WALKTYPE_NORMAL</name> | <name>DAV_WALKTYPE_LOCKNULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>func</name></name> = <name>dav_inherit_walker</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>walk_ctx</name></name> = &amp;<name>ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>root</name></name> = <name>resource</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>w</name>.<name>lockdb</name></name> = <name>lockdb</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>ctx</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>lock</name></name> = <name>locks</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>skip_root</name></name> = !<name>use_parent</name></expr>;</expr_stmt>

    <comment type="block">/* ### do something with multi_status */</comment>
    <return>return <expr><call>(*<name><name>repos_hooks</name>-&gt;<name>walk</name></name>)<argument_list>(<argument><expr>&amp;<name><name>ctx</name>.<name>w</name></name></expr></argument>, <argument><expr><name>DAV_INFINITY</name></expr></argument>, <argument><expr>&amp;<name>multi_status</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------
**
** Functions dealing with lock-null resources
**
*/</comment>

<comment type="block">/*
** dav_get_resource_state:  Returns the state of the resource
**    r-&gt;filename:  DAV_RESOURCE_NULL, DAV_RESOURCE_LOCK_NULL,
**    or DAV_RESOURCE_EXIST.
**
**    Returns DAV_RESOURCE_ERROR if an error occurs.
*/</comment>
<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>dav_get_resource_state</name><argument_list>(<argument>request_rec *r</argument>,
                                        <argument>const dav_resource *resource</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name> *</type><name>hooks</name> <init>= <expr><call><name>DAV_GET_HOOKS_LOCKS</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>exists</name></name></expr>)</condition><then>
        <return>return <expr><name>DAV_RESOURCE_EXISTS</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name>hooks</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>locks_present</name></decl>;</decl_stmt>

        <comment type="block">/*
        ** A locknull resource has the form:
        **
        **   known-dir "/" locknull-file
        **
        ** It would be nice to look into &lt;resource&gt; to verify this form,
        ** but it does not have enough information for us. Instead, we
        ** can look at the path_info. If the form does not match, then
        ** there is no way we could have a locknull resource -- it must
        ** be a plain, null resource.
        **
        ** Apache sets r-&gt;filename to known-dir/unknown-file and r-&gt;path_info
        ** to "" for the "proper" case. If anything is in path_info, then
        ** it can't be a locknull resource.
        **
        ** ### I bet this path_info hack doesn't work for repositories.
        ** ### Need input from repository implementors! What kind of
        ** ### restructure do we need? New provider APIs?
        */</comment>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>path_info</name></name> != <name>NULL</name> &amp;&amp; *<name><name>r</name>-&gt;<name>path_info</name></name> != '\0'</expr>)</condition><then> <block>{
            <return>return <expr><name>DAV_RESOURCE_NULL</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>(<name>err</name> = <call>(*<name><name>hooks</name>-&gt;<name>open_lockdb</name></name>)<argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>lockdb</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* note that we might see some expired locks... *shrug* */</comment>
            <expr_stmt><expr><name>err</name> = <call>(*<name><name>hooks</name>-&gt;<name>has_locks</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr>&amp;<name>locks_present</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call>(*<name><name>hooks</name>-&gt;<name>close_lockdb</name></name>)<argument_list>(<argument><expr><name>lockdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* ### don't log an error. return err. add higher-level desc. */</comment>

            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00623</expr></argument>)</argument_list></call>
                          "Failed to query lock-null status for %s"</expr></argument>,
                          <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>DAV_RESOURCE_ERROR</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>locks_present</name></expr>)</condition><then>
            <return>return <expr><name>DAV_RESOURCE_LOCK_NULL</name></expr>;</return></then></if>
    }</block></then></if>

    <return>return <expr><name>DAV_RESOURCE_NULL</name></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro> <macro><name>dav_notify_created</name><argument_list>(<argument>request_rec *r</argument>,
                                            <argument>dav_lockdb *lockdb</argument>,
                                            <argument>const dav_resource *resource</argument>,
                                            <argument>int resource_state</argument>,
                                            <argument>int depth</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>resource_state</name> == <name>DAV_RESOURCE_LOCK_NULL</name></expr>)</condition><then> <block>{

        <comment type="block">/*
        ** The resource is no longer a locknull resource. This will remove
        ** the special marker.
        **
        ** Note that a locknull resource has already inherited all of the
        ** locks from the parent. We do not need to call dav_inherit_locks.
        **
        ** NOTE: some lock providers record locks for locknull resources using
        **       a different key than for regular resources. this will shift
        **       the lock information between the two key types.
        */</comment>
        <expr_stmt><expr><call><call>(<name>void</name>)<argument_list>(<argument><expr>*<name><name>lockdb</name>-&gt;<name>hooks</name>-&gt;<name>remove_locknull_state</name></name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
        ** There are resources under this one, which are new. We must
        ** propagate the locks down to the new resources.
        */</comment>
        <if>if <condition>(<expr><name>depth</name> &gt; 0 &amp;&amp;
            (<name>err</name> = <call><name>dav_inherit_locks</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* ### add a higher level desc? */</comment>
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>resource_state</name> == <name>DAV_RESOURCE_NULL</name></expr>)</condition><then> <block>{

        <comment type="block">/* ### should pass depth to dav_inherit_locks so that it can
        ** ### optimize for the depth==0 case.
        */</comment>

        <comment type="block">/* this resource should inherit locks from its parent */</comment>
        <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_inherit_locks</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>lockdb</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{

            <expr_stmt><expr><name>err</name> = <call><name>dav_push_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"The resource was created successfully, but "
                                 "there was a problem inheriting locks from "
                                 "the parent resource."</expr></argument>,
                                 <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>
    }</block></then></if></else></if>
    <comment type="block">/* else the resource already exists and its locks are correct. */</comment>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block>
</unit>
