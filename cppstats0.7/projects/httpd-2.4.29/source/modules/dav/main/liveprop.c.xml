<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/dav/main/liveprop.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_errno.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_xml.h"</cpp:file></cpp:include>   <comment type="block">/* for apr_text_header */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_dav.h"</cpp:file></cpp:include>


<decl_stmt><decl><type><specifier>static</specifier> <name>apr_hash_t</name> *</type><name>dav_liveprop_uris</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>dav_liveprop_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>


<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>dav_cleanup_liveprops</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>dav_liveprop_uris</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>dav_liveprop_count</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dav_register_liveprop_namespace</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>long</name></type> <name>value</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>dav_liveprop_uris</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>dav_liveprop_uris</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dav_cleanup_liveprops</name></expr></argument>, <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>value</name> = (<name>long</name>)<call><name>apr_hash_get</name><argument_list>(<argument><expr><name>dav_liveprop_uris</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>value</name> != 0</expr>)</condition><then> <block>{
        <comment type="block">/* already registered */</comment>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* start at 1, and count up */</comment>
    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>dav_liveprop_uris</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                 <argument><expr>(<name>void</name> *)++<name>dav_liveprop_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>long</argument>)</argument_list></macro> <macro><name>dav_get_liveprop_ns_index</name><argument_list>(<argument>const char *uri</argument>)</argument_list></macro>
<block>{
    <return>return <expr>(<name>long</name>)<call><name>apr_hash_get</name><argument_list>(<argument><expr><name>dav_liveprop_uris</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>long</argument>)</argument_list></macro> <macro><name>dav_get_liveprop_ns_count</name><argument_list>(<argument>void</argument>)</argument_list></macro>
<block>{
    <return>return <expr><name>dav_liveprop_count</name></expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_add_all_liveprop_xmlns</name><argument_list>(<argument>apr_pool_t *p</argument>,
                                             <argument>apr_text_header *phdr</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>idx</name> <init>= <expr><call><name>apr_hash_first</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dav_liveprop_uris</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <for>for ( <init>;</init> <condition><expr><name>idx</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>idx</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></incr> ) <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>s</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>" xmlns:lp%ld=\"%s\""</expr></argument>, <argument><expr>(<name>long</name>)<name>val</name></expr></argument>, <argument><expr>(const <name>char</name> *)<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_text_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>dav_do_find_liveprop</name><argument_list>(<argument>const char *ns_uri</argument>, <argument>const char *name</argument>,
                                      <argument>const dav_liveprop_group *group</argument>,
                                      <argument>const dav_hooks_liveprop **hooks</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type><name>uris</name> <init>= <expr><name><name>group</name>-&gt;<name>namespace_uris</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_liveprop_spec</name> *</type><name>scan</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ns</name></decl>;</decl_stmt>

    <comment type="block">/* first: locate the namespace in the namespace table */</comment>
    <for>for (<init><expr><name>ns</name> = 0</expr>;</init> <condition><expr><name><name>uris</name><index>[<expr><name>ns</name></expr>]</index></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>ns</name></expr></incr>)
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ns_uri</name></expr></argument>, <argument><expr><name><name>uris</name><index>[<expr><name>ns</name></expr>]</index></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <break>break;</break></then></if></for>
    <if>if <condition>(<expr><name><name>uris</name><index>[<expr><name>ns</name></expr>]</index></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* not our property (the namespace matched none of ours) */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <comment type="block">/* second: look for the property in the liveprop specs */</comment>
    <for>for (<init><expr><name>scan</name> = <name><name>group</name>-&gt;<name>specs</name></name></expr>;</init> <condition><expr><name><name>scan</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>scan</name></expr></incr>)
        <if>if <condition>(<expr><name>ns</name> == <name><name>scan</name>-&gt;<name>ns</name></name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>scan</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>hooks</name> = <name><name>group</name>-&gt;<name>hooks</name></name></expr>;</expr_stmt>
            <return>return <expr><name><name>scan</name>-&gt;<name>propid</name></name></expr>;</return>
        }</block></then></if></for>

    <comment type="block">/* not our property (same namespace, but no matching prop name) */</comment>
    <return>return <expr>0</expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>long</argument>)</argument_list></macro> <macro><name>dav_get_liveprop_info</name><argument_list>(<argument>int propid</argument>,
                                       <argument>const dav_liveprop_group *group</argument>,
                                       <argument>const dav_liveprop_spec **info</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>dav_liveprop_spec</name> *</type><name>scan</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>scan</name> = <name><name>group</name>-&gt;<name>specs</name></name></expr>;</init> <condition><expr><name><name>scan</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>scan</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>scan</name>-&gt;<name>propid</name></name> == <name>propid</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>info</name> = <name>scan</name></expr>;</expr_stmt>

            <comment type="block">/* map the provider-local NS into a global NS index */</comment>
            <return>return <expr><call><name>dav_get_liveprop_ns_index</name><argument_list>(<argument><expr><name><name>group</name>-&gt;<name>namespace_uris</name><index>[<expr><name><name>scan</name>-&gt;<name>ns</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* assert: should not reach this point */</comment>
    <expr_stmt><expr>*<name>info</name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block>

<macro><name>DAV_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>dav_register_liveprop_group</name><argument_list>(<argument>apr_pool_t *p</argument>,
                                              <argument>const dav_liveprop_group *group</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* register the namespace URIs */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type> <name>uris</name> <init>= <expr><name><name>group</name>-&gt;<name>namespace_uris</name></name></expr></init></decl>;</decl_stmt>

    <for>for ( <init>;</init> <condition><expr>*<name>uris</name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>uris</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>dav_register_liveprop_namespace</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>*<name>uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block>
</unit>
