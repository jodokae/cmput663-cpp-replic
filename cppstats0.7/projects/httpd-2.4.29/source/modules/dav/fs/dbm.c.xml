<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/dav/fs/dbm.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
** DAV extension module for Apache 2.0.*
**  - Database support using DBM-style databases,
**    part of the filesystem repository implementation
*/</comment>

<comment type="block">/*
** This implementation uses a SDBM database per file and directory to
** record the properties. These databases are kept in a subdirectory (of
** the directory in question or the directory that holds the file in
** question) named by the macro DAV_FS_STATE_DIR (.DAV). The filename of the
** database is equivalent to the target filename, and is
** DAV_FS_STATE_FILE_FOR_DIR (.state_for_dir) for the directory itself.
*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_file_io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_dbm.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_BYTEFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>       <comment type="block">/* for ntohs and htons */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_dav.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>      <comment type="block">/* for ap_server_conf */</comment>

<expr_stmt><expr><call><name>APLOG_USE_MODULE</name><argument_list>(<argument><expr><name>dav_fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<struct>struct <name>dav_db</name> <block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_dbm_t</name> *</type><name>file</name></decl>;</decl_stmt>

    <comment type="block">/* when used as a property database: */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>version</name></decl>;</decl_stmt>                <comment type="block">/* *minor* version of this db */</comment>

    <decl_stmt><decl><type><name>dav_buffer</name></type> <name>ns_table</name></decl>;</decl_stmt>        <comment type="block">/* table of namespace URIs */</comment>
    <decl_stmt><decl><type><name>short</name></type> <name>ns_count</name></decl>;</decl_stmt>             <comment type="block">/* number of entries in table */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ns_table_dirty</name></decl>;</decl_stmt>         <comment type="block">/* ns_table was modified */</comment>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>uri_index</name></decl>;</decl_stmt>      <comment type="block">/* map URIs to (1-based) table indices */</comment>

    <decl_stmt><decl><type><name>dav_buffer</name></type> <name>wb_key</name></decl>;</decl_stmt>          <comment type="block">/* work buffer for dav_gdbm_key */</comment>

    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>iter</name></decl>;</decl_stmt>           <comment type="block">/* iteration key */</comment>
}</block>;</struct>

<comment type="block">/* -------------------------------------------------------------------------
 *
 * GENERIC DBM ACCESS
 *
 * For the most part, this just uses the APR DBM functions. They are wrapped
 * a bit with some error handling (using the mod_dav error functions).
 */</comment>

<function><type><name>void</name></type> <name>dav_dbm_get_statefiles</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>state1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>state2</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>fname</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>fname</name> = <name>DAV_FS_STATE_FILE_FOR_DIR</name></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>apr_dbm_get_usednames</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>state1</name></expr></argument>, <argument><expr><name>state2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_fs_dbm_error</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                    <param><decl><type><name>apr_status_t</name></type> <name>status</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>errcode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr>200</expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>p</name> = <name>db</name> ? <name><name>db</name>-&gt;<name>pool</name></name> : <name>p</name></expr>;</expr_stmt>

    <comment type="block">/* There might not be a &lt;db&gt; if we had problems creating it. */</comment>
    <if>if <condition>(<expr><name>db</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>errcode</name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>errstr</name> = "Could not open property database."</expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>APR_STATUS_IS_EDSOOPEN</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00576</expr></argument>)</argument_list></call>
            "The DBM driver could not be loaded"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr>(<name>void</name>) <call><name>apr_dbm_geterror</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr>&amp;<name>errcode</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errstr</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name>err</name> = <call><name>dav_new_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>errstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* ensure that our state subdirectory is present */</comment>
<comment type="block">/* ### does this belong here or in dav_fs_repos.c ?? */</comment>
<function><type><name>void</name></type> <name>dav_fs_ensure_state_dir</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type> <name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pathname</name> <init>= <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr>"/" <name>DAV_FS_STATE_DIR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* ### do we need to deal with the umask? */</comment>

    <comment type="block">/* just try to make it, ignoring any resulting errors */</comment>
    <expr_stmt><expr>(<name>void</name>) <call><name>apr_dir_make</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* dav_dbm_open_direct:  Opens a *dbm database specified by path.
 *    ro = boolean read-only flag.
 */</comment>
<function><type><name>dav_error</name> *</type> <name>dav_dbm_open_direct</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>int</name></type> <name>ro</name></decl></param>,
                                <param><decl><type><name>dav_db</name> **</type><name>pdb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_dbm_t</name> *</type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>pdb</name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>status</name> = <call><name>apr_dbm_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>,
                               <argument><expr><name>ro</name> ? <name>APR_DBM_READONLY</name> : <name>APR_DBM_RWCREATE</name></expr></argument>,
                               <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call>)
                != <name>APR_SUCCESS</name>
        &amp;&amp; !<name>ro</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### do something with 'status' */</comment>

        <comment type="block">/* we can't continue if we couldn't open the file
           and we need to write */</comment>
        <return>return <expr><call><name>dav_fs_dbm_error</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* may be NULL if we tried to open a non-existent db as read-only */</comment>
    <if>if <condition>(<expr><name>file</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* we have an open database... return it */</comment>
        <expr_stmt><expr>*<name>pdb</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>**<name>pdb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>(*<name>pdb</name>)-&gt;<name>pool</name></name> = <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>(*<name>pdb</name>)-&gt;<name>file</name></name> = <name>file</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_dbm_open</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type> <name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                <param><decl><type><name>int</name></type> <name>ro</name></decl></param>, <param><decl><type><name>dav_db</name> **</type><name>pdb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>

    <comment type="block">/* Get directory and filename for resource */</comment>
    <comment type="block">/* ### should test this result value... */</comment>
    <expr_stmt><expr>(<name>void</name>) <call><name>dav_fs_dir_file_name</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr>&amp;<name>dirpath</name></expr></argument>, <argument><expr>&amp;<name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If not opening read-only, ensure the state dir exists */</comment>
    <if>if <condition>(<expr>!<name>ro</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### what are the perf implications of always checking this? */</comment>
        <expr_stmt><expr><call><name>dav_fs_ensure_state_dir</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>pathname</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>, <argument><expr>"/" <name>DAV_FS_STATE_DIR</name> "/"</expr></argument>,
                              <argument><expr><name>fname</name> ? <name>fname</name> : <name>DAV_FS_STATE_FILE_FOR_DIR</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ### readers cannot open while a writer has this open; we should
       ### perform a few retries with random pauses. */</comment>

    <comment type="block">/* ### do we need to deal with the umask? */</comment>

    <return>return <expr><call><name>dav_dbm_open_direct</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>ro</name></expr></argument>, <argument><expr><name>pdb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>dav_dbm_close</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>apr_dbm_close</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>dav_error</name> *</type> <name>dav_dbm_fetch</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_datum_t</name></type> <name>key</name></decl></param>, <param><decl><type><name>apr_datum_t</name> *</type><name>pvalue</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>key</name>.<name>dptr</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* no key could be created (namespace not known) =&gt; no value */</comment>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>pvalue</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    }</block></then> <else>else <block>{
        <expr_stmt><expr><name>status</name> = <call><name>apr_dbm_fetch</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><call><name>dav_fs_dbm_error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>dav_error</name> *</type> <name>dav_dbm_store</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_datum_t</name></type> <name>key</name></decl></param>, <param><decl><type><name>apr_datum_t</name></type> <name>value</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><call><name>apr_dbm_store</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>dav_fs_dbm_error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>dav_error</name> *</type> <name>dav_dbm_delete</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_datum_t</name></type> <name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><call><name>apr_dbm_delete</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>dav_fs_dbm_error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>dav_dbm_exists</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_datum_t</name></type> <name>key</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>apr_dbm_exists</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_dbm_firstkey</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_datum_t</name> *</type><name>pkey</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><call><name>apr_dbm_firstkey</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>dav_fs_dbm_error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_dbm_nextkey</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_datum_t</name> *</type><name>pkey</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><call><name>apr_dbm_nextkey</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><call><name>dav_fs_dbm_error</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>dav_dbm_freedatum</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_datum_t</name></type> <name>data</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>apr_dbm_freedatum</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* -------------------------------------------------------------------------
 *
 * PROPERTY DATABASE FUNCTIONS
 */</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GDBM_NS_KEY</name></cpp:macro>         <cpp:value>"METADATA"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_GDBM_NS_KEY_LEN</name></cpp:macro>     <cpp:value>8</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>major</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DBVSN_MAJOR</name></cpp:macro>         <cpp:value>4</cpp:value></cpp:define>
    <comment type="block">/*
    ** V4 -- 0.9.9 ..
    **       Prior versions could have keys or values with invalid
    **       namespace prefixes as a result of the xmlns="" form not
    **       resetting the default namespace to be "no namespace". The
    **       namespace would be set to "" which is invalid; it should
    **       be set to "no namespace".
    **
    ** V3 -- 0.9.8
    **       Prior versions could have values with invalid namespace
    **       prefixes due to an incorrect mapping of input to propdb
    **       namespace indices. Version bumped to obsolete the old
    **       values.
    **
    ** V2 -- 0.9.7
    **       This introduced the xml:lang value into the property value's
    **       record in the propdb.
    **
    ** V1 -- .. 0.9.6
    **       Initial version.
    */</comment>


    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>minor</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_DBVSN_MINOR</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>

    <decl_stmt><decl><type><name>short</name></type> <name>ns_count</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_propdb_metadata</name>;</typedef>

<struct>struct <name>dav_deadprop_rollback</name> <block>{
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>value</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>dav_namespace_map</name> <block>{
    <decl_stmt><decl><type><name>int</name> *</type><name>ns_map</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
** Internal function to build a key
**
** WARNING: returns a pointer to a "static" buffer holding the key. The
**          value must be copied or no longer used if this function is
**          called again.
*/</comment>
<function><type><specifier>static</specifier> <name>apr_datum_t</name></type> <name>dav_build_key</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>nsbuf</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>l_ns</name></decl>, <decl><type ref="prev"/><name>l_name</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>name</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Convert namespace ID to a string. "no namespace" is an empty string,
     * so the keys will have the form ":name". Otherwise, the keys will
     * have the form "#:name".
     */</comment>
    <if>if <condition>(<expr>*<name><name>name</name>-&gt;<name>ns</name></name> == '\0'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>nsbuf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name>l_ns</name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>long</name></type> <name>ns_id</name> <init>= <expr>(<name>long</name>)<call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>uri_index</name></name></expr></argument>, <argument><expr><name><name>name</name>-&gt;<name>ns</name></name></expr></argument>,
                                      <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>


        <if>if <condition>(<expr><name>ns_id</name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* the namespace was not found(!) */</comment>
            <return>return <expr><name>key</name></expr>;</return>         <comment type="block">/* zeroed */</comment>
        }</block></then></if>

        <expr_stmt><expr><name>l_ns</name> = <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>nsbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nsbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>ns_id</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* assemble: #:name */</comment>
    <expr_stmt><expr><call><name>dav_set_bufsize</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name><name>db</name>-&gt;<name>wb_key</name></name></expr></argument>, <argument><expr><name>l_ns</name> + 1 + <name>l_name</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>wb_key</name>.<name>buf</name></name></expr></argument>, <argument><expr><name>nsbuf</name></expr></argument>, <argument><expr><name>l_ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>db</name>-&gt;<name>wb_key</name>.<name>buf</name><index>[<expr><name>l_ns</name></expr>]</index></name> = ':'</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>db</name>-&gt;<name>wb_key</name>.<name>buf</name><index>[<expr><name>l_ns</name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name><name>name</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>l_name</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* build the database key */</comment>
    <expr_stmt><expr><name><name>key</name>.<name>dsize</name></name> = <name>l_ns</name> + 1 + <name>l_name</name> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name>.<name>dptr</name></name> = <name><name>db</name>-&gt;<name>wb_key</name>.<name>buf</name></name></expr>;</expr_stmt>

    <return>return <expr><name>key</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dav_append_prop</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>,
                            <param><decl><type><name>apr_text_header</name> *</type><name>phdr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lang</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* skip past the xml:lang value */</comment>
    <expr_stmt><expr><name>value</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>

    <if>if <condition>(<expr>*<name>value</name> == '\0'</expr>)</condition><then> <block>{
        <comment type="block">/* the property is an empty value */</comment>
        <if>if <condition>(<expr>*<name>name</name> == ':'</expr>)</condition><then> <block>{
            <comment type="block">/* "no namespace" case */</comment>
            <expr_stmt><expr><name>s</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&lt;%s/&gt;" <name>DEBUG_CR</name></expr></argument>, <argument><expr><name>name</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>s</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&lt;ns%s/&gt;" <name>DEBUG_CR</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>*<name>lang</name> != '\0'</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>*<name>name</name> == ':'</expr>)</condition><then> <block>{
            <comment type="block">/* "no namespace" case */</comment>
            <expr_stmt><expr><name>s</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&lt;%s xml:lang=\"%s\"&gt;%s&lt;/%s&gt;" <name>DEBUG_CR</name></expr></argument>,
                             <argument><expr><name>name</name>+1</expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>name</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>s</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&lt;ns%s xml:lang=\"%s\"&gt;%s&lt;/ns%s&gt;" <name>DEBUG_CR</name></expr></argument>,
                             <argument><expr><name>name</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>*<name>name</name> == ':'</expr>)</condition><then> <block>{
        <comment type="block">/* "no namespace" case */</comment>
        <expr_stmt><expr><name>s</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&lt;%s&gt;%s&lt;/%s&gt;" <name>DEBUG_CR</name></expr></argument>, <argument><expr><name>name</name>+1</expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>name</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>s</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&lt;ns%s&gt;%s&lt;/ns%s&gt;" <name>DEBUG_CR</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if>

    <expr_stmt><expr><call><name>apr_text_append</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_open</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>int</name></type> <name>ro</name></decl></param>,
                                   <param><decl><type><name>dav_db</name> **</type><name>pdb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_db</name> *</type><name>db</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>value</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>pdb</name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/*
    ** Return if an error occurred, or there is no database.
    **
    ** NOTE: db could be NULL if we attempted to open a readonly
    **       database that doesn't exist. If we require read/write
    **       access, then a database was created and opened.
    */</comment>
    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_dbm_open</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>, <argument><expr><name>ro</name></expr></argument>, <argument><expr>&amp;<name>db</name></expr></argument>)</argument_list></call>) != <name>NULL</name>
        || <name>db</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>

    <expr_stmt><expr><name><name>db</name>-&gt;<name>uri_index</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>key</name>.<name>dptr</name></name> = <name>DAV_GDBM_NS_KEY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>key</name>.<name>dsize</name></name> = <name>DAV_GDBM_NS_KEY_LEN</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_dbm_fetch</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### push a higher-level description? */</comment>
        <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>value</name>.<name>dptr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_propdb_metadata</name></type> <name>m</name> <init>= <expr><block>{
            <expr><name>DAV_DBVSN_MAJOR</name></expr>, <expr><name>DAV_DBVSN_MINOR</name></expr>, <expr>0</expr>
        }</block></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
        ** If there is no METADATA key, then the database may be
        ** from versions 0.9.0 .. 0.9.4 (which would be incompatible).
        ** These can be identified by the presence of an NS_TABLE entry.
        */</comment>
        <expr_stmt><expr><name><name>key</name>.<name>dptr</name></name> = "NS_TABLE"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name>.<name>dsize</name></name> = 8</expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>dav_dbm_exists</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>dav_dbm_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* call it a major version error */</comment>
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                 <argument><expr><name>DAV_ERR_PROP_BAD_MAJOR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"Prop database has the wrong major "
                                 "version number and cannot be used."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="block">/* initialize a new metadata structure */</comment>
        <expr_stmt><expr><call><name>dav_set_bufsize</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name><name>db</name>-&gt;<name>ns_table</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>ns_table</name>.<name>buf</name></name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>dav_propdb_metadata</name></type> <name>m</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>ns</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>dav_set_bufsize</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name><name>db</name>-&gt;<name>ns_table</name></name></expr></argument>, <argument><expr><name><name>value</name>.<name>dsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>ns_table</name>.<name>buf</name></name></expr></argument>, <argument><expr><name><name>value</name>.<name>dptr</name></name></expr></argument>, <argument><expr><name><name>value</name>.<name>dsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr><name><name>value</name>.<name>dptr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>m</name>.<name>major</name></name> != <name>DAV_DBVSN_MAJOR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>dav_dbm_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                 <argument><expr><name>DAV_ERR_PROP_BAD_MAJOR</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"Prop database has the wrong major "
                                 "version number and cannot be used."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>db</name>-&gt;<name>version</name></name> = <name><name>m</name>.<name>minor</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>db</name>-&gt;<name>ns_count</name></name> = <call><name>ntohs</name><argument_list>(<argument><expr><name><name>m</name>.<name>ns_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>dav_dbm_freedatum</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* create db-&gt;uri_index */</comment>
        <for>for (<init><expr><name>ns</name> = 0</expr>, <expr><name>uri</name> = <name><name>db</name>-&gt;<name>ns_table</name>.<name>buf</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name>dav_propdb_metadata</name></expr></argument>)</argument_list></sizeof></expr>;</init>
             <condition><expr><name>ns</name>++ &lt; <name><name>db</name>-&gt;<name>ns_count</name></name></expr>;</condition>
             <incr><expr><name>uri</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call> + 1</expr></incr>) <block>{

            <comment type="block">/* we must copy the key, in case ns_table.buf moves */</comment>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>uri_index</name></name></expr></argument>,
                         <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                         <argument><expr>(<name>void</name> *)<name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></else></if>

    <expr_stmt><expr>*<name>pdb</name> = <name>db</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dav_propdb_close</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>)</parameter_list>
<block>{

    <if>if <condition>(<expr><name><name>db</name>-&gt;<name>ns_table_dirty</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>dav_propdb_metadata</name></type> <name>m</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>key</name>.<name>dptr</name></name> = <name>DAV_GDBM_NS_KEY</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>key</name>.<name>dsize</name></name> = <name>DAV_GDBM_NS_KEY_LEN</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>value</name>.<name>dptr</name></name> = <name><name>db</name>-&gt;<name>ns_table</name>.<name>buf</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>value</name>.<name>dsize</name></name> = <name><name>db</name>-&gt;<name>ns_table</name>.<name>cur_len</name></name></expr>;</expr_stmt>

        <comment type="block">/* fill in the metadata that we store into the prop db. */</comment>
        <expr_stmt><expr><name><name>m</name>.<name>major</name></name> = <name>DAV_DBVSN_MAJOR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m</name>.<name>minor</name></name> = <name><name>db</name>-&gt;<name>version</name></name></expr>;</expr_stmt>          <comment type="block">/* ### keep current minor version? */</comment>
        <expr_stmt><expr><name><name>m</name>.<name>ns_count</name></name> = <call><name>htons</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>ns_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>ns_table</name>.<name>buf</name></name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>err</name> = <call><name>dav_dbm_store</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>aprerr</name></name></expr></argument>, <argument><expr><name>ap_server_conf</name></expr></argument>,
                         <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00577</expr></argument>)</argument_list></call> "Error writing propdb: %s"</expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>dav_dbm_close</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_define_namespaces</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>dav_xmlns_info</name> *</type><name>xi</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>ns</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name> <init>= <expr><name><name>db</name>-&gt;<name>ns_table</name>.<name>buf</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name>dav_propdb_metadata</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <comment type="block">/* within the prop values, we use "ns%d" for prefixes... register them */</comment>
    <for>for (<init><expr><name>ns</name> = 0</expr>;</init> <condition><expr><name>ns</name> &lt; <name><name>db</name>-&gt;<name>ns_count</name></name></expr>;</condition> <incr><expr>++<name>ns</name></expr>, <expr><name>uri</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call> + 1</expr></incr>) <block>{

        <comment type="block">/* Empty URIs signify the empty namespace. These do not get a
           namespace prefix. when we generate the value, we will simply
           leave off the prefix, which is defined by mod_dav to be the
           empty namespace. */</comment>
        <if>if <condition>(<expr>*<name>uri</name> == '\0'</expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <comment type="block">/* ns_table.buf can move, so copy its value (we want the values to
           last as long as the provided dav_xmlns_info). */</comment>
        <expr_stmt><expr><call><name>dav_xmlns_add</name><argument_list>(<argument><expr><name>xi</name></expr></argument>,
                      <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"ns%d"</expr></argument>, <argument><expr><name>ns</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>xi</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_output_value</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>,
                                           <param><decl><type><name>dav_xmlns_info</name> *</type><name>xi</name></decl></param>,
                                           <param><decl><type><name>apr_text_header</name> *</type><name>phdr</name></decl></param>,
                                           <param><decl><type><name>int</name> *</type><name>found</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name> <init>= <expr><call><name>dav_build_key</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_dbm_fetch</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>value</name>.<name>dptr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>found</name> = 0</expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>found</name> = 1</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>dav_append_prop</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>key</name>.<name>dptr</name></name></expr></argument>, <argument><expr><name><name>value</name>.<name>dptr</name></name></expr></argument>, <argument><expr><name>phdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>dav_dbm_freedatum</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_map_namespaces</name><parameter_list>(
    <param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>,
    <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>namespaces</name></decl></param>,
    <param><decl><type><name>dav_namespace_map</name> **</type><name>mapping</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_namespace_map</name> *</type><name>m</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>m</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name> *</type><name>pmap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>puri</name></decl>;</decl_stmt>

    <comment type="block">/*
    ** Iterate over the provided namespaces. If a namespace already appears
    ** in our internal map of URI -&gt; ns_id, then store that in the map. If
    ** we don't know the namespace yet, then add it to the map and to our
    ** table of known namespaces.
    */</comment>
    <expr_stmt><expr><name><name>m</name>-&gt;<name>ns_map</name></name> = <name>pmap</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>namespaces</name>-&gt;<name>nelts</name></name> * <sizeof>sizeof<argument_list>(<argument><expr>*<name>pmap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <name><name>namespaces</name>-&gt;<name>nelts</name></name></expr>, <expr><name>puri</name> = (const <name>char</name> **)<name><name>namespaces</name>-&gt;<name>elts</name></name></expr>;</init>
         <condition><expr><name>i</name>-- &gt; 0</expr>;</condition>
         <incr><expr>++<name>puri</name></expr>, <expr>++<name>pmap</name></expr></incr>) <block>{

        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name> <init>= <expr>*<name>puri</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>uri_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>long</name></type> <name>ns_id</name> <init>= <expr>(<name>long</name>)<call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>uri_index</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>uri_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ns_id</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>dav_check_bufsize</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name><name>db</name>-&gt;<name>ns_table</name></name></expr></argument>, <argument><expr><name>uri_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>ns_table</name>.<name>buf</name></name> + <name><name>db</name>-&gt;<name>ns_table</name>.<name>cur_len</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>uri_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>db</name>-&gt;<name>ns_table</name>.<name>cur_len</name></name> += <name>uri_len</name> + 1</expr>;</expr_stmt>

            <comment type="block">/* copy the uri in case the passed-in namespaces changes in
               some way. */</comment>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>uri_index</name></name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>uri_len</name></expr></argument>,
                         <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><call>(<name>long</name>)<argument_list>(<argument><expr><name><name>db</name>-&gt;<name>ns_count</name></name> + 1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>db</name>-&gt;<name>ns_table_dirty</name></name> = 1</expr>;</expr_stmt>

            <expr_stmt><expr>*<name>pmap</name> = <name><name>db</name>-&gt;<name>ns_count</name></name>++</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>*<name>pmap</name> = <name>ns_id</name> - 1</expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>

    <expr_stmt><expr>*<name>mapping</name> = <name>m</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_store</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>apr_xml_elem</name> *</type><name>elem</name></decl></param>,
                                    <param><decl><type><name>dav_namespace_map</name> *</type><name>mapping</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name> <init>= <expr><call><name>dav_build_key</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>value</name></decl>;</decl_stmt>

    <comment type="block">/* Note: mapping-&gt;ns_map was set up in dav_propdb_map_namespaces() */</comment>

    <comment type="block">/* ### use a db- subpool for these values? clear on exit? */</comment>

    <comment type="block">/* quote all the values in the element */</comment>
    <comment type="block">/* ### be nice to do this without affecting the element itself */</comment>
    <comment type="block">/* ### of course, the cast indicates Badness is occurring here */</comment>
    <expr_stmt><expr><call><name>apr_xml_quote_elem</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>(<name>apr_xml_elem</name> *)<name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* generate a text blob for the xml:lang plus the contents */</comment>
    <expr_stmt><expr><call><name>apr_xml_to_text</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>elem</name></expr></argument>, <argument><expr><name>APR_XML_X2T_LANG_INNER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                    <argument><expr><name><name>mapping</name>-&gt;<name>ns_map</name></name></expr></argument>,
                    <argument><expr>(const <name>char</name> **)&amp;<name><name>value</name>.<name>dptr</name></name></expr></argument>, <argument><expr>&amp;<name><name>value</name>.<name>dsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>dav_dbm_store</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_remove</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name> <init>= <expr><call><name>dav_build_key</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>dav_dbm_delete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dav_propdb_exists</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name> <init>= <expr><call><name>dav_build_key</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>dav_dbm_exists</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>dav_get_ns_table_uri</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>int</name></type> <name>ns_id</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name><name>db</name>-&gt;<name>ns_table</name>.<name>buf</name></name> + <sizeof>sizeof<argument_list>(<argument><expr><name>dav_propdb_metadata</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>ns_id</name>--</expr>)</condition>
        <expr_stmt><expr><name>p</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></while>

    <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>dav_set_name</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>dav_prop_name</name> *</type><name>pname</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><name><name>db</name>-&gt;<name>iter</name>.<name>dptr</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pname</name>-&gt;<name>ns</name></name> = <name><name>pname</name>-&gt;<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>*<name>s</name> == ':'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>pname</name>-&gt;<name>ns</name></name> = ""</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pname</name>-&gt;<name>name</name></name> = <name>s</name> + 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>pname</name>-&gt;<name>ns</name></name> = <call><name>dav_get_ns_table_uri</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>s</name><index>[<expr>1</expr>]</index></name> == ':'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>pname</name>-&gt;<name>name</name></name> = <name>s</name> + 2</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>pname</name>-&gt;<name>name</name></name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>s</name> + 2</expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_next_name</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>dav_prop_name</name> *</type><name>pname</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <comment type="block">/* free the previous key. note: if the loop is aborted, then the DBM
       will toss the key (via pool cleanup) */</comment>
    <if>if <condition>(<expr><name><name>db</name>-&gt;<name>iter</name>.<name>dptr</name></name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>dav_dbm_freedatum</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_dbm_nextkey</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name><name>db</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>

    <comment type="block">/* skip past the METADATA key */</comment>
    <if>if <condition>(<expr><name><name>db</name>-&gt;<name>iter</name>.<name>dptr</name></name> != <name>NULL</name> &amp;&amp; *<name><name>db</name>-&gt;<name>iter</name>.<name>dptr</name></name> == 'M'</expr>)</condition><then>
        <return>return <expr><call><name>dav_propdb_next_name</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><call><name>dav_set_name</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_first_name</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>, <param><decl><type><name>dav_prop_name</name> *</type><name>pname</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_dbm_firstkey</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr>&amp;<name><name>db</name>-&gt;<name>iter</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>

    <comment type="block">/* skip past the METADATA key */</comment>
    <if>if <condition>(<expr><name><name>db</name>-&gt;<name>iter</name>.<name>dptr</name></name> != <name>NULL</name> &amp;&amp; *<name><name>db</name>-&gt;<name>iter</name>.<name>dptr</name></name> == 'M'</expr>)</condition><then>
        <return>return <expr><call><name>dav_propdb_next_name</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><call><name>dav_set_name</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_get_rollback</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>dav_prop_name</name> *</type><name>name</name></decl></param>,
                                           <param><decl><type><name>dav_deadprop_rollback</name> **</type><name>prollback</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>dav_deadprop_rollback</name> *</type><name>rb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>key</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>key</name> = <call><name>dav_build_key</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rb</name>-&gt;<name>key</name>.<name>dptr</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>key</name>.<name>dptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rb</name>-&gt;<name>key</name>.<name>dsize</name></name> = <name><name>key</name>.<name>dsize</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>err</name> = <call><name>dav_dbm_fetch</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>value</name>.<name>dptr</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>rb</name>-&gt;<name>value</name>.<name>dptr</name></name> = <call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>value</name>.<name>dptr</name></name></expr></argument>, <argument><expr><name><name>value</name>.<name>dsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>rb</name>-&gt;<name>value</name>.<name>dsize</name></name> = <name><name>value</name>.<name>dsize</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr>*<name>prollback</name> = <name>rb</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type> <name>dav_propdb_apply_rollback</name><parameter_list>(<param><decl><type><name>dav_db</name> *</type><name>db</name></decl></param>,
                                             <param><decl><type><name>dav_deadprop_rollback</name> *</type><name>rollback</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>rollback</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* no rollback, nothing to do */</comment>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>rollback</name>-&gt;<name>value</name>.<name>dptr</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <comment type="block">/* don't fail if the thing isn't really there. */</comment>
        <expr_stmt><expr>(<name>void</name>) <call><name>dav_dbm_delete</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>rollback</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><call><name>dav_dbm_store</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name><name>rollback</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>rollback</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_db</name></type> <name>dav_hooks_db_dbm</name> <init>=
<expr><block>{
    <expr><name>dav_propdb_open</name></expr>,
    <expr><name>dav_propdb_close</name></expr>,
    <expr><name>dav_propdb_define_namespaces</name></expr>,
    <expr><name>dav_propdb_output_value</name></expr>,
    <expr><name>dav_propdb_map_namespaces</name></expr>,
    <expr><name>dav_propdb_store</name></expr>,
    <expr><name>dav_propdb_remove</name></expr>,
    <expr><name>dav_propdb_exists</name></expr>,
    <expr><name>dav_propdb_first_name</name></expr>,
    <expr><name>dav_propdb_next_name</name></expr>,
    <expr><name>dav_propdb_get_rollback</name></expr>,
    <expr><name>dav_propdb_apply_rollback</name></expr>,

    <expr><name>NULL</name></expr> <comment type="block">/* ctx */</comment>
}</block></expr></init></decl>;</decl_stmt>
</unit>
