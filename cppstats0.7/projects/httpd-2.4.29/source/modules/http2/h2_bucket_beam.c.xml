<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/http2/h2_bucket_beam.c"><comment type="block">/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_atomic.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_buckets.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_mutex.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_cond.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_protocol.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_bucket_beam.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>h2_beam_emitted</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>h2_beam_proxy</name> *</type><name>proxy</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_NEXT</name><parameter_list>(<param><type><name>e</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APR_RING_NEXT((e), link)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_PREV</name><parameter_list>(<param><type><name>e</name></type></param>)</parameter_list></cpp:macro>             <cpp:value>APR_RING_PREV((e), link)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_REMOVE</name><parameter_list>(<param><type><name>e</name></type></param>)</parameter_list></cpp:macro>           <cpp:value>APR_RING_REMOVE((e), link)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_LIST_INIT</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>APR_RING_INIT(&amp;(b)-&gt;list, h2_beam_proxy, link);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_LIST_SENTINEL</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>APR_RING_SENTINEL(&amp;(b)-&gt;list, h2_beam_proxy, link)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_LIST_EMPTY</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>APR_RING_EMPTY(&amp;(b)-&gt;list, h2_beam_proxy, link)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_LIST_FIRST</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>APR_RING_FIRST(&amp;(b)-&gt;list)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_LIST_LAST</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>	      <cpp:value>APR_RING_LAST(&amp;(b)-&gt;list)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_PROXY_BLIST_INSERT_HEAD</name><parameter_list>(<param><type><name>b</name></type></param>, <param><type><name>e</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {				\
	h2_beam_proxy *ap__b = (e);                                        \
	APR_RING_INSERT_HEAD(&amp;(b)-&gt;list, ap__b, h2_beam_proxy, link);	\
    } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_LIST_INSERT_TAIL</name><parameter_list>(<param><type><name>b</name></type></param>, <param><type><name>e</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {				\
	h2_beam_proxy *ap__b = (e);					\
	APR_RING_INSERT_TAIL(&amp;(b)-&gt;list, ap__b, h2_beam_proxy, link);	\
    } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_LIST_CONCAT</name><parameter_list>(<param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {					\
        APR_RING_CONCAT(&amp;(a)-&gt;list, &amp;(b)-&gt;list, h2_beam_proxy, link);	\
    } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BPROXY_LIST_PREPEND</name><parameter_list>(<param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {					\
        APR_RING_PREPEND(&amp;(a)-&gt;list, &amp;(b)-&gt;list, h2_beam_proxy, link);	\
    } while (0)</cpp:value></cpp:define>


<comment type="block">/*******************************************************************************
 * beam bucket with reference to beam and bucket it represents
 ******************************************************************************/</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>apr_bucket_type_t</name></type> <name>h2_bucket_type_beam</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BUCKET_IS_BEAM</name><parameter_list>(<param><type><name>e</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>(e-&gt;type == &amp;h2_bucket_type_beam)</cpp:value></cpp:define>

<struct>struct <name>h2_beam_proxy</name> <block>{
    <decl_stmt><decl><type><name>apr_bucket_refcount</name></type> <name>refcount</name></decl>;</decl_stmt>
    <macro><name>APR_RING_ENTRY</name><argument_list>(<argument>h2_beam_proxy</argument>)</argument_list></macro> <expr_stmt><expr><name>link</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bsender</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>n</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name>Dummy</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>beam_bucket_read</name><parameter_list>(<param><decl><type><name>apr_bucket</name> *</type><name>b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>str</name></decl></param>, 
                                     <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_proxy</name> *</type><name>d</name> <init>= <expr><name><name>b</name>-&gt;<name>data</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>d</name>-&gt;<name>bsender</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><call><name>apr_bucket_read</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>bsender</name></name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>str</name> = <name>data</name> + <name><name>b</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>len</name> = <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>str</name> = &amp;<name>Dummy</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>len</name> = 0</expr>;</expr_stmt>
    <return>return <expr><name>APR_ECONNRESET</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>beam_bucket_destroy</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_proxy</name> *</type><name>d</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>apr_bucket_shared_destroy</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* When the beam gets destroyed before this bucket, it will
         * NULLify its reference here. This is not protected by a mutex,
         * so it will not help with race conditions.
         * But it lets us shut down memory pool with circulare beam
         * references. */</comment>
        <if>if <condition>(<expr><name><name>d</name>-&gt;<name>beam</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>h2_beam_emitted</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>beam</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>apr_bucket_free</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_bucket</name> *</type> <name>h2_beam_bucket_make</name><parameter_list>(<param><decl><type><name>apr_bucket</name> *</type><name>b</name></decl></param>, 
                                        <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>,
                                        <param><decl><type><name>apr_bucket</name> *</type><name>bsender</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_proxy</name> *</type><name>d</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>d</name> = <call><name>apr_bucket_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>H2_BPROXY_LIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>proxies</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name>-&gt;<name>beam</name></name> = <name>beam</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name>-&gt;<name>bsender</name></name> = <name>bsender</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>d</name>-&gt;<name>n</name></name> = <name>n</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_shared_make</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>bsender</name>? <name><name>bsender</name>-&gt;<name>length</name></name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>type</name></name> = &amp;<name>h2_bucket_type_beam</name></expr>;</expr_stmt>

    <return>return <expr><name>b</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_bucket</name> *</type><name>h2_beam_bucket_create</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>,
                                         <param><decl><type><name>apr_bucket</name> *</type><name>bsender</name></decl></param>,
                                         <param><decl><type><name>apr_bucket_alloc_t</name> *</type><name>list</name></decl></param>,
                                         <param><decl><type><name>apr_size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>APR_BUCKET_INIT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>free</name></name> = <name>apr_bucket_free</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>list</name></name> = <name>list</name></expr>;</expr_stmt>
    <return>return <expr><call><name>h2_beam_bucket_make</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>beam</name></expr></argument>, <argument><expr><name>bsender</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>apr_bucket_type_t</name></type> <name>h2_bucket_type_beam</name> <init>= <expr><block>{
    <expr>"BEAM"</expr>, <expr>5</expr>, <expr><name>APR_BUCKET_DATA</name></expr>,
    <expr><name>beam_bucket_destroy</name></expr>,
    <expr><name>beam_bucket_read</name></expr>,
    <expr><name>apr_bucket_setaside_noop</name></expr>,
    <expr><name>apr_bucket_shared_split</name></expr>,
    <expr><name>apr_bucket_shared_copy</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*******************************************************************************
 * h2_blist, a brigade without allocations
 ******************************************************************************/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>apr_array_header_t</name> *</type><name>beamers</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cleanup_beamers</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr>(<name>void</name>)<name>dummy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>beamers</name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>h2_register_bucket_beamer</name><parameter_list>(<param><decl><type><name>h2_bucket_beamer</name> *</type><name>beamer</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>beamers</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>apr_hook_global_pool</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><name>cleanup_beamers</name></expr></argument>, <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>beamers</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>apr_hook_global_pool</name></expr></argument>, <argument><expr>10</expr></argument>, 
                                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_bucket_beamer</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>beamers</name></expr></argument>, <argument><expr><name>h2_bucket_beamer</name>*</expr></argument>)</argument_list></call> = <name>beamer</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_bucket</name> *</type><name>h2_beam_bucket</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                                  <param><decl><type><name>apr_bucket_brigade</name> *</type><name>dest</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>apr_bucket</name> *</type><name>src</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>beamers</name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>beamers</name>-&gt;<name>nelts</name></name> &amp;&amp; <name>b</name> == <name>NULL</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>h2_bucket_beamer</name> *</type><name>beamer</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>beamer</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>beamers</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>h2_bucket_beamer</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>b</name> = <call><name>beamer</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
    <return>return <expr><name>b</name></expr>;</return>
}</block></function>


<comment type="block">/*******************************************************************************
 * bucket beam that can transport buckets across threads
 ******************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mutex_leave</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>mutex_enter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_beam_lock</name> *</type><name>pbl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>pbl</name>-&gt;<name>mutex</name></name> = <name><name>beam</name>-&gt;<name>lock</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pbl</name>-&gt;<name>leave</name></name> = <name>mutex_leave</name></expr>;</expr_stmt>
    <return>return <expr><call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>pbl</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>enter_yellow</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>h2_beam_lock</name> *</type><name>pbl</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>mutex_enter</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>pbl</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>leave_yellow</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>h2_beam_lock</name> *</type><name>pbl</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>pbl</name>-&gt;<name>leave</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>pbl</name>-&gt;<name>leave</name></name><argument_list>(<argument><expr><name><name>pbl</name>-&gt;<name>leave_ctx</name></name></expr></argument>, <argument><expr><name><name>pbl</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_off_t</name></type> <name>bucket_mem_used</name><parameter_list>(<param><decl><type><name>apr_bucket</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* should all have determinate length */</comment>
        <return>return <expr><name><name>b</name>-&gt;<name>length</name></name></expr>;</return>
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>report_consumption</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>h2_beam_lock</name> *</type><name>pbl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>len</name> <init>= <expr><name><name>beam</name>-&gt;<name>received_bytes</name></name> - <name><name>beam</name>-&gt;<name>cons_bytes_reported</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_io_callback</name> *</type><name>cb</name> <init>= <expr><name><name>beam</name>-&gt;<name>cons_io_cb</name></name></expr></init></decl>;</decl_stmt>
     
    <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>cb</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name> <init>= <expr><name><name>beam</name>-&gt;<name>cons_ctx</name></name></expr></init></decl>;</decl_stmt>
            
            <if>if <condition>(<expr><name>pbl</name></expr>)</condition><then> <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>pbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>cb</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>beam</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>pbl</name></expr>)</condition><then> <expr_stmt><expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>pbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><name>rv</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>cons_bytes_reported</name></name> += <name>len</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>report_prod_io</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>int</name></type> <name>force</name></decl></param>, <param><decl><type><name>h2_beam_lock</name> *</type><name>pbl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>len</name> <init>= <expr><name><name>beam</name>-&gt;<name>sent_bytes</name></name> - <name><name>beam</name>-&gt;<name>prod_bytes_reported</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>force</name> || <name>len</name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>h2_beam_io_callback</name> *</type><name>cb</name> <init>= <expr><name><name>beam</name>-&gt;<name>prod_io_cb</name></name></expr></init></decl>;</decl_stmt> 
        <if>if <condition>(<expr><name>cb</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name> <init>= <expr><name><name>beam</name>-&gt;<name>prod_ctx</name></name></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>pbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>cb</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>beam</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>pbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>prod_bytes_reported</name></name> += <name>len</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>calc_buffered</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>b</name> = <call><name>H2_BLIST_FIRST</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</init> 
         <condition><expr><name>b</name> != <call><name>H2_BLIST_SENTINEL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> == ((<name>apr_size_t</name>)-1)</expr>)</condition><then> <block>{
            <comment type="block">/* do not count */</comment>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* if unread, has no real mem footprint. */</comment>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>len</name> += <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></for>
    <return>return <expr><name>len</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_purge_sent</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <comment type="block">/* delete all sender buckets in purge brigade, needs to be called
     * from sender thread only */</comment>
    <while>while <condition>(<expr>!<call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>purge_list</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>b</name> = <call><name>H2_BLIST_FIRST</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>purge_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>calc_space_left</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>max_buf_size</name></name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_off_t</name></type> <name>len</name> <init>= <expr><call><name>calc_buffered</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <return>return <expr>(<name><name>beam</name>-&gt;<name>max_buf_size</name></name> &gt; <name>len</name>? (<name><name>beam</name>-&gt;<name>max_buf_size</name></name> - <name>len</name>) : 0)</expr>;</return>
    }</block></then></if>
    <return>return <expr><name>APR_SIZE_MAX</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>buffer_is_empty</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>((!<name><name>beam</name>-&gt;<name>recv_buffer</name></name> || <call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name></expr></argument>)</argument_list></call>)
            &amp;&amp; <call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>wait_empty</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,  
                               <param><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    
    <while>while <condition>(<expr>!<call><name>buffer_is_empty</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call> &amp;&amp; <name>APR_SUCCESS</name> == <name>rv</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name>APR_BLOCK_READ</name> != <name>block</name> || !<name>lock</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>timeout</name></name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_timedwait</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></while>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>wait_not_empty</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,  
                                   <param><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    
    <while>while <condition>(<expr><call><name>buffer_is_empty</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call> &amp;&amp; <name>APR_SUCCESS</name> == <name>rv</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>closed</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>APR_EOF</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>APR_BLOCK_READ</name> != <name>block</name> || !<name>lock</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>timeout</name></name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_timedwait</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if></else></if>
    }</block></while>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>wait_not_full</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>, 
                                  <param><decl><type><name>apr_size_t</name> *</type><name>pspace_left</name></decl></param>, <param><decl><type><name>h2_beam_lock</name> *</type><name>bl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>left</name></decl>;</decl_stmt>
    
    <while>while <condition>(<expr>0 == (<name>left</name> = <call><name>calc_space_left</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call>) &amp;&amp; <name>APR_SUCCESS</name> == <name>rv</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>block</name> != <name>APR_BLOCK_READ</name> || !<name><name>bl</name>-&gt;<name>mutex</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>timeout</name></name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_timedwait</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>, <argument><expr><name><name>bl</name>-&gt;<name>mutex</name></name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_wait</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>, <argument><expr><name><name>bl</name>-&gt;<name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if></else></if>
    }</block></while>
    <expr_stmt><expr>*<name>pspace_left</name> = <name>left</name></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>h2_beam_emitted</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>h2_beam_proxy</name> *</type><name>proxy</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <comment type="block">/* even when beam buckets are split, only the one where
         * refcount drops to 0 will call us */</comment>
        <expr_stmt><expr><call><name>H2_BPROXY_REMOVE</name><argument_list>(<argument><expr><name>proxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* invoked from receiver thread, the last beam bucket for the send
         * bucket is about to be destroyed.
         * remove it from the hold, where it should be now */</comment>
        <if>if <condition>(<expr><name><name>proxy</name>-&gt;<name>bsender</name></name></expr>)</condition><then> <block>{
            <for>for (<init><expr><name>b</name> = <call><name>H2_BLIST_FIRST</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>)</argument_list></call></expr>;</init> 
                 <condition><expr><name>b</name> != <call><name>H2_BLIST_SENTINEL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>)</argument_list></call></expr>;</condition>
                 <incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
                 <if>if <condition>(<expr><name>b</name> == <name><name>proxy</name>-&gt;<name>bsender</name></name></expr>)</condition><then> <block>{
                    <break>break;</break>
                 }</block></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>b</name> != <call><name>H2_BLIST_SENTINEL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* bucket is in hold as it should be, mark this one
                 * and all before it for purging. We might have placed meta
                 * buckets without a receiver proxy into the hold before it 
                 * and schedule them for purging now */</comment>
                <for>for (<init><expr><name>b</name> = <call><name>H2_BLIST_FIRST</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>)</argument_list></call></expr>;</init> 
                     <condition><expr><name>b</name> != <call><name>H2_BLIST_SENTINEL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>)</argument_list></call></expr>;</condition>
                     <incr><expr><name>b</name> = <name>next</name></expr></incr>) <block>{
                    <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>b</name> == <name><name>proxy</name>-&gt;<name>bsender</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>H2_BLIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>purge_list</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>H2_BLIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>purge_list</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <comment type="block">/* another data bucket before this one in hold. this
                         * is normal since DATA buckets need not be destroyed
                         * in order */</comment>
                    }</block></else></if></else></if>
                }</block></for>
                
                <expr_stmt><expr><name><name>proxy</name>-&gt;<name>bsender</name></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* it should be there unless we screwed up */</comment>
                <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>, 
                              <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03384</expr></argument>)</argument_list></call> "h2_beam(%d-%s): emitted bucket not "
                              "in hold, n=%d"</expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>tag</name></name></expr></argument>, 
                              <argument><expr>(<name>int</name>)<name><name>proxy</name>-&gt;<name>n</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr>!<name><name>proxy</name>-&gt;<name>bsender</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
        <comment type="block">/* notify anyone waiting on space to become available */</comment>
        <if>if <condition>(<expr>!<name><name>bl</name>.<name>mutex</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>r_purge_sent</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>h2_blist_cleanup</name><parameter_list>(<param><decl><type><name>h2_blist</name> *</type><name>bl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>!<call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>e</name> = <call><name>H2_BLIST_FIRST</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>beam_close</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>beam</name>-&gt;<name>closed</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>closed</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>h2_beam_is_closed</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name><name>beam</name>-&gt;<name>closed</name></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pool_register</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, 
                         <param><function_decl><type><name>apr_status_t</name></type> (*<name>cleanup</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>pool</name> &amp;&amp; <name>pool</name> != <name><name>beam</name>-&gt;<name>pool</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_pool_pre_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>beam</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pool_kill</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                     <param><function_decl><type><name>apr_status_t</name></type> (*<name>cleanup</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
    <if>if <condition>(<expr><name>pool</name> &amp;&amp; <name>pool</name> != <name><name>beam</name>-&gt;<name>pool</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_pool_cleanup_kill</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>beam</name></expr></argument>, <argument><expr><name>cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>beam_recv_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* receiver pool has gone away, clear references */</comment>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>recv_pool</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>beam_send_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* sender is going away, clear up all references to its memory */</comment>
    <expr_stmt><expr><call><name>r_purge_sent</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>h2_blist_cleanup</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>report_consumption</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr>!<call><name>H2_BPROXY_LIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>proxies</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>h2_beam_proxy</name> *</type><name>proxy</name> <init>= <expr><call><name>H2_BPROXY_LIST_FIRST</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>proxies</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>H2_BPROXY_REMOVE</name><argument_list>(<argument><expr><name>proxy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>proxy</name>-&gt;<name>beam</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>proxy</name>-&gt;<name>bsender</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><call><name>h2_blist_cleanup</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>purge_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>h2_blist_cleanup</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>send_pool</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>beam_set_send_pool</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> 
<block>{
    <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>send_pool</name></name> != <name>pool</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>send_pool</name></name> &amp;&amp; <name><name>beam</name>-&gt;<name>send_pool</name></name> != <name><name>beam</name>-&gt;<name>pool</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>pool_kill</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>, <argument><expr><name>beam_send_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>beam_send_cleanup</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>send_pool</name></name> = <name>pool</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>pool_register</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>, <argument><expr><name>beam_send_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>recv_buffer_cleanup</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>h2_beam_lock</name> *</type><name>bl</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name> &amp;&amp; !<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_off_t</name></type> <name>bblen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_brigade_length</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>bblen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>received_bytes</name></name> += <name>bblen</name></expr>;</expr_stmt>
        
        <comment type="block">/* need to do this unlocked since bucket destroy might 
         * call this beam again. */</comment>
        <if>if <condition>(<expr><name>bl</name></expr>)</condition><then> <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>bl</name></expr>)</condition><then> <expr_stmt><expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        
        <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>cons_ev_cb</name></name></expr>)</condition><then> <block>{ 
            <expr_stmt><expr><call><name><name>beam</name>-&gt;<name>cons_ev_cb</name></name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>cons_ctx</name></name></expr></argument>, <argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>beam_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>safe_send</name> <init>= <expr>(<name><name>beam</name>-&gt;<name>owner</name></name> == <name>H2_BEAM_OWNER_SEND</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>safe_recv</name> <init>= <expr>(<name><name>beam</name>-&gt;<name>owner</name></name> == <name>H2_BEAM_OWNER_RECV</name>)</expr></init></decl>;</decl_stmt>
    
    <comment type="block">/* 
     * Owner of the beam is going away, depending on which side it owns,
     * cleanup strategies will differ.
     *
     * In general, receiver holds references to memory from sender. 
     * Clean up receiver first, if safe, then cleanup sender, if safe.
     */</comment>
     
    <comment type="block">/* When modify send is not safe, this means we still have multi-thread
     * protection and the owner is receiving the buckets. If the sending
     * side has not gone away, this means we could have dangling buckets
     * in our lists that never get destroyed. This should not happen. */</comment>
    <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>safe_send</name> || !<name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>safe_recv</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>recv_pool</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>pool_kill</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>recv_pool</name></name></expr></argument>, <argument><expr><name>beam_recv_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>beam</name>-&gt;<name>recv_pool</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>recv_buffer_cleanup</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>recv_pool</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>
    
    <if>if <condition>(<expr><name>safe_send</name> &amp;&amp; <name><name>beam</name>-&gt;<name>send_pool</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>pool_kill</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>, <argument><expr><name>beam_send_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> = <call><name>beam_send_cleanup</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>safe_recv</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><call><name>H2_BPROXY_LIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>proxies</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>purge_list</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_beam_destroy</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>apr_pool_cleanup_kill</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>beam</name></expr></argument>, <argument><expr><name>beam_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>beam_cleanup</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_beam_create</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> **</type><name>pbeam</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, 
                            <param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl></param>, 
                            <param><decl><type><name>h2_beam_owner_t</name></type> <name>owner</name></decl></param>,
                            <param><decl><type><name>apr_size_t</name></type> <name>max_buf_size</name></decl></param>,
                            <param><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>beam</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>beam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>beam</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_ENOMEM</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>beam</name>-&gt;<name>id</name></name> = <name>id</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>tag</name></name> = <name>tag</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>owner</name></name> = <name>owner</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>H2_BLIST_INIT</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>H2_BLIST_INIT</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>H2_BLIST_INIT</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>purge_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>H2_BPROXY_LIST_INIT</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>proxies</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>tx_mem_limits</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>max_buf_size</name></name> = <name>max_buf_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>timeout</name></name> = <name>timeout</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>lock</name></name></expr></argument>, <argument><expr><name>APR_THREAD_MUTEX_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>APR_SUCCESS</name> == <name>rv</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_thread_cond_create</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>change</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>APR_SUCCESS</name> == <name>rv</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_pool_pre_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>beam</name></expr></argument>, <argument><expr><name>beam_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>pbeam</name> = <name>beam</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>h2_beam_buffer_size_set</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>buffer_size</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>max_buf_size</name></name> = <name>buffer_size</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>apr_size_t</name></type> <name>h2_beam_buffer_size_get</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buffer_size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>buffer_size</name> = <name><name>beam</name>-&gt;<name>max_buf_size</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>buffer_size</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>h2_beam_timeout_set</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>timeout</name></name> = <name>timeout</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>apr_interval_time_t</name></type> <name>h2_beam_timeout_get</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>timeout</name> = <name><name>beam</name>-&gt;<name>timeout</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>timeout</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>h2_beam_abort</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name><name>beam</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>beam</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>r_purge_sent</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>h2_blist_cleanup</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>report_consumption</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_beam_close</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>r_purge_sent</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>beam_close</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>report_consumption</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name><name>beam</name>-&gt;<name>aborted</name></name>? <name>APR_ECONNABORTED</name> : <name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_beam_leave</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>recv_buffer_cleanup</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>beam_close</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_beam_wait_empty</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr>(<name>status</name> = <call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call>) == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>wait_empty</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>bl</name>.<name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>move_to_hold</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                         <param><decl><type><name>apr_bucket_brigade</name> *</type><name>sender_bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><name>sender_bb</name> &amp;&amp; !<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>sender_bb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>sender_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>H2_BLIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>append_bucket</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                                  <param><decl><type><name>apr_bucket</name> *</type><name>b</name></decl></param>,
                                  <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                  <param><decl><type><name>apr_size_t</name> *</type><name>pspace_left</name></decl></param>,
                                  <param><decl><type><name>h2_beam_lock</name> *</type><name>pbl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>can_beam</name></decl>, <decl><type ref="prev"/><name>check_len</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
    }</block></then></if>
    
    <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>beam</name>-&gt;<name>closed</name></name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>H2_BLIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* For file buckets the problem is their internal readpool that
         * is used on the first read to allocate buffer/mmap.
         * Since setting aside a file bucket will de-register the
         * file cleanup function from the previous pool, we need to
         * call that only from the sender thread.
         *
         * Currently, we do not handle file bucket with refcount &gt; 1 as
         * the beam is then not in complete control of the file's lifetime.
         * Which results in the bug that a file get closed by the receiver
         * while the sender or the beam still have buckets using it. 
         * 
         * Additionally, we allow callbacks to prevent beaming file
         * handles across. The use case for this is to limit the number 
         * of open file handles and rather use a less efficient beam
         * transport. */</comment>
        <decl_stmt><decl><type><name>apr_bucket_file</name> *</type><name>bf</name> <init>= <expr><name><name>b</name>-&gt;<name>data</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name> <init>= <expr><name><name>bf</name>-&gt;<name>fd</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>can_beam</name> = (<name><name>bf</name>-&gt;<name>refcount</name>.<name>refcount</name></name> == 1)</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>can_beam</name> &amp;&amp; <name><name>beam</name>-&gt;<name>can_beam_fn</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>can_beam</name> = <call><name><name>beam</name>-&gt;<name>can_beam_fn</name></name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>can_beam_ctx</name></name></expr></argument>, <argument><expr><name>beam</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>check_len</name> = !<name>can_beam</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> == ((<name>apr_size_t</name>)-1)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>status</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr><name>check_len</name> = 1</expr>;</expr_stmt>
    }</block></else></if></else></if>
    
    <if>if <condition>(<expr><name>check_len</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> &gt; *<name>pspace_left</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>*<name>pspace_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr>*<name>pspace_left</name> -= <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* The fundamental problem is that reading a sender bucket from
     * a receiver thread is a total NO GO, because the bucket might use
     * its pool/bucket_alloc from a foreign thread and that will
     * corrupt. */</comment>
    <expr_stmt><expr><name>status</name> = <name>APR_ENOTIMPL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>APR_BUCKET_IS_TRANSIENT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* this takes care of transient buckets and converts them
         * into heap ones. Other bucket types might or might not be
         * affected by this. */</comment>
        <expr_stmt><expr><name>status</name> = <call><name>apr_bucket_setaside</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_HEAP</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* For heap buckets read from a receiver thread is fine. The
         * data will be there and live until the bucket itself is
         * destroyed. */</comment>
        <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_POOL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* pool buckets are bastards that register at pool cleanup
         * to morph themselves into heap buckets. That may happen anytime,
         * even after the bucket data pointer has been read. So at
         * any time inside the receiver thread, the pool bucket memory
         * may disappear. yikes. */</comment>
        <expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_bucket_heap_make</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &amp;&amp; <name>can_beam</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>apr_bucket_setaside</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if></else></if>
    
    <if>if <condition>(<expr><name>status</name> == <name>APR_ENOTIMPL</name></expr>)</condition><then> <block>{
        <comment type="block">/* we have no knowledge about the internals of this bucket,
         * but hope that after read, its data stays immutable for the
         * lifetime of the bucket. (see pool bucket handling above for
         * a counter example).
         * We do the read while in the sender thread, so that the bucket may
         * use pools/allocators safely. */</comment>
        <expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>status</name> = <call><name>apr_bucket_setaside</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name> &amp;&amp; <name>status</name> != <name>APR_ENOTIMPL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>
    
    <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>H2_BLIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>beam</name>-&gt;<name>sent_bytes</name></name> += <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>h2_beam_send_from</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    <comment type="block">/* Called from the sender thread to add buckets to the beam */</comment>
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>r_purge_sent</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>beam_set_send_pool</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_beam_send</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                          <param><decl><type><name>apr_bucket_brigade</name> *</type><name>sender_bb</name></decl></param>, 
                          <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>space_left</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>

    <comment type="block">/* Called from the sender thread to add buckets to the beam */</comment>
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>send_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>r_purge_sent</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>move_to_hold</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>sender_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rv</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>sender_bb</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>force_report</name> <init>= <expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>sender_bb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>space_left</name> = <call><name>calc_space_left</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>sender_bb</name></expr></argument>)</argument_list></call> &amp;&amp; <name>APR_SUCCESS</name> == <name>rv</name></expr>)</condition> <block>{
                <if>if <condition>(<expr><name>space_left</name> &lt;= 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>report_prod_io</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>force_report</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rv</name> = <call><name>wait_not_full</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr>&amp;<name>space_left</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>APR_SUCCESS</name> != <name>rv</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                }</block></then></if>
                <expr_stmt><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>sender_bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name>append_bucket</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr>&amp;<name>space_left</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            
            <expr_stmt><expr><call><name>report_prod_io</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>force_report</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><call><name>report_consumption</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_beam_receive</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                             <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, 
                             <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                             <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bsender</name></decl>, *<decl><type ref="prev"/><name>brecv</name></decl>, *<decl><type ref="prev"/><name>ng</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>transferred</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>remain</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>transferred_buckets</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    
    <comment type="block">/* Called from the receiver thread to take buckets from the beam */</comment>
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>readbytes</name> &lt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>readbytes</name> = <name>APR_SIZE_MAX</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>remain</name> = <name>readbytes</name></expr>;</expr_stmt>
        
<label><name>transfer</name>:</label>
        <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>recv_buffer_cleanup</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
            <goto>goto <name>leave</name>;</goto>
        }</block></then></if>

        <comment type="block">/* transfer enough buckets from our receiver brigade, if we have one */</comment>
        <while>while <condition>(<expr><name>remain</name> &gt;= 0 
               &amp;&amp; <name><name>beam</name>-&gt;<name>recv_buffer</name></name> 
               &amp;&amp; !<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
               
            <expr_stmt><expr><name>brecv</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>brecv</name>-&gt;<name>length</name></name> &gt; 0 &amp;&amp; <name>remain</name> &lt;= 0</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>            
            <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>brecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>brecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>remain</name> -= <name><name>brecv</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>transferred</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* transfer from our sender brigade, transforming sender buckets to
         * receiver ones until we have enough */</comment>
        <while>while <condition>(<expr><name>remain</name> &gt;= 0 &amp;&amp; !<call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
               
            <expr_stmt><expr><name>brecv</name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>bsender</name> = <call><name>H2_BLIST_FIRST</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>            
            <if>if <condition>(<expr><name><name>bsender</name>-&gt;<name>length</name></name> &gt; 0 &amp;&amp; <name>remain</name> &lt;= 0</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
                        
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>brecv</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>beam</name>-&gt;<name>close_sent</name></name> = 1</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FLUSH</name><argument_list>(<argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>brecv</name> = <call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name>AP_BUCKET_IS_ERROR</name><argument_list>(<argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>ap_bucket_error</name> *</type><name>eb</name> <init>= <expr>(<name>ap_bucket_error</name> *)<name>bsender</name></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name>brecv</name> = <call><name>ap_bucket_error_create</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>data</name></name></expr></argument>,
                                                    <argument><expr><name><name>bb</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if></else></if></else></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>bsender</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>H2_BLIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>, <argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FILE</name><argument_list>(<argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* This is set aside into the target brigade pool so that 
                 * any read operation messes with that pool and not 
                 * the sender one. */</comment>
                <decl_stmt><decl><type><name>apr_bucket_file</name> *</type><name>f</name> <init>= <expr>(<name>apr_bucket_file</name> *)<name><name>bsender</name>-&gt;<name>data</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name> <init>= <expr><name><name>f</name>-&gt;<name>fd</name></name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>setaside</name> <init>= <expr>(<name><name>f</name>-&gt;<name>readpool</name></name> != <name><name>bb</name>-&gt;<name>p</name></name>)</expr></init></decl>;</decl_stmt>
                
                <if>if <condition>(<expr><name>setaside</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>status</name> = <call><name>apr_file_setaside</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>bb</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <goto>goto <name>leave</name>;</goto>
                    }</block></then></if>
                    <expr_stmt><expr>++<name><name>beam</name>-&gt;<name>files_beamed</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>ng</name> = <call><name>apr_brigade_insert_file</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>bsender</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>bsender</name>-&gt;<name>length</name></name></expr></argument>, 
                                             <argument><expr><name><name>bb</name>-&gt;<name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_MMAP</name></expr></cpp:if>
                <comment type="block">/* disable mmap handling as this leads to segfaults when
                 * the underlying file is changed while memory pointer has
                 * been handed out. See also PR 59348 */</comment>
                <expr_stmt><expr><call><name>apr_bucket_file_enable_mmap</name><argument_list>(<argument><expr><name>ng</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>H2_BLIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>, <argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>remain</name> -= <name><name>bsender</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>transferred</name></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>transferred_buckets</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* create a "receiver" standin bucket. we took care about the
                 * underlying sender bucket and its data when we placed it into
                 * the sender brigade.
                 * the beam bucket will notify us on destruction that bsender is
                 * no longer needed. */</comment>
                <expr_stmt><expr><name>brecv</name> = <call><name>h2_beam_bucket_create</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>bsender</name></expr></argument>, <argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>,
                                               <argument><expr><name><name>beam</name>-&gt;<name>buckets_sent</name></name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if></else></if>
            
            <comment type="block">/* Place the sender bucket into our hold, to be destroyed when no
             * receiver bucket references it any more. */</comment>
            <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>H2_BLIST_INSERT_TAIL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>hold_list</name></name></expr></argument>, <argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><name><name>beam</name>-&gt;<name>received_bytes</name></name> += <name><name>bsender</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>transferred_buckets</name></expr>;</expr_stmt>
            
            <if>if <condition>(<expr><name>brecv</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>brecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>remain</name> -= <name><name>brecv</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>transferred</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* let outside hook determine how bucket is beamed */</comment>
                <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>brecv</name> = <call><name>h2_beam_bucket</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bsender</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                
                <while>while <condition>(<expr><name>brecv</name> &amp;&amp; <name>brecv</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                    <expr_stmt><expr>++<name>transferred</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>remain</name> -= <name><name>brecv</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>brecv</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>brecv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></while>
            }</block></else></if>
        }</block></while>

        <if>if <condition>(<expr><name>remain</name> &lt; 0</expr>)</condition><then> <block>{
            <comment type="block">/* too much, put some back into out recv_buffer */</comment>
            <expr_stmt><expr><name>remain</name> = <name>readbytes</name></expr>;</expr_stmt>
            <for>for (<init><expr><name>brecv</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
                 <condition><expr><name>brecv</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
                 <incr><expr><name>brecv</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>brecv</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
                <expr_stmt><expr><name>remain</name> -= (<name><name>beam</name>-&gt;<name>tx_mem_limits</name></name>? <call><name>bucket_mem_used</name><argument_list>(<argument><expr><name>brecv</name></expr></argument>)</argument_list></call> 
                           : <name><name>brecv</name>-&gt;<name>length</name></name>)</expr>;</expr_stmt>
                <if>if <condition>(<expr><name>remain</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>brecv</name></expr></argument>, <argument><expr><name><name>brecv</name>-&gt;<name>length</name></name>+<name>remain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name> = <call><name>apr_brigade_split_ex</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, 
                                                             <argument><expr><call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>brecv</name></expr></argument>)</argument_list></call></expr></argument>, 
                                                             <argument><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>closed</name></name> &amp;&amp; <call><name>buffer_is_empty</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* beam is closed and we have nothing more to receive */</comment> 
            <if>if <condition>(<expr>!<name><name>beam</name>-&gt;<name>close_sent</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>beam</name>-&gt;<name>close_sent</name></name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr>++<name>transferred</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        
        <if>if <condition>(<expr><name>transferred_buckets</name> &gt; 0</expr>)</condition><then> <block>{
           <if>if <condition>(<expr><name><name>beam</name>-&gt;<name>cons_ev_cb</name></name></expr>)</condition><then> <block>{ 
               <expr_stmt><expr><call><name><name>beam</name>-&gt;<name>cons_ev_cb</name></name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>cons_ctx</name></name></expr></argument>, <argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        
        <if>if <condition>(<expr><name>transferred</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_thread_cond_broadcast</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>change</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>status</name> = <call><name>wait_not_empty</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>bl</name>.<name>mutex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <goto>goto <name>leave</name>;</goto>
            }</block></then></if>
            <goto>goto <name>transfer</name>;</goto>
        }</block></else></if>
<label><name>leave</name>:</label>        
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>h2_beam_on_consumed</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                         <param><decl><type><name>h2_beam_ev_callback</name> *</type><name>ev_cb</name></decl></param>,
                         <param><decl><type><name>h2_beam_io_callback</name> *</type><name>io_cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>cons_ev_cb</name></name> = <name>ev_cb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>cons_io_cb</name></name> = <name>io_cb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>cons_ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name>h2_beam_on_produced</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                         <param><decl><type><name>h2_beam_io_callback</name> *</type><name>io_cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>prod_io_cb</name></name> = <name>io_cb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>prod_ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name>h2_beam_on_file_beam</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                          <param><decl><type><name>h2_beam_can_beam_callback</name> *</type><name>cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>can_beam_fn</name></name> = <name>cb</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>beam</name>-&gt;<name>can_beam_ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>


<function><type><name>apr_off_t</name></type> <name>h2_beam_get_buffered</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>l</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>b</name> = <call><name>H2_BLIST_FIRST</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</init> 
            <condition><expr><name>b</name> != <call><name>H2_BLIST_SENTINEL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</condition>
            <incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
            <comment type="block">/* should all have determinate length */</comment>
            <expr_stmt><expr><name>l</name> += <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>l</name></expr>;</return>
}</block></function>

<function><type><name>apr_off_t</name></type> <name>h2_beam_get_mem_used</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>l</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>b</name> = <call><name>H2_BLIST_FIRST</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</init> 
            <condition><expr><name>b</name> != <call><name>H2_BLIST_SENTINEL</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call></expr>;</condition>
            <incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
            <expr_stmt><expr><name>l</name> += <call><name>bucket_mem_used</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>l</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>h2_beam_empty</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>empty</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>empty</name> = (<call><name>H2_BLIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>send_list</name></name></expr></argument>)</argument_list></call> 
                 &amp;&amp; (!<name><name>beam</name>-&gt;<name>recv_buffer</name></name> || <call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>beam</name>-&gt;<name>recv_buffer</name></name></expr></argument>)</argument_list></call>))</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>empty</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>h2_beam_holds_proxies</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>has_proxies</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>has_proxies</name> = !<call><name>H2_BPROXY_LIST_EMPTY</name><argument_list>(<argument><expr>&amp;<name><name>beam</name>-&gt;<name>proxies</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>has_proxies</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>h2_beam_was_received</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>happend</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>happend</name> = (<name><name>beam</name>-&gt;<name>received_bytes</name></name> &gt; 0)</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>happend</name></expr>;</return>
}</block></function>

<function><type><name>apr_size_t</name></type> <name>h2_beam_get_files_beamed</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>n</name> = <name><name>beam</name>-&gt;<name>files_beamed</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>h2_beam_no_files</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>h2_beam_report_consumption</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_beam_lock</name></type> <name>bl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>enter_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>report_consumption</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>leave_yellow</name><argument_list>(<argument><expr><name>beam</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>h2_beam_log</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>beam</name> &amp;&amp; <call><name>APLOG_C_IS_LEVEL</name><argument_list>(<argument><expr><name>c</name></expr></argument>,<argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, 
                      <argument><expr>"beam(%ld-%d,%s,closed=%d,aborted=%d,empty=%d,buf=%ld): %s"</expr></argument>, 
                      <argument><expr>(<name><name>c</name>-&gt;<name>master</name></name>? <name><name>c</name>-&gt;<name>master</name>-&gt;<name>id</name></name> : <name><name>c</name>-&gt;<name>id</name></name>)</expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>tag</name></name></expr></argument>, 
                      <argument><expr><name><name>beam</name>-&gt;<name>closed</name></name></expr></argument>, <argument><expr><name><name>beam</name>-&gt;<name>aborted</name></name></expr></argument>, <argument><expr><call><name>h2_beam_empty</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr></argument>, 
                      <argument><expr>(<name>long</name>)<call><name>h2_beam_get_buffered</name><argument_list>(<argument><expr><name>beam</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>


</unit>
