<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/http2/h2_util.h"><comment type="block">/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__mod_h2__h2_util__</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__mod_h2__h2_util__</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;nghttp2/nghttp2.h&gt;</cpp:file></cpp:include>

<comment type="block">/*******************************************************************************
 * some debugging/format helpers
 ******************************************************************************/</comment>
<struct_decl>struct <name>h2_request</name>;</struct_decl>
<struct_decl>struct <name>nghttp2_frame</name>;</struct_decl>

<function_decl><type><name>size_t</name></type> <name>h2_util_hex_dump</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>maxlen</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>datalen</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>h2_util_header_print</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>maxlen</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>namelen</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>valuelen</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>h2_util_camel_case_header</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>h2_util_frame_print</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>nghttp2_frame</name> *</type><name>frame</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>maxlen</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * ihash - hash for structs with int identifier
 ******************************************************************************/</comment>
<typedef>typedef <type>struct <name>h2_ihash_t</name></type> <name>h2_ihash_t</name>;</typedef>
<typedef>typedef <function_decl><type><name>int</name></type> <name>h2_ihash_iter_t</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/**
 * Create a hash for structures that have an identifying int member.
 * @param pool the pool to use
 * @param offset_of_int the offsetof() the int member in the struct
 */</comment>
<function_decl><type><name>h2_ihash_t</name> *</type><name>h2_ihash_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>offset_of_int</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>h2_ihash_count</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>h2_ihash_empty</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name> *</type><name>h2_ihash_get</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Iterate over the hash members (without defined order) and invoke
 * fn for each member until 0 is returned.
 * @param ih the hash to iterate over
 * @param fn the function to invoke on each member
 * @param ctx user supplied data passed into each iteration call
 * @return 0 if one iteration returned 0, otherwise != 0
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_ihash_iter</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>h2_ihash_iter_t</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>h2_ihash_add</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>h2_ihash_remove</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>h2_ihash_remove_val</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> *</type><name>val</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>h2_ihash_clear</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>size_t</name></type> <name>h2_ihash_shift</name><parameter_list>(<param><decl><type><name>h2_ihash_t</name> *</type><name>ih</name></decl></param>, <param><decl><type><name>void</name> **</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>max</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * iqueue - sorted list of int with user defined ordering
 ******************************************************************************/</comment>
<typedef>typedef <type><struct>struct <name>h2_iqueue</name> <block>{
    <decl_stmt><decl><type><name>int</name> *</type><name>elts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nelts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>nalloc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block></struct></type> <name>h2_iqueue</name>;</typedef>

<comment type="block">/**
 * Comparator for two int to determine their order.
 *
 * @param i1 first int to compare
 * @param i2 second int to compare
 * @param ctx provided user data
 * @return value is the same as for strcmp() and has the effect:
 *    == 0: s1 and s2 are treated equal in ordering
 *     &lt; 0: s1 should be sorted before s2
 *     &gt; 0: s2 should be sorted before s1
 */</comment>
<typedef>typedef <function_decl><type><name>int</name></type> <name>h2_iq_cmp</name><parameter_list>(<param><decl><type><name>int</name></type> <name>i1</name></decl></param>, <param><decl><type><name>int</name></type> <name>i2</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/**
 * Allocate a new queue from the pool and initialize.
 * @param id the identifier of the queue
 * @param pool the memory pool
 */</comment>
<function_decl><type><name>h2_iqueue</name> *</type><name>h2_iq_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return != 0 iff there are no tasks in the queue.
 * @param q the queue to check
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_iq_empty</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return the number of int in the queue.
 * @param q the queue to get size on
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_iq_count</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Add a stream id to the queue. 
 *
 * @param q the queue to append the id to
 * @param sid the stream id to add
 * @param cmp the comparator for sorting
 * @param ctx user data for comparator
 * @return != 0 iff id was not already there 
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_iq_add</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>, <param><decl><type><name>h2_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Append the id to the queue if not already present. 
 *
 * @param q the queue to append the id to
 * @param sid the id to append
 * @return != 0 iff id was not already there 
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_iq_append</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Remove the stream id from the queue. Return != 0 iff task
 * was found in queue.
 * @param q the task queue
 * @param sid the stream id to remove
 * @return != 0 iff task was found in queue
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_iq_remove</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Remove all entries in the queue.
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_iq_clear</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Sort the stream idqueue again. Call if the task ordering
 * has changed.
 *
 * @param q the queue to sort
 * @param cmp the comparator for sorting
 * @param ctx user data for the comparator 
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_iq_sort</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>h2_iq_cmp</name> *</type><name>cmp</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get the first id from the queue or 0 if the queue is empty. 
 * The id is being removed.
 *
 * @param q the queue to get the first id from
 * @return the first id of the queue, 0 if empty
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_iq_shift</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get the first max ids from the queue. All these ids will be removed.
 *
 * @param q the queue to get the first task from
 * @param pint the int array to receive the values
 * @param max the maximum number of ids to shift
 * @return the actual number of ids shifted
 */</comment>
<function_decl><type><name>size_t</name></type> <name>h2_iq_mshift</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pint</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>max</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Determine if int is in the queue already
 *
 * @parm q the queue
 * @param sid the integer id to check for
 * @return != 0 iff sid is already in the queue
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_iq_contains</name><parameter_list>(<param><decl><type><name>h2_iqueue</name> *</type><name>q</name></decl></param>, <param><decl><type><name>int</name></type> <name>sid</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * FIFO queue (void* elements)
 ******************************************************************************/</comment>

<comment type="block">/**
 * A thread-safe FIFO queue with some extra bells and whistles, if you
 * do not need anything special, better use 'apr_queue'.
 */</comment>
<typedef>typedef <type>struct <name>h2_fifo</name></type> <name>h2_fifo</name>;</typedef>

<comment type="block">/**
 * Create a FIFO queue that can hold up to capacity elements. Elements can
 * appear several times.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_create</name><parameter_list>(<param><decl><type><name>h2_fifo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Create a FIFO set that can hold up to capacity elements. Elements only
 * appear once. Pushing an element already present does not change the
 * queue and is successful.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_set_create</name><parameter_list>(<param><decl><type><name>h2_fifo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_term</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_interrupt</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>h2_fifo_count</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Push en element into the queue. Blocks if there is no capacity left.
 * 
 * @param fifo the FIFO queue
 * @param elem the element to push
 * @return APR_SUCCESS on push, APR_EAGAIN on try_push on a full queue,
 *         APR_EEXIST when in set mode and elem already there.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_push</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_try_push</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_pull</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_try_pull</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> **</type><name>pelem</name></decl></param>)</parameter_list>;</function_decl>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>H2_FIFO_OP_PULL</name></decl>,   <comment type="block">/* pull the element from the queue, ie discard it */</comment>
    <decl><name>H2_FIFO_OP_REPUSH</name></decl>, <comment type="block">/* pull and immediatley re-push it */</comment>
}</block></enum></type> <name>h2_fifo_op_t</name>;</typedef>

<typedef>typedef <function_decl><type><name>h2_fifo_op_t</name></type> <name>h2_fifo_peek_fn</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>head</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/**
 * Call given function on the head of the queue, once it exists, and
 * perform the returned operation on it. The queue will hold its lock during
 * this time, so no other operations on the queue are possible.
 * @param fifo the queue to peek at
 * @param fn   the function to call on the head, once available
 * @param ctx  context to pass in call to function
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_peek</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_fifo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Non-blocking version of h2_fifo_peek.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_try_peek</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_fifo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Remove the elem from the queue, will remove multiple appearances.
 * @param elem  the element to remove
 * @return APR_SUCCESS iff &gt; 0 elems were removed, APR_EAGAIN otherwise.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_fifo_remove</name><parameter_list>(<param><decl><type><name>h2_fifo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>void</name> *</type><name>elem</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * iFIFO queue (int elements)
 ******************************************************************************/</comment>

<comment type="block">/**
 * A thread-safe FIFO queue with some extra bells and whistles, if you
 * do not need anything special, better use 'apr_queue'.
 */</comment>
<typedef>typedef <type>struct <name>h2_ififo</name></type> <name>h2_ififo</name>;</typedef>

<comment type="block">/**
 * Create a FIFO queue that can hold up to capacity int. ints can
 * appear several times.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_create</name><parameter_list>(<param><decl><type><name>h2_ififo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Create a FIFO set that can hold up to capacity integers. Ints only
 * appear once. Pushing an int already present does not change the
 * queue and is successful.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_set_create</name><parameter_list>(<param><decl><type><name>h2_ififo</name> **</type><name>pfifo</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>int</name></type> <name>capacity</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_term</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_interrupt</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>h2_ififo_count</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Push an int into the queue. Blocks if there is no capacity left.
 * 
 * @param fifo the FIFO queue
 * @param id  the int to push
 * @return APR_SUCCESS on push, APR_EAGAIN on try_push on a full queue,
 *         APR_EEXIST when in set mode and elem already there.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_push</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_try_push</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_pull</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pi</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_try_pull</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name> *</type><name>pi</name></decl></param>)</parameter_list>;</function_decl>

<typedef>typedef <function_decl><type><name>h2_fifo_op_t</name></type> <name>h2_ififo_peek_fn</name><parameter_list>(<param><decl><type><name>int</name></type> <name>head</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/**
 * Call given function on the head of the queue, once it exists, and
 * perform the returned operation on it. The queue will hold its lock during
 * this time, so no other operations on the queue are possible.
 * @param fifo the queue to peek at
 * @param fn   the function to call on the head, once available
 * @param ctx  context to pass in call to function
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_peek</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_ififo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Non-blocking version of h2_fifo_peek.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_try_peek</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>h2_ififo_peek_fn</name> *</type><name>fn</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Remove the integer from the queue, will remove multiple appearances.
 * @param id  the integer to remove
 * @return APR_SUCCESS iff &gt; 0 ints were removed, APR_EAGAIN otherwise.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_ififo_remove</name><parameter_list>(<param><decl><type><name>h2_ififo</name> *</type><name>fifo</name></decl></param>, <param><decl><type><name>int</name></type> <name>id</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * common helpers
 ******************************************************************************/</comment>
<comment type="block">/* h2_log2(n) iff n is a power of 2 */</comment>
<function_decl><type><name>unsigned</name> <name>char</name></type> <name>h2_log2</name><parameter_list>(<param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Count the bytes that all key/value pairs in a table have
 * in length (exlucding terminating 0s), plus additional extra per pair.
 *
 * @param t the table to inspect
 * @param pair_extra the extra amount to add per pair
 * @return the number of bytes all key/value pairs have
 */</comment>
<function_decl><type><name>apr_size_t</name></type> <name>h2_util_table_bytes</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>t</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>pair_extra</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Match a header value against a string constance, case insensitive */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_HD_MATCH_LIT</name><parameter_list>(<param><type><name>l</name></type></param>, <param><type><name>name</name></type></param>, <param><type><name>nlen</name></type></param>)</parameter_list></cpp:macro>  \
    <cpp:value>((nlen == sizeof(l) - 1) &amp;&amp; !apr_strnatcasecmp(l, name))</cpp:value></cpp:define>

<comment type="block">/*******************************************************************************
 * HTTP/2 header helpers
 ******************************************************************************/</comment>
<function_decl><type><name>int</name></type> <name>h2_req_ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>h2_req_ignore_trailer</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> <name>h2_res_ignore_trailer</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Set the push policy for the given request. Takes request headers into 
 * account, see draft https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00
 * for details.
 * 
 * @param headers the http headers to inspect
 * @param p the pool to use
 * @param push_enabled if HTTP/2 server push is generally enabled for this request
 * @return the push policy desired
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_push_policy_determine</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>push_enabled</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * base64 url encoding, different table from normal base64
 ******************************************************************************/</comment>
<comment type="block">/**
 * I always wanted to write my own base64url decoder...not. See 
 * https://tools.ietf.org/html/rfc4648#section-5 for description.
 */</comment>
<function_decl><type><name>apr_size_t</name></type> <name>h2_util_base64url_decode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>decoded</name></decl></param>, 
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoded</name></decl></param>, 
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>h2_util_base64url_encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, 
                                     <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * nghttp2 helpers
 ******************************************************************************/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_HD_MATCH_LIT_CS</name><parameter_list>(<param><type><name>l</name></type></param>, <param><type><name>name</name></type></param>)</parameter_list></cpp:macro>  \
    <cpp:value>((strlen(name) == sizeof(l) - 1) &amp;&amp; !apr_strnatcasecmp(l, name))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_CREATE_NV_LIT_CS</name><parameter_list>(<param><type><name>nv</name></type></param>, <param><type><name>NAME</name></type></param>, <param><type><name>VALUE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>nv-&gt;name = (uint8_t *)NAME;      \
                                             nv-&gt;namelen = sizeof(NAME) - 1;  \
                                             nv-&gt;value = (uint8_t *)VALUE;    \
                                             nv-&gt;valuelen = strlen(VALUE)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_CREATE_NV_CS_LIT</name><parameter_list>(<param><type><name>nv</name></type></param>, <param><type><name>NAME</name></type></param>, <param><type><name>VALUE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>nv-&gt;name = (uint8_t *)NAME;      \
                                             nv-&gt;namelen = strlen(NAME);      \
                                             nv-&gt;value = (uint8_t *)VALUE;    \
                                             nv-&gt;valuelen = sizeof(VALUE) - 1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_CREATE_NV_CS_CS</name><parameter_list>(<param><type><name>nv</name></type></param>, <param><type><name>NAME</name></type></param>, <param><type><name>VALUE</name></type></param>)</parameter_list></cpp:macro> <cpp:value>nv-&gt;name = (uint8_t *)NAME;       \
                                            nv-&gt;namelen = strlen(NAME);       \
                                            nv-&gt;value = (uint8_t *)VALUE;     \
                                            nv-&gt;valuelen = strlen(VALUE)</cpp:value></cpp:define>

<function_decl><type><name>int</name></type> <name>h2_util_ignore_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>

<struct_decl>struct <name>h2_headers</name>;</struct_decl>

<typedef>typedef <type><struct>struct <name>h2_ngheader</name> <block>{
    <decl_stmt><decl><type><name>nghttp2_nv</name> *</type><name>nv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nvlen</name></decl>;</decl_stmt>
}</block></struct></type> <name>h2_ngheader</name>;</typedef>

<function_decl><type><name>apr_status_t</name></type> <name>h2_res_create_ngtrailer</name><parameter_list>(<param><decl><type><name>h2_ngheader</name> **</type><name>ph</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, 
                                     <param><decl><type>struct <name>h2_headers</name> *</type><name>headers</name></decl></param>)</parameter_list>;</function_decl> 
<function_decl><type><name>apr_status_t</name></type> <name>h2_res_create_ngheader</name><parameter_list>(<param><decl><type><name>h2_ngheader</name> **</type><name>ph</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, 
                                    <param><decl><type>struct <name>h2_headers</name> *</type><name>headers</name></decl></param>)</parameter_list>;</function_decl> 
<function_decl><type><name>apr_status_t</name></type> <name>h2_req_create_ngheader</name><parameter_list>(<param><decl><type><name>h2_ngheader</name> **</type><name>ph</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, 
                                    <param><decl><type><specifier>const</specifier> struct <name>h2_request</name> *</type><name>req</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>apr_status_t</name></type> <name>h2_req_add_header</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, 
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nlen</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>vlen</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * h2_request helpers
 ******************************************************************************/</comment>

<function_decl><type>struct <name>h2_request</name> *</type><name>h2_req_create</name><parameter_list>(<param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>method</name></decl></param>, 
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authority</name></decl></param>, 
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_table_t</name> *</type><name>header</name></decl></param>,
                                 <param><decl><type><name>int</name></type> <name>serialize</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*******************************************************************************
 * apr brigade helpers
 ******************************************************************************/</comment>

<comment type="block">/**
 * Concatenate at most length bytes from src to dest brigade, splitting
 * buckets if necessary and reading buckets of indeterminate length.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_brigade_concat_length</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>dest</name></decl></param>, 
                                      <param><decl><type><name>apr_bucket_brigade</name> *</type><name>src</name></decl></param>,
                                      <param><decl><type><name>apr_off_t</name></type> <name>length</name></decl></param>)</parameter_list>;</function_decl>
                                
<comment type="block">/**
 * Copy at most length bytes from src to dest brigade, splitting
 * buckets if necessary and reading buckets of indeterminate length.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_brigade_copy_length</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>dest</name></decl></param>, 
                                    <param><decl><type><name>apr_bucket_brigade</name> *</type><name>src</name></decl></param>,
                                    <param><decl><type><name>apr_off_t</name></type> <name>length</name></decl></param>)</parameter_list>;</function_decl>
                                
<comment type="block">/**
 * Return != 0 iff there is a FLUSH or EOS bucket in the brigade.
 * @param bb the brigade to check on
 * @return != 0 iff brigade holds FLUSH or EOS bucket (or both)
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_util_has_eos</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Check how many bytes of the desired amount are available and if the
 * end of stream is reached by that amount.
 * @param bb the brigade to check
 * @param plen the desired length and, on return, the available length
 * @param on return, if eos has been reached
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_util_bb_avail</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, 
                              <param><decl><type><name>apr_off_t</name> *</type><name>plen</name></decl></param>, <param><decl><type><name>int</name> *</type><name>peos</name></decl></param>)</parameter_list>;</function_decl>

<typedef>typedef <function_decl><type><name>apr_status_t</name></type> <name>h2_util_pass_cb</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, 
                                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/**
 * Read at most *plen bytes from the brigade and pass them into the
 * given callback. If cb is NULL, just return the amount of data that
 * could have been read.
 * If an EOS was/would be encountered, set *peos != 0.
 * @param bb the brigade to read from
 * @param cb the callback to invoke for the read data
 * @param ctx optional data passed to callback
 * @param plen inout, as input gives the maximum number of bytes to read,
 *    on return specifies the actual/would be number of bytes
 * @param peos != 0 iff an EOS bucket was/would be encountered.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_util_bb_readx</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, 
                              <param><decl><type><name>h2_util_pass_cb</name> *</type><name>cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, 
                              <param><decl><type><name>apr_off_t</name> *</type><name>plen</name></decl></param>, <param><decl><type><name>int</name> *</type><name>peos</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Print a bucket's meta data (type and length) to the buffer.
 * @return number of characters printed
 */</comment>
<function_decl><type><name>apr_size_t</name></type> <name>h2_util_bucket_print</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bmax</name></decl></param>, 
                                <param><decl><type><name>apr_bucket</name> *</type><name>b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl></param>)</parameter_list>;</function_decl>
                                
<comment type="block">/**
 * Prints the brigade bucket types and lengths into the given buffer
 * up to bmax.
 * @return number of characters printed
 */</comment>
<function_decl><type><name>apr_size_t</name></type> <name>h2_util_bb_print</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bmax</name></decl></param>, 
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl></param>, 
                            <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/**
 * Logs the bucket brigade (which bucket types with what length)
 * to the log at the given level.
 * @param c the connection to log for
 * @param sid the stream identifier this brigade belongs to
 * @param level the log level (as in APLOG_*)
 * @param tag a short message text about the context
 * @param bb the brigade to log
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>h2_util_bb_log</name><parameter_list>(<param><type><name>c</name></type></param>, <param><type><name>sid</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>tag</name></type></param>, <param><type><name>bb</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>do { \
    char buffer[4 * 1024]; \
    const char *line = "(null)"; \
    apr_size_t len, bmax = sizeof(buffer)/sizeof(buffer[0]); \
    len = h2_util_bb_print(buffer, bmax, (tag), "", (bb)); \
    ap_log_cerror(APLOG_MARK, level, 0, (c), "bb_dump(%ld): %s", \
        ((c)-&gt;master? (c)-&gt;master-&gt;id : (c)-&gt;id), (len? buffer : line)); \
} while(0)</cpp:value></cpp:define>


<typedef>typedef <function_decl><type><name>int</name></type> <name>h2_bucket_gate</name><parameter_list>(<param><decl><type><name>apr_bucket</name> *</type><name>b</name></decl></param>)</parameter_list>;</function_decl></typedef>
<comment type="block">/**
 * Transfer buckets from one brigade to another with a limit on the 
 * maximum amount of bytes transferred. Does no setaside magic, lifetime
 * of brigades must fit. 
 * @param to   brigade to transfer buckets to
 * @param from brigades to remove buckets from
 * @param plen maximum bytes to transfer, actual bytes transferred
 * @param peos if an EOS bucket was transferred
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_append_brigade</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>to</name></decl></param>,
                               <param><decl><type><name>apr_bucket_brigade</name> *</type><name>from</name></decl></param>, 
                               <param><decl><type><name>apr_off_t</name> *</type><name>plen</name></decl></param>,
                               <param><decl><type><name>int</name> *</type><name>peos</name></decl></param>,
                               <param><decl><type><name>h2_bucket_gate</name> *</type><name>should_append</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get an approximnation of the memory footprint of the given
 * brigade. This varies from apr_brigade_length as
 * - no buckets are ever read
 * - only buckets known to allocate memory (HEAP+POOL) are counted
 * - the bucket struct itself is counted
 */</comment>
<function_decl><type><name>apr_off_t</name></type> <name>h2_brigade_mem_size</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__mod_h2__h2_util__) */</comment>
</unit>
