<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/http2/h2_from_h1.c"><comment type="block">/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_date.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_connection.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_protocol.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_request.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;util_time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_headers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_from_h1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_task.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_util.h"</cpp:file></cpp:include>


<comment type="block">/* This routine is called by apr_table_do and merges all instances of
 * the passed field values into a single array that will be further
 * processed by some later routine.  Originally intended to help split
 * and recombine multiple Vary fields, though it is generic to any field
 * consisting of comma/space-separated tokens.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>uniq_field_values</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>d</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>strpp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name></decl>;</decl_stmt>
    
    <expr_stmt><expr>(<name>void</name>)<name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>values</name> = (<name>apr_array_header_t</name> *)<name>d</name></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>e</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>values</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <do>do <block>{
        <comment type="block">/* Find a non-empty fieldname */</comment>
        
        <while>while <condition>(<expr>*<name>e</name> == ',' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>e</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>*<name>e</name> == '\0'</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>start</name> = <name>e</name></expr>;</expr_stmt>
        <while>while <condition>(<expr>*<name>e</name> != '\0' &amp;&amp; *<name>e</name> != ',' &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>e</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>*<name>e</name> != '\0'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>e</name>++ = '\0'</expr>;</expr_stmt>
        }</block></then></if>
        
        <comment type="block">/* Now add it to values if it isn't already represented.
         * Could be replaced by a ap_array_strcasecmp() if we had one.
         */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>strpp</name> = (<name>char</name> **) <name><name>values</name>-&gt;<name>elts</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name><name>values</name>-&gt;<name>nelts</name></name></expr>;</condition>
             <incr><expr>++<name>i</name></expr>, <expr>++<name>strpp</name></expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>strpp</name> &amp;&amp; <call><name>apr_strnatcasecmp</name><argument_list>(<argument><expr>*<name>strpp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>i</name> == <name><name>values</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{  <comment type="block">/* if not found */</comment>
            <expr_stmt><expr>*(<name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call> = <name>start</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block> while <condition>(<expr>*<name>e</name> != '\0'</expr>)</condition>;</do>
    
    <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
 * Since some clients choke violently on multiple Vary fields, or
 * Vary fields with duplicate tokens, combine any multiples and remove
 * any duplicates.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fix_vary</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>varies</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>varies</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Extract all Vary fields from the headers_out, separate each into
     * its comma-separated fieldname values, and then add them to varies
     * if not already present in the array.
     */</comment>
    <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>uniq_field_values</name></expr></argument>, <argument><expr><name>varies</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* If we found any, replace old Vary fields with unique-ified value */</comment>
    
    <if>if <condition>(<expr><name><name>varies</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>,
                       <argument><expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>varies</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_basic_http_header</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>date</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proxy_date</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>server</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>us</name> <init>= <expr><call><name>ap_get_server_banner</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/*
     * keep the set-by-proxy server and date headers, otherwise
     * generate a new server header / date header
     */</comment>
    <if>if <condition>(<expr><name>r</name> &amp;&amp; <name><name>r</name>-&gt;<name>proxyreq</name></name> != <name>PROXYREQ_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>proxy_date</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Date"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>proxy_date</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * proxy_date needs to be const. So use date for the creation of
             * our own Date header and pass it over to proxy_date later to
             * avoid a compiler warning.
             */</comment>
            <expr_stmt><expr><name>date</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>APR_RFC822_DATE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_recent_rfc822_date</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>server</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Server"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>date</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>APR_RFC822_DATE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_recent_rfc822_date</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name>r</name>? <name><name>r</name>-&gt;<name>request_time</name></name> : <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"Date"</expr></argument>, <argument><expr><name>proxy_date</name> ? <name>proxy_date</name> : <name>date</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>r</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Date"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr>!<name>server</name> &amp;&amp; *<name>us</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>server</name> = <name>us</name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><name>server</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr>"Server"</expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>r</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Server"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>copy_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>apr_table_addn</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>h2_headers</name> *</type><name>create_response</name><parameter_list>(<param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>clheader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ctype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl>;</decl_stmt>
    <comment type="block">/*
     * Now that we are ready to send a response, we need to combine the two
     * header field tables into a single table.  If we don't do this, our
     * later attempts to set or unset a given fieldname might be bypassed.
     */</comment>
    <if>if <condition>(<expr>!<call><name>apr_is_empty_table</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>headers_out</name></name> = <call><name>apr_table_overlay</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>,
                                           <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_clear</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <comment type="block">/*
     * Remove the 'Vary' header field if the client can't handle it.
     * Since this will have nasty effects on HTTP/1.1 caches, force
     * the response into HTTP/1.0 mode.
     */</comment>
    <if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"force-no-vary"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"force-response-1.0"</expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>fix_vary</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    
    <comment type="block">/*
     * Now remove any ETag response header field if earlier processing
     * says so (such as a 'FileETag None' directive).
     */</comment>
    <if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"no-etag"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"ETag"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <comment type="block">/* determine the protocol and whether we should use keepalives. */</comment>
    <expr_stmt><expr><call><name>ap_set_keepalive</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>chunked</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <expr_stmt><expr><name>ctype</name> = <call><name>ap_make_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>content_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ctype</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Type"</expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>content_encoding</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Encoding"</expr></argument>,
                       <argument><expr><name><name>r</name>-&gt;<name>content_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr>!<call><name>apr_is_empty_array</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>content_languages</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> **</type><name>languages</name> <init>= <expr><call>(<name>char</name> **)<argument_list>(<argument><expr><name><name>r</name>-&gt;<name>content_languages</name>-&gt;<name>elts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>field</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Language"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        
        <while>while <condition>(<expr><name>field</name> &amp;&amp; (<name>token</name> = <call><name>ap_get_list_item</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>r</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<call><name>apr_strnatcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>languages</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>i</name> == <name><name>r</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*((<name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>content_languages</name></name></expr></argument>)</argument_list></call>) = <name>token</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>
        
        <expr_stmt><expr><name>field</name> = <call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>content_languages</name></name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Language"</expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <comment type="block">/*
     * Control cachability for non-cachable responses if not already set by
     * some other part of the server configuration.
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>no_cache</name></name> &amp;&amp; !<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Expires"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>date</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>APR_RFC822_DATE_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_recent_rfc822_date</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_addn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Expires"</expr></argument>, <argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <comment type="block">/* This is a hack, but I can't find anyway around it.  The idea is that
     * we don't want to send out 0 Content-Lengths if it is a head request.
     * This happens when modules try to outsmart the server, and return
     * if they see a HEAD request.  Apache 1.3 handlers were supposed to
     * just return in that situation, and the core handled the HEAD.  In
     * 2.0, if a handler returns, then the core sends an EOS bucket down
     * the filter stack, and the content-length filter computes a C-L of
     * zero and that gets put in the headers, and we end up sending a
     * zero C-L to the client.  We can't just remove the C-L filter,
     * because well behaved 2.0 handlers will send their data down the stack,
     * and we will compute a real C-L for the head request. RBB
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>header_only</name></name>
        &amp;&amp; (<name>clheader</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call>)
        &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>clheader</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <expr_stmt><expr><name>headers</name> = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>set_basic_http_header</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>status</name></name> == <name>HTTP_NOT_MODIFIED</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>copy_header</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>,
                     <argument><expr>"ETag"</expr></argument>,
                     <argument><expr>"Content-Location"</expr></argument>,
                     <argument><expr>"Expires"</expr></argument>,
                     <argument><expr>"Cache-Control"</expr></argument>,
                     <argument><expr>"Vary"</expr></argument>,
                     <argument><expr>"Warning"</expr></argument>,
                     <argument><expr>"WWW-Authenticate"</expr></argument>,
                     <argument><expr>"Proxy-Authenticate"</expr></argument>,
                     <argument><expr>"Set-Cookie"</expr></argument>,
                     <argument><expr>"Set-Cookie2"</expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>copy_header</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    
    <return>return <expr><call><name>h2_headers_rcreate</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr><name>headers</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>H2_RP_STATUS_LINE</name></decl>,
    <decl><name>H2_RP_HEADER_LINE</name></decl>,
    <decl><name>H2_RP_DONE</name></decl>
}</block></enum></type> <name>h2_rp_state_t</name>;</typedef>

<typedef>typedef <type><struct>struct <name>h2_response_parser</name> <block>{
    <decl_stmt><decl><type><name>h2_rp_state_t</name></type> <name>state</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>http_status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>hlines</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmp</name></decl>;</decl_stmt>
}</block></struct></type> <name>h2_response_parser</name>;</typedef>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>parse_header</name><parameter_list>(<param><decl><type><name>h2_response_parser</name> *</type><name>parser</name></decl></param>, <param><decl><type><name>char</name> *</type><name>line</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hline</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name><name>line</name><index>[<expr>0</expr>]</index></name> == ' ' || <name><name>line</name><index>[<expr>0</expr>]</index></name> == '\t'</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> **</type><name>plast</name></decl>;</decl_stmt>
        <comment type="block">/* continuation line from the header before this */</comment>
        <while>while <condition>(<expr><name><name>line</name><index>[<expr>0</expr>]</index></name> == ' ' || <name><name>line</name><index>[<expr>0</expr>]</index></name> == '\t'</expr>)</condition> <block>{
            <expr_stmt><expr>++<name>line</name></expr>;</expr_stmt>
        }</block></while>
        
        <expr_stmt><expr><name>plast</name> = <call><name>apr_array_pop</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>hlines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>plast</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* not well formed */</comment>
            <return>return <expr><name>APR_EINVAL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>hline</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>task</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%s %s"</expr></argument>, <argument><expr>*<name>plast</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* new header line */</comment>
        <expr_stmt><expr><name>hline</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>task</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>hlines</name></name></expr></argument>, <argument><expr>const <name>char</name>*</expr></argument>)</argument_list></call> = <name>hline</name></expr>;</expr_stmt> 
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>get_line</name><parameter_list>(<param><decl><type><name>h2_response_parser</name> *</type><name>parser</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, 
                             <param><decl><type><name>char</name> *</type><name>line</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name> <init>= <expr><name><name>parser</name>-&gt;<name>task</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr>!<name><name>parser</name>-&gt;<name>tmp</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>parser</name>-&gt;<name>tmp</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>status</name> = <call><name>apr_brigade_split_line</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>, 
                                    <argument><expr><name>HUGE_STRING_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>--<name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> = <call><name>apr_brigade_flatten</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="block">/* we assume a non-0 containing line and remove trailing crlf. */</comment>
            <expr_stmt><expr><name><name>line</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>len</name> &gt;= 2 &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>H2_CRLF</name></expr></argument>, <argument><expr><name>line</name> + <name>len</name> - 2</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>len</name> -= 2</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>line</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name></name></expr></argument>,
                              <argument><expr>"h2_task(%s): read response line: %s"</expr></argument>, 
                              <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* this does not look like a complete line yet */</comment>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name></name></expr></argument>,
                              <argument><expr>"h2_task(%s): read response, incomplete line: %s"</expr></argument>, 
                              <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>APR_EAGAIN</name></expr>;</return>
            }</block></else></if>
        }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_table_t</name> *</type><name>make_table</name><parameter_list>(<param><decl><type><name>h2_response_parser</name> *</type><name>parser</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name> <init>= <expr><name><name>parser</name>-&gt;<name>task</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>hlines</name> <init>= <expr><name><name>parser</name>-&gt;<name>hlines</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>hlines</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers</name> <init>= <expr><call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>hlines</name>-&gt;<name>nelts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>        
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>hlines</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>hline</name> <init>= <expr>((<name>char</name> **)<name><name>hlines</name>-&gt;<name>elts</name></name>)<index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> *</type><name>sep</name> <init>= <expr><call><name>ap_strchr</name><argument_list>(<argument><expr><name>hline</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>sep</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>APR_EINVAL</name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name></name></expr></argument>,
                              <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02955</expr></argument>)</argument_list></call> "h2_task(%s): invalid header[%d] '%s'"</expr></argument>,
                              <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>hline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* not valid format, abort */</comment>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr>(*<name>sep</name>++) = '\0'</expr>;</expr_stmt>
            <while>while <condition>(<expr>*<name>sep</name> == ' ' || *<name>sep</name> == '\t'</expr>)</condition> <block>{
                <expr_stmt><expr>++<name>sep</name></expr>;</expr_stmt>
            }</block></while>
            
            <if>if <condition>(<expr>!<call><name>h2_util_ignore_header</name><argument_list>(<argument><expr><name>hline</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_merge</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>hline</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>headers</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <return>return <expr><call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>        
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>pass_response</name><parameter_list>(<param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, 
                                  <param><decl><type><name>h2_response_parser</name> *</type><name>parser</name></decl></param>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>h2_headers</name> *</type><name>response</name> <init>= <expr><call><name>h2_headers_create</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>http_status</name></name></expr></argument>, 
                                             <argument><expr><call><name>make_table</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> = <call><name>h2_bucket_headers_create</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                      
    <expr_stmt><expr><name>status</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>tmp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* reset parser for possible next response */</comment>
    <expr_stmt><expr><name><name>parser</name>-&gt;<name>state</name></name> = <name>H2_RP_STATUS_LINE</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_array_clear</name><argument_list>(<argument><expr><name><name>parser</name>-&gt;<name>hlines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>response</name>-&gt;<name>status</name></name> &gt;= 200</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>task</name>-&gt;<name>output</name>.<name>sent_response</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name></name></expr></argument>, 
                  <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03197</expr></argument>)</argument_list></call> "h2_task(%s): passed response %d"</expr></argument>, 
                  <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>response</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>parse_status</name><parameter_list>(<param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>, <param><decl><type><name>char</name> *</type><name>line</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_response_parser</name> *</type><name>parser</name> <init>= <expr><name><name>task</name>-&gt;<name>output</name>.<name>rparser</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>sindex</name> <init>= <expr>(<call><name>apr_date_checkmask</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr>"HTTP/#.# ###*"</expr></argument>)</argument_list></call>? 9 : 
                  (<call><name>apr_date_checkmask</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr>"HTTP/# ###*"</expr></argument>)</argument_list></call>? 7 : 0))</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>sindex</name> &gt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name>sindex</name> + 3</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>keepchar</name> <init>= <expr><name><name>line</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>line</name><index>[<expr><name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parser</name>-&gt;<name>http_status</name></name> = <call><name>atoi</name><argument_list>(<argument><expr>&amp;<name><name>line</name><index>[<expr><name>sindex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>line</name><index>[<expr><name>k</name></expr>]</index></name> = <name>keepchar</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parser</name>-&gt;<name>state</name></name> = <name>H2_RP_HEADER_LINE</name></expr>;</expr_stmt>
        
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>
    <comment type="block">/* Seems like there is garbage on the connection. May be a leftover
     * from a previous proxy request. 
     * This should only happen if the H2_RESPONSE filter is not yet in 
     * place (post_read_request has not been reached and the handler wants
     * to write something. Probably just the interim response we are
     * waiting for. But if there is other data hanging around before
     * that, this needs to fail. */</comment>
    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03467</expr></argument>)</argument_list></call>
                  "h2_task(%s): unable to parse status line: %s"</expr></argument>, 
                  <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>APR_EINVAL</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_from_h1_parse_response</name><parameter_list>(<param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, 
                                       <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_response_parser</name> *</type><name>parser</name> <init>= <expr><name><name>task</name>-&gt;<name>output</name>.<name>rparser</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>HUGE_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>parser</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>parser</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>parser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parser</name>-&gt;<name>task</name></name> = <name>task</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parser</name>-&gt;<name>state</name></name> = <name>H2_RP_STATUS_LINE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>parser</name>-&gt;<name>hlines</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>task</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name>-&gt;<name>output</name>.<name>rparser</name></name> = <name>parser</name></expr>;</expr_stmt>
    }</block></then></if>
    
    <while>while <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call> &amp;&amp; <name>status</name> == <name>APR_SUCCESS</name></expr>)</condition> <block>{
        <switch>switch <condition>(<expr><name><name>parser</name>-&gt;<name>state</name></name></expr>)</condition> <block>{
            <case>case <expr><name>H2_RP_STATUS_LINE</name></expr>:
            </case><case>case <expr><name>H2_RP_HEADER_LINE</name></expr>:
                <expr_stmt><expr><name>status</name> = <call><name>get_line</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>status</name> == <name>APR_EAGAIN</name></expr>)</condition><then> <block>{
                    <comment type="block">/* need more data */</comment>
                    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>status</name></expr>;</return>
                }</block></then></if></else></if>
                <if>if <condition>(<expr><name><name>parser</name>-&gt;<name>state</name></name> == <name>H2_RP_STATUS_LINE</name></expr>)</condition><then> <block>{
                    <comment type="block">/* instead of parsing, just take it directly */</comment>
                    <expr_stmt><expr><name>status</name> = <call><name>parse_status</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><name><name>line</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
                    <comment type="block">/* end of headers, pass response onward */</comment>
                    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                                  <argument><expr>"h2_task(%s): end of response"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>pass_response</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                                  <argument><expr>"h2_task(%s): response header %s"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>status</name> = <call><name>parse_header</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if></else></if>
                <break>break;</break>
                
            </case><default>default:
                <return>return <expr><name>status</name></expr>;</return>
        </default>}</block></switch>
    }</block></while>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_filter_headers_out</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>bresp</name></decl>, *<decl><type ref="prev"/><name>body_bucket</name> <init>= <expr><name>NULL</name></expr></init>, *<name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_bucket_error</name> *</type><name>eb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_headers</name> *</type><name>response</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>headers_passing</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                  <argument><expr>"h2_task(%s): output_filter called"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if>if <condition>(<expr>!<name><name>task</name>-&gt;<name>output</name>.<name>sent_response</name></name> &amp;&amp; !<name><name>f</name>-&gt;<name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* check, if we need to send the response now. Until we actually
         * see a DATA bucket or some EOS/EOR, we do not do so. */</comment>
        <for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
            <if>if <condition>(<expr><call><name>AP_BUCKET_IS_ERROR</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>eb</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>eb</name> = <name><name>b</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>AP_BUCKET_IS_EOC</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* If we see an EOC bucket it is a signal that we should get out
                 * of the way doing nothing.
                 */</comment>
                <expr_stmt><expr><call><name>ap_remove_output_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                              <argument><expr>"h2_task(%s): eoc bucket passed"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then>
            <else>else <if>if <condition>(<expr><call><name>H2_BUCKET_IS_HEADERS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>headers_passing</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>APR_BUCKET_IS_FLUSH</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ 
                <expr_stmt><expr><name>body_bucket</name> = <name>b</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if></else></if></else></if></else></if>
        }</block></for>
        
        <if>if <condition>(<expr><name>eb</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>st</name> <init>= <expr><name><name>eb</name>-&gt;<name>status</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03047</expr></argument>)</argument_list></call>
                          "h2_task(%s): err bucket status=%d"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* throw everything away and replace it with the error response
             * generated by ap_die() */</comment>
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_die</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>AP_FILTER_ERROR</name></expr>;</return>
        }</block></then></if>
        
        <if>if <condition>(<expr><name>body_bucket</name> || !<name>headers_passing</name></expr>)</condition><then> <block>{
            <comment type="block">/* time to insert the response bucket before the body or if
             * no h2_headers is passed, e.g. the response is empty */</comment>
            <expr_stmt><expr><name>response</name> = <call><name>create_response</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>response</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03048</expr></argument>)</argument_list></call>
                              "h2_task(%s): unable to create response"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>APR_ENOMEM</name></expr>;</return>
            }</block></then></if>
            
            <expr_stmt><expr><name>bresp</name> = <call><name>h2_bucket_headers_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>, <argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>body_bucket</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>body_bucket</name></expr></argument>, <argument><expr><name>bresp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_HEAD</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bresp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name><name>task</name>-&gt;<name>output</name>.<name>sent_response</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>sent_bodyct</name></name> = 1</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>header_only</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                      <argument><expr>"h2_task(%s): header_only, cleanup output brigade"</expr></argument>, 
                      <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>b</name> = <name>body_bucket</name>? <name>body_bucket</name> : <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> || <call><name>AP_BUCKET_IS_EOR</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if> 
            <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_bucket_destroy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>b</name> = <name>next</name></expr>;</expr_stmt>
        }</block></while>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>task</name>-&gt;<name>output</name>.<name>sent_response</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* lets get out of the way, our task is done */</comment>
        <expr_stmt><expr><call><name>ap_remove_output_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>make_chunk</name><parameter_list>(<param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, 
                       <param><decl><type><name>apr_bucket</name> *</type><name>first</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>chunk_len</name></decl></param>, 
                       <param><decl><type><name>apr_bucket</name> *</type><name>tail</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Surround the buckets [first, tail[ with new buckets carrying the
     * HTTP/1.1 chunked encoding format. If tail is NULL, the chunk extends
     * to the end of the brigade. */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>len</name> = <call><name>apr_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>H2_ALEN</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>, 
                       <argument><expr>"%"<name>APR_UINT64_T_HEX_FMT</name>"\r\n"</expr></argument>, <argument><expr>(<name>apr_uint64_t</name>)<name>chunk_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> = <call><name>apr_bucket_heap_create</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>c</name> = <call><name>apr_bucket_heap_create</name><argument_list>(<argument><expr>"\r\n"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>tail</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>task</name>-&gt;<name>input</name>.<name>chunked_total</name></name> += <name>chunk_len</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>c</name></name></expr></argument>,
                  <argument><expr>"h2_task(%s): added chunk %ld, total %ld"</expr></argument>, 
                  <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr>(<name>long</name>)<name>chunk_len</name></expr></argument>, <argument><expr>(<name>long</name>)<name><name>task</name>-&gt;<name>input</name>.<name>chunked_total</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ser_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name>ctx</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>apr_brigade_printf</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"%s: %s\r\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>read_and_chunk</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>h2_task</name> *</type><name>task</name></decl></param>,
                                   <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name><name>task</name>-&gt;<name>input</name>.<name>bbchunk</name></name></expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr>!<name>bb</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>task</name>-&gt;<name>input</name>.<name>bbchunk</name></name> = <name>bb</name></expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>first_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_off_t</name></type> <name>bblen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <comment type="block">/* get more data from the lower layer filters. Always do this
         * in larger pieces, since we handle the read modes ourself. */</comment>
        <expr_stmt><expr><name>status</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, 
                                <argument><expr><name>AP_MODE_READBYTES</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr>32*1024</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> == <name>APR_EOF</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name><name>task</name>-&gt;<name>input</name>.<name>eos</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>status</name> = <call><name>apr_brigade_puts</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"0\r\n\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>task</name>-&gt;<name>input</name>.<name>eos</name></name> = 1</expr>;</expr_stmt>
                <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>ap_remove_input_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>status</name></expr>;</return>
            
        }</block></then>
        <else>else <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>status</name></expr>;</return>
        }</block></then></if></else></if>

        <for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init> 
             <condition><expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call> &amp;&amp; !<name><name>task</name>-&gt;<name>input</name>.<name>eos</name></name></expr>;</condition> 
             <incr><expr><name>b</name> = <name>next</name></expr></incr>) <block>{
            <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>first_data</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>make_chunk</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>first_data</name></expr></argument>, <argument><expr><name>bblen</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>first_data</name> = <name>NULL</name></expr>;</expr_stmt>
                }</block></then></if>
                
                <if>if <condition>(<expr><call><name>H2_BUCKET_IS_HEADERS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>h2_headers</name> *</type><name>headers</name> <init>= <expr><call><name>h2_bucket_headers_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    
                    <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                                  <argument><expr>"h2_task(%s): receiving trailers"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tmp</name> = <call><name>apr_brigade_split_ex</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr>!<call><name>apr_is_empty_table</name><argument_list>(<argument><expr><name><name>headers</name>-&gt;<name>headers</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>status</name> = <call><name>apr_brigade_puts</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"0\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>ser_header</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>headers</name>-&gt;<name>headers</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>status</name> = <call><name>apr_brigade_puts</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>status</name> = <call><name>apr_brigade_puts</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"0\r\n\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <expr_stmt><expr><name><name>r</name>-&gt;<name>trailers_in</name></name> = <call><name>apr_table_clone</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>headers</name>-&gt;<name>headers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>apr_bucket_destroy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>task</name>-&gt;<name>input</name>.<name>eos</name></name> = 1</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>tmp</name> = <call><name>apr_brigade_split_ex</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>status</name> = <call><name>apr_brigade_puts</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"0\r\n\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>task</name>-&gt;<name>input</name>.<name>eos</name></name> = 1</expr>;</expr_stmt>
                }</block></then></if></else></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_bucket_destroy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> 
            <else>else <block>{
                <if>if <condition>(<expr>!<name>first_data</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>first_data</name> = <name>b</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>bblen</name> = 0</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><name>bblen</name> += <name><name>b</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            }</block></else></if></else></if>    
        }</block></for>
        
        <if>if <condition>(<expr><name>first_data</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>make_chunk</name><argument_list>(<argument><expr><name>task</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>first_data</name></expr></argument>, <argument><expr><name>bblen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>            
    }</block></then></if>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_filter_request_in</name><parameter_list>(<param><decl><type><name>ap_filter_t</name>*</type> <name>f</name></decl></param>,
                                  <param><decl><type><name>apr_bucket_brigade</name>*</type> <name>bb</name></decl></param>,
                                  <param><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl></param>,
                                  <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                  <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name> <init>=
        <expr>(<name>core_server_config</name> *) <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                                    <argument><expr>&amp;<name>core_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>,
                  <argument><expr>"h2_task(%s): request filter, exp=%d"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>expecting_100</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>task</name>-&gt;<name>request</name>-&gt;<name>chunked</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* pipe data through, just take care of trailers */</comment>
        <for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init> 
             <condition><expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>b</name> = <name>next</name></expr></incr>) <block>{
            <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>H2_BUCKET_IS_HEADERS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>h2_headers</name> *</type><name>headers</name> <init>= <expr><call><name>h2_bucket_headers_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                              <argument><expr>"h2_task(%s): receiving trailers"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>trailers_in</name></name> = <name><name>headers</name>-&gt;<name>headers</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>conf</name> &amp;&amp; <name><name>conf</name>-&gt;<name>merge_trailers</name></name> == <name>AP_MERGE_TRAILERS_ENABLE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>r</name>-&gt;<name>headers_in</name></name> = <call><name>apr_table_overlay</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>,
                                                      <argument><expr><name><name>r</name>-&gt;<name>trailers_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                    
                }</block></then></if>
                <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_bucket_destroy</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_remove_input_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Things are more complicated. The standard HTTP input filter, which
     * does a lot what we do not want to duplicate, also cares about chunked
     * transfer encoding and trailers.
     * We need to simulate chunked encoding for it to be happy.
     */</comment>
    <if>if <condition>(<expr>(<name>status</name> = <call><name>read_and_chunk</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>task</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_EXHAUSTIVE</name></expr>)</condition><then> <block>{
        <comment type="block">/* return all we have */</comment>
        <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>input</name>.<name>bbchunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_READBYTES</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>h2_brigade_concat_length</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>input</name>.<name>bbchunk</name></name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_SPECULATIVE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>h2_brigade_copy_length</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>input</name>.<name>bbchunk</name></name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_GETLINE</name></expr>)</condition><then> <block>{
        <comment type="block">/* we are reading a single LF line, e.g. the HTTP headers. 
         * this has the nasty side effect to split the bucket, even
         * though it ends with CRLF and creates a 0 length bucket */</comment>
        <expr_stmt><expr><name>status</name> = <call><name>apr_brigade_split_line</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>input</name>.<name>bbchunk</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, 
                                        <argument><expr><name>HUGE_STRING_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>APLOGctrace1</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof>-1</expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>apr_brigade_flatten</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                          <argument><expr>"h2_task(%s): getline: %s"</expr></argument>,
                          <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* Hmm, well. There is mode AP_MODE_EATCRLF, but we chose not
         * to support it. Seems to work. */</comment>
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>APR_ENOTIMPL</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                      <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02942</expr></argument>)</argument_list></call> 
                      "h2_task, unsupported READ mode %d"</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> = <name>APR_ENOTIMPL</name></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if>
    
    <expr_stmt><expr><call><name>h2_util_bb_log</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>stream_id</name></name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>"forwarding input"</expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_filter_trailers_out</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_task</name> *</type><name>task</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>, *<decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
 
    <if>if <condition>(<expr><name>task</name> &amp;&amp; <name>r</name></expr>)</condition><then> <block>{
        <comment type="block">/* Detect the EOS/EOR bucket and forward any trailers that may have
         * been set to our h2_headers.
         */</comment>
        <for>for (<init><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>b</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
            <if>if <condition>(<expr>(<call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> || <call><name>AP_BUCKET_IS_EOR</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>)
                &amp;&amp; <name><name>r</name>-&gt;<name>trailers_out</name></name> &amp;&amp; !<call><name>apr_is_empty_table</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>trailers_out</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>h2_headers</name> *</type><name>headers</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>trailers</name></decl>;</decl_stmt>
                
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03049</expr></argument>)</argument_list></call>
                              "h2_task(%s): sending trailers"</expr></argument>, <argument><expr><name><name>task</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>trailers</name> = <call><name>apr_table_clone</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>trailers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>headers</name> = <call><name>h2_headers_rcreate</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>HTTP_OK</name></expr></argument>, <argument><expr><name>trailers</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>e</name> = <call><name>h2_bucket_headers_create</name><argument_list>(<argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>, <argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_table_clear</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>trailers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_remove_output_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>     
    }</block></then></if>
     
    <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

</unit>
