<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/http2/h2_push.c"><comment type="block">/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_time.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>H2_OPENSSL</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;openssl/sha.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_core.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_h2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_push.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_headers.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_session.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2_stream.h"</cpp:file></cpp:include>

<comment type="block">/*******************************************************************************
 * link header handling 
 ******************************************************************************/</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>policy_str</name><parameter_list>(<param><decl><type><name>h2_push_policy</name></type> <name>policy</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name>policy</name></expr>)</condition> <block>{
        <case>case <expr><name>H2_PUSH_NONE</name></expr>:
            <return>return <expr>"none"</expr>;</return>
        </case><case>case <expr><name>H2_PUSH_FAST_LOAD</name></expr>:
            <return>return <expr>"fast-load"</expr>;</return>
        </case><case>case <expr><name>H2_PUSH_HEAD</name></expr>:
            <return>return <expr>"head"</expr>;</return>
        </case><default>default:
            <return>return <expr>"default"</expr>;</return>
    </default>}</block></switch>
}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>h2_request</name> *</type><name>req</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>push_policy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>pushes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>slen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>link</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>params</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>b</name><index>[<expr>4096</expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>link_ctx</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>attr_char</name><parameter_list>(<param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list> 
<block>{
    <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
        <case>case <expr>'!'</expr>:
        </case><case>case <expr>'#'</expr>:
        </case><case>case <expr>'$'</expr>:
        </case><case>case <expr>'&amp;'</expr>:
        </case><case>case <expr>'+'</expr>:
        </case><case>case <expr>'-'</expr>:
        </case><case>case <expr>'.'</expr>:
        </case><case>case <expr>'^'</expr>:
        </case><case>case <expr>'_'</expr>:
        </case><case>case <expr>'`'</expr>:
        </case><case>case <expr>'|'</expr>:
        </case><case>case <expr>'~'</expr>:
            <return>return <expr>1</expr>;</return>
        </case><default>default:
            <return>return <expr><call><name>apr_isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ptoken_char</name><parameter_list>(<param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list> 
<block>{
    <switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
        <case>case <expr>'!'</expr>:
        </case><case>case <expr>'#'</expr>:
        </case><case>case <expr>'$'</expr>:
        </case><case>case <expr>'&amp;'</expr>:
        </case><case>case <expr>'\''</expr>:
        </case><case>case <expr>'('</expr>:
        </case><case>case <expr>')'</expr>:
        </case><case>case <expr>'*'</expr>:
        </case><case>case <expr>'+'</expr>:
        </case><case>case <expr>'-'</expr>:
        </case><case>case <expr>'.'</expr>:
        </case><case>case <expr>'/'</expr>:
        </case><case>case <expr>':'</expr>:
        </case><case>case <expr>'&lt;'</expr>:
        </case><case>case <expr>'='</expr>:
        </case><case>case <expr>'&gt;'</expr>:
        </case><case>case <expr>'?'</expr>:
        </case><case>case <expr>'@'</expr>:
        </case><case>case <expr>'['</expr>:
        </case><case>case <expr>']'</expr>:
        </case><case>case <expr>'^'</expr>:
        </case><case>case <expr>'_'</expr>:
        </case><case>case <expr>'`'</expr>:
        </case><case>case <expr>'{'</expr>:
        </case><case>case <expr>'|'</expr>:
        </case><case>case <expr>'}'</expr>:
        </case><case>case <expr>'~'</expr>:
            <return>return <expr>1</expr>;</return>
        </case><default>default:
            <return>return <expr><call><name>apr_isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>skip_ws</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <while>while <condition>(<expr><name><name>ctx</name>-&gt;<name>i</name></name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name> 
           &amp;&amp; (((<name>c</name> = <name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name><name>ctx</name>-&gt;<name>i</name></name></expr>]</index></name>) == ' ') || (<name>c</name> == '\t'))</expr>)</condition> <block>{
        <expr_stmt><expr>++<name><name>ctx</name>-&gt;<name>i</name></name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr>(<name><name>ctx</name>-&gt;<name>i</name></name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_chr</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>char</name></type> <name>c</name></decl></param>, <param><decl><type><name>size_t</name> *</type><name>pidx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>j</name> = <name><name>ctx</name>-&gt;<name>i</name></name></expr>;</init> <condition><expr><name>j</name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name>j</name></expr>]</index></name> == <name>c</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>pidx</name> = <name>j</name></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></for> 
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_chr</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>i</name></name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name> &amp;&amp; <name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name><name>ctx</name>-&gt;<name>i</name></name></expr>]</index></name> == <name>c</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name><name>ctx</name>-&gt;<name>i</name></name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>mk_str</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>end</name></decl></param>)</parameter_list> 
<block>{
    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>i</name></name> &lt; <name>end</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>s</name></name> + <name><name>ctx</name>-&gt;<name>i</name></name></expr></argument>, <argument><expr><name>end</name> - <name><name>ctx</name>-&gt;<name>i</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr>(<name>char</name>*)""</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_qstring</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>ps</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'\"'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>end</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>find_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'\"'</expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>ps</name> = <call><name>mk_str</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = <name>end</name> + 1</expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_ptoken</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>ps</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = <name><name>ctx</name>-&gt;<name>i</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name> &amp;&amp; <call><name>ptoken_char</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <comment type="block">/* nop */</comment>
        }</block></for>
        <if>if <condition>(<expr><name>i</name> &gt; <name><name>ctx</name>-&gt;<name>i</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>ps</name> = <call><name>mk_str</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = <name>i</name></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>read_link</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'&lt;'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>end</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>find_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'&gt;'</expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>link</name></name> = <call><name>mk_str</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = <name>end</name> + 1</expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_pname</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pname</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for (<init><expr><name>i</name> = <name><name>ctx</name>-&gt;<name>i</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name><name>ctx</name>-&gt;<name>slen</name></name> &amp;&amp; <call><name>attr_char</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <comment type="block">/* nop */</comment>
        }</block></for>
        <if>if <condition>(<expr><name>i</name> &gt; <name><name>ctx</name>-&gt;<name>i</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>pname</name> = <call><name>mk_str</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = <name>i</name></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_pvalue</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pvalue</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>read_qstring</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>)</argument_list></call> || <call><name>read_ptoken</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_param</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>';'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>value</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>read_pname</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>read_pvalue</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* value is optional */</comment>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>params</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_sep</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>skip_ws</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>read_chr</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_params</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list> 
<block>{
    <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>params</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>params</name></name> = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>apr_table_clear</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>params</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>same_authority</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>h2_request</name> *</type><name>req</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>apr_uri_t</name> *</type><name>uri</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>uri</name>-&gt;<name>scheme</name></name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>uri</name>-&gt;<name>scheme</name></name></expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>uri</name>-&gt;<name>hostinfo</name></name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>uri</name>-&gt;<name>hostinfo</name></name></expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>authority</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>set_push_header</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>size_t</name></type> <name>klen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"User-Agent"</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call>
        || <call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"Accept"</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call>
        || <call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"Accept-Encoding"</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call>
        || <call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"Accept-Language"</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call>
        || <call><name>H2_HD_MATCH_LIT</name><argument_list>(<argument><expr>"Cache-Control"</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>has_param</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>param</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>params</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr>!!<name>p</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>has_relation</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>val</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>params</name></name></expr></argument>, <argument><expr>"rel"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>val</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>s</name> = <call><name>ap_strstr_c</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>s</name> &amp;&amp; (<name>s</name> == <name>val</name> || <name><name>s</name><index>[<expr>-1</expr>]</index></name> == ' ')</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>s</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!*<name>s</name> || *<name>s</name> == ' '</expr>)</condition><then> <block>{
                <return>return <expr>1</expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_push</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* so, we have read a Link header and need to decide
     * if we transform it into a push.
     */</comment>
    <if>if <condition>(<expr><call><name>has_relation</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>"preload"</expr></argument>)</argument_list></call> &amp;&amp; !<call><name>has_param</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>"nopush"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>uri</name></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>apr_uri_parse</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>link</name></name></expr></argument>, <argument><expr>&amp;<name>uri</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>uri</name>.<name>path</name></name> &amp;&amp; <call><name>same_authority</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>req</name></name></expr></argument>, <argument><expr>&amp;<name>uri</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>method</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>h2_request</name> *</type><name>req</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>h2_push</name> *</type><name>push</name></decl>;</decl_stmt>
                
                <comment type="block">/* We only want to generate pushes for resources in the
                 * same authority than the original request.
                 * icing: i think that is wise, otherwise we really need to
                 * check that the vhost/server is available and uses the same
                 * TLS (if any) parameters.
                 */</comment>
                <expr_stmt><expr><name>path</name> = <call><name>apr_uri_unparse</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>uri</name></expr></argument>, <argument><expr><name>APR_URI_UNP_OMITSITEPART</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>push</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>push</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>ctx</name>-&gt;<name>push_policy</name></name></expr>)</condition> <block>{
                    <case>case <expr><name>H2_PUSH_HEAD</name></expr>:
                        <expr_stmt><expr><name>method</name> = "HEAD"</expr>;</expr_stmt>
                        <break>break;</break>
                    </case><default>default:
                        <expr_stmt><expr><name>method</name> = "GET"</expr>;</expr_stmt>
                        <break>break;</break>
                </default>}</block></switch>
                <expr_stmt><expr><name>headers</name> = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>set_push_header</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>req</name>-&gt;<name>headers</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>req</name> = <call><name>h2_req_create</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>method</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>req</name>-&gt;<name>scheme</name></name></expr></argument>,
                                    <argument><expr><name><name>ctx</name>-&gt;<name>req</name>-&gt;<name>authority</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>,
                                    <argument><expr><name><name>ctx</name>-&gt;<name>req</name>-&gt;<name>serialize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/* atm, we do not push on pushes */</comment>
                <expr_stmt><expr><call><name>h2_request_end_headers</name><argument_list>(<argument><expr><name>req</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>push</name>-&gt;<name>req</name></name> = <name>req</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>has_param</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>"critical"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>h2_priority</name> *</type><name>prio</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>prio</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <expr_stmt><expr><name><name>prio</name>-&gt;<name>dependency</name></name> = <name>H2_DEPENDANT_BEFORE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>push</name>-&gt;<name>priority</name></name> = <name>prio</name></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>pushes</name></name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>pushes</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_push</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>pushes</name></name></expr></argument>, <argument><expr><name>h2_push</name>*</expr></argument>)</argument_list></call> = <name>push</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>inspect_link</name><parameter_list>(<param><decl><type><name>link_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>slen</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* RFC 5988 &lt;https://tools.ietf.org/html/rfc5988#section-6.2.1&gt;
      Link           = "Link" ":" #link-value
      link-value     = "&lt;" URI-Reference "&gt;" *( ";" link-param )
      link-param     = ( ( "rel" "=" relation-types )
                     | ( "anchor" "=" &lt;"&gt; URI-Reference &lt;"&gt; )
                     | ( "rev" "=" relation-types )
                     | ( "hreflang" "=" Language-Tag )
                     | ( "media" "=" ( MediaDesc | ( &lt;"&gt; MediaDesc &lt;"&gt; ) ) )
                     | ( "title" "=" quoted-string )
                     | ( "title*" "=" ext-value )
                     | ( "type" "=" ( media-type | quoted-mt ) )
                     | ( link-extension ) )
      link-extension = ( parmname [ "=" ( ptoken | quoted-string ) ] )
                     | ( ext-name-star "=" ext-value )
      ext-name-star  = parmname "*" ; reserved for RFC2231-profiled
                                    ; extensions.  Whitespace NOT
                                    ; allowed in between.
      ptoken         = 1*ptokenchar
      ptokenchar     = "!" | "#" | "$" | "%" | "&amp;" | "'" | "("
                     | ")" | "*" | "+" | "-" | "." | "/" | DIGIT
                     | ":" | "&lt;" | "=" | "&gt;" | "?" | "@" | ALPHA
                     | "[" | "]" | "^" | "_" | "`" | "{" | "|"
                     | "}" | "~"
      media-type     = type-name "/" subtype-name
      quoted-mt      = &lt;"&gt; media-type &lt;"&gt;
      relation-types = relation-type
                     | &lt;"&gt; relation-type *( 1*SP relation-type ) &lt;"&gt;
      relation-type  = reg-rel-type | ext-rel-type
      reg-rel-type   = LOALPHA *( LOALPHA | DIGIT | "." | "-" )
      ext-rel-type   = URI
      
      and from &lt;https://tools.ietf.org/html/rfc5987&gt;
      parmname      = 1*attr-char
      attr-char     = ALPHA / DIGIT
                       / "!" / "#" / "$" / "&amp;" / "+" / "-" / "."
                       / "^" / "_" / "`" / "|" / "~"
     */</comment>

     <expr_stmt><expr><name><name>ctx</name>-&gt;<name>s</name></name> = <name>s</name></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>ctx</name>-&gt;<name>slen</name></name> = <name>slen</name></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>ctx</name>-&gt;<name>i</name></name> = 0</expr>;</expr_stmt>
     
     <while>while <condition>(<expr><call><name>read_link</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>init_params</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>read_param</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <comment type="block">/* nop */</comment>
        }</block></while>
        <expr_stmt><expr><call><name>add_push</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<call><name>read_sep</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
     }</block></while>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>head_iter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> 
<block>{
    <if>if <condition>(<expr>!<call><name>apr_strnatcasecmp</name><argument_list>(<argument><expr>"link"</expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>inspect_link</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>apr_array_header_t</name> *</type><name>h2_push_collect</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>h2_request</name> *</type><name>req</name></decl></param>,
                                    <param><decl><type><name>int</name></type> <name>push_policy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>h2_headers</name> *</type><name>res</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>req</name> &amp;&amp; <name>push_policy</name> != <name>H2_PUSH_NONE</name></expr>)</condition><then> <block>{
        <comment type="block">/* Collect push candidates from the request/response pair.
         * 
         * One source for pushes are "rel=preload" link headers
         * in the response.
         * 
         * TODO: This may be extended in the future by hooks or callbacks
         * where other modules can provide push information directly.
         */</comment>
        <if>if <condition>(<expr><name><name>res</name>-&gt;<name>headers</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>link_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>.<name>req</name></name> = <name>req</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>.<name>push_policy</name></name> = <name>push_policy</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>.<name>pool</name></name> = <name>p</name></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>head_iter</name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr><name><name>res</name>-&gt;<name>headers</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>ctx</name>.<name>pushes</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>res</name>-&gt;<name>headers</name></name></expr></argument>, <argument><expr>"push-policy"</expr></argument>, 
                               <argument><expr><call><name>policy_str</name><argument_list>(<argument><expr><name>push_policy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name><name>ctx</name>.<name>pushes</name></name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*******************************************************************************
 * push diary 
 *
 * - The push diary keeps track of resources already PUSHed via HTTP/2 on this
 *   connection. It records a hash value from the absolute URL of the resource
 *   pushed.
 * - Lacking openssl, it uses 'apr_hashfunc_default' for the value
 * - with openssl, it uses SHA256 to calculate the hash value
 * - whatever the method to generate the hash, the diary keeps a maximum of 64
 *   bits per hash, limiting the memory consumption to about 
 *      H2PushDiarySize * 8 
 *   bytes. Entries are sorted by most recently used and oldest entries are
 *   forgotten first.
 * - Clients can initialize/replace the push diary by sending a 'Cache-Digest'
 *   header. Currently, this is the base64url encoded value of the cache digest
 *   as specified in https://datatracker.ietf.org/doc/draft-kazuho-h2-cache-digest/
 *   This draft can be expected to evolve and the definition of the header
 *   will be added there and refined.
 * - The cache digest header is a Golomb Coded Set of hash values, but it may
 *   limit the amount of bits per hash value even further. For a good description
 *   of GCS, read here:
 *      http://giovanni.bajo.it/post/47119962313/golomb-coded-sets-smaller-than-bloom-filters
 * - The means that the push diary might be initialized with hash values of much
 *   less than 64 bits, leading to more false positives, but smaller digest size.
 ******************************************************************************/</comment>
 
 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GCSLOG_LEVEL</name></cpp:macro>   <cpp:value>APLOG_TRACE1</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>h2_push_diary_entry</name> <block>{
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>hash</name></decl>;</decl_stmt>
}</block></struct></type> <name>h2_push_diary_entry</name>;</typedef>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>H2_OPENSSL</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>sha256_update</name><parameter_list>(<param><decl><type><name>SHA256_CTX</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>SHA256_Update</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>calc_sha256_hash</name><parameter_list>(<param><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl></param>, <param><decl><type><name>apr_uint64_t</name> *</type><name>phash</name></decl></param>, <param><decl><type><name>h2_push</name> *</type><name>push</name></decl></param>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>SHA256_CTX</name></type> <name>sha256</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hash</name><index>[<expr><name>SHA256_DIGEST_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>SHA256_Init</name><argument_list>(<argument><expr>&amp;<name>sha256</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sha256_update</name><argument_list>(<argument><expr>&amp;<name>sha256</name></expr></argument>, <argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sha256_update</name><argument_list>(<argument><expr>&amp;<name>sha256</name></expr></argument>, <argument><expr>"://"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sha256_update</name><argument_list>(<argument><expr>&amp;<name>sha256</name></expr></argument>, <argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>authority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>sha256_update</name><argument_list>(<argument><expr>&amp;<name>sha256</name></expr></argument>, <argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SHA256_Final</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr>&amp;<name>sha256</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>val</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> != <sizeof>sizeof<argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <expr_stmt><expr><name>val</name> = <name>val</name> * 256 + <name><name>hash</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
    <expr_stmt><expr>*<name>phash</name> = <name>val</name> &gt;&gt; (64 - <name><name>diary</name>-&gt;<name>mask_bits</name></name>)</expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>val_apr_hash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <return>return <expr><call><name>apr_hashfunc_default</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>calc_apr_hash</name><parameter_list>(<param><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl></param>, <param><decl><type><name>apr_uint64_t</name> *</type><name>phash</name></decl></param>, <param><decl><type><name>h2_push</name> *</type><name>push</name></decl></param>)</parameter_list> 
<block>{
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>val</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_UINT64_MAX</name> &gt; <name>UINT_MAX</name></expr></cpp:if>
    <expr_stmt><expr><name>val</name> = (<call>(<name>apr_uint64_t</name>)<argument_list>(<argument><expr><call><name>val_apr_hash</name><argument_list>(<argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;&lt; 32)</expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> ^= (<call>(<name>apr_uint64_t</name>)<argument_list>(<argument><expr><call><name>val_apr_hash</name><argument_list>(<argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>authority</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;&lt; 16)</expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> ^= <call><name>val_apr_hash</name><argument_list>(<argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>val</name> = <call><name>val_apr_hash</name><argument_list>(<argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> ^= <call><name>val_apr_hash</name><argument_list>(<argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>authority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> ^= <call><name>val_apr_hash</name><argument_list>(<argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr>*<name>phash</name> = <name>val</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_int32_t</name></type> <name>ceil_power_of_2</name><parameter_list>(<param><decl><type><name>apr_int32_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>n</name> &lt;= 2</expr>)</condition><then> <return>return <expr>2</expr>;</return></then></if>
    <expr_stmt><expr>--<name>n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> |= <name>n</name> &gt;&gt; 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> |= <name>n</name> &gt;&gt; 2</expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> |= <name>n</name> &gt;&gt; 4</expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> |= <name>n</name> &gt;&gt; 8</expr>;</expr_stmt>
    <expr_stmt><expr><name>n</name> |= <name>n</name> &gt;&gt; 16</expr>;</expr_stmt>
    <return>return <expr>++<name>n</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>h2_push_diary</name> *</type><name>diary_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>h2_push_digest_type</name></type> <name>dtype</name></decl></param>, 
                                   <param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_push_diary</name> *</type><name>diary</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>N</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>diary</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>diary</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name><name>diary</name>-&gt;<name>NMax</name></name>        = <call><name>ceil_power_of_2</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>diary</name>-&gt;<name>N</name></name>           = <name><name>diary</name>-&gt;<name>NMax</name></name></expr>;</expr_stmt>
        <comment type="block">/* the mask we use in value comparison depends on where we got
         * the values from. If we calculate them ourselves, we can use
         * the full 64 bits.
         * If we set the diary via a compressed golomb set, we have less
         * relevant bits and need to use a smaller mask. */</comment>
        <expr_stmt><expr><name><name>diary</name>-&gt;<name>mask_bits</name></name>   = 64</expr>;</expr_stmt>
        <comment type="block">/* grows by doubling, start with a power of 2 */</comment>
        <expr_stmt><expr><name><name>diary</name>-&gt;<name>entries</name></name>     = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>16</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_push_diary_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        
        <switch>switch <condition>(<expr><name>dtype</name></expr>)</condition> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>H2_OPENSSL</name></cpp:ifdef>
            <case>case <expr><name>H2_PUSH_DIGEST_SHA256</name></expr>:
                <expr_stmt><expr><name><name>diary</name>-&gt;<name>dtype</name></name>       = <name>H2_PUSH_DIGEST_SHA256</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>diary</name>-&gt;<name>dcalc</name></name>       = <name>calc_sha256_hash</name></expr>;</expr_stmt>
                <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* ifdef H2_OPENSSL */</comment>
            </case><default>default:
                <expr_stmt><expr><name><name>diary</name>-&gt;<name>dtype</name></name>       = <name>H2_PUSH_DIGEST_APR_HASH</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>diary</name>-&gt;<name>dcalc</name></name>       = <name>calc_apr_hash</name></expr>;</expr_stmt>
                <break>break;</break>
        </default>}</block></switch>
    }</block></then></if>
    
    <return>return <expr><name>diary</name></expr>;</return>
}</block></function>

<function><type><name>h2_push_diary</name> *</type><name>h2_push_diary_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>int</name></type> <name>N</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>diary_create</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>H2_PUSH_DIGEST_SHA256</name></expr></argument>, <argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>h2_push_diary_find</name><parameter_list>(<param><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl></param>, <param><decl><type><name>apr_uint64_t</name></type> <name>hash</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>diary</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>h2_push_diary_entry</name> *</type><name>e</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

        <comment type="block">/* search from the end, where the last accessed digests are */</comment>
        <for>for (<init><expr><name>i</name> = <name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>nelts</name></name>-1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
            <expr_stmt><expr><name>e</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>entries</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>h2_push_diary_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>e</name>-&gt;<name>hash</name></name> == <name>hash</name></expr>)</condition><then> <block>{
                <return>return <expr><name>i</name></expr>;</return>
            }</block></then></if>
        }</block></for>
    }</block></then></if>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>h2_push_diary_entry</name> *</type><name>move_to_last</name><parameter_list>(<param><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>idx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_push_diary_entry</name> *</type><name>entries</name> <init>= <expr>(<name>h2_push_diary_entry</name>*)<name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_push_diary_entry</name></type> <name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>lastidx</name> <init>= <expr><name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>nelts</name></name>-1</expr></init></decl>;</decl_stmt>
    
    <comment type="block">/* move entry[idx] to the end */</comment>
    <if>if <condition>(<expr><name>idx</name> &lt; <name>lastidx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>e</name> =  <name><name>entries</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>entries</name>+<name>idx</name></expr></argument>, <argument><expr><name>entries</name>+<name>idx</name>+1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></sizeof> * (<name>lastidx</name> - <name>idx</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>entries</name><index>[<expr><name>lastidx</name></expr>]</index></name> = <name>e</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>&amp;<name><name>entries</name><index>[<expr><name>lastidx</name></expr>]</index></name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>h2_push_diary_append</name><parameter_list>(<param><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl></param>, <param><decl><type><name>h2_push_diary_entry</name> *</type><name>e</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_push_diary_entry</name> *</type><name>ne</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>nelts</name></name> &lt; <name><name>diary</name>-&gt;<name>N</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* append a new diary entry at the end */</comment>
        <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>entries</name></name></expr></argument>, <argument><expr><name>h2_push_diary_entry</name></expr></argument>)</argument_list></call> = *<name>e</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ne</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>entries</name></name></expr></argument>, <argument><expr><name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>nelts</name></name>-1</expr></argument>, <argument><expr><name>h2_push_diary_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* replace content with new digest. keeps memory usage constant once diary is full */</comment>
        <expr_stmt><expr><name>ne</name> = <call><name>move_to_last</name><argument_list>(<argument><expr><name>diary</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>ne</name> = *<name>e</name></expr>;</expr_stmt>
    }</block></else></if>
    <comment type="block">/* Intentional no APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>pool</name></name></expr></argument>,
                  <argument><expr>"push_diary_append: %"<name>APR_UINT64_T_HEX_FMT</name></expr></argument>, <argument><expr><name><name>ne</name>-&gt;<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>apr_array_header_t</name> *</type><name>h2_push_diary_update</name><parameter_list>(<param><decl><type><name>h2_session</name> *</type><name>session</name></decl></param>, <param><decl><type><name>apr_array_header_t</name> *</type><name>pushes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>npushes</name> <init>= <expr><name>pushes</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_push_diary_entry</name></type> <name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name><name>session</name>-&gt;<name>push_diary</name></name> &amp;&amp; <name>pushes</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>npushes</name> = <name>NULL</name></expr>;</expr_stmt>
        
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>pushes</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>h2_push</name> *</type><name>push</name></decl>;</decl_stmt>
            
            <expr_stmt><expr><name>push</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>pushes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>h2_push</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name><name>session</name>-&gt;<name>push_diary</name>-&gt;<name>dcalc</name></name><argument_list>(<argument><expr><name><name>session</name>-&gt;<name>push_diary</name></name></expr></argument>, <argument><expr>&amp;<name><name>e</name>.<name>hash</name></name></expr></argument>, <argument><expr><name>push</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>idx</name> = <call><name>h2_push_diary_find</name><argument_list>(<argument><expr><name><name>session</name>-&gt;<name>push_diary</name></name></expr></argument>, <argument><expr><name><name>e</name>.<name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>idx</name> &gt;= 0</expr>)</condition><then> <block>{
                <comment type="block">/* Intentional no APLOGNO */</comment>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>session</name>-&gt;<name>c</name></name></expr></argument>,
                              <argument><expr>"push_diary_update: already there PUSH %s"</expr></argument>, <argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>move_to_last</name><argument_list>(<argument><expr><name><name>session</name>-&gt;<name>push_diary</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* Intentional no APLOGNO */</comment>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>session</name>-&gt;<name>c</name></name></expr></argument>,
                              <argument><expr>"push_diary_update: adding PUSH %s"</expr></argument>, <argument><expr><name><name>push</name>-&gt;<name>req</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>npushes</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>npushes</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>pushes</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h2_push_diary_entry</name>*</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>npushes</name></expr></argument>, <argument><expr><name>h2_push</name>*</expr></argument>)</argument_list></call> = <name>push</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>h2_push_diary_append</name><argument_list>(<argument><expr><name><name>session</name>-&gt;<name>push_diary</name></name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
    }</block></then></if>
    <return>return <expr><name>npushes</name></expr>;</return>
}</block></function>
    
<function><type><name>apr_array_header_t</name> *</type><name>h2_push_collect_update</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, 
                                           <param><decl><type><specifier>const</specifier> struct <name>h2_request</name> *</type><name>req</name></decl></param>, 
                                           <param><decl><type><specifier>const</specifier> struct <name>h2_headers</name> *</type><name>res</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>h2_session</name> *</type><name>session</name> <init>= <expr><name><name>stream</name>-&gt;<name>session</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cache_digest</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>req</name>-&gt;<name>headers</name></name></expr></argument>, <argument><expr>"Cache-Digest"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>pushes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>cache_digest</name> &amp;&amp; <name><name>session</name>-&gt;<name>push_diary</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>h2_push_diary_digest64_set</name><argument_list>(<argument><expr><name><name>session</name>-&gt;<name>push_diary</name></name></expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>authority</name></name></expr></argument>, 
                                            <argument><expr><name>cache_digest</name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name><name>session</name>-&gt;<name>c</name></name></expr></argument>,
                          <argument><expr><call><name>H2_SSSN_LOG</name><argument_list>(<argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03057</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>session</name></expr></argument>,
                          <argument><expr>"push diary set from Cache-Digest: %s"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cache_digest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>pushes</name> = <call><name>h2_push_collect</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>req</name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>push_policy</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>h2_push_diary_update</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>session</name></name></expr></argument>, <argument><expr><name>pushes</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_int32_t</name></type> <name>h2_log2inv</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name>log2</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>log2</name>? (1 &lt;&lt; <name>log2</name>) : 1</expr>;</return>
}</block></function>


<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>log2p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>mask_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>delta_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>fixed_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>fixed_mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>datalen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>last</name></decl>;</decl_stmt>
}</block></struct></type> <name>gset_encoder</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_puint64</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>p2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_uint64_t</name> *</type><name>pu1</name> <init>= <expr><name>p1</name></expr></init>, *<name>pu2</name> <init>= <expr><name>p2</name></expr></init></decl>;</decl_stmt>
    <return>return <expr>(*<name>pu1</name> &gt; *<name>pu2</name>)? 1 : ((*<name>pu1</name> == *<name>pu2</name>)? 0 : -1)</expr>;</return>
}</block></function>

<comment type="block">/* in golomb bit stream encoding, bit 0 is the 8th of the first char, or
 * more generally: 
 *      char(bit/8) &amp; cbit_mask[(bit % 8)]
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>cbit_mask</name><index>[]</index></name> <init>= <expr><block>{
    <expr>0x80u</expr>,
    <expr>0x40u</expr>,
    <expr>0x20u</expr>,
    <expr>0x10u</expr>,
    <expr>0x08u</expr>,
    <expr>0x04u</expr>,
    <expr>0x02u</expr>,
    <expr>0x01u</expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>gset_encode_bit</name><parameter_list>(<param><decl><type><name>gset_encoder</name> *</type><name>encoder</name></decl></param>, <param><decl><type><name>int</name></type> <name>bit</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>++<name><name>encoder</name>-&gt;<name>bit</name></name> &gt;= 8</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>++<name><name>encoder</name>-&gt;<name>offset</name></name> &gt;= <name><name>encoder</name>-&gt;<name>datalen</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nlen</name> <init>= <expr><name><name>encoder</name>-&gt;<name>datalen</name></name>*2</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>ndata</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>encoder</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>nlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr>!<name>ndata</name></expr>)</condition><then> <block>{
                <return>return <expr><name>APR_ENOMEM</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ndata</name></expr></argument>, <argument><expr><name><name>encoder</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>encoder</name>-&gt;<name>datalen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>encoder</name>-&gt;<name>data</name></name> = <name>ndata</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>encoder</name>-&gt;<name>datalen</name></name> = <name>nlen</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>encoder</name>-&gt;<name>bit</name></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>encoder</name>-&gt;<name>data</name><index>[<expr><name><name>encoder</name>-&gt;<name>offset</name></name></expr>]</index></name> = 0xffu</expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr>!<name>bit</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>encoder</name>-&gt;<name>data</name><index>[<expr><name><name>encoder</name>-&gt;<name>offset</name></name></expr>]</index></name> &amp;= ~<name><name>cbit_mask</name><index>[<expr><name><name>encoder</name>-&gt;<name>bit</name></name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>gset_encode_next</name><parameter_list>(<param><decl><type><name>gset_encoder</name> *</type><name>encoder</name></decl></param>, <param><decl><type><name>apr_uint64_t</name></type> <name>pval</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>delta</name></decl>, <decl><type ref="prev"/><name>flex_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>delta</name> = <name>pval</name> - <name><name>encoder</name>-&gt;<name>last</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>-&gt;<name>last</name></name> = <name>pval</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>flex_bits</name> = (<name>delta</name> &gt;&gt; <name><name>encoder</name>-&gt;<name>fixed_bits</name></name>)</expr>;</expr_stmt>
    <comment type="block">/* Intentional no APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>encoder</name>-&gt;<name>pool</name></name></expr></argument>,
                  <argument><expr>"h2_push_diary_enc: val=%"<name>APR_UINT64_T_HEX_FMT</name>", delta=%"
                  <name>APR_UINT64_T_HEX_FMT</name>" flex_bits=%"<name>APR_UINT64_T_FMT</name>", "
                  ", fixed_bits=%d, fixed_val=%"<name>APR_UINT64_T_HEX_FMT</name></expr></argument>, 
                  <argument><expr><name>pval</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>flex_bits</name></expr></argument>, <argument><expr><name><name>encoder</name>-&gt;<name>fixed_bits</name></name></expr></argument>, <argument><expr><name>delta</name>&amp;<name><name>encoder</name>-&gt;<name>fixed_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr><name>flex_bits</name> != 0</expr>;</condition> <incr><expr>--<name>flex_bits</name></expr></incr>) <block>{
        <expr_stmt><expr><name>status</name> = <call><name>gset_encode_bit</name><argument_list>(<argument><expr><name>encoder</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>status</name></expr>;</return>
        }</block></then></if>
    }</block></for>
    <expr_stmt><expr><name>status</name> = <call><name>gset_encode_bit</name><argument_list>(<argument><expr><name>encoder</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>

    <for>for (<init><expr><name>i</name> = <name><name>encoder</name>-&gt;<name>fixed_bits</name></name>-1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name>status</name> = <call><name>gset_encode_bit</name><argument_list>(<argument><expr><name>encoder</name></expr></argument>, <argument><expr>(<name>delta</name> &gt;&gt; <name>i</name>) &amp; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>status</name></expr>;</return>
        }</block></then></if>
    }</block></for>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * Get a cache digest as described in 
 * https://datatracker.ietf.org/doc/draft-kazuho-h2-cache-digest/
 * from the contents of the push diary.
 * 
 * @param diary the diary to calculdate the digest from
 * @param p the pool to use
 * @param pdata on successful return, the binary cache digest
 * @param plen on successful return, the length of the binary data
 */</comment>
<function><type><name>apr_status_t</name></type> <name>h2_push_diary_digest_get</name><parameter_list>(<param><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, 
                                      <param><decl><type><name>int</name></type> <name>maxP</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authority</name></decl></param>, 
                                      <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pdata</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>plen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>nelts</name></decl>, <decl><type ref="prev"/><name>N</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>log2n</name></decl>, <decl><type ref="prev"/><name>log2pmax</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>gset_encoder</name></type> <name>encoder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uint64_t</name> *</type><name>hashes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>hash_count</name></decl>;</decl_stmt>
    
    <expr_stmt><expr><name>nelts</name> = <name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>nelts</name> &gt; <name>APR_UINT32_MAX</name></expr>)</condition><then> <block>{
        <comment type="block">/* should not happen */</comment>
        <return>return <expr><name>APR_ENOTIMPL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>N</name> = <call><name>ceil_power_of_2</name><argument_list>(<argument><expr><name>nelts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>log2n</name> = <call><name>h2_log2</name><argument_list>(<argument><expr><name>N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Now log2p is the max number of relevant bits, so that
     * log2p + log2n == mask_bits. We can uise a lower log2p
     * and have a shorter set encoding...
     */</comment>
    <expr_stmt><expr><name>log2pmax</name> = <call><name>h2_log2</name><argument_list>(<argument><expr><call><name>ceil_power_of_2</name><argument_list>(<argument><expr><name>maxP</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>encoder</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>encoder</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>diary</name></name> = <name>diary</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>log2p</name></name> = <call><name>H2MIN</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>mask_bits</name></name> - <name>log2n</name></expr></argument>, <argument><expr><name>log2pmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>mask_bits</name></name> = <name>log2n</name> + <name><name>encoder</name>.<name>log2p</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>delta_bits</name></name> = <name><name>diary</name>-&gt;<name>mask_bits</name></name> - <name><name>encoder</name>.<name>mask_bits</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>fixed_bits</name></name> = <name><name>encoder</name>.<name>log2p</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>fixed_mask</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>fixed_mask</name></name> = (<name><name>encoder</name>.<name>fixed_mask</name></name> &lt;&lt; <name><name>encoder</name>.<name>fixed_bits</name></name>) - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>datalen</name></name> = 512</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>data</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>encoder</name>.<name>pool</name></name></expr></argument>, <argument><expr><name><name>encoder</name>.<name>datalen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>encoder</name>.<name>data</name><index>[<expr>0</expr>]</index></name> = <name>log2n</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>data</name><index>[<expr>1</expr>]</index></name> = <name><name>encoder</name>.<name>log2p</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>offset</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>bit</name></name> = 8</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>encoder</name>.<name>last</name></name> = 0</expr>;</expr_stmt>
    
    <comment type="block">/* Intentional no APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                  <argument><expr>"h2_push_diary_digest_get: %d entries, N=%d, log2n=%d, "
                  "mask_bits=%d, enc.mask_bits=%d, delta_bits=%d, enc.log2p=%d, authority=%s"</expr></argument>, 
                  <argument><expr>(<name>int</name>)<name>nelts</name></expr></argument>, <argument><expr>(<name>int</name>)<name>N</name></expr></argument>, <argument><expr>(<name>int</name>)<name>log2n</name></expr></argument>, <argument><expr><name><name>diary</name>-&gt;<name>mask_bits</name></name></expr></argument>, 
                  <argument><expr>(<name>int</name>)<name><name>encoder</name>.<name>mask_bits</name></name></expr></argument>, <argument><expr>(<name>int</name>)<name><name>encoder</name>.<name>delta_bits</name></name></expr></argument>, 
                  <argument><expr>(<name>int</name>)<name><name>encoder</name>.<name>log2p</name></name></expr></argument>, <argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  
    <if>if <condition>(<expr>!<name>authority</name> || !<name><name>diary</name>-&gt;<name>authority</name></name> 
        || !<call><name>strcmp</name><argument_list>(<argument><expr>"*"</expr></argument>, <argument><expr><name>authority</name></expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>authority</name></name></expr></argument>, <argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>hash_count</name> = <name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hashes</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>encoder</name>.<name>pool</name></name></expr></argument>, <argument><expr><name>hash_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>hash_count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <expr_stmt><expr><name><name>hashes</name><index>[<expr><name>i</name></expr>]</index></name> = ((&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>entries</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>h2_push_diary_entry</name></expr></argument>)</argument_list></call>)-&gt;<name>hash</name> 
                         &gt;&gt; <name><name>encoder</name>.<name>delta_bits</name></name>)</expr>;</expr_stmt>
        }</block></for>
        
        <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>hashes</name></expr></argument>, <argument><expr><name>hash_count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>apr_uint64_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_puint64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>hash_count</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr>!<name>i</name> || (<name><name>hashes</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>hashes</name><index>[<expr><name>i</name>-1</expr>]</index></name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>gset_encode_next</name><argument_list>(<argument><expr>&amp;<name>encoder</name></expr></argument>, <argument><expr><name><name>hashes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <comment type="block">/* Intentional no APLOGNO */</comment>
        <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                      <argument><expr>"h2_push_diary_digest_get: golomb compressed hashes, %d bytes"</expr></argument>,
                      <argument><expr>(<name>int</name>)<name><name>encoder</name>.<name>offset</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr>*<name>pdata</name> = (const <name>char</name> *)<name><name>encoder</name>.<name>data</name></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>plen</name> = <name><name>encoder</name>.<name>offset</name></name> + 1</expr>;</expr_stmt>
    
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>log2p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>datalen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>offset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>last_val</name></decl>;</decl_stmt>
}</block></struct></type> <name>gset_decoder</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>gset_decode_next_bit</name><parameter_list>(<param><decl><type><name>gset_decoder</name> *</type><name>decoder</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>++<name><name>decoder</name>-&gt;<name>bit</name></name> &gt;= 8</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>++<name><name>decoder</name>-&gt;<name>offset</name></name> &gt;= <name><name>decoder</name>-&gt;<name>datalen</name></name></expr>)</condition><then> <block>{
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>decoder</name>-&gt;<name>bit</name></name> = 0</expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name><name>decoder</name>-&gt;<name>data</name><index>[<expr><name><name>decoder</name>-&gt;<name>offset</name></name></expr>]</index></name> &amp; <name><name>cbit_mask</name><index>[<expr><name><name>decoder</name>-&gt;<name>bit</name></name></expr>]</index></name>)? 1 : 0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>gset_decode_next</name><parameter_list>(<param><decl><type><name>gset_decoder</name> *</type><name>decoder</name></decl></param>, <param><decl><type><name>apr_uint64_t</name> *</type><name>phash</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>flex</name> <init>= <expr>0</expr></init>, <name>fixed</name> <init>= <expr>0</expr></init>, <name>delta</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    
    <comment type="block">/* read 1 bits until we encounter 0, then read log2n(diary-P) bits.
     * On a malformed bit-string, this will not fail, but produce results
     * which are pbly too large. Luckily, the diary will modulo the hash.
     */</comment>
    <while>while <condition>(<expr>1</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><call><name>gset_decode_next_bit</name><argument_list>(<argument><expr><name>decoder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>bit</name> == -1</expr>)</condition><then> <block>{
            <return>return <expr><name>APR_EINVAL</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>bit</name></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr>++<name>flex</name></expr>;</expr_stmt>
    }</block></while>
    
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>decoder</name>-&gt;<name>log2p</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>bit</name> <init>= <expr><call><name>gset_decode_next_bit</name><argument_list>(<argument><expr><name>decoder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>bit</name> == -1</expr>)</condition><then> <block>{
            <return>return <expr><name>APR_EINVAL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>fixed</name> = (<name>fixed</name> &lt;&lt; 1) | <name>bit</name></expr>;</expr_stmt>
    }</block></for>
    
    <expr_stmt><expr><name>delta</name> = (<name>flex</name> &lt;&lt; <name><name>decoder</name>-&gt;<name>log2p</name></name>) | <name>fixed</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>phash</name> = <name>delta</name> + <name><name>decoder</name>-&gt;<name>last_val</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoder</name>-&gt;<name>last_val</name></name> = *<name>phash</name></expr>;</expr_stmt>
    
    <comment type="block">/* Intentional no APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>decoder</name>-&gt;<name>pool</name></name></expr></argument>,
                  <argument><expr>"h2_push_diary_digest_dec: val=%"<name>APR_UINT64_T_HEX_FMT</name>", delta=%"
                  <name>APR_UINT64_T_HEX_FMT</name>", flex=%d, fixed=%"<name>APR_UINT64_T_HEX_FMT</name></expr></argument>, 
                  <argument><expr>*<name>phash</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr>(<name>int</name>)<name>flex</name></expr></argument>, <argument><expr><name>fixed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * Initialize the push diary by a cache digest as described in 
 * https://datatracker.ietf.org/doc/draft-kazuho-h2-cache-digest/
 * .
 * @param diary the diary to set the digest into
 * @param data the binary cache digest
 * @param len the length of the cache digest
 * @return APR_EINVAL if digest was not successfully parsed
 */</comment>
<function><type><name>apr_status_t</name></type> <name>h2_push_diary_digest_set</name><parameter_list>(<param><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authority</name></decl></param>, 
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>gset_decoder</name></type> <name>decoder</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>log2n</name></decl>, <decl><type ref="prev"/><name>log2p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>N</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_push_diary_entry</name></type> <name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>len</name> &lt; 2</expr>)</condition><then> <block>{
        <comment type="block">/* at least this should be there */</comment>
        <return>return <expr><name>APR_EINVAL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>log2n</name> = <name><name>data</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>log2p</name> = <name><name>data</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>diary</name>-&gt;<name>mask_bits</name></name> = <name>log2n</name> + <name>log2p</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>diary</name>-&gt;<name>mask_bits</name></name> &gt; 64</expr>)</condition><then> <block>{
        <comment type="block">/* cannot handle */</comment>
        <return>return <expr><name>APR_ENOTIMPL</name></expr>;</return>
    }</block></then></if>
    
    <comment type="block">/* whatever is in the digest, it replaces the diary entries */</comment>
    <expr_stmt><expr><call><name>apr_array_clear</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>authority</name> || !<call><name>strcmp</name><argument_list>(<argument><expr>"*"</expr></argument>, <argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>diary</name>-&gt;<name>authority</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<name><name>diary</name>-&gt;<name>authority</name></name> || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>authority</name></name></expr></argument>, <argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>diary</name>-&gt;<name>authority</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>authority</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <expr_stmt><expr><name>N</name> = <call><name>h2_log2inv</name><argument_list>(<argument><expr><name>log2n</name> + <name>log2p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>decoder</name>.<name>diary</name></name>    = <name>diary</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoder</name>.<name>pool</name></name>     = <name>pool</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoder</name>.<name>log2p</name></name>    = <name>log2p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoder</name>.<name>data</name></name>     = (const <name>unsigned</name> <name>char</name>*)<name>data</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoder</name>.<name>datalen</name></name>  = <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoder</name>.<name>offset</name></name>   = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoder</name>.<name>bit</name></name>      = 8</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>decoder</name>.<name>last_val</name></name> = 0</expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>diary</name>-&gt;<name>N</name></name> = <name>N</name></expr>;</expr_stmt>
    <comment type="block">/* Determine effective N we use for storage */</comment>
    <if>if <condition>(<expr>!<name>N</name></expr>)</condition><then> <block>{
        <comment type="block">/* a totally empty cache digest. someone tells us that she has no
         * entries in the cache at all. Use our own preferences for N+mask 
         */</comment>
        <expr_stmt><expr><name><name>diary</name>-&gt;<name>N</name></name> = <name><name>diary</name>-&gt;<name>NMax</name></name></expr>;</expr_stmt>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>N</name> &gt; <name><name>diary</name>-&gt;<name>NMax</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Store not more than diary is configured to hold. We open us up
         * to DOS attacks otherwise. */</comment>
        <expr_stmt><expr><name><name>diary</name>-&gt;<name>N</name></name> = <name><name>diary</name>-&gt;<name>NMax</name></name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    
    <comment type="block">/* Intentional no APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                  <argument><expr>"h2_push_diary_digest_set: N=%d, log2n=%d, "
                  "diary-&gt;mask_bits=%d, dec.log2p=%d"</expr></argument>, 
                  <argument><expr>(<name>int</name>)<name><name>diary</name>-&gt;<name>N</name></name></expr></argument>, <argument><expr>(<name>int</name>)<name>log2n</name></expr></argument>, <argument><expr><name><name>diary</name>-&gt;<name>mask_bits</name></name></expr></argument>, 
                  <argument><expr>(<name>int</name>)<name><name>decoder</name>.<name>log2p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>diary</name>-&gt;<name>N</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>gset_decode_next</name><argument_list>(<argument><expr>&amp;<name>decoder</name></expr></argument>, <argument><expr>&amp;<name><name>e</name>.<name>hash</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="block">/* the data may have less than N values */</comment>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><call><name>h2_push_diary_append</name><argument_list>(<argument><expr><name>diary</name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    
    <comment type="block">/* Intentional no APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                  <argument><expr>"h2_push_diary_digest_set: diary now with %d entries, mask_bits=%d"</expr></argument>, 
                  <argument><expr>(<name>int</name>)<name><name>diary</name>-&gt;<name>entries</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><name><name>diary</name>-&gt;<name>mask_bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<function><type><name>apr_status_t</name></type> <name>h2_push_diary_digest64_set</name><parameter_list>(<param><decl><type><name>h2_push_diary</name> *</type><name>diary</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authority</name></decl></param>, 
                                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data64url</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>h2_util_base64url_decode</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>data64url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <comment type="block">/* Intentional no APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>GCSLOG_LEVEL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                  <argument><expr>"h2_push_diary_digest64_set: digest=%s, dlen=%d"</expr></argument>, 
                  <argument><expr><name>data64url</name></expr></argument>, <argument><expr>(<name>int</name>)<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>h2_push_diary_digest_set</name><argument_list>(<argument><expr><name>diary</name></expr></argument>, <argument><expr><name>authority</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

</unit>
