<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/http2/h2_stream.h"><comment type="block">/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__mod_h2__h2_stream__</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__mod_h2__h2_stream__</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"h2.h"</cpp:file></cpp:include>

<comment type="block">/**
 * A HTTP/2 stream, e.g. a client request+response in HTTP/1.1 terms.
 * 
 * A stream always belongs to a h2_session, the one managing the
 * connection to the client. The h2_session writes to the h2_stream,
 * adding HEADERS and DATA and finally an EOS. When headers are done,
 * h2_stream is scheduled for handling, which is expected to produce
 * a response h2_headers at least.
 * 
 * The h2_headers may be followed by more h2_headers (interim responses) and
 * by DATA frames read from the h2_stream until EOS is reached. Trailers
 * are send when a last h2_headers is received. This always closes the stream
 * output.
 */</comment>

<struct_decl>struct <name>h2_mplx</name>;</struct_decl>
<struct_decl>struct <name>h2_priority</name>;</struct_decl>
<struct_decl>struct <name>h2_request</name>;</struct_decl>
<struct_decl>struct <name>h2_headers</name>;</struct_decl>
<struct_decl>struct <name>h2_session</name>;</struct_decl>
<struct_decl>struct <name>h2_task</name>;</struct_decl>
<struct_decl>struct <name>h2_bucket_beam</name>;</struct_decl>

<typedef>typedef <type>struct <name>h2_stream</name></type> <name>h2_stream</name>;</typedef>

<typedef>typedef <function_decl><type><name>void</name></type> <name>h2_stream_state_cb</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> <name>h2_stream_event_cb</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, 
                                <param><decl><type><name>h2_stream_event_t</name></type> <name>ev</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/**
 * Callback structure for events and stream state transisitions
 */</comment>
<typedef>typedef <type><struct>struct <name>h2_stream_monitor</name> <block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_stream_state_cb</name> *</type><name>on_state_enter</name></decl>;</decl_stmt>   <comment type="block">/* called when a state is entered */</comment>
    <decl_stmt><decl><type><name>h2_stream_state_cb</name> *</type><name>on_state_invalid</name></decl>;</decl_stmt> <comment type="block">/* called when an invalid state change
                                             was detected */</comment>
    <decl_stmt><decl><type><name>h2_stream_event_cb</name> *</type><name>on_state_event</name></decl>;</decl_stmt>   <comment type="block">/* called right before the given event
                                             result in a new stream state */</comment>
    <decl_stmt><decl><type><name>h2_stream_event_cb</name> *</type><name>on_event</name></decl>;</decl_stmt>         <comment type="block">/* called for events that do not 
                                             trigger a state change */</comment>
}</block></struct></type> <name>h2_stream_monitor</name>;</typedef>

<struct>struct <name>h2_stream</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>                     <comment type="block">/* http2 stream identifier */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>initiated_on</name></decl>;</decl_stmt>           <comment type="block">/* initiating stream id (PUSH) or 0 */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>           <comment type="block">/* the memory pool for this stream */</comment>
    <decl_stmt><decl><type>struct <name>h2_session</name> *</type><name>session</name></decl>;</decl_stmt> <comment type="block">/* the session this stream belongs to */</comment>
    <decl_stmt><decl><type><name>h2_stream_state_t</name></type> <name>state</name></decl>;</decl_stmt>    <comment type="block">/* state of this stream */</comment>
    
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>created</name></decl>;</decl_stmt>         <comment type="block">/* when stream was created */</comment>
    
    <decl_stmt><decl><type><specifier>const</specifier> struct <name>h2_request</name> *</type><name>request</name></decl>;</decl_stmt> <comment type="block">/* the request made in this stream */</comment>
    <decl_stmt><decl><type>struct <name>h2_request</name> *</type><name>rtmp</name></decl>;</decl_stmt>    <comment type="block">/* request being assembled */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>trailers</name></decl>;</decl_stmt>      <comment type="block">/* optional incoming trailers */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>request_headers_added</name></decl>;</decl_stmt>  <comment type="block">/* number of request headers added */</comment>
    
    <decl_stmt><decl><type>struct <name>h2_bucket_beam</name> *</type><name>input</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>in_buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>in_window_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>in_last_write</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type>struct <name>h2_bucket_beam</name> *</type><name>output</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>out_buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>max_mem</name></decl>;</decl_stmt>         <comment type="block">/* maximum amount of data buffered */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>rst_error</name></decl>;</decl_stmt>              <comment type="block">/* stream error for RST_STREAM */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>aborted</name>   : 1</expr>;</expr_stmt> <comment type="block">/* was aborted */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>scheduled</name> : 1</expr>;</expr_stmt> <comment type="block">/* stream has been scheduled */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>has_response</name> : 1</expr>;</expr_stmt> <comment type="block">/* response headers are known */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>input_eof</name> : 1</expr>;</expr_stmt> <comment type="block">/* no more request data coming */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>out_checked</name> : 1</expr>;</expr_stmt> <comment type="block">/* output eof was double checked */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>push_policy</name></decl>;</decl_stmt>   <comment type="block">/* which push policy to use for this request */</comment>
    
    <decl_stmt><decl><type>struct <name>h2_task</name> *</type><name>task</name></decl>;</decl_stmt>       <comment type="block">/* assigned task to fullfill request */</comment>
    
    <decl_stmt><decl><type><specifier>const</specifier> <name>h2_priority</name> *</type><name>pref_priority</name></decl>;</decl_stmt> <comment type="block">/* preferred priority for this stream */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>out_data_frames</name></decl>;</decl_stmt>  <comment type="block">/* # of DATA frames sent */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>out_data_octets</name></decl>;</decl_stmt>  <comment type="block">/* # of DATA octets (payload) sent */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>in_data_frames</name></decl>;</decl_stmt>   <comment type="block">/* # of DATA frames received */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>in_data_octets</name></decl>;</decl_stmt>   <comment type="block">/* # of DATA octets (payload) received */</comment>
    
    <decl_stmt><decl><type><name>h2_stream_monitor</name> *</type><name>monitor</name></decl>;</decl_stmt> <comment type="block">/* optional monitor for stream states */</comment>
}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_STREAM_RST</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>def</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>(s-&gt;rst_error? s-&gt;rst_error : (def))</cpp:value></cpp:define>

<comment type="block">/**
 * Create a stream in H2_SS_IDLE state.
 * @param id      the stream identifier
 * @param pool    the memory pool to use for this stream
 * @param session the session this stream belongs to
 * @param monitor an optional monitor to be called for events and 
 *                state transisitions
 * @param initiated_on the id of the stream this one was initiated on (PUSH)
 *
 * @return the newly opened stream
 */</comment>
<function_decl><type><name>h2_stream</name> *</type><name>h2_stream_create</name><parameter_list>(<param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, 
                            <param><decl><type>struct <name>h2_session</name> *</type><name>session</name></decl></param>,
                            <param><decl><type><name>h2_stream_monitor</name> *</type><name>monitor</name></decl></param>,
                            <param><decl><type><name>int</name></type> <name>initiated_on</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Destroy memory pool if still owned by the stream.
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_stream_destroy</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Prepare the stream so that processing may start.
 * 
 * This is the time to allocated resources not needed before.
 * 
 * @param stream the stream to prep 
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_prep_processing</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Set a new monitor for this stream, replacing any existing one. Can
 * be called with NULL to have no monitor installed.
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_stream_set_monitor</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>h2_stream_monitor</name> *</type><name>monitor</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Dispatch (handle) an event on the given stream.
 * @param stream  the streama the event happened on
 * @param ev      the type of event
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_stream_dispatch</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>h2_stream_event_t</name></type> <name>ev</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Cleanup references into requst processing.
 *
 * @param stream the stream to cleanup
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_stream_cleanup</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Detach the memory pool from the stream. Will prevent stream
 * destruction to take the pool with it.
 *
 * @param stream the stream to detach the pool from
 * @result the detached memory pool or NULL if stream no longer has one
 */</comment>
<function_decl><type><name>apr_pool_t</name> *</type><name>h2_stream_detach_pool</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Notify the stream that amount bytes have been consumed of its input
 * since the last invocation of this method (delta amount).
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_in_consumed</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>amount</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Set complete stream headers from given h2_request.
 * 
 * @param stream stream to write request to
 * @param r the request with all the meta data
 * @param eos != 0 iff stream input is closed
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_stream_set_request</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>h2_request</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Set complete stream header from given request_rec.
 * 
 * @param stream stream to write request to
 * @param r the request with all the meta data
 * @param eos != 0 iff stream input is closed
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_set_request_rec</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, 
                                       <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name></type> <name>eos</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Add a HTTP/2 header (including pseudo headers) or trailer 
 * to the given stream, depending on stream state.
 *
 * @param stream stream to write the header to
 * @param name the name of the HTTP/2 header
 * @param nlen the number of characters in name
 * @param value the header value
 * @param vlen the number of characters in value
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_add_header</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>nlen</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>vlen</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_send_frame</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>int</name></type> <name>frame_type</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_recv_frame</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>int</name></type> <name>frame_type</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Process a frame of received DATA.
 *
 * @param stream stream to write the data to
 * @param flags the frame flags
 * @param data the beginning of the bytes to write
 * @param len the number of bytes to write
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_recv_DATA</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>uint8_t</name></type> <name>flags</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>uint8_t</name> *</type><name>data</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_flush_input</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Reset the stream. Stream write/reads will return errors afterwards.
 *
 * @param stream the stream to reset
 * @param error_code the HTTP/2 error code
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_stream_rst</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>int</name></type> <name>error_code</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Determine if stream was closed already. This is true for
 * states H2_SS_CLOSED, H2_SS_CLEANUP. But not true
 * for H2_SS_CLOSED_L and H2_SS_CLOSED_R.
 *
 * @param stream the stream to check on
 * @return != 0 iff stream has been closed
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_stream_was_closed</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Do a speculative read on the stream output to determine the 
 * amount of data that can be read.
 * 
 * @param stream the stream to speculatively read from
 * @param plen (in-/out) number of bytes requested and on return amount of bytes that
 *        may be read without blocking
 * @param peos (out) != 0 iff end of stream will be reached when reading plen
 *        bytes (out value).
 * @param presponse (out) the response of one became available
 * @return APR_SUCCESS if out information was computed successfully.
 *         APR_EAGAIN if not data is available and end of stream has not been
 *         reached yet.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_out_prepare</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>apr_off_t</name> *</type><name>plen</name></decl></param>, 
                                   <param><decl><type><name>int</name> *</type><name>peos</name></decl></param>, <param><decl><type><name>h2_headers</name> **</type><name>presponse</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Read a maximum number of bytes into the bucket brigade.
 * 
 * @param stream the stream to read from
 * @param bb the brigade to append output to
 * @param plen (in-/out) max. number of bytes to append and on return actual
 *        number of bytes appended to brigade
 * @param peos (out) != 0 iff end of stream has been reached while reading
 * @return APR_SUCCESS if out information was computed successfully.
 *         APR_EAGAIN if not data is available and end of stream has not been
 *         reached yet.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_read_to</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, 
                               <param><decl><type><name>apr_off_t</name> *</type><name>plen</name></decl></param>, <param><decl><type><name>int</name> *</type><name>peos</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get optional trailers for this stream, may be NULL. Meaningful
 * results can only be expected when the end of the response body has
 * been reached.
 *
 * @param stream to ask for trailers
 * @return trailers for NULL
 */</comment>
<function_decl><type><name>apr_table_t</name> *</type><name>h2_stream_get_trailers</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Submit any server push promises on this stream and schedule
 * the tasks connection with these.
 *
 * @param stream the stream for which to submit
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_stream_submit_pushes</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>h2_headers</name> *</type><name>response</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get priority information set for this stream.
 */</comment>
<function_decl><type><specifier>const</specifier> struct <name>h2_priority</name> *</type><name>h2_stream_get_priority</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>, 
                                                 <param><decl><type><name>h2_headers</name> *</type><name>response</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return a textual representation of the stream state as in RFC 7540
 * nomenclator, all caps, underscores.
 */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>h2_stream_state_str</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Determine if stream is ready for submitting a response or a RST
 * @param stream the stream to check
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_stream_is_ready</name><parameter_list>(<param><decl><type><name>h2_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_STRM_MSG</name><parameter_list>(<param><type><name>s</name></type></param>, <param><type><name>msg</name></type></param>)</parameter_list></cpp:macro>     \
    <cpp:value>"h2_stream(%ld-%d,%s): "msg, s-&gt;session-&gt;id, s-&gt;id, h2_stream_state_str(s)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_STRM_LOG</name><parameter_list>(<param><type><name>aplogno</name></type></param>, <param><type><name>s</name></type></param>, <param><type><name>msg</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>aplogno H2_STRM_MSG(s, msg)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(__mod_h2__h2_stream__) */</comment>
</unit>
