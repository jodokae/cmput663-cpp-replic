<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/http2/h2_bucket_beam.h"><comment type="block">/* Copyright 2015 greenbytes GmbH (https://www.greenbytes.de)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>h2_bucket_beam_h</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>h2_bucket_beam_h</name></cpp:macro></cpp:define>

<struct_decl>struct <name>apr_thread_mutex_t</name>;</struct_decl>
<struct_decl>struct <name>apr_thread_cond_t</name>;</struct_decl>

<comment type="block">/*******************************************************************************
 * apr_bucket list without bells and whistles
 ******************************************************************************/</comment>
 
<comment type="block">/**
 * h2_blist can hold a list of buckets just like apr_bucket_brigade, but
 * does not to any allocations or related features.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <macro><name>APR_RING_HEAD</name><argument_list>(<argument>h2_bucket_list</argument>, <argument>apr_bucket</argument>)</argument_list></macro> <expr_stmt><expr><name>list</name></expr>;</expr_stmt>
}</block></struct></type> <name>h2_blist</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_INIT</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>        <cpp:value>APR_RING_INIT(&amp;(b)-&gt;list, apr_bucket, link);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_SENTINEL</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>APR_RING_SENTINEL(&amp;(b)-&gt;list, apr_bucket, link)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_EMPTY</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>APR_RING_EMPTY(&amp;(b)-&gt;list, apr_bucket, link)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_FIRST</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>       <cpp:value>APR_RING_FIRST(&amp;(b)-&gt;list)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_LAST</name><parameter_list>(<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>	<cpp:value>APR_RING_LAST(&amp;(b)-&gt;list)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_INSERT_HEAD</name><parameter_list>(<param><type><name>b</name></type></param>, <param><type><name>e</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {				\
	apr_bucket *ap__b = (e);                                        \
	APR_RING_INSERT_HEAD(&amp;(b)-&gt;list, ap__b, apr_bucket, link);	\
    } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_INSERT_TAIL</name><parameter_list>(<param><type><name>b</name></type></param>, <param><type><name>e</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {				\
	apr_bucket *ap__b = (e);					\
	APR_RING_INSERT_TAIL(&amp;(b)-&gt;list, ap__b, apr_bucket, link);	\
    } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_CONCAT</name><parameter_list>(<param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {					\
        APR_RING_CONCAT(&amp;(a)-&gt;list, &amp;(b)-&gt;list, apr_bucket, link);	\
    } while (0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>H2_BLIST_PREPEND</name><parameter_list>(<param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do {					\
        APR_RING_PREPEND(&amp;(a)-&gt;list, &amp;(b)-&gt;list, apr_bucket, link);	\
    } while (0)</cpp:value></cpp:define>

<comment type="block">/*******************************************************************************
 * h2_bucket_beam
 ******************************************************************************/</comment>

<comment type="block">/**
 * A h2_bucket_beam solves the task of transferring buckets, esp. their data,
 * across threads with zero buffer copies.
 *
 * When a thread, let's call it the sender thread, wants to send buckets to
 * another, the green thread, it creates a h2_bucket_beam and adds buckets
 * via the h2_beam_send(). It gives the beam to the green thread which then
 * can receive buckets into its own brigade via h2_beam_receive().
 *
 * Sending and receiving can happen concurrently.
 *
 * The beam can limit the amount of data it accepts via the buffer_size. This
 * can also be adjusted during its lifetime. Sends and receives can be done blocking. 
 * A timeout can be set for such blocks.
 *
 * Care needs to be taken when terminating the beam. The beam registers at
 * the pool it was created with and will cleanup after itself. However, if
 * received buckets do still exist, already freed memory might be accessed.
 * The beam does a assertion on this condition.
 * 
 * The proper way of shutting down a beam is to first make sure there are no
 * more green buckets out there, then cleanup the beam to purge eventually
 * still existing sender buckets and then, possibly, terminate the beam itself
 * (or the pool it was created with).
 *
 * The following restrictions apply to bucket transport:
 * - only EOS and FLUSH meta buckets are copied through. All other meta buckets
 *   are kept in the beams hold.
 * - all kind of data buckets are transported through:
 *   - transient buckets are converted to heap ones on send
 *   - heap and pool buckets require no extra handling
 *   - buckets with indeterminate length are read on send
 *   - file buckets will transfer the file itself into a new bucket, if allowed
 *   - all other buckets are read on send to make sure data is present
 *
 * This assures that when the sender thread sends its sender buckets, the data
 * is made accessible while still on the sender side. The sender bucket then enters
 * the beams hold storage.
 * When the green thread calls receive, sender buckets in the hold are wrapped
 * into special beam buckets. Beam buckets on read present the data directly
 * from the internal sender one, but otherwise live on the green side. When a
 * beam bucket gets destroyed, it notifies its beam that the corresponding
 * sender bucket from the hold may be destroyed.
 * Since the destruction of green buckets happens in the green thread, any
 * corresponding sender bucket can not immediately be destroyed, as that would
 * result in race conditions.
 * Instead, the beam transfers such sender buckets from the hold to the purge
 * storage. Next time there is a call from the sender side, the buckets in
 * purge will be deleted.
 *
 * There are callbacks that can be registesender with a beam:
 * - a "consumed" callback that gets called on the sender side with the
 *   amount of data that has been received by the green side. The amount
 *   is a delta from the last callback invocation. The sender side can trigger
 *   these callbacks by calling h2_beam_send() with a NULL brigade.
 * - a "can_beam_file" callback that can prohibit the transfer of file handles
 *   through the beam. This will cause file buckets to be read on send and
 *   its data buffer will then be transports just like a heap bucket would.
 *   When no callback is registered, no restrictions apply and all files are
 *   passed through.
 *   File handles transfersender to the green side will stay there until the
 *   receiving brigade's pool is destroyed/cleared. If the pool lives very
 *   long or if many different files are beamed, the process might run out
 *   of available file handles.
 *
 * The name "beam" of course is inspired by good old transporter
 * technology where humans are kept inside the transporter's memory
 * buffers until the transmission is complete. Star gates use a similar trick.
 */</comment>

<typedef>typedef <function_decl><type><name>void</name></type> <name>h2_beam_mutex_leave</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>,  <param><decl><type>struct <name>apr_thread_mutex_t</name> *</type><name>lock</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>mutex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_mutex_leave</name> *</type><name>leave</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>leave_ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>h2_beam_lock</name>;</typedef>

<typedef>typedef <type>struct <name>h2_bucket_beam</name></type> <name>h2_bucket_beam</name>;</typedef>

<typedef>typedef <function_decl><type><name>apr_status_t</name></type> <name>h2_beam_mutex_enter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_beam_lock</name> *</type><name>pbl</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>void</name></type> <name>h2_beam_io_callback</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>,
                                 <param><decl><type><name>apr_off_t</name></type> <name>bytes</name></decl></param>)</parameter_list>;</function_decl></typedef>
<typedef>typedef <function_decl><type><name>void</name></type> <name>h2_beam_ev_callback</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type>struct <name>h2_beam_proxy</name></type> <name>h2_beam_proxy</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
    <macro><name>APR_RING_HEAD</name><argument_list>(<argument>h2_beam_proxy_list</argument>, <argument>h2_beam_proxy</argument>)</argument_list></macro> <expr_stmt><expr><name>list</name></expr>;</expr_stmt>
}</block></struct></type> <name>h2_bproxy_list</name>;</typedef>

<typedef>typedef <function_decl><type><name>int</name></type> <name>h2_beam_can_beam_callback</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>,
                                      <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>H2_BEAM_OWNER_SEND</name></decl>,
    <decl><name>H2_BEAM_OWNER_RECV</name></decl>
}</block></enum></type> <name>h2_beam_owner_t</name>;</typedef>

<comment type="block">/**
 * Will deny all transfer of apr_file_t across the beam and force
 * a data copy instead.
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_beam_no_files</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>)</parameter_list>;</function_decl>

<struct>struct <name>h2_bucket_beam</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_owner_t</name></type> <name>owner</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_blist</name></type> <name>send_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_blist</name></type> <name>hold_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_blist</name></type> <name>purge_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>recv_buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_bproxy_list</name></type> <name>proxies</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>send_pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>recv_pool</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>max_buf_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>sent_bytes</name></decl>;</decl_stmt>     <comment type="block">/* amount of bytes send */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>received_bytes</name></decl>;</decl_stmt> <comment type="block">/* amount of bytes received */</comment>

    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buckets_sent</name></decl>;</decl_stmt>  <comment type="block">/* # of beam buckets sent */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>files_beamed</name></decl>;</decl_stmt>  <comment type="block">/* how many file handles have been set aside */</comment>
    
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>aborted</name> : 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>closed</name> : 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>close_sent</name> : 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>tx_mem_limits</name> : 1</expr>;</expr_stmt> <comment type="block">/* only memory size counts on transfers */</comment>

    <decl_stmt><decl><type>struct <name>apr_thread_mutex_t</name> *</type><name>lock</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>apr_thread_cond_t</name> *</type><name>change</name></decl>;</decl_stmt>
    
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>cons_bytes_reported</name></decl>;</decl_stmt>    <comment type="block">/* amount of bytes reported as consumed */</comment>
    <decl_stmt><decl><type><name>h2_beam_ev_callback</name> *</type><name>cons_ev_cb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>h2_beam_io_callback</name> *</type><name>cons_io_cb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>cons_ctx</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>prod_bytes_reported</name></decl>;</decl_stmt>    <comment type="block">/* amount of bytes reported as produced */</comment>
    <decl_stmt><decl><type><name>h2_beam_io_callback</name> *</type><name>prod_io_cb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>prod_ctx</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>h2_beam_can_beam_callback</name> *</type><name>can_beam_fn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>can_beam_ctx</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * Creates a new bucket beam for transfer of buckets across threads.
 *
 * The pool the beam is created with will be protected by the given 
 * mutex and will be used in multiple threads. It needs a pool allocator
 * that is only used inside that same mutex.
 *
 * @param pbeam         will hold the created beam on return
 * @param pool          pool owning the beam, beam will cleanup when pool released
 * @param id            identifier of the beam
 * @param tag           tag identifying beam for logging
 * @param owner         if the beam is owned by the sender or receiver, e.g. if
 *                      the pool owner is using this beam for sending or receiving
 * @param buffer_size   maximum memory footprint of buckets buffered in beam, or
 *                      0 for no limitation
 * @param timeout       timeout for blocking operations
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_beam_create</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> **</type><name>pbeam</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, 
                            <param><decl><type><name>int</name></type> <name>id</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl></param>,
                            <param><decl><type><name>h2_beam_owner_t</name></type> <name>owner</name></decl></param>,  
                            <param><decl><type><name>apr_size_t</name></type> <name>buffer_size</name></decl></param>,
                            <param><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Destroys the beam immediately without cleanup.
 */</comment> 
<function_decl><type><name>apr_status_t</name></type> <name>h2_beam_destroy</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Send buckets from the given brigade through the beam. Will hold buckets 
 * internally as long as they have not been processed by the receiving side.
 * All accepted buckets are removed from the given brigade. Will return with
 * APR_EAGAIN on non-blocking sends when not all buckets could be accepted.
 * 
 * Call from the sender side only.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_beam_send</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>,  
                          <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>, 
                          <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Register the pool from which future buckets are send. This defines
 * the lifetime of the buckets, e.g. the pool should not be cleared/destroyed
 * until the data is no longer needed (or has been received).
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_beam_send_from</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Receive buckets from the beam into the given brigade. Will return APR_EOF
 * when reading past an EOS bucket. Reads can be blocking until data is 
 * available or the beam has been closed. Non-blocking calls return APR_EAGAIN
 * if no data is available.
 *
 * Call from the receiver side only.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_beam_receive</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                             <param><decl><type><name>apr_bucket_brigade</name> *</type><name>green_buckets</name></decl></param>, 
                             <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                             <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Determine if beam is empty. 
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_beam_empty</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Determine if beam has handed out proxy buckets that are not destroyed. 
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_beam_holds_proxies</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Abort the beam. Will cleanup any buffered buckets and answer all send
 * and receives with APR_ECONNABORTED.
 * 
 * Call from the sender side only.
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_beam_abort</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Close the beam. Sending an EOS bucket serves the same purpose. 
 * 
 * Call from the sender side only.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_beam_close</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Receives leaves the beam, e.g. will no longer read. This will
 * interrupt any sender blocked writing and fail future send. 
 * 
 * Call from the receiver side only.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_beam_leave</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type> <name>h2_beam_is_closed</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return APR_SUCCESS when all buckets in transit have been handled. 
 * When called with APR_BLOCK_READ and a mutex set, will wait until the green
 * side has consumed all data. Otherwise APR_EAGAIN is returned.
 * With clear_buffers set, any queued data is discarded.
 * If a timeout is set on the beam, waiting might also time out and
 * return APR_ETIMEUP.
 *
 * Call from the sender side only.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>h2_beam_wait_empty</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** 
 * Set/get the timeout for blocking read/write operations. Only works
 * if a mutex has been set for the beam.
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_beam_timeout_set</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                         <param><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_interval_time_t</name></type> <name>h2_beam_timeout_get</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Set/get the maximum buffer size for beam data (memory footprint).
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_beam_buffer_size_set</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                             <param><decl><type><name>apr_size_t</name></type> <name>buffer_size</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>apr_size_t</name></type> <name>h2_beam_buffer_size_get</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Register a callback to be invoked on the sender side with the
 * amount of bytes that have been consumed by the receiver, since the
 * last callback invocation or reset.
 * @param beam the beam to set the callback on
 * @param ev_cb the callback or NULL, called when bytes are consumed
 * @param io_cb the callback or NULL, called on sender with bytes consumed
 * @param ctx  the context to use in callback invocation
 * 
 * Call from the sender side, io callbacks invoked on sender side, ev callback
 * from any side.
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_beam_on_consumed</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                         <param><decl><type><name>h2_beam_ev_callback</name> *</type><name>ev_cb</name></decl></param>,
                         <param><decl><type><name>h2_beam_io_callback</name> *</type><name>io_cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Call any registered consumed handler, if any changes have happened
 * since the last invocation. 
 * @return !=0 iff a handler has been called
 *
 * Needs to be invoked from the sending side.
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_beam_report_consumption</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Register a callback to be invoked on the receiver side with the
 * amount of bytes that have been produces by the sender, since the
 * last callback invocation or reset.
 * @param beam the beam to set the callback on
 * @param io_cb the callback or NULL, called on receiver with bytes produced
 * @param ctx  the context to use in callback invocation
 * 
 * Call from the receiver side, callbacks invoked on either side.
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_beam_on_produced</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                         <param><decl><type><name>h2_beam_io_callback</name> *</type><name>io_cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Register a callback that may prevent a file from being beam as
 * file handle, forcing the file content to be copied. Then no callback
 * is set (NULL), file handles are transferred directly.
 * @param beam the beam to set the callback on
 * @param io_cb the callback or NULL, called on receiver with bytes produced
 * @param ctx  the context to use in callback invocation
 * 
 * Call from the receiver side, callbacks invoked on either side.
 */</comment>
<function_decl><type><name>void</name></type> <name>h2_beam_on_file_beam</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                          <param><decl><type><name>h2_beam_can_beam_callback</name> *</type><name>cb</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ctx</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get the amount of bytes currently buffered in the beam (unread).
 */</comment>
<function_decl><type><name>apr_off_t</name></type> <name>h2_beam_get_buffered</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get the memory used by the buffered buckets, approximately.
 */</comment>
<function_decl><type><name>apr_off_t</name></type> <name>h2_beam_get_mem_used</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return != 0 iff (some) data from the beam has been received.
 */</comment>
<function_decl><type><name>int</name></type> <name>h2_beam_was_received</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>apr_size_t</name></type> <name>h2_beam_get_files_beamed</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>)</parameter_list>;</function_decl>

<typedef>typedef <function_decl><type><name>apr_bucket</name> *</type><name>h2_bucket_beamer</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, 
                                     <param><decl><type><name>apr_bucket_brigade</name> *</type><name>dest</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>apr_bucket</name> *</type><name>src</name></decl></param>)</parameter_list>;</function_decl></typedef>

<function_decl><type><name>void</name></type> <name>h2_register_bucket_beamer</name><parameter_list>(<param><decl><type><name>h2_bucket_beamer</name> *</type><name>beamer</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type> <name>h2_beam_log</name><parameter_list>(<param><decl><type><name>h2_bucket_beam</name> *</type><name>beam</name></decl></param>, <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* h2_bucket_beam_h */</comment>
</unit>
