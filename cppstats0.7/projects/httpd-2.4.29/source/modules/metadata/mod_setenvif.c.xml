<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/metadata/mod_setenvif.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * mod_setenvif.c
 * Set environment variables based on matching request headers or
 * attributes against regex strings
 *
 * Paul Sutton &lt;paul@ukweb.com&gt; 27 Oct 1996
 * Based on mod_browser by Alexei Kosut &lt;akosut@organic.com&gt;
 */</comment>

<comment type="block">/*
 * Used to set environment variables based on the incoming request headers,
 * or some selected other attributes of the request (e.g., the remote host
 * name).
 *
 * Usage:
 *
 *   SetEnvIf name regex var ...
 *
 * where name is either a HTTP request header name, or one of the
 * special values (see below). 'name' may be a regex when it is used
 * to specify an HTTP request header name. The 'value' of the header
 &amp; (or the value of the special value from below) are compared against
 * the regex argument. If this is a simple string, a simple sub-string
 * match is performed. Otherwise, a request expression match is
 * done. If the value matches the string or regular expression, the
 * environment variables listed as var ... are set. Each var can
 * be in one of three formats: var, which sets the named variable
 * (the value "1"); var=value, which sets the variable to
 * the given value; or !var, which unsets the variable is it has
 * been previously set.
 *
 * Normally the strings are compared with regard to case. To ignore
 * case, use the directive SetEnvIfNoCase instead.
 *
 * Special values for 'name' are:
 *
 *   server_addr        IP address of interface on which request arrived
 *                      (analogous to SERVER_ADDR set in ap_add_common_vars())
 *   remote_host        Remote host name (if available)
 *   remote_addr        Remote IP address
 *   request_method     Request method (GET, POST, etc)
 *   request_uri        Requested URI
 *
 * Examples:
 *
 * To set the environment variable LOCALHOST if the client is the local
 * machine:
 *
 *    SetEnvIf remote_addr 127.0.0.1 LOCALHOST
 *
 * To set LOCAL if the client is the local host, or within our company's
 * domain (192.168.10):
 *
 *    SetEnvIf remote_addr 192.168.10. LOCAL
 *    SetEnvIf remote_addr 127.0.0.1   LOCALHOST
 *
 * This could be written as:
 *
 *    SetEnvIf remote_addr (127.0.0.1|192.168.10.) LOCAL
 *
 * To set HAVE_TS if the client request contains any header beginning
 * with "TS" with a value beginning with a lower case alphabet:
 *
 *    SetEnvIf ^TS* ^[a-z].* HAVE_TS
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strmatch.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>

<enum>enum <name>special</name> <block>{
    <decl><name>SPECIAL_NOT</name></decl>,
    <decl><name>SPECIAL_REMOTE_ADDR</name></decl>,
    <decl><name>SPECIAL_REMOTE_HOST</name></decl>,
    <decl><name>SPECIAL_REQUEST_URI</name></decl>,
    <decl><name>SPECIAL_REQUEST_METHOD</name></decl>,
    <decl><name>SPECIAL_REQUEST_PROTOCOL</name></decl>,
    <decl><name>SPECIAL_SERVER_ADDR</name></decl>
}</block>;</enum>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>                 <comment type="block">/* header name */</comment>
    <decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>pnamereg</name></decl>;</decl_stmt>       <comment type="block">/* compiled header name regex */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>regex</name></decl>;</decl_stmt>                <comment type="block">/* regex to match against */</comment>
    <decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>preg</name></decl>;</decl_stmt>           <comment type="block">/* compiled regex */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_strmatch_pattern</name> *</type><name>pattern</name></decl>;</decl_stmt> <comment type="block">/* non-regex pattern to match */</comment>
    <decl_stmt><decl><type><name>ap_expr_info_t</name> *</type><name>expr</name></decl>;</decl_stmt>       <comment type="block">/* parsed expression */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>features</name></decl>;</decl_stmt>      <comment type="block">/* env vars to set (or unset) */</comment>
    <enum>enum <name>special</name> <name>special_type</name>;</enum>  <comment type="block">/* is it a "special" header ? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>icase</name></decl>;</decl_stmt>                  <comment type="block">/* ignoring case? */</comment>
}</block></struct></type> <name>sei_entry</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>conditionals</name></decl>;</decl_stmt>
}</block></struct></type> <name>sei_cfg_rec</name>;</typedef>

<decl_stmt><decl><type><name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>setenvif_module</name></decl>;</decl_stmt>

<comment type="block">/*
 * These routines, the create- and merge-config functions, are called
 * for both the server-wide and the per-directory contexts.  This is
 * because the different definitions are used at different times; the
 * server-wide ones are used in the post-read-request phase, and the
 * per-directory ones are used during the header-parse phase (after
 * the URI has been mapped to a file and we have anything from the
 * .htaccess file and &lt;Directory&gt; and &lt;Files&gt; containers).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_setenvif_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>sei_cfg_rec</name> *</type><name>new</name> <init>= <expr>(<name>sei_cfg_rec</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sei_cfg_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>new</name>-&gt;<name>conditionals</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>20</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sei_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>(<name>void</name> *) <name>new</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_setenvif_config_svr</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>dummy</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>create_setenvif_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_setenvif_config_dir</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dummy</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>create_setenvif_config</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>merge_setenvif_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>basev</name></decl></param>, <param><decl><type><name>void</name> *</type><name>overridesv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>sei_cfg_rec</name> *</type><name>a</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sei_cfg_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sei_cfg_rec</name> *</type><name>base</name> <init>= <expr><name>basev</name></expr></init>, *<name>overrides</name> <init>= <expr><name>overridesv</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>a</name>-&gt;<name>conditionals</name></name> = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>conditionals</name></name></expr></argument>,
                                       <argument><expr><name><name>overrides</name>-&gt;<name>conditionals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>a</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * any non-NULL magic constant will do... used to indicate if AP_REG_ICASE should
 * be used
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ICASE_MAGIC</name></cpp:macro>  <cpp:value>((void *)(&amp;setenvif_module))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEI_MAGIC_HEIRLOOM</name></cpp:macro> <cpp:value>"setenvif-phase-flag"</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>ap_regex_t</name> *</type><name>is_header_regex_regex</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_header_regex</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>name</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* If a Header name contains characters other than:
     *    -,_,[A-Z\, [a-z] and [0-9].
     * assume the header name is a regular expression.
     */</comment>
    <if>if <condition>(<expr><call><name>ap_regexec</name><argument_list>(<argument><expr><name>is_header_regex_regex</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* If the input string does not take advantage of regular
 * expression metacharacters, return a pointer to an equivalent
 * string that can be searched using apr_strmatch().  (The
 * returned string will often be the input string.  But if
 * the input string contains escaped characters, the returned
 * string will be a copy with the escapes removed.)
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>non_regex_pattern</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>escapes_found</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>in_escape</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr>*<name>src</name></expr>)</condition> <block>{
        <switch>switch <condition>(<expr>*<name>src</name></expr>)</condition> <block>{
        <case>case <expr>'^'</expr>:
        </case><case>case <expr>'.'</expr>:
        </case><case>case <expr>'$'</expr>:
        </case><case>case <expr>'|'</expr>:
        </case><case>case <expr>'('</expr>:
        </case><case>case <expr>')'</expr>:
        </case><case>case <expr>'['</expr>:
        </case><case>case <expr>']'</expr>:
        </case><case>case <expr>'*'</expr>:
        </case><case>case <expr>'+'</expr>:
        </case><case>case <expr>'?'</expr>:
        </case><case>case <expr>'{'</expr>:
        </case><case>case <expr>'}'</expr>:
            <if>if <condition>(<expr>!<name>in_escape</name></expr>)</condition><then> <block>{
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name>in_escape</name> = 0</expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr>'\\'</expr>:
            <if>if <condition>(<expr>!<name>in_escape</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>in_escape</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>escapes_found</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>in_escape</name> = 0</expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
        </case><default>default:
            <if>if <condition>(<expr><name>in_escape</name></expr>)</condition><then> <block>{
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>
            <break>break;</break>
        </default>}</block></switch>
        <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
    }</block></while>
    <if>if <condition>(<expr>!<name>escapes_found</name></expr>)</condition><then> <block>{
        <return>return <expr><name>s</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>unescaped</name> <init>= <expr>(<name>char</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>src</name> - <name>s</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>dst</name> <init>= <expr><name>unescaped</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>src</name> = <name>s</name></expr>;</expr_stmt>
        <do>do <block>{
            <if>if <condition>(<expr>*<name>src</name> == '\\'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
            }</block></then></if>
        }</block> while <condition>(<expr>(*<name>dst</name>++ = *<name>src</name>++)</expr>)</condition>;</do>
        <return>return <expr><name>unescaped</name></expr>;</return>
    }</block></else></if>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_envvars</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>args</name></decl></param>, <param><decl><type><name>sei_entry</name> *</type><name>new</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>feature</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>beenhere</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>var</name></decl>;</decl_stmt>

    <for>for ( <init>;</init> <condition>;</condition> <incr/>) <block>{
        <expr_stmt><expr><name>feature</name> = <call><name>ap_getword_conf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!*<name>feature</name></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>beenhere</name>++</expr>;</expr_stmt>

        <expr_stmt><expr><name>var</name> = <call><name>ap_getword</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>feature</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>feature</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>new</name>-&gt;<name>features</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>feature</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>var</name> == '!'</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>new</name>-&gt;<name>features</name></name></expr></argument>, <argument><expr><name>var</name> + 1</expr></argument>, <argument><expr>"!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>new</name>-&gt;<name>features</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></for>

    <if>if <condition>(<expr>!<name>beenhere</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Missing envariable expression for "</expr></argument>,
                           <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_setenvif_core</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
                                     <param><decl><type><name>char</name> *</type><name>fname</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>regex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>simple_pattern</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sei_cfg_rec</name> *</type><name>sconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sei_entry</name> *</type><name>new</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sei_entry</name> *</type><name>entries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>icase</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Determine from our context into which record to put the entry.
     * cmd-&gt;path == NULL means we're in server-wide context; otherwise,
     * we're dealing with a per-directory setting.
     */</comment>
    <expr_stmt><expr><name>sconf</name> = (<name><name>cmd</name>-&gt;<name>path</name></name> != <name>NULL</name>)
      ? (<name>sei_cfg_rec</name> *) <name>mconfig</name>
      : (<name>sei_cfg_rec</name> *) <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                               <argument><expr>&amp;<name>setenvif_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entries</name> = (<name>sei_entry</name> *) <name><name>sconf</name>-&gt;<name>conditionals</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
    <comment type="block">/* get regex */</comment>
    <expr_stmt><expr><name>regex</name> = <call><name>ap_getword_conf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!*<name>regex</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Missing regular expression for "</expr></argument>,
                           <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * If we've already got a sei_entry with the same name we want to
     * just copy the name pointer... so that later on we can compare
     * two header names just by comparing the pointers.
     */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>sconf</name>-&gt;<name>conditionals</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name>new</name> = &amp;<name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>new</name>-&gt;<name>name</name></name> &amp;&amp; !<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>new</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>fname</name> = <name><name>new</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* if the last entry has an identical headername and regex then
     * merge with it
     */</comment>
    <expr_stmt><expr><name>i</name> = <name><name>sconf</name>-&gt;<name>conditionals</name>-&gt;<name>nelts</name></name> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>icase</name> = <name><name>cmd</name>-&gt;<name>info</name></name> == <name>ICASE_MAGIC</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>i</name> &lt; 0
        || <name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>fname</name>
        || <name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name>.<name>icase</name> != <name>icase</name>
        || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name>.<name>regex</name></expr></argument>, <argument><expr><name>regex</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

        <comment type="block">/* no match, create a new entry */</comment>
        <expr_stmt><expr><name>new</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>sconf</name>-&gt;<name>conditionals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name>-&gt;<name>name</name></name> = <name>fname</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name>-&gt;<name>regex</name></name> = <name>regex</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new</name>-&gt;<name>icase</name></name> = <name>icase</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>simple_pattern</name> = <call><name>non_regex_pattern</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>regex</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>pattern</name></name> = <call><name>apr_strmatch_precompile</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>,
                                                   <argument><expr><name>simple_pattern</name></expr></argument>, <argument><expr>!<name>icase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>new</name>-&gt;<name>pattern</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>,
                                   <argument><expr>" pattern could not be compiled."</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>new</name>-&gt;<name>preg</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>preg</name></name> = <call><name>ap_pregcomp</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>regex</name></expr></argument>,
                                    <argument><expr>(<name>AP_REG_EXTENDED</name> | (<name>icase</name> ? <name>AP_REG_ICASE</name> : 0))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>new</name>-&gt;<name>preg</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>,
                                   <argument><expr>" regex could not be compiled."</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>new</name>-&gt;<name>pattern</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name><name>new</name>-&gt;<name>features</name></name> = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr>"remote_addr"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>special_type</name></name> = <name>SPECIAL_REMOTE_ADDR</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr>"remote_host"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>special_type</name></name> = <name>SPECIAL_REMOTE_HOST</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr>"request_uri"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>special_type</name></name> = <name>SPECIAL_REQUEST_URI</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr>"request_method"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>special_type</name></name> = <name>SPECIAL_REQUEST_METHOD</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr>"request_protocol"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>special_type</name></name> = <name>SPECIAL_REQUEST_PROTOCOL</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr>"server_addr"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>special_type</name></name> = <name>SPECIAL_SERVER_ADDR</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>new</name>-&gt;<name>special_type</name></name> = <name>SPECIAL_NOT</name></expr>;</expr_stmt>
            <comment type="block">/* Handle fname as a regular expression.
             * If fname a simple header string, identify as such
             * (new-&gt;pnamereg = NULL) to avoid the overhead of searching
             * through headers_in for a regex match.
             */</comment>
            <if>if <condition>(<expr><call><name>is_header_regex</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>temp_pool</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>new</name>-&gt;<name>pnamereg</name></name> = <call><name>ap_pregcomp</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>,
                                            <argument><expr>(<name>AP_REG_EXTENDED</name> | <name>AP_REG_NOSUB</name>
                                             | (<name>icase</name> ? <name>AP_REG_ICASE</name> : 0))</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>new</name>-&gt;<name>pnamereg</name></name> == <name>NULL</name></expr>)</condition><then>
                    <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>,
                                       <argument><expr>"Header name regex could not be "
                                       "compiled."</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name><name>new</name>-&gt;<name>pnamereg</name></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></else></if></else></if></else></if></else></if></else></if></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>new</name> = &amp;<name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><call><name>add_envvars</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_setenvif</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>fname</name></decl>;</decl_stmt>

    <comment type="block">/* get header name */</comment>
    <expr_stmt><expr><name>fname</name> = <call><name>ap_getword_conf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!*<name>fname</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Missing header-field name for "</expr></argument>,
                           <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <return>return <expr><call><name>add_setenvif_core</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>mconfig</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_setenvifexpr</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>expr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sei_cfg_rec</name> *</type><name>sconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sei_entry</name> *</type><name>new</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Determine from our context into which record to put the entry.
     * cmd-&gt;path == NULL means we're in server-wide context; otherwise,
     * we're dealing with a per-directory setting.
     */</comment>
    <expr_stmt><expr><name>sconf</name> = (<name><name>cmd</name>-&gt;<name>path</name></name> != <name>NULL</name>)
      ? (<name>sei_cfg_rec</name> *) <name>mconfig</name>
      : (<name>sei_cfg_rec</name> *) <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                               <argument><expr>&amp;<name>setenvif_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* get expr */</comment>
    <expr_stmt><expr><name>expr</name> = <call><name>ap_getword_conf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!*<name>expr</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Missing expression for "</expr></argument>,
                           <argument><expr><name><name>cmd</name>-&gt;<name>cmd</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>new</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>sconf</name>-&gt;<name>conditionals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>features</name></name> = <call><name>apr_table_make</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>regex</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>pattern</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>preg</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>expr</name></name> = <call><name>ap_expr_parse_cmd</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Could not parse expression \"%s\": %s"</expr></argument>,
                            <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <return>return <expr><call><name>add_envvars</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * This routine handles the BrowserMatch* directives.  It simply turns around
 * and feeds them, with the appropriate embellishments, to the general-purpose
 * command handler.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_browser</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>args</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>add_setenvif_core</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>mconfig</name></expr></argument>, <argument><expr>"User-Agent"</expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>setenvif_module_cmds</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><call><name>AP_INIT_RAW_ARGS</name><argument_list>(<argument><expr>"SetEnvIf"</expr></argument>, <argument><expr><name>add_setenvif</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"A header-name, regex and a list of variables."</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_RAW_ARGS</name><argument_list>(<argument><expr>"SetEnvIfNoCase"</expr></argument>, <argument><expr><name>add_setenvif</name></expr></argument>, <argument><expr><name>ICASE_MAGIC</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"a header-name, regex and a list of variables."</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_RAW_ARGS</name><argument_list>(<argument><expr>"SetEnvIfExpr"</expr></argument>, <argument><expr><name>add_setenvifexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"an expression and a list of variables."</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_RAW_ARGS</name><argument_list>(<argument><expr>"BrowserMatch"</expr></argument>, <argument><expr><name>add_browser</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"A browser regex and a list of variables."</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_RAW_ARGS</name><argument_list>(<argument><expr>"BrowserMatchNoCase"</expr></argument>, <argument><expr><name>add_browser</name></expr></argument>, <argument><expr><name>ICASE_MAGIC</name></expr></argument>,
                     <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"A browser regex and a list of variables."</expr></argument>)</argument_list></call></expr>,
    <expr><block>{ <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This routine gets called at two different points in request processing:
 * once before the URI has been translated (during the post-read-request
 * phase) and once after (during the header-parse phase).  We use different
 * config records for the two different calls to reduce overhead (by not
 * re-doing the server-wide settings during directory processing), and
 * signal which call it is by having the earlier one pass a flag to the
 * later one.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>match_headers</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>sei_cfg_rec</name> *</type><name>sconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>sei_entry</name> *</type><name>entries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_table_entry_t</name> *</type><name>elts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl>, *<decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>val_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>last_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_regmatch_t</name></type> <name><name>regm</name><index>[<expr><name>AP_MAX_REG_MATCH</name></expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>setenvif_module</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_set_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>setenvif_module</name></expr></argument>,
                             <argument><expr><name>SEI_MAGIC_HEIRLOOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>sconf</name>  = (<name>sei_cfg_rec</name> *) <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                                      <argument><expr>&amp;<name>setenvif_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>sconf</name> = (<name>sei_cfg_rec</name> *) <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                     <argument><expr>&amp;<name>setenvif_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>entries</name> = (<name>sei_entry</name> *) <name><name>sconf</name>-&gt;<name>conditionals</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>last_name</name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> = <name>NULL</name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>sconf</name>-&gt;<name>conditionals</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>sei_entry</name> *</type><name>b</name> <init>= <expr>&amp;<name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>expr</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* Optimize the case where a bunch of directives in a row use the
             * same header.  Remember we don't need to strcmp the two header
             * names because we made sure the pointers were equal during
             * configuration.
             */</comment>
            <if>if <condition>(<expr><name><name>b</name>-&gt;<name>name</name></name> != <name>last_name</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>last_name</name> = <name><name>b</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
                <switch>switch <condition>(<expr><name><name>b</name>-&gt;<name>special_type</name></name></expr>)</condition> <block>{
                <case>case <expr><name>SPECIAL_REMOTE_ADDR</name></expr>:
                    <expr_stmt><expr><name>val</name> = <name><name>r</name>-&gt;<name>useragent_ip</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>SPECIAL_SERVER_ADDR</name></expr>:
                    <expr_stmt><expr><name>val</name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>local_ip</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>SPECIAL_REMOTE_HOST</name></expr>:
                    <expr_stmt><expr><name>val</name> = <call><name>ap_get_useragent_host</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>REMOTE_NAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>SPECIAL_REQUEST_URI</name></expr>:
                    <expr_stmt><expr><name>val</name> = <name><name>r</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>SPECIAL_REQUEST_METHOD</name></expr>:
                    <expr_stmt><expr><name>val</name> = <name><name>r</name>-&gt;<name>method</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>SPECIAL_REQUEST_PROTOCOL</name></expr>:
                    <expr_stmt><expr><name>val</name> = <name><name>r</name>-&gt;<name>protocol</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                </case><case>case <expr><name>SPECIAL_NOT</name></expr>:
                    <if>if <condition>(<expr><name><name>b</name>-&gt;<name>pnamereg</name></name></expr>)</condition><then> <block>{
                        <comment type="block">/* Matching headers_in against a regex. Iterate through
                         * the headers_in until we find a match or run out of
                         * headers.
                         */</comment>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name>
                            *</type><name>arr</name> <init>= <expr><call><name>apr_table_elts</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><name>elts</name> = (const <name>apr_table_entry_t</name> *) <name><name>arr</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>val</name> = <name>NULL</name></expr>;</expr_stmt>
                        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>arr</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
                            <if>if <condition>(<expr>!<call><name>ap_regexec</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pnamereg</name></name></expr></argument>, <argument><expr><name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>val</name> = <name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>val</name></expr>;</expr_stmt>
                            }</block></then></if>
                        }</block></for>
                    }</block></then>
                    <else>else <block>{
                        <comment type="block">/* Not matching against a regex */</comment>
                        <expr_stmt><expr><name>val</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>val</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></else></if>
                </case>}</block></switch>
                <expr_stmt><expr><name>val_len</name> = <name>val</name> ? <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
            }</block></then></if>

        }</block></then></if>

        <comment type="block">/*
         * A NULL value indicates that the header field or special entity
         * wasn't present or is undefined.  Represent that as an empty string
         * so that REs like "^$" will work and allow envariable setting
         * based on missing or empty field. This is also necessary to make
         * ap_pregsub work after evaluating an ap_expr_t which does set the
         * regexp backref data.
         */</comment>
        <if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>val</name> = ""</expr>;</expr_stmt>
            <expr_stmt><expr><name>val_len</name> = 0</expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr>(<name><name>b</name>-&gt;<name>pattern</name></name> &amp;&amp; <call><name>apr_strmatch</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pattern</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>val_len</name></expr></argument>)</argument_list></call>) ||
            (<name><name>b</name>-&gt;<name>preg</name></name> &amp;&amp; !<call><name>ap_regexec</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>preg</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>AP_MAX_REG_MATCH</name></expr></argument>, <argument><expr><name>regm</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>) ||
            (<name><name>b</name>-&gt;<name>expr</name></name> &amp;&amp; <call><name>ap_expr_exec_re</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>expr</name></name></expr></argument>, <argument><expr><name>AP_MAX_REG_MATCH</name></expr></argument>, <argument><expr><name>regm</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call> &gt; 0)</expr>)</condition><then>
        <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>arr</name> <init>= <expr><call><name>apr_table_elts</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>features</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>elts</name> = (const <name>apr_table_entry_t</name> *) <name><name>arr</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

            <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>arr</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
                <if>if <condition>(<expr>*(<name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>val</name>) == '!'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>pattern</name></name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>char</name> *</type><name>replaced</name> <init>= <expr><call><name>ap_pregsub</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>val</name></expr></argument>, <argument><expr><name>val</name></expr></argument>,
                                                    <argument><expr><name>AP_MAX_REG_MATCH</name></expr></argument>, <argument><expr><name>regm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <if>if <condition>(<expr><name>replaced</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name></expr></argument>,
                                           <argument><expr><name>replaced</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then>
                        <else>else <block>{
                            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01505</expr></argument>)</argument_list></call>
                                          "Regular expression replacement "
                                          "failed for '%s', value too long?"</expr></argument>,
                                          <argument><expr><name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
                        }</block></else></if>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name></expr></argument>,
                                       <argument><expr><name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></else></if>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>"Setting %s"</expr></argument>,
                              <argument><expr><name><name>elts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></for>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_hook_header_parser</name><argument_list>(<argument><expr><name>match_headers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_post_read_request</name><argument_list>(<argument><expr><name>match_headers</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>is_header_regex_regex</name> = <call><name>ap_pregcomp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"^[-A-Za-z0-9_]*$"</expr></argument>,
                                        <argument><expr>(<name>AP_REG_EXTENDED</name> | <name>AP_REG_NOSUB</name> )</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>is_header_regex_regex</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>setenvif</name></expr></argument>)</argument_list></call> =
<block>{
    <expr><name>STANDARD20_MODULE_STUFF</name></expr>,
    <expr><name>create_setenvif_config_dir</name></expr>, <comment type="block">/* dir config creater */</comment>
    <expr><name>merge_setenvif_config</name></expr>,      <comment type="block">/* dir merger --- default is to override */</comment>
    <expr><name>create_setenvif_config_svr</name></expr>, <comment type="block">/* server config */</comment>
    <expr><name>merge_setenvif_config</name></expr>,      <comment type="block">/* merge server configs */</comment>
    <expr><name>setenvif_module_cmds</name></expr>,       <comment type="block">/* command apr_table_t */</comment>
    <expr><name>register_hooks</name></expr>              <comment type="block">/* register hooks */</comment>
}</block></expr>;</expr_stmt>
</unit>
