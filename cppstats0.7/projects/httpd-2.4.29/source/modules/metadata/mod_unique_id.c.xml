<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/metadata/mod_unique_id.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * mod_unique_id.c: generate a unique identifier for each request
 *
 * Original author: Dean Gaudet &lt;dgaudet@arctic.org&gt;
 * UUencoding modified by: Alvaro Martinez Echevarria &lt;alvaro@lander.es&gt;
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_BYTEFUNC</name></cpp:macro></cpp:define>   <comment type="block">/* for htons() et al */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_general.h"</cpp:file></cpp:include>    <comment type="block">/* for APR_OFFSETOF                */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_network_io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>  <comment type="block">/* for ap_hook_post_read_request */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROOT_SIZE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>stamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>root</name><index>[<expr><name>ROOT_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>counter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>thread_index</name></decl>;</decl_stmt>
}</block></struct></type> <name>unique_id_rec</name>;</typedef>

<comment type="block">/* We are using thread_index (the index into the scoreboard), because we
 * cannot guarantee the thread_id will be an integer.
 *
 * This code looks like it won't give a unique ID with the new thread logic.
 * It will.  The reason is, we don't increment the counter in a thread_safe
 * manner.  Because the thread_index is also in the unique ID now, this does
 * not matter.  In order for the id to not be unique, the same thread would
 * have to get the same counter twice in the same second.
 */</comment>

<comment type="block">/* Comments:
 *
 * We want an identifier which is unique across all hits, everywhere.
 * "everywhere" includes multiple httpd instances on the same machine, or on
 * multiple machines.  Essentially "everywhere" should include all possible
 * httpds across all servers at a particular "site".  We make some assumptions
 * that if the site has a cluster of machines then their time is relatively
 * synchronized.  We also assume that the first address returned by a
 * gethostbyname (gethostname()) is unique across all the machines at the
 * "site".
 *
 * The root is assumed to absolutely uniquely identify this one child
 * from all other currently running children on all servers (including
 * this physical server if it is running multiple httpds) from each
 * other.
 *
 * The stamp and counter are used to distinguish all hits for a
 * particular root.  The stamp is updated using r-&gt;request_time,
 * saving cpu cycles.  The counter is never reset, and is used to
 * permit up to 64k requests in a single second by a single child.
 *
 * The 144-bits of unique_id_rec are encoded using the alphabet
 * [A-Za-z0-9@-], resulting in 24 bytes of printable characters.  That is then
 * stuffed into the environment variable UNIQUE_ID so that it is available to
 * other modules.  The alphabet choice differs from normal base64 encoding
 * [A-Za-z0-9+/] because + and / are special characters in URLs and we want to
 * make it easy to use UNIQUE_ID in URLs.
 *
 * Note that UNIQUE_ID should be considered an opaque token by other
 * applications.  No attempt should be made to dissect its internal components.
 * It is an abstraction that may change in the future as the needs of this
 * module change.
 *
 * It is highly desirable that identifiers exist for "eternity".  But future
 * needs (such as much faster webservers, or moving to a
 * multithreaded server) may dictate a need to change the contents of
 * unique_id_rec.  Such a future implementation should ensure that the first
 * field is still a time_t stamp.  By doing that, it is possible for a site to
 * have a "flag second" in which they stop all of their old-format servers,
 * wait one entire second, and then start all of their new-servers.  This
 * procedure will ensure that the new space of identifiers is completely unique
 * from the old space.  (Since the first four unencoded bytes always differ.)
 *
 * Note: previous implementations used 32-bits of IP address plus pid
 * in place of the PRNG output in the "root" field.  This was
 * insufficient for IPv6-only hosts, required working DNS to determine
 * a unique IP address (fragile), and needed a [0, 1) second sleep
 * call at startup to avoid pid reuse.  Use of the PRNG avoids all
 * these issues.
 */</comment>

<comment type="block">/*
 * Sun Jun  7 05:43:49 CEST 1998 -- Alvaro
 * More comments:
 * 1) The UUencoding prodecure is now done in a general way, avoiding the problems
 * with sizes and paddings that can arise depending on the architecture. Now the
 * offsets and sizes of the elements of the unique_id_rec structure are calculated
 * in unique_id_global_init; and then used to duplicate the structure without the
 * paddings that might exist. The multithreaded server fix should be now very easy:
 * just add a new "tid" field to the unique_id_rec structure, and increase by one
 * UNIQUE_ID_REC_MAX.
 * 2) unique_id_rec.stamp has been changed from "time_t" to "unsigned int", because
 * its size is 64bits on some platforms (linux/alpha), and this caused problems with
 * htonl/ntohl. Well, this shouldn't be a problem till year 2106.
 */</comment>

<comment type="block">/*
 * XXX: We should have a per-thread counter and not use cur_unique_id.counter
 * XXX: in all threads, because this is bad for performance on multi-processor
 * XXX: systems: Writing to the same address from several CPUs causes cache
 * XXX: thrashing.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unique_id_rec</name></type> <name>cur_unique_id</name></decl>;</decl_stmt>

<comment type="block">/*
 * Number of elements in the structure unique_id_rec.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNIQUE_ID_REC_MAX</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>short</name></type> <name><name>unique_id_rec_offset</name><index>[<expr><name>UNIQUE_ID_REC_MAX</name></expr>]</index></name></decl>,
                      <decl><type ref="prev"/><name><name>unique_id_rec_size</name><index>[<expr><name>UNIQUE_ID_REC_MAX</name></expr>]</index></name></decl>,
                      <decl><type ref="prev"/><name>unique_id_rec_total_size</name></decl>,
                      <decl><type ref="prev"/><name>unique_id_rec_size_uu</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>unique_id_global_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>main_server</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Calculate the sizes and offsets in cur_unique_id.
     */</comment>
    <expr_stmt><expr><name><name>unique_id_rec_offset</name><index>[<expr>0</expr>]</index></name> = <call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>unique_id_rec</name></expr></argument>, <argument><expr><name>stamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unique_id_rec_size</name><index>[<expr>0</expr>]</index></name> = <sizeof>sizeof<argument_list>(<argument><expr><name><name>cur_unique_id</name>.<name>stamp</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unique_id_rec_offset</name><index>[<expr>1</expr>]</index></name> = <call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>unique_id_rec</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unique_id_rec_size</name><index>[<expr>1</expr>]</index></name> = <sizeof>sizeof<argument_list>(<argument><expr><name><name>cur_unique_id</name>.<name>root</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unique_id_rec_offset</name><index>[<expr>2</expr>]</index></name> = <call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>unique_id_rec</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unique_id_rec_size</name><index>[<expr>2</expr>]</index></name> = <sizeof>sizeof<argument_list>(<argument><expr><name><name>cur_unique_id</name>.<name>counter</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unique_id_rec_offset</name><index>[<expr>3</expr>]</index></name> = <call><name>APR_OFFSETOF</name><argument_list>(<argument><expr><name>unique_id_rec</name></expr></argument>, <argument><expr><name>thread_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>unique_id_rec_size</name><index>[<expr>3</expr>]</index></name> = <sizeof>sizeof<argument_list>(<argument><expr><name><name>cur_unique_id</name>.<name>thread_index</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>unique_id_rec_total_size</name> = <name><name>unique_id_rec_size</name><index>[<expr>0</expr>]</index></name> + <name><name>unique_id_rec_size</name><index>[<expr>1</expr>]</index></name> +
                               <name><name>unique_id_rec_size</name><index>[<expr>2</expr>]</index></name> + <name><name>unique_id_rec_size</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Calculate the size of the structure when encoded.
     */</comment>
    <expr_stmt><expr><name>unique_id_rec_size_uu</name> = (<name>unique_id_rec_total_size</name>*8+5)/6</expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>unique_id_child_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_random_insecure_bytes</name><argument_list>(<argument><expr>&amp;<name><name>cur_unique_id</name>.<name>root</name></name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cur_unique_id</name>.<name>root</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we use 0 as the initial counter we have a little less protection
     * against restart problems, and a little less protection against a clock
     * going backwards in time.
     */</comment>
    <expr_stmt><expr><call><name>ap_random_insecure_bytes</name><argument_list>(<argument><expr>&amp;<name><name>cur_unique_id</name>.<name>counter</name></name></expr></argument>,
                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cur_unique_id</name>.<name>counter</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* NOTE: This is *NOT* the same encoding used by base64encode ... the last two
 * characters should be + and /.  But those two characters have very special
 * meanings in URLs, and we want to make it easy to use identifiers in
 * URLs.  So we replace them with @ and -.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>uuencoder</name><index>[<expr>64</expr>]</index></name> <init>= <expr><block>{
    <expr>'A'</expr>, <expr>'B'</expr>, <expr>'C'</expr>, <expr>'D'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'G'</expr>, <expr>'H'</expr>, <expr>'I'</expr>, <expr>'J'</expr>, <expr>'K'</expr>, <expr>'L'</expr>, <expr>'M'</expr>,
    <expr>'N'</expr>, <expr>'O'</expr>, <expr>'P'</expr>, <expr>'Q'</expr>, <expr>'R'</expr>, <expr>'S'</expr>, <expr>'T'</expr>, <expr>'U'</expr>, <expr>'V'</expr>, <expr>'W'</expr>, <expr>'X'</expr>, <expr>'Y'</expr>, <expr>'Z'</expr>,
    <expr>'a'</expr>, <expr>'b'</expr>, <expr>'c'</expr>, <expr>'d'</expr>, <expr>'e'</expr>, <expr>'f'</expr>, <expr>'g'</expr>, <expr>'h'</expr>, <expr>'i'</expr>, <expr>'j'</expr>, <expr>'k'</expr>, <expr>'l'</expr>, <expr>'m'</expr>,
    <expr>'n'</expr>, <expr>'o'</expr>, <expr>'p'</expr>, <expr>'q'</expr>, <expr>'r'</expr>, <expr>'s'</expr>, <expr>'t'</expr>, <expr>'u'</expr>, <expr>'v'</expr>, <expr>'w'</expr>, <expr>'x'</expr>, <expr>'y'</expr>, <expr>'z'</expr>,
    <expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>, <expr>'8'</expr>, <expr>'9'</expr>, <expr>'@'</expr>, <expr>'-'</expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>gen_unique_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
    <comment type="block">/*
     * Buffer padded with two final bytes, used to copy the unique_id_red
     * structure without the internal paddings that it could have.
     */</comment>
    <decl_stmt><decl><type><name>unique_id_rec</name></type> <name>new_unique_id</name></decl>;</decl_stmt>
    <struct>struct <block>{
        <decl_stmt><decl><type><name>unique_id_rec</name></type> <name>foo</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>pad</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
    }</block> <decl><name>paddedbuf</name></decl>;</struct>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>x</name></decl>,*<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>counter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>,<decl><type ref="prev"/><name>j</name></decl>,<decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>new_unique_id</name>.<name>root</name></name></expr></argument>, <argument><expr>&amp;<name><name>cur_unique_id</name>.<name>root</name></name></expr></argument>, <argument><expr><name>ROOT_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_unique_id</name>.<name>counter</name></name> = <name><name>cur_unique_id</name>.<name>counter</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_unique_id</name>.<name>stamp</name></name> = <call><name>htonl</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>int</name>)<call><name>apr_time_sec</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new_unique_id</name>.<name>thread_index</name></name> = <call><name>htonl</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>int</name>)<name><name>r</name>-&gt;<name>connection</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* we'll use a temporal buffer to avoid uuencoding the possible internal
     * paddings of the original structure */</comment>
    <expr_stmt><expr><name>x</name> = (<name>unsigned</name> <name>char</name> *) &amp;<name>paddedbuf</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>UNIQUE_ID_REC_MAX</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>y</name> = ((<name>unsigned</name> <name>char</name> *) &amp;<name>new_unique_id</name>) + <name><name>unique_id_rec_offset</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>unique_id_rec_size</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>j</name>++</expr>, <expr><name>k</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name><name>x</name><index>[<expr><name>k</name></expr>]</index></name> = <name><name>y</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
    }</block></for>
    <comment type="block">/*
     * We reset two more bytes just in case padding is needed for the uuencoding.
     */</comment>
    <expr_stmt><expr><name><name>x</name><index>[<expr><name>k</name>++</expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>x</name><index>[<expr><name>k</name>++</expr>]</index></name> = '\0'</expr>;</expr_stmt>

    <comment type="block">/* alloc str and do the uuencoding */</comment>
    <expr_stmt><expr><name>str</name> = (<name>char</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>unique_id_rec_size_uu</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>k</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>unique_id_rec_total_size</name></expr>;</condition> <incr><expr><name>i</name> += 3</expr></incr>) <block>{
        <expr_stmt><expr><name>y</name> = <name>x</name> + <name>i</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>str</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>uuencoder</name><index>[<expr><name><name>y</name><index>[<expr>0</expr>]</index></name> &gt;&gt; 2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>str</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>uuencoder</name><index>[<expr>((<name><name>y</name><index>[<expr>0</expr>]</index></name> &amp; 0x03) &lt;&lt; 4) | ((<name><name>y</name><index>[<expr>1</expr>]</index></name> &amp; 0xf0) &gt;&gt; 4)</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>k</name> == <name>unique_id_rec_size_uu</name></expr>)</condition><then> <break>break;</break></then></if>
        <expr_stmt><expr><name><name>str</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>uuencoder</name><index>[<expr>((<name><name>y</name><index>[<expr>1</expr>]</index></name> &amp; 0x0f) &lt;&lt; 2) | ((<name><name>y</name><index>[<expr>2</expr>]</index></name> &amp; 0xc0) &gt;&gt; 6)</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>k</name> == <name>unique_id_rec_size_uu</name></expr>)</condition><then> <break>break;</break></then></if>
        <expr_stmt><expr><name><name>str</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>uuencoder</name><index>[<expr><name><name>y</name><index>[<expr>2</expr>]</index></name> &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>str</name><index>[<expr><name>k</name>++</expr>]</index></name> = '\0'</expr>;</expr_stmt>

    <comment type="block">/* and increment the identifier for the next call */</comment>

    <expr_stmt><expr><name>counter</name> = <call><name>ntohs</name><argument_list>(<argument><expr><name><name>new_unique_id</name>.<name>counter</name></name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cur_unique_id</name>.<name>counter</name></name> = <call><name>htons</name><argument_list>(<argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>str</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * There are two ways the generation of a unique id can be triggered:
 *
 * - from the post_read_request hook which calls set_unique_id()
 * - from error logging via the generate_log_id hook which calls
 *   generate_log_id(). This may happen before or after set_unique_id()
 *   has been called, or not at all.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>generate_log_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>request_rec</name> *</type><name>r</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>id</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* we do not care about connection ids */</comment>
    <if>if <condition>(<expr><name>r</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>DECLINED</name></expr>;</return></then></if>

    <comment type="block">/* XXX: do we need special handling for internal redirects? */</comment>

    <comment type="block">/* if set_unique_id() has been called for this request, use it */</comment>
    <expr_stmt><expr>*<name>id</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"UNIQUE_ID"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!*<name>id</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>id</name> = <call><name>gen_unique_id</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>set_unique_id</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <comment type="block">/* copy the unique_id if this is an internal redirect (we're never
     * actually called for sub requests, so we don't need to test for
     * them) */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>prev</name></name></expr>)</condition><then> <block>{
       <expr_stmt><expr><name>id</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"REDIRECT_UNIQUE_ID"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>id</name></expr>)</condition><then> <block>{
        <comment type="block">/* if we have a log id, it was set by our generate_log_id() function
         * and we should reuse the same id
         */</comment>
        <expr_stmt><expr><name>id</name> = <name><name>r</name>-&gt;<name>log_id</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>id</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>id</name> = <call><name>gen_unique_id</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* set the environment variable */</comment>
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"UNIQUE_ID"</expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_hook_post_config</name><argument_list>(<argument><expr><name>unique_id_global_init</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_child_init</name><argument_list>(<argument><expr><name>unique_id_child_init</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_post_read_request</name><argument_list>(<argument><expr><name>set_unique_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_generate_log_id</name><argument_list>(<argument><expr><name>generate_log_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>unique_id</name></expr></argument>)</argument_list></call> = <block>{
    <expr><name>STANDARD20_MODULE_STUFF</name></expr>,
    <expr><name>NULL</name></expr>,                       <comment type="block">/* dir config creater */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* dir merger --- default is to override */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* server config */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* merge server configs */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* command apr_table_t */</comment>
    <expr><name>register_hooks</name></expr>              <comment type="block">/* register hooks */</comment>
}</block></expr>;</expr_stmt>
</unit>
