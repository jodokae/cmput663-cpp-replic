<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/metadata/mod_mime_magic.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * mod_mime_magic: MIME type lookup via file magic numbers
 * Copyright (c) 1996-1997 Cisco Systems, Inc.
 *
 * This software was submitted by Cisco Systems to the Apache Software Foundation in July
 * 1997.  Future revisions and derivatives of this source code must
 * acknowledge Cisco Systems as the original contributor of this module.
 * All other licensing and usage conditions are those of the Apache Software Foundation.
 *
 * Some of this code is derived from the free version of the file command
 * originally posted to comp.sources.unix.  Copyright info for that program
 * is included below as required.
 * ---------------------------------------------------------------------------
 * - Copyright (c) Ian F. Darwin, 1987. Written by Ian F. Darwin.
 *
 * This software is not subject to any license of the American Telephone and
 * Telegraph Company or of the Regents of the University of California.
 *
 * Permission is granted to anyone to use this software for any purpose on any
 * computer system, and to alter it and redistribute it freely, subject to
 * the following restrictions:
 *
 * 1. The author is not responsible for the consequences of use of this
 * software, no matter how awful, even if they arise from flaws in it.
 *
 * 2. The origin of this software must not be misrepresented, either by
 * explicit claim or by omission.  Since few users ever read sources, credits
 * must appear in the documentation.
 *
 * 3. Altered versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.  Since few users ever read
 * sources, credits must appear in the documentation.
 *
 * 4. This notice may not be removed or altered.
 * -------------------------------------------------------------------------
 *
 * For compliance with Mr Darwin's terms: this has been very significantly
 * modified from the free "file" command.
 * - all-in-one file for compilation convenience when moving from one
 *   version of Apache to the next.
 * - Memory allocation is done through the Apache API's apr_pool_t structure.
 * - All functions have had necessary Apache API request or server
 *   structures passed to them where necessary to call other Apache API
 *   routines.  (i.e. usually for logging, files, or memory allocation in
 *   itself or a called function.)
 * - struct magic has been converted from an array to a single-ended linked
 *   list because it only grows one record at a time, it's only accessed
 *   sequentially, and the Apache API has no equivalent of realloc().
 * - Functions have been changed to get their parameters from the server
 *   configuration instead of globals.  (It should be reentrant now but has
 *   not been tested in a threaded environment.)
 * - Places where it used to print results to stdout now saves them in a
 *   list where they're used to set the MIME type in the Apache request
 *   record.
 * - Command-line flags have been removed since they will never be used here.
 *
 * Ian Kluft &lt;ikluft@cisco.com&gt;
 * Engineering Information Framework
 * Central Engineering
 * Cisco Systems, Inc.
 * San Jose, CA, USA
 *
 * Initial installation          July/August 1996
 * Misc bug fixes                May 1997
 * Submission to Apache Software Foundation    July 1997
 *
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_script.h"</cpp:file></cpp:include>

<comment type="block">/* ### this isn't set by configure? does anybody set this? */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UTIME_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utime.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * data structures and related constants
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODNAME</name></cpp:macro>        <cpp:value>"mod_mime_magic"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIME_MAGIC_DEBUG</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIME_BINARY_UNKNOWN</name></cpp:macro>    <cpp:value>"application/octet-stream"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIME_TEXT_UNKNOWN</name></cpp:macro>    <cpp:value>"text/plain"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXMIMESTRING</name></cpp:macro>        <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/* HOWMANY must be at least 4096 to make gzip -dcq work */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOWMANY</name></cpp:macro>  <cpp:value>4096</cpp:value></cpp:define>
<comment type="block">/* SMALL_HOWMANY limits how much work we do to figure out text files */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALL_HOWMANY</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXDESC</name></cpp:macro>    <cpp:value>50</cpp:value></cpp:define>   <comment type="block">/* max leng of text description */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXstring</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>    <comment type="block">/* max leng of "string" types */</comment>

<struct>struct <name>magic</name> <block>{
    <decl_stmt><decl><type>struct <name>magic</name> *</type><name>next</name></decl>;</decl_stmt>     <comment type="block">/* link to next entry */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>;</decl_stmt>             <comment type="block">/* line number from magic file */</comment>

    <decl_stmt><decl><type><name>short</name></type> <name>flag</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INDIR</name></cpp:macro>  <cpp:value>1</cpp:value></cpp:define>            <comment type="block">/* if '&gt;(...)' appears,  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNSIGNED</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>          <comment type="block">/* comparison is unsigned */</comment>
    <decl_stmt><decl><type><name>short</name></type> <name>cont_level</name></decl>;</decl_stmt>       <comment type="block">/* level of "&gt;" */</comment>
    <struct>struct <block>{
        <decl_stmt><decl><type><name>char</name></type> <name>type</name></decl>;</decl_stmt>          <comment type="block">/* byte short long */</comment>
        <decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>;</decl_stmt>        <comment type="block">/* offset from indirection */</comment>
    }</block> <decl><name>in</name></decl>;</struct>
    <decl_stmt><decl><type><name>long</name></type> <name>offset</name></decl>;</decl_stmt>            <comment type="block">/* offset to magic number */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>reln</name></decl>;</decl_stmt>     <comment type="block">/* relation (0=eq, '&gt;'=gt, etc) */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>type</name></decl>;</decl_stmt>              <comment type="block">/* int, short, long or string. */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>vallen</name></decl>;</decl_stmt>            <comment type="block">/* length of string value, if any */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTE</name></cpp:macro>      <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHORT</name></cpp:macro>     <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG</name></cpp:macro>      <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRING</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DATE</name></cpp:macro>      <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BESHORT</name></cpp:macro>   <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BELONG</name></cpp:macro>    <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BEDATE</name></cpp:macro>    <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LESHORT</name></cpp:macro>  <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LELONG</name></cpp:macro>   <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEDATE</name></cpp:macro>   <cpp:value>12</cpp:value></cpp:define>
    <union>union <name>VALUETYPE</name> <block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>b</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>h</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>l</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>s</name><index>[<expr><name>MAXstring</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hs</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* 2 bytes of a fixed-endian "short" */</comment>
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>hl</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* 2 bytes of a fixed-endian "long" */</comment>
    }</block> <decl><name>value</name></decl>;</union>                   <comment type="block">/* either number or string */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name></decl>;</decl_stmt>        <comment type="block">/* mask before comparison with value */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name>nospflag</name></decl>;</decl_stmt>             <comment type="block">/* suppress space character */</comment>

    <comment type="block">/* NOTE: this string is suspected of overrunning - find it! */</comment>
    <decl_stmt><decl><type><name>char</name></type> <name><name>desc</name><index>[<expr><name>MAXDESC</name></expr>]</index></name></decl>;</decl_stmt>        <comment type="block">/* description */</comment>
}</block>;</struct>

<comment type="block">/*
 * data structures for tar file recognition
 * --------------------------------------------------------------------------
 * Header file for public domain tar (tape archive) program.
 *
 * @(#)tar.h 1.20 86/10/29    Public Domain. Created 25 August 1985 by John
 * Gilmore, ihnp4!hoptoad!gnu.
 *
 * Header block on tape.
 *
 * I'm going to use traditional DP naming conventions here. A "block" is a big
 * chunk of stuff that we do I/O on. A "record" is a piece of info that we
 * care about. Typically many "record"s fit into a "block".
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RECORDSIZE</name></cpp:macro>    <cpp:value>512</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NAMSIZ</name></cpp:macro>    <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TUNMLEN</name></cpp:macro>    <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TGNMLEN</name></cpp:macro>    <cpp:value>32</cpp:value></cpp:define>

<union>union <name>record</name> <block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>charptr</name><index>[<expr><name>RECORDSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <struct>struct <name>header</name> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>NAMSIZ</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>mode</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>uid</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>gid</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>size</name><index>[<expr>12</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>mtime</name><index>[<expr>12</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>chksum</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name>linkflag</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>linkname</name><index>[<expr><name>NAMSIZ</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>magic</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>uname</name><index>[<expr><name>TUNMLEN</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>gname</name><index>[<expr><name>TGNMLEN</name></expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>devmajor</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>devminor</name><index>[<expr>8</expr>]</index></name></decl>;</decl_stmt>
    }</block> <decl><name>header</name></decl>;</struct>
}</block>;</union>

<comment type="block">/* The magic field is filled with this if uname and gname are valid. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>    <cpp:macro><name>TMAGIC</name></cpp:macro>        <cpp:value>"ustar  "</cpp:value></cpp:define>   <comment type="block">/* 7 chars and a null */</comment>

<comment type="block">/*
 * file-function prototypes
 */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ascmagic</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type> <name>char</name> *</decl></param>, <param><decl><type><name>apr_size_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>is_tar</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>char</name> *</decl></param>, <param><decl><type><name>apr_size_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>softmagic</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type> <name>char</name> *</decl></param>, <param><decl><type><name>apr_size_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>tryit</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type> <name>char</name> *</decl></param>, <param><decl><type><name>apr_size_t</name></type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>zmagic</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type> <name>char</name> *</decl></param>, <param><decl><type><name>apr_size_t</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>getvalue</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type></decl></param>, <param><decl><type>struct</type> <name>magic</name> *</decl></param>, <param><decl><type><name>char</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>hextoint</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> *</type><name>getstr</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>int</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>parse</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>match</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type><name>unsigned</name></type> <name>char</name> *</decl></param>, <param><decl><type><name>apr_size_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mget</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type>union</type> <name>VALUETYPE</name> *</decl></param>, <param><decl><type><name>unsigned</name></type> <name>char</name> *</decl></param>,
                <param><decl><type>struct</type> <name>magic</name> *</decl></param>, <param><decl><type><name>apr_size_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mcheck</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type>union</type> <name>VALUETYPE</name> *</decl></param>, <param><decl><type>struct</type> <name>magic</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mprint</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type>union</type> <name>VALUETYPE</name> *</decl></param>, <param><decl><type>struct</type> <name>magic</name> *</decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>uncompress</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>,
                      <param><decl><type><name>unsigned</name></type> <name>char</name> **</decl></param>, <param><decl><type><name>apr_size_t</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>from_oct</name><parameter_list>(<param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fsmagic</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fn</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * includes for ASCII substring recognition formerly "names.h" in file
 * command
 *
 * Original notes: names and types used by ascmagic in file(1). These tokens are
 * here because they can appear anywhere in the first HOWMANY bytes, while
 * tokens in /etc/magic must appear at fixed offsets into the file. Don't
 * make HOWMANY too high unless you have a very fast CPU.
 */</comment>

<comment type="block">/* these types are used to index the apr_table_t 'types': keep em in sync! */</comment>
<comment type="block">/* HTML inserted in first because this is a web server module now */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_HTML</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>   <comment type="block">/* HTML */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_C</name></cpp:macro>       <cpp:value>1</cpp:value></cpp:define>   <comment type="block">/* first and foremost on UNIX */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_FORT</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>   <comment type="block">/* the oldest one */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_MAKE</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>   <comment type="block">/* Makefiles */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_PLI</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>   <comment type="block">/* PL/1 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_MACH</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>   <comment type="block">/* some kinda assembler */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_ENG</name></cpp:macro>     <cpp:value>6</cpp:value></cpp:define>   <comment type="block">/* English */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_PAS</name></cpp:macro>     <cpp:value>7</cpp:value></cpp:define>   <comment type="block">/* Pascal */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_MAIL</name></cpp:macro>    <cpp:value>8</cpp:value></cpp:define>   <comment type="block">/* Electronic mail */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_NEWS</name></cpp:macro>    <cpp:value>9</cpp:value></cpp:define>   <comment type="block">/* Usenet Netnews */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>types</name><index>[]</index></name> <init>=
<expr><block>{
    <expr>"text/html"</expr>,             <comment type="block">/* HTML */</comment>
    <expr>"text/plain"</expr>,            <comment type="block">/* "c program text", */</comment>
    <expr>"text/plain"</expr>,            <comment type="block">/* "fortran program text", */</comment>
    <expr>"text/plain"</expr>,            <comment type="block">/* "make commands text", */</comment>
    <expr>"text/plain"</expr>,            <comment type="block">/* "pl/1 program text", */</comment>
    <expr>"text/plain"</expr>,            <comment type="block">/* "assembler program text", */</comment>
    <expr>"text/plain"</expr>,            <comment type="block">/* "English text", */</comment>
    <expr>"text/plain"</expr>,            <comment type="block">/* "pascal program text", */</comment>
    <expr>"message/rfc822"</expr>,        <comment type="block">/* "mail text", */</comment>
    <expr>"message/news"</expr>,          <comment type="block">/* "news text", */</comment>
    <expr>"application/binary"</expr>,    <comment type="block">/* "can't happen error on names.h/types", */</comment>
    <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>

<struct><specifier>static</specifier> <specifier>const</specifier> struct <name>names</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>short</name></type> <name>type</name></decl>;</decl_stmt>
}</block> <decl><name><name>names</name><index>[]</index></name> <init>= <expr><block>{

    <comment type="block">/* These must be sorted by eye for optimal hit rate */</comment>
    <comment type="block">/* Add to this list only after substantial meditation */</comment>
    <expr><block>{
        <expr>"&lt;html&gt;"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;HTML&gt;"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;head&gt;"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;HEAD&gt;"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;title&gt;"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;TITLE&gt;"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;h1&gt;"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;H1&gt;"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;!--"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&lt;!DOCTYPE HTML"</expr>, <expr><name>L_HTML</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"/*"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,               <comment type="block">/* must precede "The", "the", etc. */</comment>
    <expr><block>{
        <expr>"#include"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"char"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"The"</expr>, <expr><name>L_ENG</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"the"</expr>, <expr><name>L_ENG</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"double"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"extern"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"float"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"real"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"struct"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"union"</expr>, <expr><name>L_C</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"CFLAGS"</expr>, <expr><name>L_MAKE</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"LDFLAGS"</expr>, <expr><name>L_MAKE</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"all:"</expr>, <expr><name>L_MAKE</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>".PRECIOUS"</expr>, <expr><name>L_MAKE</name></expr>
    }</block></expr>,
    <comment type="block">/*
     * Too many files of text have these words in them.  Find another way to
     * recognize Fortrash.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>    <name>NOTDEF</name></cpp:ifdef>
    <expr><block>{
        <expr>"subroutine"</expr>, <expr><name>L_FORT</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"function"</expr>, <expr><name>L_FORT</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"block"</expr>, <expr><name>L_FORT</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"common"</expr>, <expr><name>L_FORT</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"dimension"</expr>, <expr><name>L_FORT</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"integer"</expr>, <expr><name>L_FORT</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"data"</expr>, <expr><name>L_FORT</name></expr>
    }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* NOTDEF */</comment>
    <expr><block>{
        <expr>".ascii"</expr>, <expr><name>L_MACH</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>".asciiz"</expr>, <expr><name>L_MACH</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>".byte"</expr>, <expr><name>L_MACH</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>".even"</expr>, <expr><name>L_MACH</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>".globl"</expr>, <expr><name>L_MACH</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"clr"</expr>, <expr><name>L_MACH</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"(input,"</expr>, <expr><name>L_PAS</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"dcl"</expr>, <expr><name>L_PLI</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"Received:"</expr>, <expr><name>L_MAIL</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"&gt;From"</expr>, <expr><name>L_MAIL</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"Return-Path:"</expr>, <expr><name>L_MAIL</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"Cc:"</expr>, <expr><name>L_MAIL</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"Newsgroups:"</expr>, <expr><name>L_NEWS</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"Path:"</expr>, <expr><name>L_NEWS</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr>"Organization:"</expr>, <expr><name>L_NEWS</name></expr>
    }</block></expr>,
    <expr><block>{
        <expr><name>NULL</name></expr>, <expr>0</expr>
    }</block></expr>
}</block></expr></init></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NNAMES</name></cpp:macro> <cpp:value>((sizeof(names)/sizeof(struct names)) - 1)</cpp:value></cpp:define>

<comment type="block">/*
 * Result String List (RSL)
 *
 * The file(1) command prints its output.  Instead, we store the various
 * "printed" strings in a list (allocating memory as we go) and concatenate
 * them at the end when we finally know how much space they'll need.
 */</comment>

<typedef>typedef <type><struct>struct <name>magic_rsl_s</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl>;</decl_stmt>                  <comment type="block">/* string, possibly a fragment */</comment>
    <decl_stmt><decl><type>struct <name>magic_rsl_s</name> *</type><name>next</name></decl>;</decl_stmt>   <comment type="block">/* pointer to next fragment */</comment>
}</block></struct></type> <name>magic_rsl</name>;</typedef>

<comment type="block">/*
 * Apache module configuration structures
 */</comment>

<comment type="block">/* per-server info */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>magicfile</name></decl>;</decl_stmt>    <comment type="block">/* where magic be found */</comment>
    <decl_stmt><decl><type>struct <name>magic</name> *</type><name>magic</name></decl>;</decl_stmt>      <comment type="block">/* head of magic config list */</comment>
    <decl_stmt><decl><type>struct <name>magic</name> *</type><name>last</name></decl>;</decl_stmt>
}</block></struct></type> <name>magic_server_config_rec</name>;</typedef>

<comment type="block">/* per-request info */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>magic_rsl</name> *</type><name>head</name></decl>;</decl_stmt>          <comment type="block">/* result string list */</comment>
    <decl_stmt><decl><type><name>magic_rsl</name> *</type><name>tail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>suf_recursion</name></decl>;</decl_stmt>   <comment type="block">/* recursion depth in suffix check */</comment>
}</block></struct></type> <name>magic_req_rec</name>;</typedef>

<comment type="block">/*
 * configuration functions - called by Apache API routines
 */</comment>

<decl_stmt><decl><type><name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>mime_magic_module</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_magic_server_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>d</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* allocate the config - use pcalloc because it needs to be zeroed */</comment>
    <return>return <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>magic_server_config_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>merge_magic_server_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>basev</name></decl></param>, <param><decl><type><name>void</name> *</type><name>addv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>base</name> <init>= <expr>(<name>magic_server_config_rec</name> *) <name>basev</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>add</name> <init>= <expr>(<name>magic_server_config_rec</name> *) <name>addv</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>new</name> <init>= <expr>(<name>magic_server_config_rec</name> *)
                            <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>magic_server_config_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>new</name>-&gt;<name>magicfile</name></name> = <name><name>add</name>-&gt;<name>magicfile</name></name> ? <name><name>add</name>-&gt;<name>magicfile</name></name> : <name><name>base</name>-&gt;<name>magicfile</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>magic</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>last</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>new</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_magicfile</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>conf</name> <init>= <expr>(<name>magic_server_config_rec</name> *)
    <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                      <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>conf</name></expr>)</condition><then> <block>{
        <return>return <expr><name>MODNAME</name> ": server structure not allocated"</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>conf</name>-&gt;<name>magicfile</name></name> = <name>arg</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * configuration file commands - exported to Apache API
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>mime_magic_cmds</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"MimeMagicFile"</expr></argument>, <argument><expr><name>set_magicfile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
     <argument><expr>"Path to MIME Magic file (in file(1) format)"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * RSL (result string list) processing routines
 *
 * These collect strings that would have been printed in fragments by file(1)
 * into a list of magic_rsl structures with the strings. When complete,
 * they're concatenated together to become the MIME content and encoding
 * types.
 *
 * return value conventions for these functions: functions which return int:
 * failure = -1, other = result functions which return pointers: failure = 0,
 * other = result
 */</comment>

<comment type="block">/* allocate a per-request structure and put it in the request record */</comment>
<function><type><specifier>static</specifier> <name>magic_req_rec</name> *</type><name>magic_set_config</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>magic_req_rec</name> *</type><name>req_dat</name> <init>= <expr>(<name>magic_req_rec</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>magic_req_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>req_dat</name>-&gt;<name>head</name></name> = <name><name>req_dat</name>-&gt;<name>tail</name></name> = (<name>magic_rsl</name> *) <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_set_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>, <argument><expr><name>req_dat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>req_dat</name></expr>;</return>
}</block></function>

<comment type="block">/* add a string to the result string list for this request */</comment>
<comment type="block">/* it is the responsibility of the caller to allocate "str" */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>magic_rsl_add</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>magic_req_rec</name> *</type><name>req_dat</name> <init>= <expr>(<name>magic_req_rec</name> *)
                    <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_rsl</name> *</type><name>rsl</name></decl>;</decl_stmt>

    <comment type="block">/* make sure we have a list to put it in */</comment>
    <if>if <condition>(<expr>!<name>req_dat</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>APR_EINVAL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01507</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": request config should not be NULL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!(<name>req_dat</name> = <call><name>magic_set_config</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <comment type="block">/* failure */</comment>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* allocate the list entry */</comment>
    <expr_stmt><expr><name>rsl</name> = (<name>magic_rsl</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>magic_rsl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* fill it */</comment>
    <expr_stmt><expr><name><name>rsl</name>-&gt;<name>str</name></name> = <name>str</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>rsl</name>-&gt;<name>next</name></name> = (<name>magic_rsl</name> *) <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* append to the list */</comment>
    <if>if <condition>(<expr><name><name>req_dat</name>-&gt;<name>head</name></name> &amp;&amp; <name><name>req_dat</name>-&gt;<name>tail</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>req_dat</name>-&gt;<name>tail</name>-&gt;<name>next</name></name> = <name>rsl</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>req_dat</name>-&gt;<name>tail</name></name> = <name>rsl</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>req_dat</name>-&gt;<name>head</name></name> = <name><name>req_dat</name>-&gt;<name>tail</name></name> = <name>rsl</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* success */</comment>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* RSL hook for puts-type functions */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>magic_rsl_puts</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>magic_rsl_add</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* RSL hook for printf-type functions */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>magic_rsl_printf</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>str</name></decl></param>,<param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXMIMESTRING</name></expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* assemble the string into the buffer */</comment>
    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* add the buffer to the list */</comment>
    <return>return <expr><call><name>magic_rsl_add</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* RSL hook for putchar-type functions */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>magic_rsl_putchar</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* high overhead for 1 char - just hope they don't do this much */</comment>
    <expr_stmt><expr><name><name>str</name><index>[<expr>0</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>str</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><call><name>magic_rsl_add</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* allocate and copy a contiguous string from a result string list */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>rsl_strdup</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name></type> <name>start_frag</name></decl></param>, <param><decl><type><name>int</name></type> <name>start_pos</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>result</name></decl>;</decl_stmt>       <comment type="block">/* return value */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>cur_frag</name></decl>,       <comment type="block">/* current fragment number/counter */</comment>
        <decl><type ref="prev"/><name>cur_pos</name></decl>,        <comment type="block">/* current position within fragment */</comment>
        <decl><type ref="prev"/><name>res_pos</name></decl>;</decl_stmt>        <comment type="block">/* position in result string */</comment>
    <decl_stmt><decl><type><name>magic_rsl</name> *</type><name>frag</name></decl>;</decl_stmt>    <comment type="block">/* list-traversal pointer */</comment>
    <decl_stmt><decl><type><name>magic_req_rec</name> *</type><name>req_dat</name> <init>= <expr>(<name>magic_req_rec</name> *)
                    <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* allocate the result string */</comment>
    <expr_stmt><expr><name>result</name> = (<name>char</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* loop through and collect the string */</comment>
    <expr_stmt><expr><name>res_pos</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>frag</name> = <name><name>req_dat</name>-&gt;<name>head</name></name></expr>, <expr><name>cur_frag</name> = 0</expr>;</init>
         <condition><expr><name><name>frag</name>-&gt;<name>next</name></name></expr>;</condition>
         <incr><expr><name>frag</name> = <name><name>frag</name>-&gt;<name>next</name></name></expr>, <expr><name>cur_frag</name>++</expr></incr>) <block>{
        <comment type="block">/* loop to the first fragment */</comment>
        <if>if <condition>(<expr><name>cur_frag</name> &lt; <name>start_frag</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <comment type="block">/* loop through and collect chars */</comment>
        <for>for (<init><expr><name>cur_pos</name> = (<name>cur_frag</name> == <name>start_frag</name>) ? <name>start_pos</name> : 0</expr>;</init>
             <condition><expr><name><name>frag</name>-&gt;<name>str</name><index>[<expr><name>cur_pos</name></expr>]</index></name></expr>;</condition>
             <incr><expr><name>cur_pos</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><name>cur_frag</name> &gt;= <name>start_frag</name>
                &amp;&amp; <name>cur_pos</name> &gt;= <name>start_pos</name>
                &amp;&amp; <name>res_pos</name> &lt;= <name>len</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>result</name><index>[<expr><name>res_pos</name>++</expr>]</index></name> = <name><name>frag</name>-&gt;<name>str</name><index>[<expr><name>cur_pos</name></expr>]</index></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>res_pos</name> &gt; <name>len</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
            }</block></then></if>
        }</block></for>
    }</block></for>

    <comment type="block">/* clean up and return */</comment>
    <expr_stmt><expr><name><name>result</name><index>[<expr><name>res_pos</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01508</argument>)</argument_list></macro>
             <name>MODNAME</name> ": rsl_strdup() %d chars: %s"</expr></argument>, <argument><expr><name>res_pos</name> - 1</expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/* states for the state-machine algorithm in magic_rsl_to_request() */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>rsl_leading_space</name></decl>, <decl><name>rsl_type</name></decl>, <decl><name>rsl_subtype</name></decl>, <decl><name>rsl_separator</name></decl>, <decl><name>rsl_encoding</name></decl>
}</block></enum></type> <name>rsl_states</name>;</typedef>

<comment type="block">/* process the RSL and set the MIME info in the request record */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>magic_rsl_to_request</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>cur_frag</name></decl>,         <comment type="block">/* current fragment number/counter */</comment>
        <decl><type ref="prev"/><name>cur_pos</name></decl>,          <comment type="block">/* current position within fragment */</comment>
        <decl><type ref="prev"/><name>type_frag</name></decl>,        <comment type="block">/* content type starting point: fragment */</comment>
        <decl><type ref="prev"/><name>type_pos</name></decl>,         <comment type="block">/* content type starting point: position */</comment>
        <decl><type ref="prev"/><name>type_len</name></decl>,         <comment type="block">/* content type length */</comment>
        <decl><type ref="prev"/><name>encoding_frag</name></decl>,    <comment type="block">/* content encoding starting point: fragment */</comment>
        <decl><type ref="prev"/><name>encoding_pos</name></decl>,     <comment type="block">/* content encoding starting point: position */</comment>
        <decl><type ref="prev"/><name>encoding_len</name></decl>;</decl_stmt>     <comment type="block">/* content encoding length */</comment>

    <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_rsl</name> *</type><name>frag</name></decl>;</decl_stmt>      <comment type="block">/* list-traversal pointer */</comment>
    <decl_stmt><decl><type><name>rsl_states</name></type> <name>state</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>magic_req_rec</name> *</type><name>req_dat</name> <init>= <expr>(<name>magic_req_rec</name> *)
                    <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* check if we have a result */</comment>
    <if>if <condition>(<expr>!<name>req_dat</name> || !<name><name>req_dat</name>-&gt;<name>head</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* empty - no match, we defer to other Apache modules */</comment>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* start searching for the type and encoding */</comment>
    <expr_stmt><expr><name>state</name> = <name>rsl_leading_space</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>type_frag</name> = <name>type_pos</name> = <name>type_len</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>encoding_frag</name> = <name>encoding_pos</name> = <name>encoding_len</name> = 0</expr>;</expr_stmt>
    <for>for (<init><expr><name>frag</name> = <name><name>req_dat</name>-&gt;<name>head</name></name></expr>, <expr><name>cur_frag</name> = 0</expr>;</init>
         <condition><expr><name>frag</name> &amp;&amp; <name><name>frag</name>-&gt;<name>next</name></name></expr>;</condition>
         <incr><expr><name>frag</name> = <name><name>frag</name>-&gt;<name>next</name></name></expr>, <expr><name>cur_frag</name>++</expr></incr>) <block>{
        <comment type="block">/* loop through the characters in the fragment */</comment>
        <for>for (<init><expr><name>cur_pos</name> = 0</expr>;</init> <condition><expr><name><name>frag</name>-&gt;<name>str</name><index>[<expr><name>cur_pos</name></expr>]</index></name></expr>;</condition> <incr><expr><name>cur_pos</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>frag</name>-&gt;<name>str</name><index>[<expr><name>cur_pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* process whitespace actions for each state */</comment>
                <if>if <condition>(<expr><name>state</name> == <name>rsl_leading_space</name></expr>)</condition><then> <block>{
                    <comment type="block">/* eat whitespace in this state */</comment>
                    <continue>continue;</continue>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>state</name> == <name>rsl_type</name></expr>)</condition><then> <block>{
                    <comment type="block">/* whitespace: type has no slash! */</comment>
                    <return>return <expr><name>DECLINED</name></expr>;</return>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>state</name> == <name>rsl_subtype</name></expr>)</condition><then> <block>{
                    <comment type="block">/* whitespace: end of MIME type */</comment>
                    <expr_stmt><expr><name>state</name>++</expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>state</name> == <name>rsl_separator</name></expr>)</condition><then> <block>{
                    <comment type="block">/* eat whitespace in this state */</comment>
                    <continue>continue;</continue>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>state</name> == <name>rsl_encoding</name></expr>)</condition><then> <block>{
                    <comment type="block">/* whitespace: end of MIME encoding */</comment>
                    <comment type="block">/* we're done */</comment>
                    <expr_stmt><expr><name>frag</name> = <name><name>req_dat</name>-&gt;<name>tail</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then>
                <else>else <block>{
                    <comment type="block">/* should not be possible */</comment>
                    <comment type="block">/* abandon malfunctioning module */</comment>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01509</argument>)</argument_list></macro>
                                <name>MODNAME</name> ": bad state %d (ws)"</expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>DECLINED</name></expr>;</return>
                }</block></else></if></else></if></else></if></else></if></else></if>
                <comment type="block">/* NOTREACHED */</comment>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>state</name> == <name>rsl_type</name> &amp;&amp;
                     <name><name>frag</name>-&gt;<name>str</name><index>[<expr><name>cur_pos</name></expr>]</index></name> == '/'</expr>)</condition><then> <block>{
                <comment type="block">/* copy the char and go to rsl_subtype state */</comment>
                <expr_stmt><expr><name>type_len</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>state</name>++</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* process non-space actions for each state */</comment>
                <if>if <condition>(<expr><name>state</name> == <name>rsl_leading_space</name></expr>)</condition><then> <block>{
                    <comment type="block">/* non-space: begin MIME type */</comment>
                    <expr_stmt><expr><name>state</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>type_frag</name> = <name>cur_frag</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>type_pos</name> = <name>cur_pos</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>type_len</name> = 1</expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>state</name> == <name>rsl_type</name> ||
                         <name>state</name> == <name>rsl_subtype</name></expr>)</condition><then> <block>{
                    <comment type="block">/* non-space: adds to type */</comment>
                    <expr_stmt><expr><name>type_len</name>++</expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>state</name> == <name>rsl_separator</name></expr>)</condition><then> <block>{
                    <comment type="block">/* non-space: begin MIME encoding */</comment>
                    <expr_stmt><expr><name>state</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>encoding_frag</name> = <name>cur_frag</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>encoding_pos</name> = <name>cur_pos</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>encoding_len</name> = 1</expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then>
                <else>else <if>if <condition>(<expr><name>state</name> == <name>rsl_encoding</name></expr>)</condition><then> <block>{
                    <comment type="block">/* non-space: adds to encoding */</comment>
                    <expr_stmt><expr><name>encoding_len</name>++</expr>;</expr_stmt>
                    <continue>continue;</continue>
                }</block></then>
                <else>else <block>{
                    <comment type="block">/* should not be possible */</comment>
                    <comment type="block">/* abandon malfunctioning module */</comment>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01510</argument>)</argument_list></macro>
                                <name>MODNAME</name> ": bad state %d (ns)"</expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>DECLINED</name></expr>;</return>
                }</block></else></if></else></if></else></if></else></if>
                <comment type="block">/* NOTREACHED */</comment>
            }</block></else></if></else></if>
            <comment type="block">/* NOTREACHED */</comment>
        }</block></for>
    }</block></for>

    <comment type="block">/* if we ended prior to state rsl_subtype, we had incomplete info */</comment>
    <if>if <condition>(<expr><name>state</name> != <name>rsl_subtype</name> &amp;&amp; <name>state</name> != <name>rsl_separator</name> &amp;&amp;
        <name>state</name> != <name>rsl_encoding</name></expr>)</condition><then> <block>{
        <comment type="block">/* defer to other modules */</comment>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* save the info in the request record */</comment>
    <expr_stmt><expr><name>tmp</name> = <call><name>rsl_strdup</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>type_frag</name></expr></argument>, <argument><expr><name>type_pos</name></expr></argument>, <argument><expr><name>type_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* XXX: this could be done at config time I'm sure... but I'm
     * confused by all this magic_rsl stuff. -djg */</comment>
    <expr_stmt><expr><call><name>ap_content_type_tolower</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>state</name> == <name>rsl_encoding</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>tmp</name> = <call><name>rsl_strdup</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>encoding_frag</name></expr></argument>,
                                         <argument><expr><name>encoding_pos</name></expr></argument>, <argument><expr><name>encoding_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* XXX: this could be done at config time I'm sure... but I'm
         * confused by all this magic_rsl stuff. -djg */</comment>
        <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>content_encoding</name></name> = <name>tmp</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* detect memory allocation or other errors */</comment>
    <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>content_type</name></name> ||
        (<name>state</name> == <name>rsl_encoding</name> &amp;&amp; !<name><name>r</name>-&gt;<name>content_encoding</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01511</argument>)</argument_list></macro>
                      <name>MODNAME</name> ": unexpected state %d; could be caused by bad "
                      "data in magic file"</expr></argument>,
                      <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* success! */</comment>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * magic_process - process input file r        Apache API request record
 * (formerly called "process" in file command, prefix added for clarity) Opens
 * the file and reads a fixed-size buffer to begin processing the contents.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>magic_process</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr><name>HOWMANY</name> + 1</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* one extra for terminating '\0' */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nbytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>           <comment type="block">/* number of bytes read from a datafile */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <comment type="block">/*
     * first try judging the file based on its filesystem status
     */</comment>
    <switch>switch <condition>(<expr>(<name>result</name> = <call><name>fsmagic</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
    <case>case <expr><name>DONE</name></expr>:
        <expr_stmt><expr><call><name>magic_rsl_putchar</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>OK</name></expr>;</return>
    </case><case>case <expr><name>OK</name></expr>:
        <break>break;</break>
    </case><default>default:
        <comment type="block">/* fatal error, bail out */</comment>
        <return>return <expr><name>result</name></expr>;</return>
    </default>}</block></switch>

    <if>if <condition>(<expr><call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <comment type="block">/* We can't open it, but we were able to stat it. */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01512</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": can't read `%s'"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* let some other handler decide what the problem is */</comment>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * try looking at the first HOWMANY bytes
     */</comment>
    <expr_stmt><expr><name>nbytes</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>result</name> = <call><name>apr_file_read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>(<name>char</name> *) <name>buf</name></expr></argument>, <argument><expr>&amp;<name>nbytes</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01513</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": read failed: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>nbytes</name> == 0</expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>nbytes</name>++</expr>]</index></name> = '\0'</expr>;</expr_stmt>  <comment type="block">/* null-terminate it */</comment>
        <expr_stmt><expr><name>result</name> = <call><name>tryit</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>result</name> != <name>OK</name></expr>)</condition><then> <block>{
            <return>return <expr><name>result</name></expr>;</return>
        }</block></then></if>
    }</block></else></if>

    <expr_stmt><expr>(<name>void</name>) <call><name>apr_file_close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_putchar</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>tryit</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nb</name></decl></param>,
                 <param><decl><type><name>int</name></type> <name>checkzmagic</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * Try compression stuff
     */</comment>
    <if>if <condition>(<expr><name>checkzmagic</name> == 1</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>zmagic</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
            <return>return <expr><name>OK</name></expr>;</return></then></if>
    }</block></then></if>

    <comment type="block">/*
     * try tests in /etc/magic (or surrogate magic file)
     */</comment>
    <if>if <condition>(<expr><call><name>softmagic</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
        <return>return <expr><name>OK</name></expr>;</return></then></if>

    <comment type="block">/*
     * try known keywords, check for ascii-ness too.
     */</comment>
    <if>if <condition>(<expr><call><name>ascmagic</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
        <return>return <expr><name>OK</name></expr>;</return></then></if>

    <comment type="block">/*
     * abandon hope, all ye who remain here
     */</comment>
    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive>    <cpp:macro><name>EATAB</name></cpp:macro> <cpp:value>{while (apr_isspace(*l))  ++l;}</cpp:value></cpp:define>

<comment type="block">/*
 * apprentice - load configuration from the magic file r
 *  API request record
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apprentice</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>BUFSIZ</name> + 1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>errs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>lineno</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>rule</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>magic</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>prevm</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>conf</name> <init>= <expr>(<name>magic_server_config_rec</name> *)
                    <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name> <init>= <expr><call><name>ap_server_root_relative</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>magicfile</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>fname</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>APR_EBADPATH</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01514</argument>)</argument_list></macro>
                     <name>MODNAME</name> ": Invalid magic file path %s"</expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>magicfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>result</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                                <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01515</argument>)</argument_list></macro>
                     <name>MODNAME</name> ": can't read magic file %s"</expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* set up the magic list (empty) */</comment>
    <expr_stmt><expr><name><name>conf</name>-&gt;<name>magic</name></name> = <name><name>conf</name>-&gt;<name>last</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* parse it */</comment>
    <for>for (<init><expr><name>lineno</name> = 1</expr>;</init> <condition><expr><call><name>apr_file_gets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>;</condition> <incr><expr><name>lineno</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>ws_offset</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>last</name> <init>= <expr><name>line</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> - 1</expr></init></decl>;</decl_stmt> <comment type="block">/* guaranteed that len &gt;= 1 since an
                                               * "empty" line contains a '\n'
                                               */</comment>

        <comment type="block">/* delete newline and any other trailing whitespace */</comment>
        <while>while <condition>(<expr><name>last</name> &gt;= <name>line</name>
               &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>last</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>*<name>last</name> = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr>--<name>last</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* skip leading whitespace */</comment>
        <expr_stmt><expr><name>ws_offset</name> = 0</expr>;</expr_stmt>
        <while>while <condition>(<expr><name><name>line</name><index>[<expr><name>ws_offset</name></expr>]</index></name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>line</name><index>[<expr><name>ws_offset</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr><name>ws_offset</name>++</expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* skip blank lines */</comment>
        <if>if <condition>(<expr><name><name>line</name><index>[<expr><name>ws_offset</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* comment, do not parse */</comment>
        <if>if <condition>(<expr><name><name>line</name><index>[<expr><name>ws_offset</name></expr>]</index></name> == '#'</expr>)</condition><then>
            <continue>continue;</continue></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <comment type="block">/* if we get here, we're going to use it so count it */</comment>
        <expr_stmt><expr><name>rule</name>++</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* parse it */</comment>
        <if>if <condition>(<expr><call><name>parse</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name> + <name>ws_offset</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
            <expr_stmt><expr>++<name>errs</name></expr>;</expr_stmt></then></if>
    }</block></for>

    <expr_stmt><expr>(<name>void</name>) <call><name>apr_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01516</argument>)</argument_list></macro>
                <name>MODNAME</name> ": apprentice conf=%x file=%s m=%s m-&gt;next=%s last=%s"</expr></argument>,
                <argument><expr><name>conf</name></expr></argument>,
                <argument><expr><name><name>conf</name>-&gt;<name>magicfile</name></name> ? <name><name>conf</name>-&gt;<name>magicfile</name></name> : "NULL"</expr></argument>,
                <argument><expr><name><name>conf</name>-&gt;<name>magic</name></name> ? "set" : "NULL"</expr></argument>,
                <argument><expr>(<name><name>conf</name>-&gt;<name>magic</name></name> &amp;&amp; <name><name>conf</name>-&gt;<name>magic</name>-&gt;<name>next</name></name>) ? "set" : "NULL"</expr></argument>,
                <argument><expr><name><name>conf</name>-&gt;<name>last</name></name> ? "set" : "NULL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01517</argument>)</argument_list></macro>
                <name>MODNAME</name> ": apprentice read %d lines, %d rules, %d errors"</expr></argument>,
                <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>rule</name></expr></argument>, <argument><expr><name>errs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><name>prevm</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01518</argument>)</argument_list></macro>
                <name>MODNAME</name> ": apprentice test"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>m</name> = <name><name>conf</name>-&gt;<name>magic</name></name></expr>;</init> <condition><expr><name>m</name></expr>;</condition> <incr><expr><name>m</name> = <name><name>m</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 24) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 16) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 8) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>apr_isprint</name><argument_list>(<argument><expr>((<name>unsigned</name> <name>long</name>) <name>m</name>) &amp; 255</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01519</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": apprentice: POINTER CLOBBERED! "
                        "m=\"%c%c%c%c\" line=%d"</expr></argument>,
                        <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 24) &amp; 255</expr></argument>,
                        <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 16) &amp; 255</expr></argument>,
                        <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 8) &amp; 255</expr></argument>,
                        <argument><expr>((<name>unsigned</name> <name>long</name>) <name>m</name>) &amp; 255</expr></argument>,
                        <argument><expr><name>prevm</name> ? <name><name>prevm</name>-&gt;<name>lineno</name></name> : -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>prevm</name> = <name>m</name></expr>;</expr_stmt>
    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr>(<name>errs</name> ? -1 : 0)</expr>;</return>
}</block></function>

<comment type="block">/*
 * extend the sign bit if the comparison is to be signed
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>signextend</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type>struct <name>magic</name> *</type><name>m</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>v</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!(<name><name>m</name>-&gt;<name>flag</name></name> &amp; <name>UNSIGNED</name>)</expr>)</condition><then>
        <switch>switch <condition>(<expr><name><name>m</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
            <comment type="block">/*
             * Do not remove the casts below.  They are vital. When later
             * compared with the data, the sign extension must have happened.
             */</comment>
        <case>case <expr><name>BYTE</name></expr>:
            <expr_stmt><expr><name>v</name> = (<name>char</name>) <name>v</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>SHORT</name></expr>:
        </case><case>case <expr><name>BESHORT</name></expr>:
        </case><case>case <expr><name>LESHORT</name></expr>:
            <expr_stmt><expr><name>v</name> = (<name>short</name>) <name>v</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>DATE</name></expr>:
        </case><case>case <expr><name>BEDATE</name></expr>:
        </case><case>case <expr><name>LEDATE</name></expr>:
        </case><case>case <expr><name>LONG</name></expr>:
        </case><case>case <expr><name>BELONG</name></expr>:
        </case><case>case <expr><name>LELONG</name></expr>:
            <expr_stmt><expr><name>v</name> = (<name>long</name>) <name>v</name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>STRING</name></expr>:
            <break>break;</break>
        </case><default>default:
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01520</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": can't happen: m-&gt;type=%d"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        </default>}</block></switch></then></if>
    <return>return <expr><name>v</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * parse one line from magic file, put into magic[index++] if valid
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parse</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>serv</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>l</name></decl></param>, <param><decl><type><name>int</name></type> <name>lineno</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>magic</name> *</type><name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>t</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>conf</name> <init>= <expr>(<name>magic_server_config_rec</name> *)
                    <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>serv</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* allocate magic structure entry */</comment>
    <expr_stmt><expr><name>m</name> = (struct <name>magic</name> *) <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>magic</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* append to linked list */</comment>
    <expr_stmt><expr><name><name>m</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>magic</name></name> || !<name><name>conf</name>-&gt;<name>last</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>conf</name>-&gt;<name>magic</name></name> = <name><name>conf</name>-&gt;<name>last</name></name> = <name>m</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>conf</name>-&gt;<name>last</name>-&gt;<name>next</name></name> = <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>conf</name>-&gt;<name>last</name></name> = <name>m</name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* set values in magic structure */</comment>
    <expr_stmt><expr><name><name>m</name>-&gt;<name>flag</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m</name>-&gt;<name>cont_level</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>m</name>-&gt;<name>lineno</name></name> = <name>lineno</name></expr>;</expr_stmt>

    <while>while <condition>(<expr>*<name>l</name> == '&gt;'</expr>)</condition> <block>{
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>  <comment type="block">/* step over */</comment>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>cont_level</name></name>++</expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name><name>m</name>-&gt;<name>cont_level</name></name> != 0 &amp;&amp; *<name>l</name> == '('</expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>  <comment type="block">/* step over */</comment>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>flag</name></name> |= <name>INDIR</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* get offset, then skip over it */</comment>
    <expr_stmt><expr><name><name>m</name>-&gt;<name>offset</name></name> = (<name>int</name>) <call><name>strtol</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>l</name> == <name>t</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>serv</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01521</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": offset %s invalid"</expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>l</name> = <name>t</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>m</name>-&gt;<name>flag</name></name> &amp; <name>INDIR</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>in</name>.<name>type</name></name> = <name>LONG</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>in</name>.<name>offset</name></name> = 0</expr>;</expr_stmt>
        <comment type="block">/*
         * read [.lbs][+-]nnnnn)
         */</comment>
        <if>if <condition>(<expr>*<name>l</name> == '.'</expr>)</condition><then> <block>{
            <switch>switch <condition>(<expr>*++<name>l</name></expr>)</condition> <block>{
            <case>case <expr>'l'</expr>:
                <expr_stmt><expr><name><name>m</name>-&gt;<name>in</name>.<name>type</name></name> = <name>LONG</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'s'</expr>:
                <expr_stmt><expr><name><name>m</name>-&gt;<name>in</name>.<name>type</name></name> = <name>SHORT</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><case>case <expr>'b'</expr>:
                <expr_stmt><expr><name><name>m</name>-&gt;<name>in</name>.<name>type</name></name> = <name>BYTE</name></expr>;</expr_stmt>
                <break>break;</break>
            </case><default>default:
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>serv</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01522</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": indirect offset type %c invalid"</expr></argument>, <argument><expr>*<name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            </default>}</block></switch>
            <expr_stmt><expr><name>l</name>++</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>s</name> = <name>l</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>l</name> == '+' || *<name>l</name> == '-'</expr>)</condition><then>
            <expr_stmt><expr><name>l</name>++</expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>) *<name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>m</name>-&gt;<name>in</name>.<name>offset</name></name> = <call><name>strtol</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>&amp;<name>t</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>s</name> == '-'</expr>)</condition><then>
                <expr_stmt><expr><name><name>m</name>-&gt;<name>in</name>.<name>offset</name></name> = -<name><name>m</name>-&gt;<name>in</name>.<name>offset</name></name></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else
            <expr_stmt><expr><name>t</name> = <name>l</name></expr>;</expr_stmt></else></if>
        <if>if <condition>(<expr>*<name>t</name>++ != ')'</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>serv</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01523</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": missing ')' in indirect offset"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>l</name> = <name>t</name></expr>;</expr_stmt>
    }</block></then></if>


    <while>while <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name>) *<name>l</name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt></while>
    <expr_stmt><expr><name>EATAB</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBYTE</name></cpp:macro>           <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSHORT</name></cpp:macro>          <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NLONG</name></cpp:macro>           <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NSTRING</name></cpp:macro>         <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NDATE</name></cpp:macro>           <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBESHORT</name></cpp:macro>        <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBELONG</name></cpp:macro>         <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBEDATE</name></cpp:macro>         <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NLESHORT</name></cpp:macro>        <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NLELONG</name></cpp:macro>         <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NLEDATE</name></cpp:macro>         <cpp:value>6</cpp:value></cpp:define>

    <if>if <condition>(<expr>*<name>l</name> == 'u'</expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>flag</name></name> |= <name>UNSIGNED</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* get type, skip it */</comment>
    <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"byte"</expr></argument>, <argument><expr><name>NBYTE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>BYTE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NBYTE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"short"</expr></argument>, <argument><expr><name>NSHORT</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>SHORT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NSHORT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"long"</expr></argument>, <argument><expr><name>NLONG</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>LONG</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NLONG</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"string"</expr></argument>, <argument><expr><name>NSTRING</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>STRING</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NSTRING</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"date"</expr></argument>, <argument><expr><name>NDATE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>DATE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NDATE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"beshort"</expr></argument>, <argument><expr><name>NBESHORT</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>BESHORT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NBESHORT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"belong"</expr></argument>, <argument><expr><name>NBELONG</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>BELONG</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NBELONG</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"bedate"</expr></argument>, <argument><expr><name>NBEDATE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>BEDATE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NBEDATE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"leshort"</expr></argument>, <argument><expr><name>NLESHORT</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>LESHORT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NLESHORT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"lelong"</expr></argument>, <argument><expr><name>NLELONG</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>LELONG</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NLELONG</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>"ledate"</expr></argument>, <argument><expr><name>NLEDATE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>m</name>-&gt;<name>type</name></name> = <name>LEDATE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>l</name> += <name>NLEDATE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>serv</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01524</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": type %s invalid"</expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
    <comment type="block">/* New-style anding: "0 byte&amp;0x80 =0x80 dynamically linked" */</comment>
    <if>if <condition>(<expr>*<name>l</name> == '&amp;'</expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>mask</name></name> = <call><name>signextend</name><argument_list>(<argument><expr><name>serv</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>strtol</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
        <expr_stmt><expr><name><name>m</name>-&gt;<name>mask</name></name> = ~0L</expr>;</expr_stmt></else></if>
    <expr_stmt><expr><name>EATAB</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr>*<name>l</name></expr>)</condition> <block>{
    <case>case <expr>'&gt;'</expr>:
    </case><case>case <expr>'&lt;'</expr>:
        <comment type="block">/* Old-style anding: "0 byte &amp;0x80 dynamically linked" */</comment>
    </case><case>case <expr>'&amp;'</expr>:
    </case><case>case <expr>'^'</expr>:
    </case><case>case <expr>'='</expr>:
        <expr_stmt><expr><name><name>m</name>-&gt;<name>reln</name></name> = *<name>l</name></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr>'!'</expr>:
        <if>if <condition>(<expr><name><name>m</name>-&gt;<name>type</name></name> != <name>STRING</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>m</name>-&gt;<name>reln</name></name> = *<name>l</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <comment type="block">/* FALL THROUGH */</comment>
    </case><default>default:
        <if>if <condition>(<expr>*<name>l</name> == 'x' &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>l</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>m</name>-&gt;<name>reln</name></name> = *<name>l</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>
            <goto>goto <name>GetDesc</name>;</goto>  <comment type="block">/* Bill The Cat */</comment>
        }</block></then></if>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>reln</name></name> = '='</expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>
    <expr_stmt><expr><name>EATAB</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>getvalue</name><argument_list>(<argument><expr><name>serv</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr>&amp;<name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>
    <comment type="block">/*
     * now get last part - the description
     */</comment>
  <label><name>GetDesc</name>:</label>
    <expr_stmt><expr><name>EATAB</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>l</name><index>[<expr>0</expr>]</index></name> == '\b'</expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>nospflag</name></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>(<name><name>l</name><index>[<expr>0</expr>]</index></name> == '\\') &amp;&amp; (<name><name>l</name><index>[<expr>1</expr>]</index></name> == 'b')</expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>l</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>nospflag</name></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else
        <expr_stmt><expr><name><name>m</name>-&gt;<name>nospflag</name></name> = 0</expr>;</expr_stmt></else></if></else></if>
    <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name><name>m</name>-&gt;<name>desc</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>m</name>-&gt;<name>desc</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>serv</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01525</argument>)</argument_list></macro>
                <name>MODNAME</name> ": parse line=%d m=%x next=%x cont=%d desc=%s"</expr></argument>,
                <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>cont_level</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MIME_MAGIC_DEBUG */</comment>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * Read a numeric value from a pointer, into the value union of a magic
 * pointer, according to the magic type.  Update the string pointer to point
 * just after the number read.  Return 0 for success, non-zero for failure.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>getvalue</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type>struct <name>magic</name> *</type><name>m</name></decl></param>, <param><decl><type><name>char</name> **</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>slen</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>m</name>-&gt;<name>type</name></name> == <name>STRING</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>p</name> = <call><name>getstr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>*<name>p</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>value</name>.<name>s</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>m</name>-&gt;<name>value</name>.<name>s</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>vallen</name></name> = <name>slen</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>m</name>-&gt;<name>reln</name></name> != 'x'</expr>)</condition><then>
        <expr_stmt><expr><name><name>m</name>-&gt;<name>value</name>.<name>l</name></name> = <call><name>signextend</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><call><name>strtol</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * Convert a string containing C character escapes.  Stop at an unescaped
 * space or tab. Copy the converted version to "p", returning its length in
 * *slen. Return updated scan pointer as function result.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>getstr</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>serv</name></decl></param>, <param><decl><type><name>register</name> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>register</name> <name>char</name> *</type><name>p</name></decl></param>,
                    <param><decl><type><name>int</name></type> <name>plen</name></decl></param>, <param><decl><type><name>int</name> *</type><name>slen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>origs</name> <init>= <expr><name>s</name></expr></init>, *<name>origp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>pmax</name> <init>= <expr><name>p</name> + <name>plen</name> - 1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>val</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>(<name>c</name> = *<name>s</name>++) != '\0'</expr>)</condition> <block>{
        <if>if <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <break>break;</break></then></if>
        <if>if <condition>(<expr><name>p</name> &gt;= <name>pmax</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>serv</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01526</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": string too long: %s"</expr></argument>, <argument><expr><name>origs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <if>if <condition>(<expr><name>c</name> == '\\'</expr>)</condition><then> <block>{
            <switch>switch <condition>(<expr><name>c</name> = *<name>s</name>++</expr>)</condition> <block>{

            <case>case <expr>'\0'</expr>:
                <goto>goto <name>out</name>;</goto>

            </case><default>default:
                <expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>c</name></expr>;</expr_stmt>
                <break>break;</break>

            </default><case>case <expr>'n'</expr>:
                <expr_stmt><expr>*<name>p</name>++ = '\n'</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'r'</expr>:
                <expr_stmt><expr>*<name>p</name>++ = '\r'</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'b'</expr>:
                <expr_stmt><expr>*<name>p</name>++ = '\b'</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'t'</expr>:
                <expr_stmt><expr>*<name>p</name>++ = '\t'</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'f'</expr>:
                <expr_stmt><expr>*<name>p</name>++ = '\f'</expr>;</expr_stmt>
                <break>break;</break>

            </case><case>case <expr>'v'</expr>:
                <expr_stmt><expr>*<name>p</name>++ = '\v'</expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/* \ and up to 3 octal digits */</comment>
            </case><case>case <expr>'0'</expr>:
            </case><case>case <expr>'1'</expr>:
            </case><case>case <expr>'2'</expr>:
            </case><case>case <expr>'3'</expr>:
            </case><case>case <expr>'4'</expr>:
            </case><case>case <expr>'5'</expr>:
            </case><case>case <expr>'6'</expr>:
            </case><case>case <expr>'7'</expr>:
                <expr_stmt><expr><name>val</name> = <name>c</name> - '0'</expr>;</expr_stmt>
                <expr_stmt><expr><name>c</name> = *<name>s</name>++</expr>;</expr_stmt>  <comment type="block">/* try for 2 */</comment>
                <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '7'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>val</name> = (<name>val</name> &lt;&lt; 3) | (<name>c</name> - '0')</expr>;</expr_stmt>
                    <expr_stmt><expr><name>c</name> = *<name>s</name>++</expr>;</expr_stmt>  <comment type="block">/* try for 3 */</comment>
                    <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '7'</expr>)</condition><then>
                        <expr_stmt><expr><name>val</name> = (<name>val</name> &lt;&lt; 3) | (<name>c</name> - '0')</expr>;</expr_stmt></then>
                    <else>else
                        <expr_stmt><expr>--<name>s</name></expr>;</expr_stmt></else></if>
                }</block></then>
                <else>else
                    <expr_stmt><expr>--<name>s</name></expr>;</expr_stmt></else></if>
                <expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>val</name></expr>;</expr_stmt>
                <break>break;</break>

                <comment type="block">/* \x and up to 3 hex digits */</comment>
            </case><case>case <expr>'x'</expr>:
                <expr_stmt><expr><name>val</name> = 'x'</expr>;</expr_stmt>            <comment type="block">/* Default if no digits */</comment>
                <expr_stmt><expr><name>c</name> = <call><name>hextoint</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* Get next char */</comment>
                <if>if <condition>(<expr><name>c</name> &gt;= 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>val</name> = <name>c</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>c</name> = <call><name>hextoint</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>c</name> &gt;= 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>val</name> = (<name>val</name> &lt;&lt; 4) + <name>c</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>c</name> = <call><name>hextoint</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>c</name> &gt;= 0</expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>val</name> = (<name>val</name> &lt;&lt; 4) + <name>c</name></expr>;</expr_stmt>
                        }</block></then>
                        <else>else
                            <expr_stmt><expr>--<name>s</name></expr>;</expr_stmt></else></if>
                    }</block></then>
                    <else>else
                        <expr_stmt><expr>--<name>s</name></expr>;</expr_stmt></else></if>
                }</block></then>
                <else>else
                    <expr_stmt><expr>--<name>s</name></expr>;</expr_stmt></else></if>
                <expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>val</name></expr>;</expr_stmt>
                <break>break;</break>
            </case>}</block></switch>
        }</block></then>
        <else>else
            <expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>c</name></expr>;</expr_stmt></else></if>
    }</block></while>
  <label><name>out</name>:</label>
    <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>slen</name> = <name>p</name> - <name>origp</name></expr>;</expr_stmt>
    <return>return <expr><name>s</name></expr>;</return>
}</block></function>


<comment type="block">/* Single hex char to int; -1 if not a hex char. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hextoint</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>c</name> - '0'</expr>;</return></then></if>
    <if>if <condition>(<expr>(<name>c</name> &gt;= 'a') &amp;&amp; (<name>c</name> &lt;= 'f')</expr>)</condition><then>
        <return>return <expr><name>c</name> + 10 - 'a'</expr>;</return></then></if>
    <if>if <condition>(<expr>(<name>c</name> &gt;= 'A') &amp;&amp; (<name>c</name> &lt;= 'F')</expr>)</condition><then>
        <return>return <expr><name>c</name> + 10 - 'A'</expr>;</return></then></if>
    <return>return <expr>-1</expr>;</return>
}</block></function>


<comment type="block">/*
 * return DONE to indicate it's been handled
 * return OK to indicate it's a regular file still needing handling
 * other returns indicate a failure of some sort
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fsmagic</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fn</name></decl></param>)</parameter_list>
<block>{
    <switch>switch <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>filetype</name></name></expr>)</condition> <block>{
    <case>case <expr><name>APR_DIR</name></expr>:
        <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>DIR_MAGIC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DONE</name></expr>;</return>
    </case><case>case <expr><name>APR_CHR</name></expr>:
        <comment type="block">/*
         * (void) magic_rsl_printf(r,"character special (%d/%d)",
         * major(sb-&gt;st_rdev), minor(sb-&gt;st_rdev));
         */</comment>
        <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>MIME_BINARY_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DONE</name></expr>;</return>
    </case><case>case <expr><name>APR_BLK</name></expr>:
        <comment type="block">/*
         * (void) magic_rsl_printf(r,"block special (%d/%d)",
         * major(sb-&gt;st_rdev), minor(sb-&gt;st_rdev));
         */</comment>
        <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>MIME_BINARY_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DONE</name></expr>;</return>
        <comment type="block">/* TODO add code to handle V7 MUX and Blit MUX files */</comment>
    </case><case>case <expr><name>APR_PIPE</name></expr>:
        <comment type="block">/*
         * magic_rsl_puts(r,"fifo (named pipe)");
         */</comment>
        <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>MIME_BINARY_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DONE</name></expr>;</return>
    </case><case>case <expr><name>APR_LNK</name></expr>:
        <comment type="block">/* We used stat(), the only possible reason for this is that the
         * symlink is broken.
         */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01527</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": broken symlink (%s)"</expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    </case><case>case <expr><name>APR_SOCK</name></expr>:
        <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>MIME_BINARY_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DONE</name></expr>;</return>
    </case><case>case <expr><name>APR_REG</name></expr>:
        <break>break;</break>
    </case><default>default:
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01528</argument>)</argument_list></macro>
                      <name>MODNAME</name> ": invalid file type %d."</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>filetype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    </default>}</block></switch>

    <comment type="block">/*
     * regular file, check next possibility
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>size</name></name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>MIME_TEXT_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DONE</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * softmagic - lookup one file in database (already read from /etc/magic by
 * apprentice.c). Passed the name and FILE * of one file to be typed.
 */</comment>
                <comment type="block">/* ARGSUSED1 */</comment><comment type="block">/* nbytes passed for regularity, maybe need later */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>softmagic</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>match</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>1</expr>;</return></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * Go through the whole list, stopping if you find a match.  Process all the
 * continuations of that match before returning.
 *
 * We support multi-level continuations:
 *
 * At any time when processing a successful top-level match, there is a current
 * continuation level; it represents the level of the last successfully
 * matched continuation.
 *
 * Continuations above that level are skipped as, if we see one, it means that
 * the continuation that controls them - i.e, the lower-level continuation
 * preceding them - failed to match.
 *
 * Continuations below that level are processed as, if we see one, it means
 * we've finished processing or skipping higher-level continuations under the
 * control of a successful or unsuccessful lower-level continuation, and are
 * now seeing the next lower-level continuation and should process it.  The
 * current continuation level reverts to the level of the one we're seeing.
 *
 * Continuations at the current level are processed as, if we see one, there's
 * no lower-level continuation that may have failed.
 *
 * If a continuation matches, we bump the current continuation level so that
 * higher-level continuations are processed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>match</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <decl_stmt><decl><type><name>int</name></type> <name>rule_counter</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>int</name></type> <name>cont_level</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>need_separator</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>union <name>VALUETYPE</name></type> <name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>conf</name> <init>= <expr>(<name>magic_server_config_rec</name> *)
                <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>magic</name> *</type><name>m</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01529</argument>)</argument_list></macro>
                <name>MODNAME</name> ": match conf=%x file=%s m=%s m-&gt;next=%s last=%s"</expr></argument>,
                <argument><expr><name>conf</name></expr></argument>,
                <argument><expr><name><name>conf</name>-&gt;<name>magicfile</name></name> ? <name><name>conf</name>-&gt;<name>magicfile</name></name> : "NULL"</expr></argument>,
                <argument><expr><name><name>conf</name>-&gt;<name>magic</name></name> ? "set" : "NULL"</expr></argument>,
                <argument><expr>(<name><name>conf</name>-&gt;<name>magic</name></name> &amp;&amp; <name><name>conf</name>-&gt;<name>magic</name>-&gt;<name>next</name></name>) ? "set" : "NULL"</expr></argument>,
                <argument><expr><name><name>conf</name>-&gt;<name>last</name></name> ? "set" : "NULL"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <for>for (<init><expr><name>m</name> = <name><name>conf</name>-&gt;<name>magic</name></name></expr>;</init> <condition><expr><name>m</name></expr>;</condition> <incr><expr><name>m</name> = <name><name>m</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <if>if <condition>(<expr><call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 24) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 16) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 8) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
            <call><name>apr_isprint</name><argument_list>(<argument><expr>((<name>unsigned</name> <name>long</name>) <name>m</name>) &amp; 255</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01530</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": match: POINTER CLOBBERED! "
                        "m=\"%c%c%c%c\""</expr></argument>,
                        <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 24) &amp; 255</expr></argument>,
                        <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 16) &amp; 255</expr></argument>,
                        <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 8) &amp; 255</expr></argument>,
                        <argument><expr>((<name>unsigned</name> <name>long</name>) <name>m</name>) &amp; 255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
    }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for (<init><expr><name>m</name> = <name><name>conf</name>-&gt;<name>magic</name></name></expr>;</init> <condition><expr><name>m</name></expr>;</condition> <incr><expr><name>m</name> = <name><name>m</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><name>rule_counter</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01531</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": line=%d desc=%s"</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* check if main entry matches */</comment>
        <if>if <condition>(<expr>!<call><name>mget</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> ||
            !<call><name>mcheck</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type>struct <name>magic</name> *</type><name>m_cont</name></decl>;</decl_stmt>

            <comment type="block">/*
             * main entry didn't match, flush its continuations
             */</comment>
            <if>if <condition>(<expr>!<name><name>m</name>-&gt;<name>next</name></name> || (<name><name>m</name>-&gt;<name>next</name>-&gt;<name>cont_level</name></name> == 0)</expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name>m_cont</name> = <name><name>m</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>m_cont</name> &amp;&amp; (<name><name>m_cont</name>-&gt;<name>cont_level</name></name> != 0)</expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
                <expr_stmt><expr><name>rule_counter</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01532</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": line=%d mc=%x mc-&gt;next=%x cont=%d desc=%s"</expr></argument>,
                            <argument><expr><name><name>m_cont</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name>m_cont</name></expr></argument>,
                            <argument><expr><name><name>m_cont</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name><name>m_cont</name>-&gt;<name>cont_level</name></name></expr></argument>,
                            <argument><expr><name><name>m_cont</name>-&gt;<name>desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <comment type="block">/*
                 * this trick allows us to keep *m in sync when the continue
                 * advances the pointer
                 */</comment>
                <expr_stmt><expr><name>m</name> = <name>m_cont</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>m_cont</name> = <name><name>m_cont</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            }</block></while>
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* if we get here, the main entry rule was a match */</comment>
        <comment type="block">/* this will be the last run through the loop */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01533</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": rule matched, line=%d type=%d %s"</expr></argument>,
                    <argument><expr><name><name>m</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>type</name></name></expr></argument>,
                    <argument><expr>(<name><name>m</name>-&gt;<name>type</name></name> == <name>STRING</name>) ? <name><name>m</name>-&gt;<name>value</name>.<name>s</name></name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <comment type="block">/* print the match */</comment>
        <expr_stmt><expr><call><name>mprint</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * If we printed something, we'll need to print a blank before we
         * print something else.
         */</comment>
        <if>if <condition>(<expr><name><name>m</name>-&gt;<name>desc</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
            <expr_stmt><expr><name>need_separator</name> = 1</expr>;</expr_stmt></then></if>
        <comment type="block">/* and any continuations that match */</comment>
        <expr_stmt><expr><name>cont_level</name>++</expr>;</expr_stmt>
        <comment type="block">/*
         * while (m &amp;&amp; m-&gt;next &amp;&amp; m-&gt;next-&gt;cont_level != 0 &amp;&amp; ( m = m-&gt;next
         * ))
         */</comment>
        <expr_stmt><expr><name>m</name> = <name><name>m</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>m</name> &amp;&amp; (<name><name>m</name>-&gt;<name>cont_level</name></name> != 0)</expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01534</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": match line=%d cont=%d type=%d %s"</expr></argument>,
                        <argument><expr><name><name>m</name>-&gt;<name>lineno</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>cont_level</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>type</name></name></expr></argument>,
                        <argument><expr>(<name><name>m</name>-&gt;<name>type</name></name> == <name>STRING</name>) ? <name><name>m</name>-&gt;<name>value</name>.<name>s</name></name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <if>if <condition>(<expr><name>cont_level</name> &gt;= <name><name>m</name>-&gt;<name>cont_level</name></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>cont_level</name> &gt; <name><name>m</name>-&gt;<name>cont_level</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * We're at the end of the level "cont_level"
                     * continuations.
                     */</comment>
                    <expr_stmt><expr><name>cont_level</name> = <name><name>m</name>-&gt;<name>cont_level</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <if>if <condition>(<expr><call><name>mget</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call> &amp;&amp;
                    <call><name>mcheck</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * This continuation matched. Print its message, with a
                     * blank before it if the previous item printed and this
                     * item isn't empty.
                     */</comment>
                    <comment type="block">/* space if previous printed */</comment>
                    <if>if <condition>(<expr><name>need_separator</name>
                        &amp;&amp; (<name><name>m</name>-&gt;<name>nospflag</name></name> == 0)
                        &amp;&amp; (<name><name>m</name>-&gt;<name>desc</name><index>[<expr>0</expr>]</index></name> != '\0')</expr>
                        )</condition><then> <block>{
                        <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_putchar</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>need_separator</name> = 0</expr>;</expr_stmt>
                    }</block></then></if>
                    <expr_stmt><expr><call><name>mprint</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>m</name>-&gt;<name>desc</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
                        <expr_stmt><expr><name>need_separator</name> = 1</expr>;</expr_stmt></then></if>

                    <comment type="block">/*
                     * If we see any continuations at a higher level, process
                     * them.
                     */</comment>
                    <expr_stmt><expr><name>cont_level</name>++</expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>

            <comment type="block">/* move to next continuation record */</comment>
            <expr_stmt><expr><name>m</name> = <name><name>m</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01535</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": matched after %d rules"</expr></argument>, <argument><expr><name>rule_counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <return>return <expr>1</expr>;</return>  <comment type="block">/* all through */</comment>
    }</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01536</argument>)</argument_list></macro>
                <name>MODNAME</name> ": failed after %d rules"</expr></argument>, <argument><expr><name>rule_counter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr>0</expr>;</return>  <comment type="block">/* no match at all */</comment>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mprint</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type>union <name>VALUETYPE</name> *</type><name>p</name></decl></param>, <param><decl><type>struct <name>magic</name> *</type><name>m</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>pp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>time_str</name><index>[<expr><name>APR_CTIME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>m</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
    <case>case <expr><name>BYTE</name></expr>:
        <expr_stmt><expr><name>v</name> = <name><name>p</name>-&gt;<name>b</name></name></expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr><name>SHORT</name></expr>:
    </case><case>case <expr><name>BESHORT</name></expr>:
    </case><case>case <expr><name>LESHORT</name></expr>:
        <expr_stmt><expr><name>v</name> = <name><name>p</name>-&gt;<name>h</name></name></expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr><name>LONG</name></expr>:
    </case><case>case <expr><name>BELONG</name></expr>:
    </case><case>case <expr><name>LELONG</name></expr>:
        <expr_stmt><expr><name>v</name> = <name><name>p</name>-&gt;<name>l</name></name></expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr><name>STRING</name></expr>:
        <if>if <condition>(<expr><name><name>m</name>-&gt;<name>reln</name></name> == '='</expr>)</condition><then> <block>{
            <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_printf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>desc</name></name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>value</name>.<name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_printf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>desc</name></name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <return>return;</return>

    </case><case>case <expr><name>DATE</name></expr>:
    </case><case>case <expr><name>BEDATE</name></expr>:
    </case><case>case <expr><name>LEDATE</name></expr>:
        <expr_stmt><expr><call><name>apr_ctime</name><argument_list>(<argument><expr><name>time_str</name></expr></argument>, <argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr>*(<name>time_t</name> *)&amp;<name><name>p</name>-&gt;<name>l</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>pp</name> = <name>time_str</name></expr>;</expr_stmt>
        <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_printf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>desc</name></name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </case><default>default:
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01537</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": invalid m-&gt;type (%d) in mprint()."</expr></argument>,
                    <argument><expr><name><name>m</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    </default>}</block></switch>

    <expr_stmt><expr><name>v</name> = <call><name>signextend</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp; <name><name>m</name>-&gt;<name>mask</name></name></expr>;</expr_stmt>
    <expr_stmt><expr>(<name>void</name>) <call><name>magic_rsl_printf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>desc</name></name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>) <name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Convert the byte order of the data we are looking at
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>mconvert</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type>union <name>VALUETYPE</name> *</type><name>p</name></decl></param>, <param><decl><type>struct <name>magic</name> *</type><name>m</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>rt</name></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name><name>m</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
    <case>case <expr><name>BYTE</name></expr>:
    </case><case>case <expr><name>SHORT</name></expr>:
    </case><case>case <expr><name>LONG</name></expr>:
    </case><case>case <expr><name>DATE</name></expr>:
        <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>STRING</name></expr>:
        <comment type="block">/* Null terminate and eat the return */</comment>
        <expr_stmt><expr><name><name>p</name>-&gt;<name>s</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>p</name>-&gt;<name>s</name></name></expr></argument>)</argument_list></sizeof> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>rt</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>s</name></name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>rt</name> = '\0'</expr>;</expr_stmt></then></if>
        <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>BESHORT</name></expr>:
        <expr_stmt><expr><name><name>p</name>-&gt;<name>h</name></name> = <call>(<name>short</name>) <argument_list>(<argument><expr>(<name><name>p</name>-&gt;<name>hs</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 8) | (<name><name>p</name>-&gt;<name>hs</name><index>[<expr>1</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>BELONG</name></expr>:
    </case><case>case <expr><name>BEDATE</name></expr>:
        <expr_stmt><expr><name><name>p</name>-&gt;<name>l</name></name> = <call>(<name>long</name>)
            <argument_list>(<argument><expr>(<name><name>p</name>-&gt;<name>hl</name><index>[<expr>0</expr>]</index></name> &lt;&lt; 24) | (<name><name>p</name>-&gt;<name>hl</name><index>[<expr>1</expr>]</index></name> &lt;&lt; 16) | (<name><name>p</name>-&gt;<name>hl</name><index>[<expr>2</expr>]</index></name> &lt;&lt; 8) | (<name><name>p</name>-&gt;<name>hl</name><index>[<expr>3</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>LESHORT</name></expr>:
        <expr_stmt><expr><name><name>p</name>-&gt;<name>h</name></name> = <call>(<name>short</name>) <argument_list>(<argument><expr>(<name><name>p</name>-&gt;<name>hs</name><index>[<expr>1</expr>]</index></name> &lt;&lt; 8) | (<name><name>p</name>-&gt;<name>hs</name><index>[<expr>0</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    </case><case>case <expr><name>LELONG</name></expr>:
    </case><case>case <expr><name>LEDATE</name></expr>:
        <expr_stmt><expr><name><name>p</name>-&gt;<name>l</name></name> = <call>(<name>long</name>)
            <argument_list>(<argument><expr>(<name><name>p</name>-&gt;<name>hl</name><index>[<expr>3</expr>]</index></name> &lt;&lt; 24) | (<name><name>p</name>-&gt;<name>hl</name><index>[<expr>2</expr>]</index></name> &lt;&lt; 16) | (<name><name>p</name>-&gt;<name>hl</name><index>[<expr>1</expr>]</index></name> &lt;&lt; 8) | (<name><name>p</name>-&gt;<name>hl</name><index>[<expr>0</expr>]</index></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    </case><default>default:
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01538</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": invalid type %d in mconvert()."</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    </default>}</block></switch>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type> <name>mget</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type>union <name>VALUETYPE</name> *</type><name>p</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>s</name></decl></param>,
                <param><decl><type>struct <name>magic</name> *</type><name>m</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>long</name></type> <name>offset</name> <init>= <expr><name><name>m</name>-&gt;<name>offset</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>offset</name> + <sizeof>sizeof<argument_list>(<argument><expr>union <name>VALUETYPE</name></expr></argument>)</argument_list></sizeof> &gt; <name>nbytes</name></expr>)</condition><then>
                  <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name> + <name>offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>union <name>VALUETYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>mconvert</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>m</name>-&gt;<name>flag</name></name> &amp; <name>INDIR</name></expr>)</condition><then> <block>{

        <switch>switch <condition>(<expr><name><name>m</name>-&gt;<name>in</name>.<name>type</name></name></expr>)</condition> <block>{
        <case>case <expr><name>BYTE</name></expr>:
            <expr_stmt><expr><name>offset</name> = <name><name>p</name>-&gt;<name>b</name></name> + <name><name>m</name>-&gt;<name>in</name>.<name>offset</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>SHORT</name></expr>:
            <expr_stmt><expr><name>offset</name> = <name><name>p</name>-&gt;<name>h</name></name> + <name><name>m</name>-&gt;<name>in</name>.<name>offset</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </case><case>case <expr><name>LONG</name></expr>:
            <expr_stmt><expr><name>offset</name> = <name><name>p</name>-&gt;<name>l</name></name> + <name><name>m</name>-&gt;<name>in</name>.<name>offset</name></name></expr>;</expr_stmt>
            <break>break;</break>
        </case>}</block></switch>

        <if>if <condition>(<expr><name>offset</name> + <sizeof>sizeof<argument_list>(<argument><expr>union <name>VALUETYPE</name></expr></argument>)</argument_list></sizeof> &gt; <name>nbytes</name></expr>)</condition><then>
                      <return>return <expr>0</expr>;</return></then></if>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name> + <name>offset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>union <name>VALUETYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name>mconvert</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr>0</expr>;</return></then></if>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mcheck</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type>union <name>VALUETYPE</name> *</type><name>p</name></decl></param>, <param><decl><type>struct <name>magic</name> *</type><name>m</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>long</name></type> <name>l</name> <init>= <expr><name><name>m</name>-&gt;<name>value</name>.<name>l</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>long</name></type> <name>v</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>matched</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name><name>m</name>-&gt;<name>value</name>.<name>s</name><index>[<expr>0</expr>]</index></name> == 'x') &amp;&amp; (<name><name>m</name>-&gt;<name>value</name>.<name>s</name><index>[<expr>1</expr>]</index></name> == '\0')</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01539</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": BOINK"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <switch>switch <condition>(<expr><name><name>m</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
    <case>case <expr><name>BYTE</name></expr>:
        <expr_stmt><expr><name>v</name> = <name><name>p</name>-&gt;<name>b</name></name></expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr><name>SHORT</name></expr>:
    </case><case>case <expr><name>BESHORT</name></expr>:
    </case><case>case <expr><name>LESHORT</name></expr>:
        <expr_stmt><expr><name>v</name> = <name><name>p</name>-&gt;<name>h</name></name></expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr><name>LONG</name></expr>:
    </case><case>case <expr><name>BELONG</name></expr>:
    </case><case>case <expr><name>LELONG</name></expr>:
    </case><case>case <expr><name>DATE</name></expr>:
    </case><case>case <expr><name>BEDATE</name></expr>:
    </case><case>case <expr><name>LEDATE</name></expr>:
        <expr_stmt><expr><name>v</name> = <name><name>p</name>-&gt;<name>l</name></name></expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr><name>STRING</name></expr>:
        <expr_stmt><expr><name>l</name> = 0</expr>;</expr_stmt>
        <comment type="block">/*
         * What we want here is: v = strncmp(m-&gt;value.s, p-&gt;s, m-&gt;vallen);
         * but ignoring any nulls.  bcmp doesn't give -/+/0 and isn't
         * universally available anyway.
         */</comment>
        <expr_stmt><expr><name>v</name> = 0</expr>;</expr_stmt>
        <block>{
            <decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>char</name> *</type><name>a</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *) <name><name>m</name>-&gt;<name>value</name>.<name>s</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>char</name> *</type><name>b</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *) <name><name>p</name>-&gt;<name>s</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>len</name> <init>= <expr><name><name>m</name>-&gt;<name>vallen</name></name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr>--<name>len</name> &gt;= 0</expr>)</condition>
                <if>if <condition>(<expr>(<name>v</name> = *<name>b</name>++ - *<name>a</name>++) != 0</expr>)</condition><then>
                    <break>break;</break></then></if></while>
        }</block>
        <break>break;</break>
    </case><default>default:
        <comment type="block">/*  bogosity, pretend that it just wasn't a match */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01540</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": invalid type %d in mcheck()."</expr></argument>, <argument><expr><name><name>m</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    </default>}</block></switch>

    <expr_stmt><expr><name>v</name> = <call><name>signextend</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp; <name><name>m</name>-&gt;<name>mask</name></name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>m</name>-&gt;<name>reln</name></name></expr>)</condition> <block>{
    <case>case <expr>'x'</expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01541</expr></argument>)</argument_list></call>
                    "%lu == *any* = 1"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>matched</name> = 1</expr>;</expr_stmt>
        <break>break;</break>

    </case><case>case <expr>'!'</expr>:
        <expr_stmt><expr><name>matched</name> = <name>v</name> != <name>l</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01542</expr></argument>)</argument_list></call>
                    "%lu != %lu = %d"</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

    </case><case>case <expr>'='</expr>:
        <expr_stmt><expr><name>matched</name> = <name>v</name> == <name>l</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01543</expr></argument>)</argument_list></call>
                    "%lu == %lu = %d"</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

    </case><case>case <expr>'&gt;'</expr>:
        <if>if <condition>(<expr><name><name>m</name>-&gt;<name>flag</name></name> &amp; <name>UNSIGNED</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>matched</name> = <name>v</name> &gt; <name>l</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01544</expr></argument>)</argument_list></call>
                        "%lu &gt; %lu = %d"</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>matched</name> = (<name>long</name>) <name>v</name> &gt; (<name>long</name>) <name>l</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01545</expr></argument>)</argument_list></call>
                        "%ld &gt; %ld = %d"</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr>'&lt;'</expr>:
        <if>if <condition>(<expr><name><name>m</name>-&gt;<name>flag</name></name> &amp; <name>UNSIGNED</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>matched</name> = <name>v</name> &lt; <name>l</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01546</expr></argument>)</argument_list></call>
                        "%lu &lt; %lu = %d"</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>matched</name> = (<name>long</name>) <name>v</name> &lt; (<name>long</name>) <name>l</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01547</expr></argument>)</argument_list></call>
                        "%ld &lt; %ld = %d"</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr>'&amp;'</expr>:
        <expr_stmt><expr><name>matched</name> = (<name>v</name> &amp; <name>l</name>) == <name>l</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01548</expr></argument>)</argument_list></call>
                    "((%lx &amp; %lx) == %lx) = %d"</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

    </case><case>case <expr>'^'</expr>:
        <expr_stmt><expr><name>matched</name> = (<name>v</name> &amp; <name>l</name>) != <name>l</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01549</expr></argument>)</argument_list></call>
                    "((%lx &amp; %lx) != %lx) = %d"</expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

    </case><default>default:
        <comment type="block">/* bogosity, pretend it didn't match */</comment>
        <expr_stmt><expr><name>matched</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01550</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": mcheck: can't happen: invalid relation %d."</expr></argument>,
                    <argument><expr><name><name>m</name>-&gt;<name>reln</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>

    <return>return <expr><name>matched</name></expr>;</return>
}</block></function>

<comment type="block">/* an optimization over plain strcmp() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>    <cpp:macro><name>STREQ</name><parameter_list>(<param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>(*(a) == *(b) &amp;&amp; strcmp((a), (b)) == 0)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ascmagic</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>has_escapes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>nbuf</name><index>[<expr><name>SMALL_HOWMANY</name> + 1</expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* one extra for terminating '\0' */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> struct <name>names</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>small_nbytes</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>strtok_state</name></decl>;</decl_stmt>

    <comment type="block">/* these are easy, do them first */</comment>

    <comment type="block">/*
     * for troff, look for . + letter + letter or .\"; this must be done to
     * disambiguate tar archives' ./file and other trash from real troff
     * input.
     */</comment>
    <if>if <condition>(<expr>*<name>buf</name> == '.'</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>tp</name> <init>= <expr><name>buf</name> + 1</expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
            <expr_stmt><expr>++<name>tp</name></expr>;</expr_stmt></while>  <comment type="block">/* skip leading whitespace */</comment>
        <if>if <condition>(<expr>(<call><name>apr_isalnum</name><argument_list>(<argument><expr>*<name>tp</name></expr></argument>)</argument_list></call> || *<name>tp</name> == '\\') &amp;&amp;
             (<call><name>apr_isalnum</name><argument_list>(<argument><expr>*(<name>tp</name> + 1)</expr></argument>)</argument_list></call> || *<name>tp</name> == '"')</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"application/x-troff"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr>(*<name>buf</name> == 'c' || *<name>buf</name> == 'C') &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*(<name>buf</name> + 1)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Fortran */</comment>
        <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"text/plain"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* look for tokens from names.h - this is expensive!, so we'll limit
     * ourselves to only SMALL_HOWMANY bytes */</comment>
    <expr_stmt><expr><name>small_nbytes</name> = (<name>nbytes</name> &gt; <name>SMALL_HOWMANY</name>) ? <name>SMALL_HOWMANY</name> : <name>nbytes</name></expr>;</expr_stmt>
    <comment type="block">/* make a copy of the buffer here because apr_strtok() will destroy it */</comment>
    <expr_stmt><expr><name>s</name> = (<name>unsigned</name> <name>char</name> *) <call><name>memcpy</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>small_nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>s</name><index>[<expr><name>small_nbytes</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
    <expr_stmt><expr><name>has_escapes</name> = (<call><name>memchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>'\033'</expr></argument>, <argument><expr><name>small_nbytes</name></expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>;</expr_stmt>
    <while>while <condition>(<expr>(<name>token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr>(<name>char</name> *) <name>s</name></expr></argument>, <argument><expr>" \t\n\r\f"</expr></argument>, <argument><expr>&amp;<name>strtok_state</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>s</name> = <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* make apr_strtok() keep on tokin' */</comment>
        <for>for (<init><expr><name>p</name> = <name>names</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>names</name> + <name>NNAMES</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>STREQ</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><name><name>p</name>-&gt;<name>type</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>has_escapes</name></expr>)</condition><then>
                    <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>" (with escape sequences)"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <return>return <expr>1</expr>;</return>
            }</block></then></if>
        }</block></for>
    }</block></while>

    <switch>switch <condition>(<expr><call><name>is_tar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
    <case>case <expr>1</expr>:
        <comment type="block">/* V7 tar archive */</comment>
        <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"application/x-tar"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    </case><case>case <expr>2</expr>:
        <comment type="block">/* POSIX tar archive */</comment>
        <expr_stmt><expr><call><name>magic_rsl_puts</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"application/x-tar"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    </case>}</block></switch>

    <comment type="block">/* all else fails, but it is ascii... */</comment>
    <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
 * compress routines: zmagic() - returns 0 if not recognized, uncompresses
 * and prints information if recognized uncompress(s, method, old, n, newch)
 * - uncompress old into new, using method, return sizeof new
 */</comment>

<struct><specifier>static</specifier> struct <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>magic</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>maglen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name><name>argv</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>silent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>encoding</name></decl>;</decl_stmt>  <comment type="block">/* MUST be lowercase */</comment>
}</block> <decl><name><name>compr</name><index>[]</index></name> <init>= <expr><block>{

    <comment type="block">/* we use gzip here rather than uncompress because we have to pass
     * it a full filename -- and uncompress only considers filenames
     * ending with .Z
     */</comment>
    <expr><block>{
        <expr>"\037\235"</expr>, <expr>2</expr>, <expr><block>{
            <expr>"gzip"</expr>, <expr>"-dcq"</expr>, <expr><name>NULL</name></expr>
        }</block></expr>, <expr>0</expr>, <expr>"x-compress"</expr>
    }</block></expr>,
    <expr><block>{
        <expr>"\037\213"</expr>, <expr>2</expr>, <expr><block>{
            <expr>"gzip"</expr>, <expr>"-dcq"</expr>, <expr><name>NULL</name></expr>
        }</block></expr>, <expr>1</expr>, <expr>"x-gzip"</expr>
    }</block></expr>,
    <comment type="block">/*
     * XXX pcat does not work, cause I don't know how to make it read stdin,
     * so we use gzip
     */</comment>
    <expr><block>{
        <expr>"\037\036"</expr>, <expr>2</expr>, <expr><block>{
            <expr>"gzip"</expr>, <expr>"-dcq"</expr>, <expr><name>NULL</name></expr>
        }</block></expr>, <expr>0</expr>, <expr>"x-gzip"</expr>
    }</block></expr>,
}</block></expr></init></decl>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ncompr</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>compr</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>compr</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>zmagic</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>newbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>newsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ncompr</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if <condition>(<expr><name>nbytes</name> &lt; <name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name>.<name>maglen</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        <if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name>.<name>magic</name></expr></argument>, <argument><expr><name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name>.<name>maglen</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <break>break;</break></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>i</name> == <name>ncompr</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <if>if <condition>(<expr>(<name>newsize</name> = <call><name>uncompress</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>&amp;<name>newbuf</name></expr></argument>, <argument><expr><name>HOWMANY</name></expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition><then> <block>{
        <comment type="block">/* set encoding type in the request record */</comment>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>content_encoding</name></name> = <name><name>compr</name><index>[<expr><name>i</name></expr>]</index></name>.<name>encoding</name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>newbuf</name><index>[<expr><name>newsize</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>  <comment type="block">/* null-terminate uncompressed data */</comment>
        <comment type="block">/* Try to detect the content type of the uncompressed data */</comment>
        <if>if <condition>(<expr><call><name>tryit</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != <name>OK</name></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>


<struct>struct <name>uncompress_parms</name> <block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>method</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>create_uncompress_child</name><parameter_list>(<param><decl><type>struct <name>uncompress_parms</name> *</type><name>parm</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>cntxt</name></decl></param>,
                                   <param><decl><type><name>apr_file_t</name> **</type><name>pipe_in</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>new_argv</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>parm</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>child_context</name> <init>= <expr><name>cntxt</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_procattr_t</name> *</type><name>procattr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_proc_t</name> *</type><name>procnew</name></decl>;</decl_stmt>

    <comment type="block">/* XXX missing 1.3 logic:
     *
     * what happens when !compr[parm-&gt;method].silent?
     * Should we create the err pipe, read it, and copy to the log?
     */</comment>

    <if>if <condition>(<expr>(<call><name>apr_procattr_create</name><argument_list>(<argument><expr>&amp;<name>procattr</name></expr></argument>, <argument><expr><name>child_context</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name>) ||
        (<call><name>apr_procattr_io_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>,
                           <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>, <argument><expr><name>APR_NO_PIPE</name></expr></argument>)</argument_list></call>   != <name>APR_SUCCESS</name>) ||
        (<call><name>apr_procattr_dir_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>,
                              <argument><expr><call><name>ap_make_dirstr_parent</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name>) ||
        (<call><name>apr_procattr_cmdtype_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>APR_PROGRAM_PATH</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name>)</expr>)</condition><then> <block>{
        <comment type="block">/* Something bad happened, tell the world. */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>APR_ENOPROC</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01551</expr></argument>)</argument_list></call>
               "couldn't setup child process: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr>0</expr>]</index></name> = <name><name>compr</name><index>[<expr><name><name>parm</name>-&gt;<name>method</name></name></expr>]</index></name>.<name><name>argv</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr>1</expr>]</index></name> = <name><name>compr</name><index>[<expr><name><name>parm</name>-&gt;<name>method</name></name></expr>]</index></name>.<name><name>argv</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr>2</expr>]</index></name> = <name><name>r</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_argv</name><index>[<expr>3</expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>procnew</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>child_context</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>procnew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>apr_proc_create</name><argument_list>(<argument><expr><name>procnew</name></expr></argument>, <argument><expr><name><name>compr</name><index>[<expr><name><name>parm</name>-&gt;<name>method</name></name></expr>]</index></name>.<name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>,
                               <argument><expr><name>new_argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>child_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="block">/* Bad things happened. Everyone should have cleaned up. */</comment>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>APR_ENOPROC</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01552</argument>)</argument_list></macro>
                          <name>MODNAME</name> ": could not execute `%s'."</expr></argument>,
                          <argument><expr><name><name>compr</name><index>[<expr><name><name>parm</name>-&gt;<name>method</name></name></expr>]</index></name>.<name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>apr_pool_note_subprocess</name><argument_list>(<argument><expr><name>child_context</name></expr></argument>, <argument><expr><name>procnew</name></expr></argument>, <argument><expr><name>APR_KILL_AFTER_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>pipe_in</name> = <name><name>procnew</name>-&gt;<name>out</name></name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>

    <return>return <expr>(<name>rc</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>uncompress</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name></type> <name>method</name></decl></param>,
                      <param><decl><type><name>unsigned</name> <name>char</name> **</type><name>newch</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>uncompress_parms</name></type> <name>parm</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>pipe_out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>sub_context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>parm</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>parm</name>.<name>method</name></name> = <name>method</name></expr>;</expr_stmt>

    <comment type="block">/* We make a sub_pool so that we can collect our child early, otherwise
     * there are cases (i.e. generating directory indicies with mod_autoindex)
     * where we would end up with LOTS of zombies.
     */</comment>
    <if>if <condition>(<expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>sub_context</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <if>if <condition>(<expr>(<name>rv</name> = <call><name>create_uncompress_child</name><argument_list>(<argument><expr>&amp;<name>parm</name></expr></argument>, <argument><expr><name>sub_context</name></expr></argument>, <argument><expr>&amp;<name>pipe_out</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01553</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": couldn't spawn uncompress process: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>newch</name> = (<name>unsigned</name> <name>char</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>apr_file_read</name><argument_list>(<argument><expr><name>pipe_out</name></expr></argument>, <argument><expr>*<name>newch</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>sub_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01554</argument>)</argument_list></macro>
            <name>MODNAME</name> ": read failed from uncompress of %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_pool_destroy</name><argument_list>(<argument><expr><name>sub_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>n</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * is_tar() -- figure out whether file is a tar archive.
 *
 * Stolen (by author of file utility) from the public domain tar program: Public
 * Domain version written 26 Aug 1985 John Gilmore (ihnp4!hoptoad!gnu).
 *
 * @(#)list.c 1.18 9/23/86 Public Domain - gnu $Id: mod_mime_magic.c,v 1.7
 * 1997/06/24 00:41:02 ikluft Exp ikluft $
 *
 * Comments changed and some code/comments reformatted for file command by Ian
 * Darwin.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isodigit</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((unsigned char)(c) &gt;= '0') &amp;&amp; ((unsigned char)(c) &lt;= '7'))</cpp:value></cpp:define>

<comment type="block">/*
 * Return 0 if the checksum is bad (i.e., probably not a tar archive), 1 for
 * old UNIX tar file, 2 for Unix Std (POSIX) tar file.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_tar</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>
<block>{
    <macro><name>register</name></macro> <decl_stmt><decl><type>union <name>record</name> *</type><name>header</name> <init>= <expr>(union <name>record</name> *) <name>buf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>sum</name></decl>, <decl><type ref="prev"/><name>recsum</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>nbytes</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr>union <name>record</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
               <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><name>recsum</name> = <call><name>from_oct</name><argument_list>(<argument><expr>8</expr></argument>, <argument><expr><name><name>header</name>-&gt;<name>header</name>.<name>chksum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sum</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> = <name><name>header</name>-&gt;<name>charptr</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = <sizeof>sizeof<argument_list>(<argument><expr>union <name>record</name></expr></argument>)</argument_list></sizeof></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>) <block>{
        <comment type="block">/*
         * We can't use unsigned char here because of old compilers, e.g. V7.
         */</comment>
        <expr_stmt><expr><name>sum</name> += 0xFF &amp; *<name>p</name>++</expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* Adjust checksum to count the "chksum" field as blanks. */</comment>
    <for>for (<init><expr><name>i</name> = <sizeof>sizeof<argument_list>(<argument><expr><name><name>header</name>-&gt;<name>header</name>.<name>chksum</name></name></expr></argument>)</argument_list></sizeof></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition><incr/>)
        <expr_stmt><expr><name>sum</name> -= 0xFF &amp; <name><name>header</name>-&gt;<name>header</name>.<name>chksum</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
    <expr_stmt><expr><name>sum</name> += ' ' * sizeof <name><name>header</name>-&gt;<name>header</name>.<name>chksum</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>sum</name> != <name>recsum</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>   <comment type="block">/* Not a tar archive */</comment>

    <if>if <condition>(<expr>0 == <call><name>strcmp</name><argument_list>(<argument><expr><name><name>header</name>-&gt;<name>header</name>.<name>magic</name></name></expr></argument>, <argument><expr><name>TMAGIC</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>2</expr>;</return></then></if>   <comment type="block">/* Unix Standard tar archive */</comment>

    <return>return <expr>1</expr>;</return>       <comment type="block">/* Old fashioned tar archive */</comment>
}</block></function>


<comment type="block">/*
 * Quick and dirty octal conversion.
 *
 * Result is -1 if the field is invalid (all blank, or nonoctal).
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type> <name>from_oct</name><parameter_list>(<param><decl><type><name>int</name></type> <name>digs</name></decl></param>, <param><decl><type><name>char</name> *</type><name>where</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>value</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>where</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{  <comment type="block">/* Skip spaces */</comment>
        <expr_stmt><expr><name>where</name>++</expr>;</expr_stmt>
        <if>if <condition>(<expr>--<name>digs</name> &lt;= 0</expr>)</condition><then>
            <return>return <expr>-1</expr>;</return></then></if>  <comment type="block">/* All blank field */</comment>
    }</block></while>
    <expr_stmt><expr><name>value</name> = 0</expr>;</expr_stmt>
    <while>while <condition>(<expr><name>digs</name> &gt; 0 &amp;&amp; <call><name>isodigit</name><argument_list>(<argument><expr>*<name>where</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{  <comment type="block">/* Scan til nonoctal */</comment>
        <expr_stmt><expr><name>value</name> = (<name>value</name> &lt;&lt; 3) | (*<name>where</name>++ - '0')</expr>;</expr_stmt>
        <expr_stmt><expr>--<name>digs</name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name>digs</name> &gt; 0 &amp;&amp; *<name>where</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>where</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>  <comment type="block">/* Ended on non-space/nul */</comment>

    <return>return <expr><name>value</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Check for file-revision suffix
 *
 * This is for an obscure document control system used on an intranet.
 * The web representation of each file's revision has an @1, @2, etc
 * appended with the revision number.  This needs to be stripped off to
 * find the file suffix, which can be recognized by sending the name back
 * through a sub-request.  The base file name (without the @num suffix)
 * must exist because its type will be used as the result.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>revision_suffix</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>suffix_pos</name></decl>, <decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>sub_filename</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>sub</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01555</argument>)</argument_list></macro>
                <name>MODNAME</name> ": revision_suffix checking %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MIME_MAGIC_DEBUG */</comment>

    <comment type="block">/* check for recognized revision suffix */</comment>
    <expr_stmt><expr><name>suffix_pos</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name><index>[<expr><name>suffix_pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <while>while <condition>(<expr><name>suffix_pos</name> &gt;= 0 &amp;&amp; <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name><index>[<expr><name>suffix_pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr><name>suffix_pos</name>--</expr>;</expr_stmt></while>
    <if>if <condition>(<expr><name>suffix_pos</name> &lt; 0 || <name><name>r</name>-&gt;<name>filename</name><index>[<expr><name>suffix_pos</name></expr>]</index></name> != '@'</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <comment type="block">/* perform sub-request for the file name without the suffix */</comment>
    <expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>sub_filename</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>suffix_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01556</argument>)</argument_list></macro>
                <name>MODNAME</name> ": subrequest lookup for %s"</expr></argument>, <argument><expr><name>sub_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MIME_MAGIC_DEBUG */</comment>
    <expr_stmt><expr><name>sub</name> = <call><name>ap_sub_req_lookup_file</name><argument_list>(<argument><expr><name>sub_filename</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* extract content type/encoding/language from sub-request */</comment>
    <if>if <condition>(<expr><name><name>sub</name>-&gt;<name>content_type</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>sub</name>-&gt;<name>content_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01557</argument>)</argument_list></macro>
                    <name>MODNAME</name> ": subrequest %s got %s"</expr></argument>,
                    <argument><expr><name>sub_filename</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>content_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MIME_MAGIC_DEBUG */</comment>
        <if>if <condition>(<expr><name><name>sub</name>-&gt;<name>content_encoding</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>content_encoding</name></name> =
                <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>sub</name>-&gt;<name>content_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name><name>sub</name>-&gt;<name>content_languages</name></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>content_languages</name></name> = <call><name>apr_array_copy</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                  <argument><expr><name><name>sub</name>-&gt;<name>content_languages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name>n</name> &lt; <name><name>r</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>n</name></expr></incr>) <block>{
                <decl_stmt><decl><type><name>char</name> **</type><name>lang</name> <init>= <expr>((<name>char</name> **)<name><name>r</name>-&gt;<name>content_languages</name>-&gt;<name>elts</name></name>) + <name>n</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr>*<name>lang</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>*<name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
        <expr_stmt><expr><name>result</name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* clean up */</comment>
    <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * initialize the module
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>magic_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>main_server</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>main_conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
    <decl_stmt><decl><type>struct <name>magic</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>prevm</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* MIME_MAGIC_DEBUG */</comment>

    <expr_stmt><expr><name>main_conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>main_server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>s</name> = <name>main_server</name></expr>;</init> <condition><expr><name>s</name></expr>;</condition> <incr><expr><name>s</name> = <name><name>s</name>-&gt;<name>next</name></name></expr></incr>) <block>{
        <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>magicfile</name></name> == <name>NULL</name> &amp;&amp; <name>s</name> != <name>main_server</name></expr>)</condition><then> <block>{
            <comment type="block">/* inherits from the parent */</comment>
            <expr_stmt><expr>*<name>conf</name> = *<name>main_conf</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>magicfile</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <call><name>apprentice</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>result</name> == -1</expr>)</condition><then>
                <return>return <expr><name>OK</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MIME_MAGIC_DEBUG</name></expr></cpp:if>
            <expr_stmt><expr><name>prevm</name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01558</argument>)</argument_list></macro>
                        <name>MODNAME</name> ": magic_init 1 test"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <for>for (<init><expr><name>m</name> = <name><name>conf</name>-&gt;<name>magic</name></name></expr>;</init> <condition><expr><name>m</name></expr>;</condition> <incr><expr><name>m</name> = <name><name>m</name>-&gt;<name>next</name></name></expr></incr>) <block>{
                <if>if <condition>(<expr><call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 24) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
                    <call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 16) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
                    <call><name>apr_isprint</name><argument_list>(<argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 8) &amp; 255</expr></argument>)</argument_list></call> &amp;&amp;
                    <call><name>apr_isprint</name><argument_list>(<argument><expr>((<name>unsigned</name> <name>long</name>) <name>m</name>) &amp; 255</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>01559</argument>)</argument_list></macro>
                                <name>MODNAME</name> ": magic_init 1: POINTER CLOBBERED! "
                                "m=\"%c%c%c%c\" line=%d"</expr></argument>,
                                <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 24) &amp; 255</expr></argument>,
                                <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 16) &amp; 255</expr></argument>,
                                <argument><expr>(((<name>unsigned</name> <name>long</name>) <name>m</name>) &gt;&gt; 8) &amp; 255</expr></argument>,
                                <argument><expr>((<name>unsigned</name> <name>long</name>) <name>m</name>) &amp; 255</expr></argument>,
                                <argument><expr><name>prevm</name> ? <name><name>prevm</name>-&gt;<name>lineno</name></name> : -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name>prevm</name> = <name>m</name></expr>;</expr_stmt>
            }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then></if></else></if>
    }</block></for>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Find the Content-Type from any resource this module has available
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>magic_find_ct</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>magic_server_config_rec</name> *</type><name>conf</name></decl>;</decl_stmt>

    <comment type="block">/* the file has to exist */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>filetype</name></name> == <name>APR_NOFILE</name> || !<name><name>r</name>-&gt;<name>filename</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* was someone else already here? */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>content_type</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>mime_magic_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>conf</name> || !<name><name>conf</name>-&gt;<name>magic</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* initialize per-request info */</comment>
    <if>if <condition>(<expr>!<call><name>magic_set_config</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* try excluding file-revision suffixes */</comment>
    <if>if <condition>(<expr><call><name>revision_suffix</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
        <comment type="block">/* process it based on the file contents */</comment>
        <if>if <condition>(<expr>(<name>result</name> = <call><name>magic_process</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>) != <name>OK</name></expr>)</condition><then> <block>{
            <return>return <expr><name>result</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* if we have any results, put them in the request structure */</comment>
    <return>return <expr><call><name>magic_rsl_to_request</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>aszPre</name><index>[]</index></name><init>=<expr><block>{ <expr>"mod_mime.c"</expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* mod_mime_magic should be run after mod_mime, if at all. */</comment>

    <expr_stmt><expr><call><name>ap_hook_type_checker</name><argument_list>(<argument><expr><name>magic_find_ct</name></expr></argument>, <argument><expr><name>aszPre</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_post_config</name><argument_list>(<argument><expr><name>magic_init</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * Apache API module interface
 */</comment>

<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>mime_magic</name></expr></argument>)</argument_list></call> =
<block>{
    <expr><name>STANDARD20_MODULE_STUFF</name></expr>,
    <expr><name>NULL</name></expr>,                      <comment type="block">/* dir config creator */</comment>
    <expr><name>NULL</name></expr>,                      <comment type="block">/* dir merger --- default is to override */</comment>
    <expr><name>create_magic_server_config</name></expr>,        <comment type="block">/* server config */</comment>
    <expr><name>merge_magic_server_config</name></expr>, <comment type="block">/* merge server config */</comment>
    <expr><name>mime_magic_cmds</name></expr>,           <comment type="block">/* command apr_table_t */</comment>
    <expr><name>register_hooks</name></expr>              <comment type="block">/* register hooks */</comment>
}</block></expr>;</expr_stmt>
</unit>
