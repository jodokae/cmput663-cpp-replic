<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/proxy/mod_proxy.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MOD_PROXY_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOD_PROXY_H</name></cpp:macro></cpp:define>

<comment type="block">/**
 * @file  mod_proxy.h
 * @brief Proxy Extension Module for Apache
 *
 * @defgroup MOD_PROXY mod_proxy
 * @ingroup  APACHE_MODS
 * @{
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hooks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_optional.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_network_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_uri.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strmatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_fnmatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_reslist.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_uuid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_global_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_mutex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ebcdic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_provider.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_slotmem.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_NETINET_IN_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_ARPA_INET_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* for proxy_canonenc() */</comment>
<enum>enum <name>enctype</name> <block>{
    <decl><name>enc_path</name></decl>, <decl><name>enc_search</name></decl>, <decl><name>enc_user</name></decl>, <decl><name>enc_fpath</name></decl>, <decl><name>enc_parm</name></decl>
}</block>;</enum>

<typedef>typedef <type><enum>enum <block>{
    <decl><name>NONE</name></decl>, <decl><name>TCP</name></decl>, <decl><name>OPTIONS</name></decl>, <decl><name>HEAD</name></decl>, <decl><name>GET</name></decl>, <decl><name>CPING</name></decl>, <decl><name>PROVIDER</name></decl>, <decl><name>EOT</name></decl>
}</block></enum></type> <name>hcmethod_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>hcmethod_t</name></type> <name>method</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>implemented</name></decl>;</decl_stmt>
}</block></struct></type> <name>proxy_hcmethods_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>flag</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
}</block></struct></type> <name>proxy_wstat_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BALANCER_PREFIX</name></cpp:macro> <cpp:value>"balancer://"</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRLF</name></cpp:macro>   <cpp:value>"\r\n"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/*APR_CHARSET_EBCDIC*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRLF</name></cpp:macro>   <cpp:value>"\015\012"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*APR_CHARSET_EBCDIC*/</comment>

<comment type="block">/* default Max-Forwards header setting */</comment>
<comment type="block">/* Set this to -1, which complies with RFC2616 by not setting
 * max-forwards if the client didn't send it to us.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_MAX_FORWARDS</name></cpp:macro>    <cpp:value>-1</cpp:value></cpp:define>

<typedef>typedef <type>struct <name>proxy_balancer</name></type>  <name>proxy_balancer</name>;</typedef>
<typedef>typedef <type>struct <name>proxy_worker</name></type>    <name>proxy_worker</name>;</typedef>
<typedef>typedef <type>struct <name>proxy_conn_pool</name></type> <name>proxy_conn_pool</name>;</typedef>
<typedef>typedef <type>struct <name>proxy_balancer_method</name></type> <name>proxy_balancer_method</name>;</typedef>

<comment type="block">/* static information about a remote proxy */</comment>
<struct>struct <name>proxy_remote</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>scheme</name></decl>;</decl_stmt>     <comment type="block">/* the schemes handled by this proxy, or '*' */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>protocol</name></decl>;</decl_stmt>   <comment type="block">/* the scheme used to talk to this proxy */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hostname</name></decl>;</decl_stmt>   <comment type="block">/* the hostname of this proxy */</comment>
    <decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>regexp</name></decl>;</decl_stmt>     <comment type="block">/* compiled regex (if any) for the remote */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>use_regex</name></decl>;</decl_stmt>          <comment type="block">/* simple boolean. True if we have a regex pattern */</comment>
    <decl_stmt><decl><type><name>apr_port_t</name></type>  <name>port</name></decl>;</decl_stmt>       <comment type="block">/* the port for this proxy */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXYPASS_NOCANON</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXYPASS_INTERPOLATE</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXYPASS_NOQUERY</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define>
<struct>struct <name>proxy_alias</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>  *</type><name>real</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>  *</type><name>fake</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_regex_t</name>  *</type><name>regex</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>proxy_balancer</name> *</type><name>balancer</name></decl>;</decl_stmt> <comment type="block">/* only valid for reverse-proxys */</comment>
}</block>;</struct>

<struct>struct <name>dirconn_entry</name> <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>in_addr</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>mask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>apr_sockaddr_t</name> *</type><name>hostaddr</name></decl>;</decl_stmt>
    <function_decl><type><name>int</name></type> (*<name>matcher</name>) <parameter_list>(<param><decl><type>struct <name>dirconn_entry</name> *</type> <name>This</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>
}</block>;</struct>

<struct>struct <name>noproxy_entry</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>apr_sockaddr_t</name> *</type><name>addr</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>proxies</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>sec_proxy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>aliases</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>noproxies</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>dirconn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>workers</name></decl>;</decl_stmt>    <comment type="block">/* non-balancer workers, eg ProxyPass http://example.com */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>balancers</name></decl>;</decl_stmt>  <comment type="block">/* list of balancers @ config time */</comment>
    <decl_stmt><decl><type><name>proxy_worker</name>       *</type><name>forward</name></decl>;</decl_stmt>    <comment type="block">/* forward proxy worker */</comment>
    <decl_stmt><decl><type><name>proxy_worker</name>       *</type><name>reverse</name></decl>;</decl_stmt>    <comment type="block">/* reverse "module-driven" proxy worker */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>domain</name></decl>;</decl_stmt>     <comment type="block">/* domain name to use in absence of a domain name in the request */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>       <comment type="block">/* Pool used for allocating this struct's elements */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>req</name></decl>;</decl_stmt>                <comment type="block">/* true if proxy requests are enabled */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_balancers</name></decl>;</decl_stmt>      <comment type="block">/* maximum number of allowed balancers */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>bgrowth</name></decl>;</decl_stmt>            <comment type="block">/* number of post-config balancers can added */</comment>
    <enum>enum <block>{
      <decl><name>via_off</name></decl>,
      <decl><name>via_on</name></decl>,
      <decl><name>via_block</name></decl>,
      <decl><name>via_full</name></decl>
    }</block> <decl><name>viaopt</name></decl>;</enum>                   <comment type="block">/* how to deal with proxy Via: headers */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>recv_buffer_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>io_buffer_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>maxfwd</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl>;</decl_stmt>
    <enum>enum <block>{
      <decl><name>bad_error</name></decl>,
      <decl><name>bad_ignore</name></decl>,
      <decl><name>bad_body</name></decl>
    }</block> <decl><name>badopt</name></decl>;</enum>                   <comment type="block">/* how to deal with bad headers */</comment>
    <enum>enum <block>{
        <decl><name>status_off</name></decl>,
        <decl><name>status_on</name></decl>,
        <decl><name>status_full</name></decl>
    }</block> <decl><name>proxy_status</name></decl>;</enum>             <comment type="block">/* Status display options */</comment>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>source_address</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_global_mutex_t</name>  *</type><name>mutex</name></decl>;</decl_stmt> <comment type="block">/* global lock, for pool, etc */</comment>
    <decl_stmt><decl><type><name>ap_slotmem_instance_t</name> *</type><name>bslot</name></decl>;</decl_stmt>  <comment type="block">/* balancers shm data - runtime */</comment>
    <decl_stmt><decl><type><name>ap_slotmem_provider_t</name> *</type><name>storage</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>req_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>viaopt_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>recv_buffer_size_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>io_buffer_size_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>maxfwd_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>timeout_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>badopt_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>proxy_status_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>source_address_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>bgrowth_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>bal_persist</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>inherit</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>inherit_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>ppinherit</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>ppinherit_set</name>:1</expr>;</expr_stmt>
}</block></struct></type> <name>proxy_server_conf</name>;</typedef>


<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>            <comment type="block">/* The path */</comment>
    <decl_stmt><decl><type><name>ap_regex_t</name>  *</type><name>r</name></decl>;</decl_stmt>            <comment type="block">/* Is this a regex? */</comment>

<comment type="block">/* FIXME
 * ProxyPassReverse and friends are documented as working inside
 * &lt;Location&gt;.  But in fact they never have done in the case of
 * more than one &lt;Location&gt;, because the server_conf can't see it.
 * We need to move them to the per-dir config.
 * Discussed in February 2005:
 * http://marc.theaimsgroup.com/?l=apache-httpd-dev&amp;m=110726027118798&amp;w=2
 */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>raliases</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name>*</type> <name>cookie_paths</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name>*</type> <name>cookie_domains</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>p_is_fnmatch</name></decl>;</decl_stmt> <comment type="block">/* Is the path an fnmatch candidate? */</comment>
    <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>interpolate_env</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>proxy_alias</name> *</type><name>alias</name></decl>;</decl_stmt>

    <comment type="block">/**
     * the following setting masks the error page
     * returned from the 'proxied server' and just
     * forwards the status code upwards.
     * This allows the main server (us) to generate
     * the error page, (so it will look like a error
     * returned from the rest of the system
     */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>error_override</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>preserve_host</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>preserve_host_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>error_override_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>alias_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>add_forwarded_headers</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>add_forwarded_headers_set</name>:1</expr>;</expr_stmt>

    <comment type="block">/** Named back references */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>refs</name></decl>;</decl_stmt>

}</block></struct></type> <name>proxy_dir_conf</name>;</typedef>

<comment type="block">/* if we interpolate env vars per-request, we'll need a per-request
 * copy of the reverse proxy config
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>raliases</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name>*</type> <name>cookie_paths</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name>*</type> <name>cookie_domains</name></decl>;</decl_stmt>
}</block></struct></type> <name>proxy_req_conf</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>conn_rec</name>     *</type><name>connection</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name>  *</type><name>r</name></decl>;</decl_stmt>           <comment type="block">/* Request record of the backend request
                                * that is used over the backend connection. */</comment>
    <decl_stmt><decl><type><name>proxy_worker</name> *</type><name>worker</name></decl>;</decl_stmt>      <comment type="block">/* Connection pool this connection belongs to */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name>   *</type><name>pool</name></decl>;</decl_stmt>        <comment type="block">/* Subpool for hostname and addr data */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   *</type><name>hostname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>addr</name></decl>;</decl_stmt>      <comment type="block">/* Preparsed remote address info */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name>   *</type><name>scpool</name></decl>;</decl_stmt>      <comment type="block">/* Subpool used for socket and connection data */</comment>
    <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>sock</name></decl>;</decl_stmt>        <comment type="block">/* Connection socket */</comment>
    <decl_stmt><decl><type><name>void</name>         *</type><name>data</name></decl>;</decl_stmt>        <comment type="block">/* per scheme connection data */</comment>
    <decl_stmt><decl><type><name>void</name>         *</type><name>forward</name></decl>;</decl_stmt>     <comment type="block">/* opaque forward proxy data */</comment>
    <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>flags</name></decl>;</decl_stmt>        <comment type="block">/* Connection flags */</comment>
    <decl_stmt><decl><type><name>apr_port_t</name></type>   <name>port</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>is_ssl</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>close</name>:1</expr>;</expr_stmt>      <comment type="block">/* Close 'this' connection */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>need_flush</name>:1</expr>;</expr_stmt> <comment type="block">/* Flag to decide whether we need to flush the
                                * filter chain or not */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>inreslist</name>:1</expr>;</expr_stmt>  <comment type="block">/* connection in apr_reslist? */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   *</type><name>uds_path</name></decl>;</decl_stmt>    <comment type="block">/* Unix domain socket path */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   *</type><name>ssl_hostname</name></decl>;</decl_stmt><comment type="block">/* Hostname (SNI) in use by SSL connection */</comment>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmp_bb</name></decl>;</decl_stmt><comment type="block">/* Temporary brigade created with the connection
                                * and its scpool/bucket_alloc (NULL before),
                                * must be left cleaned when used (locally).
                                */</comment>
}</block></struct></type> <name>proxy_conn_rec</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
        <decl_stmt><decl><type><name>float</name></type> <name>cache_completion</name></decl>;</decl_stmt> <comment type="block">/* completion percentage */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>content_length</name></decl>;</decl_stmt> <comment type="block">/* length of the content */</comment>
}</block></struct></type> <name>proxy_completion</name>;</typedef>

<comment type="block">/* Connection pool */</comment>
<struct>struct <name>proxy_conn_pool</name> <block>{
    <decl_stmt><decl><type><name>apr_pool_t</name>     *</type><name>pool</name></decl>;</decl_stmt>   <comment type="block">/* The pool used in constructor and destructor calls */</comment>
    <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>addr</name></decl>;</decl_stmt>   <comment type="block">/* Preparsed remote address info */</comment>
    <decl_stmt><decl><type><name>apr_reslist_t</name>  *</type><name>res</name></decl>;</decl_stmt>    <comment type="block">/* Connection resource list */</comment>
    <decl_stmt><decl><type><name>proxy_conn_rec</name> *</type><name>conn</name></decl>;</decl_stmt>   <comment type="block">/* Single connection for prefork mpm */</comment>
}</block>;</struct>

<comment type="block">/* worker status bits */</comment>
<comment type="block">/*
 * NOTE: Keep up-to-date w/ proxy_wstat_tbl[]
 * in mod_proxy.c !
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_INITIALIZED</name></cpp:macro>    <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IGNORE_ERRORS</name></cpp:macro>  <cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_DRAIN</name></cpp:macro>          <cpp:value>0x0004</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_GENERIC</name></cpp:macro>        <cpp:value>0x0008</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IN_SHUTDOWN</name></cpp:macro>    <cpp:value>0x0010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_DISABLED</name></cpp:macro>       <cpp:value>0x0020</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_STOPPED</name></cpp:macro>        <cpp:value>0x0040</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IN_ERROR</name></cpp:macro>       <cpp:value>0x0080</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_HOT_STANDBY</name></cpp:macro>    <cpp:value>0x0100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_FREE</name></cpp:macro>           <cpp:value>0x0200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_HC_FAIL</name></cpp:macro>        <cpp:value>0x0400</cpp:value></cpp:define>

<comment type="block">/* worker status flags */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_INITIALIZED_FLAG</name></cpp:macro>    <cpp:value>'O'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IGNORE_ERRORS_FLAG</name></cpp:macro>  <cpp:value>'I'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_DRAIN_FLAG</name></cpp:macro>          <cpp:value>'N'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_GENERIC_FLAG</name></cpp:macro>        <cpp:value>'G'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IN_SHUTDOWN_FLAG</name></cpp:macro>    <cpp:value>'U'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_DISABLED_FLAG</name></cpp:macro>       <cpp:value>'D'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_STOPPED_FLAG</name></cpp:macro>        <cpp:value>'S'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IN_ERROR_FLAG</name></cpp:macro>       <cpp:value>'E'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_HOT_STANDBY_FLAG</name></cpp:macro>    <cpp:value>'H'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_FREE_FLAG</name></cpp:macro>           <cpp:value>'F'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_HC_FAIL_FLAG</name></cpp:macro>        <cpp:value>'C'</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_NOT_USABLE_BITMAP</name></cpp:macro> <cpp:value>( PROXY_WORKER_IN_SHUTDOWN | \
PROXY_WORKER_DISABLED | PROXY_WORKER_STOPPED | PROXY_WORKER_IN_ERROR | \
PROXY_WORKER_HC_FAIL )</cpp:value></cpp:define>

<comment type="block">/* NOTE: these check the shared status */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IS_INITIALIZED</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>( (f)-&gt;s-&gt;status &amp;  PROXY_WORKER_INITIALIZED )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IS_STANDBY</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>( (f)-&gt;s-&gt;status &amp;  PROXY_WORKER_HOT_STANDBY )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IS_USABLE</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>( ( !( (f)-&gt;s-&gt;status &amp; PROXY_WORKER_NOT_USABLE_BITMAP) ) &amp;&amp; \
  PROXY_WORKER_IS_INITIALIZED(f) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IS_DRAINING</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>( (f)-&gt;s-&gt;status &amp;  PROXY_WORKER_DRAIN )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IS_GENERIC</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>( (f)-&gt;s-&gt;status &amp;  PROXY_WORKER_GENERIC )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IS_HCFAILED</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>( (f)-&gt;s-&gt;status &amp;  PROXY_WORKER_HC_FAIL )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_IS</name><parameter_list>(<param><type><name>f</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>( (f)-&gt;s-&gt;status &amp; (b) )</cpp:value></cpp:define>

<comment type="block">/* default worker retry timeout in seconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_DEFAULT_RETRY</name></cpp:macro>    <cpp:value>60</cpp:value></cpp:define>

<comment type="block">/* Some max char string sizes, for shm fields */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_MAX_SCHEME_SIZE</name></cpp:macro>    <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_MAX_ROUTE_SIZE</name></cpp:macro>     <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_BALANCER_MAX_ROUTE_SIZE</name></cpp:macro> <cpp:value>PROXY_WORKER_MAX_ROUTE_SIZE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_MAX_NAME_SIZE</name></cpp:macro>      <cpp:value>96</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_BALANCER_MAX_NAME_SIZE</name></cpp:macro> <cpp:value>PROXY_WORKER_MAX_NAME_SIZE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_MAX_HOSTNAME_SIZE</name></cpp:macro>  <cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_BALANCER_MAX_HOSTNAME_SIZE</name></cpp:macro> <cpp:value>PROXY_WORKER_MAX_HOSTNAME_SIZE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_BALANCER_MAX_STICKY_SIZE</name></cpp:macro>  <cpp:value>64</cpp:value></cpp:define>

<comment type="block">/* RFC-1035 mentions limits of 255 for host-names and 253 for domain-names,
 * dotted together(?) this would fit the below size (+ trailing NUL).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_WORKER_RFC1035_NAME_SIZE</name></cpp:macro>  <cpp:value>512</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_MAX_PROVIDER_NAME_SIZE</name></cpp:macro>    <cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_STRNCPY</name><parameter_list>(<param><type><name>dst</name></type></param>, <param><type><name>src</name></type></param>)</parameter_list></cpp:macro> <cpp:value>ap_proxy_strncpy((dst), (src), (sizeof(dst)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_COPY_CONF_PARAMS</name><parameter_list>(<param><type><name>w</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>do {                             \
(w)-&gt;s-&gt;timeout              = (c)-&gt;timeout;               \
(w)-&gt;s-&gt;timeout_set          = (c)-&gt;timeout_set;           \
(w)-&gt;s-&gt;recv_buffer_size     = (c)-&gt;recv_buffer_size;      \
(w)-&gt;s-&gt;recv_buffer_size_set = (c)-&gt;recv_buffer_size_set;  \
(w)-&gt;s-&gt;io_buffer_size       = (c)-&gt;io_buffer_size;        \
(w)-&gt;s-&gt;io_buffer_size_set   = (c)-&gt;io_buffer_size_set;    \
} while (0)</cpp:value></cpp:define>

<comment type="block">/* use 2 hashes */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>def</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>fnv</name></decl>;</decl_stmt>
}</block></struct></type> <name>proxy_hashes</name> ;</typedef>

<comment type="block">/* Runtime worker status information. Shared in scoreboard */</comment>
<comment type="block">/* The addition of member uds_path in 2.4.7 was an incompatible API change. */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>char</name></type>      <name><name>name</name><index>[<expr><name>PROXY_WORKER_MAX_NAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>scheme</name><index>[<expr><name>PROXY_WORKER_MAX_SCHEME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* scheme to use ajp|http|https */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>hostname</name><index>[<expr><name>PROXY_WORKER_MAX_HOSTNAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* remote backend address */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>route</name><index>[<expr><name>PROXY_WORKER_MAX_ROUTE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* balancing route */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>redirect</name><index>[<expr><name>PROXY_WORKER_MAX_ROUTE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* temporary balancing redirection route */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>flusher</name><index>[<expr><name>PROXY_WORKER_MAX_SCHEME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* flush provider used by mod_proxy_fdpass */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>uds_path</name><index>[<expr><name>PROXY_WORKER_MAX_NAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* path to worker's unix domain socket if applicable */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>lbset</name></decl>;</decl_stmt>      <comment type="block">/* load balancer cluster set */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>retries</name></decl>;</decl_stmt>    <comment type="block">/* number of retries on this worker */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>lbstatus</name></decl>;</decl_stmt>   <comment type="block">/* Current lbstatus */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>lbfactor</name></decl>;</decl_stmt>   <comment type="block">/* dynamic lbfactor */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>min</name></decl>;</decl_stmt>        <comment type="block">/* Desired minimum number of available connections */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>smax</name></decl>;</decl_stmt>       <comment type="block">/* Soft maximum on the total number of connections */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>hmax</name></decl>;</decl_stmt>       <comment type="block">/* Hard maximum on the total number of connections */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>flush_wait</name></decl>;</decl_stmt> <comment type="block">/* poll wait time in microseconds if flush_auto */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>index</name></decl>;</decl_stmt>      <comment type="block">/* shm array index */</comment>
    <decl_stmt><decl><type><name>proxy_hashes</name></type>    <name>hash</name></decl>;</decl_stmt>       <comment type="block">/* hash of worker name */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>    <name>status</name></decl>;</decl_stmt>     <comment type="block">/* worker status bitfield */</comment>
    <enum>enum <block>{
        <decl><name>flush_off</name></decl>,
        <decl><name>flush_on</name></decl>,
        <decl><name>flush_auto</name></decl>
    }</block> <decl><name>flush_packets</name></decl>;</enum>           <comment type="block">/* control AJP flushing */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type>      <name>updated</name></decl>;</decl_stmt>    <comment type="block">/* timestamp of last update */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type>      <name>error_time</name></decl>;</decl_stmt> <comment type="block">/* time of the last error */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>ttl</name></decl>;</decl_stmt>    <comment type="block">/* maximum amount of time in seconds a connection
                                 * may be available while exceeding the soft limit */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>retry</name></decl>;</decl_stmt>   <comment type="block">/* retry interval */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl>;</decl_stmt> <comment type="block">/* connection timeout */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>acquire</name></decl>;</decl_stmt> <comment type="block">/* acquire timeout when the maximum number of connections is exceeded */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>ping_timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>conn_timeout</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type>      <name>recv_buffer_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type>      <name>io_buffer_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type>      <name>elected</name></decl>;</decl_stmt>    <comment type="block">/* Number of times the worker was elected */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type>      <name>busy</name></decl>;</decl_stmt>       <comment type="block">/* busyness factor */</comment>
    <decl_stmt><decl><type><name>apr_port_t</name></type>      <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type>       <name>transferred</name></decl>;</decl_stmt><comment type="block">/* Number of bytes transferred to remote */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type>       <name>read</name></decl>;</decl_stmt>       <comment type="block">/* Number of bytes read from remote */</comment>
    <decl_stmt><decl><type><name>void</name>            *</type><name>context</name></decl>;</decl_stmt>   <comment type="block">/* general purpose storage */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>keepalive</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>disablereuse</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>is_address_reusable</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>retry_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>timeout_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>acquire_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>ping_timeout_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>conn_timeout_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>recv_buffer_size_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>io_buffer_size_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>keepalive_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>disablereuse_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>     <name>was_malloced</name>:1</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>hcuri</name><index>[<expr><name>PROXY_WORKER_MAX_ROUTE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* health check uri */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>hcexpr</name><index>[<expr><name>PROXY_WORKER_MAX_SCHEME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* name of condition expr for health check */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>passes</name></decl>;</decl_stmt>     <comment type="block">/* number of successes for check to pass */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>pcount</name></decl>;</decl_stmt>     <comment type="block">/* current count of passes */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>fails</name></decl>;</decl_stmt>      <comment type="block">/* number of failures for check to fail */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>fcount</name></decl>;</decl_stmt>     <comment type="block">/* current count of failures */</comment>
    <decl_stmt><decl><type><name>hcmethod_t</name></type>      <name>method</name></decl>;</decl_stmt>     <comment type="block">/* method to use for health check */</comment>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>interval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>upgrade</name><index>[<expr><name>PROXY_WORKER_MAX_SCHEME_SIZE</name></expr>]</index></name></decl>;</decl_stmt><comment type="block">/* upgrade protocol used by mod_proxy_wstunnel */</comment>
}</block></struct></type> <name>proxy_worker_shared</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGNED_PROXY_WORKER_SHARED_SIZE</name></cpp:macro> <cpp:value>(APR_ALIGN_DEFAULT(sizeof(proxy_worker_shared)))</cpp:value></cpp:define>

<comment type="block">/* Worker configuration */</comment>
<struct>struct <name>proxy_worker</name> <block>{
    <decl_stmt><decl><type><name>proxy_hashes</name></type>    <name>hash</name></decl>;</decl_stmt>       <comment type="block">/* hash of worker name */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>local_status</name></decl>;</decl_stmt>  <comment type="block">/* status of per-process worker */</comment>
    <decl_stmt><decl><type><name>proxy_conn_pool</name>     *</type><name>cp</name></decl>;</decl_stmt>    <comment type="block">/* Connection pool to use */</comment>
    <decl_stmt><decl><type><name>proxy_worker_shared</name>   *</type><name>s</name></decl>;</decl_stmt>   <comment type="block">/* Shared data */</comment>
    <decl_stmt><decl><type><name>proxy_balancer</name>  *</type><name>balancer</name></decl>;</decl_stmt>  <comment type="block">/* which balancer am I in? */</comment>
    <decl_stmt><decl><type><name>apr_thread_mutex_t</name>  *</type><name>tmutex</name></decl>;</decl_stmt> <comment type="block">/* Thread lock for updating address cache */</comment>
    <decl_stmt><decl><type><name>void</name>            *</type><name>context</name></decl>;</decl_stmt>   <comment type="block">/* general purpose storage */</comment>
}</block>;</struct>

<comment type="block">/* default to health check every 30 seconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HCHECK_WATHCHDOG_DEFAULT_INTERVAL</name></cpp:macro> <cpp:value>(30)</cpp:value></cpp:define>
<comment type="block">/* The watchdog runs every 2 seconds, which is also the minimal check */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HCHECK_WATHCHDOG_INTERVAL</name></cpp:macro> <cpp:value>(2)</cpp:value></cpp:define>

<comment type="block">/*
 * Time to wait (in microseconds) to find out if more data is currently
 * available at the backend.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_FLUSH_WAIT</name></cpp:macro> <cpp:value>10000</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>char</name></type>      <name><name>sticky_path</name><index>[<expr><name>PROXY_BALANCER_MAX_STICKY_SIZE</name></expr>]</index></name></decl>;</decl_stmt>     <comment type="block">/* URL sticky session identifier */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>sticky</name><index>[<expr><name>PROXY_BALANCER_MAX_STICKY_SIZE</name></expr>]</index></name></decl>;</decl_stmt>          <comment type="block">/* sticky session identifier */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>lbpname</name><index>[<expr><name>PROXY_MAX_PROVIDER_NAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>  <comment type="block">/* lbmethod provider name */</comment>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>nonce</name><index>[<expr><name>APR_UUID_FORMATTED_LENGTH</name> + 1</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>name</name><index>[<expr><name>PROXY_BALANCER_MAX_NAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>sname</name><index>[<expr><name>PROXY_BALANCER_MAX_NAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>vpath</name><index>[<expr><name>PROXY_BALANCER_MAX_ROUTE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name><name>vhost</name><index>[<expr><name>PROXY_BALANCER_MAX_HOSTNAME_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl>;</decl_stmt>  <comment type="block">/* Timeout for waiting on free connection */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type>      <name>wupdated</name></decl>;</decl_stmt>     <comment type="block">/* timestamp of last change to workers list */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>max_attempts</name></decl>;</decl_stmt>     <comment type="block">/* Number of attempts before failing */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>index</name></decl>;</decl_stmt>      <comment type="block">/* shm array index */</comment>
    <decl_stmt><decl><type><name>proxy_hashes</name></type> <name>hash</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>    <name>sticky_force</name>:1</expr>;</expr_stmt>   <comment type="block">/* Disable failover for sticky sessions */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>    <name>scolonsep</name>:1</expr>;</expr_stmt>      <comment type="block">/* true if ';' seps sticky session paths */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>    <name>max_attempts_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>    <name>was_malloced</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>    <name>need_reset</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>    <name>vhosted</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>    <name>inactive</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name>    <name>forcerecovery</name>:1</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>char</name></type>      <name>sticky_separator</name></decl>;</decl_stmt>                                <comment type="block">/* separator for sessionid/route */</comment>
}</block></struct></type> <name>proxy_balancer_shared</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGNED_PROXY_BALANCER_SHARED_SIZE</name></cpp:macro> <cpp:value>(APR_ALIGN_DEFAULT(sizeof(proxy_balancer_shared)))</cpp:value></cpp:define>

<struct>struct <name>proxy_balancer</name> <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>workers</name></decl>;</decl_stmt>  <comment type="block">/* initially configured workers */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>errstatuses</name></decl>;</decl_stmt>  <comment type="block">/* statuses to force members into error */</comment>
    <decl_stmt><decl><type><name>ap_slotmem_instance_t</name> *</type><name>wslot</name></decl>;</decl_stmt>  <comment type="block">/* worker shm data - runtime */</comment>
    <decl_stmt><decl><type><name>ap_slotmem_provider_t</name> *</type><name>storage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>growth</name></decl>;</decl_stmt>                   <comment type="block">/* number of post-config workers can added */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>max_workers</name></decl>;</decl_stmt>              <comment type="block">/* maximum number of allowed workers */</comment>
    <decl_stmt><decl><type><name>proxy_hashes</name></type> <name>hash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type>      <name>wupdated</name></decl>;</decl_stmt>    <comment type="block">/* timestamp of last change to workers list */</comment>
    <decl_stmt><decl><type><name>proxy_balancer_method</name> *</type><name>lbmethod</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_global_mutex_t</name>  *</type><name>gmutex</name></decl>;</decl_stmt> <comment type="block">/* global lock for updating list of workers */</comment>
    <decl_stmt><decl><type><name>apr_thread_mutex_t</name>  *</type><name>tmutex</name></decl>;</decl_stmt> <comment type="block">/* Thread lock for updating shm */</comment>
    <decl_stmt><decl><type><name>proxy_server_conf</name> *</type><name>sconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name>            *</type><name>context</name></decl>;</decl_stmt>    <comment type="block">/* general purpose storage */</comment>
    <decl_stmt><decl><type><name>proxy_balancer_shared</name> *</type><name>s</name></decl>;</decl_stmt>    <comment type="block">/* Shared data */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>failontimeout</name></decl>;</decl_stmt>           <comment type="block">/* Whether to mark a member in Err if IO timeout occurs */</comment>
}</block>;</struct>

<struct>struct <name>proxy_balancer_method</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>            <comment type="block">/* name of the load balancer method*/</comment>
    <function_decl><type><name>proxy_worker</name> *</type>(*<name>finder</name>)<parameter_list>(<param><decl><type><name>proxy_balancer</name> *</type><name>balancer</name></decl></param>,
                            <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>void</name>            *</type><name>context</name></decl>;</decl_stmt>   <comment type="block">/* general purpose storage */</comment>
    <function_decl><type><name>apr_status_t</name></type> (*<name>reset</name>)<parameter_list>(<param><decl><type><name>proxy_balancer</name> *</type><name>balancer</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>apr_status_t</name></type> (*<name>age</name>)<parameter_list>(<param><decl><type><name>proxy_balancer</name> *</type><name>balancer</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
    <function_decl><type><name>apr_status_t</name></type> (*<name>updatelbstatus</name>)<parameter_list>(<param><decl><type><name>proxy_balancer</name> *</type><name>balancer</name></decl></param>, <param><decl><type><name>proxy_worker</name> *</type><name>elected</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_THREAD_LOCK</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>( (x) &amp;&amp; (x)-&gt;tmutex ? apr_thread_mutex_lock((x)-&gt;tmutex) : APR_SUCCESS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_THREAD_UNLOCK</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>( (x) &amp;&amp; (x)-&gt;tmutex ? apr_thread_mutex_unlock((x)-&gt;tmutex) : APR_SUCCESS)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_GLOBAL_LOCK</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>      <cpp:value>( (x) &amp;&amp; (x)-&gt;gmutex ? apr_global_mutex_lock((x)-&gt;gmutex) : APR_SUCCESS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_GLOBAL_UNLOCK</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>    <cpp:value>( (x) &amp;&amp; (x)-&gt;gmutex ? apr_global_mutex_unlock((x)-&gt;gmutex) : APR_SUCCESS)</cpp:value></cpp:define>

<comment type="block">/* hooks */</comment>

<comment type="block">/* Create a set of PROXY_DECLARE(type), PROXY_DECLARE_NONSTD(type) and
 * PROXY_DECLARE_DATA with appropriate export and import tags for the platform
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROXY_DECLARE_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_DATA</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROXY_DECLARE_EXPORT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>__declspec(dllexport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__declspec(dllexport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_DATA</name></cpp:macro>             <cpp:value>__declspec(dllexport)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>            <cpp:value>__declspec(dllimport) type __stdcall</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_NONSTD</name><parameter_list>(<param><type><name>type</name></type></param>)</parameter_list></cpp:macro>     <cpp:value>__declspec(dllimport) type</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_DATA</name></cpp:macro>             <cpp:value>__declspec(dllimport)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Using PROXY_DECLARE_OPTIONAL_HOOK instead of
 * APR_DECLARE_EXTERNAL_HOOK allows build/make_nw_export.awk
 * to distinguish between hooks that implement
 * proxy_hook_xx and proxy_hook_get_xx in mod_proxy.c and
 * those which don't.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DECLARE_OPTIONAL_HOOK</name></cpp:macro> <cpp:value>APR_DECLARE_EXTERNAL_HOOK</cpp:value></cpp:define>

<comment type="block">/* These 2 are in mod_proxy.c */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PROXY_DECLARE_DATA</name> <name>proxy_hcmethods_t</name></type> <name><name>proxy_hcmethods</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>PROXY_DECLARE_DATA</name> <name>proxy_wstat_t</name></type> <name><name>proxy_wstat_tbl</name><index>[]</index></name></decl>;</decl_stmt>

<comment type="block">/* Following 4 from health check */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>void</name></expr></argument>, <argument><expr><name>hc_show_exprs</name></expr></argument>, <argument><expr>(<name>request_rec</name> *)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>void</name></expr></argument>, <argument><expr><name>hc_select_exprs</name></expr></argument>, <argument><expr>(<name>request_rec</name> *, const <name>char</name> *)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>hc_valid_expr</name></expr></argument>, <argument><expr>(<name>request_rec</name> *, const <name>char</name> *)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>set_worker_hc_param</name></expr></argument>,
                        <argument><expr>(<name>apr_pool_t</name> *, <name>server_rec</name> *, <name>proxy_worker</name> *,
                         const <name>char</name> *, const <name>char</name> *, <name>void</name> *)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>proxy</argument>, <argument>PROXY</argument>, <argument>int</argument>, <argument>scheme_handler</argument>, <argument>(request_rec *r,
                          proxy_worker *worker, proxy_server_conf *conf, char *url,
                          const char *proxyhost, apr_port_t proxyport)</argument>)</argument_list></macro>
<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>proxy</argument>, <argument>PROXY</argument>, <argument>int</argument>, <argument>canon_handler</argument>, <argument>(request_rec *r,
                          char *url)</argument>)</argument_list></macro>

<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>proxy</argument>, <argument>PROXY</argument>, <argument>int</argument>, <argument>create_req</argument>, <argument>(request_rec *r, request_rec *pr)</argument>)</argument_list></macro>
<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>proxy</argument>, <argument>PROXY</argument>, <argument>int</argument>, <argument>fixups</argument>, <argument>(request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/**
 * pre request hook.
 * It will return the most suitable worker at the moment
 * and corresponding balancer.
 * The url is rewritten from balancer://cluster/uri to scheme://host:port/uri
 * and then the scheme_handler is called.
 *
 */</comment>
<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>proxy</argument>, <argument>PROXY</argument>, <argument>int</argument>, <argument>pre_request</argument>, <argument>(proxy_worker **worker,
                          proxy_balancer **balancer,
                          request_rec *r,
                          proxy_server_conf *conf, char **url)</argument>)</argument_list></macro>
<comment type="block">/**
 * post request hook.
 * It is called after request for updating runtime balancer status.
 */</comment>
<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>proxy</argument>, <argument>PROXY</argument>, <argument>int</argument>, <argument>post_request</argument>, <argument>(proxy_worker *worker,
                          proxy_balancer *balancer, request_rec *r,
                          proxy_server_conf *conf)</argument>)</argument_list></macro>

<comment type="block">/**
 * request status hook
 * It is called after all proxy processing has been done.  This gives other
 * modules a chance to create default content on failure, for example
 */</comment>
<macro><name>APR_DECLARE_EXTERNAL_HOOK</name><argument_list>(<argument>proxy</argument>, <argument>PROXY</argument>, <argument>int</argument>, <argument>request_status</argument>,
                          <argument>(int *status, request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/* proxy_util.c */</comment>

<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_proxy_strncpy</name><argument_list>(<argument>char *dst</argument>, <argument>const char *src</argument>,
                                             <argument>apr_size_t dlen</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_hex2c</name><argument_list>(<argument><expr>const <name>char</name> *<name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_proxy_c2hex</name><argument_list>(<argument>int ch</argument>, <argument>char *x</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro><macro><name>ap_proxy_canonenc</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *x</argument>, <argument>int len</argument>, <argument>enum enctype t</argument>,
                                       <argument>int forcedec</argument>, <argument>int proxyreq</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro><expr_stmt><expr><call><name>ap_proxy_canon_netloc</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>char</name> **const <name>urlp</name></expr></argument>, <argument><expr><name>char</name> **<name>userp</name></expr></argument>,
                                           <argument><expr><name>char</name> **<name>passwordp</name></expr></argument>, <argument><expr><name>char</name> **<name>hostp</name></expr></argument>, <argument><expr><name>apr_port_t</name> *<name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_proxyerror</name><argument_list>(<argument>request_rec *r</argument>, <argument>int statuscode</argument>, <argument>const char *message</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_checkproxyblock</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr><name>proxy_server_conf</name> *<name>conf</name></expr></argument>, <argument><expr><name>apr_sockaddr_t</name> *<name>uri_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/** Test whether the hostname/address of the request are blocked by the ProxyBlock
 * configuration.
 * @param r         request
 * @param conf      server configuration
 * @param hostname  hostname from request URI
 * @param addr      resolved address of hostname, or NULL if not known
 * @return OK on success, or else an errro
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_checkproxyblock2</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr><name>proxy_server_conf</name> *<name>conf</name></expr></argument>, 
                                             <argument><expr>const <name>char</name> *<name>hostname</name></expr></argument>, <argument><expr><name>apr_sockaddr_t</name> *<name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_pre_http_request</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>, <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* DEPRECATED (will be replaced with ap_proxy_connect_backend */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_connect_to_backend</name><argument_list>(<argument><expr><name>apr_socket_t</name> **</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>apr_sockaddr_t</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr><name>proxy_server_conf</name> *</expr></argument>, <argument><expr><name>request_rec</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/* DEPRECATED (will be replaced with ap_proxy_check_connection */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_ssl_connection_cleanup</name><argument_list>(<argument><expr><name>proxy_conn_rec</name> *<name>conn</name></expr></argument>,
                                                            <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_ssl_enable</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_ssl_disable</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_conn_is_https</name><argument_list>(<argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_ssl_val</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>, <argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>, <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr>const <name>char</name> *<name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Header mapping functions, and a typedef of their signature */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_location_reverse_map</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr><name>proxy_dir_conf</name> *<name>conf</name></expr></argument>, <argument><expr>const <name>char</name> *<name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_cookie_reverse_map</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>, <argument><expr><name>proxy_dir_conf</name> *<name>conf</name></expr></argument>, <argument><expr>const <name>char</name> *<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>ap_proxy_header_reverse_map_fn</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>,
                       <param><decl><type><name>proxy_dir_conf</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl></typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROXY_DECLARE_STATIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<typedef>typedef <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(<name>__stdcall</name> *<name>ap_proxy_header_reverse_map_fn</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>,
                                 <param><decl><type><name>proxy_dir_conf</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl></typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROXY_DECLARE_EXPORT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<typedef>typedef <macro><name>__declspec</name><argument_list>(<argument>dllexport</argument>)</argument_list></macro> <function_decl><type><specifier>const</specifier> <name>char</name> *</type>
  (<name>__stdcall</name> *<name>ap_proxy_header_reverse_map_fn</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>,
               <param><decl><type><name>proxy_dir_conf</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl></typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <macro><name>__declspec</name><argument_list>(<argument>dllimport</argument>)</argument_list></macro> <function_decl><type><specifier>const</specifier> <name>char</name> *</type>
  (<name>__stdcall</name> *<name>ap_proxy_header_reverse_map_fn</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>,
               <param><decl><type><name>proxy_dir_conf</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>)</parameter_list>;</function_decl></typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/* Connection pool API */</comment>
<comment type="block">/**
 * Return the user-land, UDS aware worker name
 * @param p        memory pool used for displaying worker name
 * @param worker   the worker
 * @return         name
 */</comment>

<macro><name>PROXY_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_worker_name</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                           <argument><expr><name>proxy_worker</name> *<name>worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Get the worker from proxy configuration
 * @param p        memory pool used for finding worker
 * @param balancer the balancer that the worker belongs to
 * @param conf     current proxy server configuration
 * @param url      url to find the worker from
 * @return         proxy_worker or NULL if not found
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>proxy_worker *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_get_worker</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                                  <argument><expr><name>proxy_balancer</name> *<name>balancer</name></expr></argument>,
                                                  <argument><expr><name>proxy_server_conf</name> *<name>conf</name></expr></argument>,
                                                  <argument><expr>const <name>char</name> *<name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Define and Allocate space for the worker to proxy configuration
 * @param p         memory pool to allocate worker from
 * @param worker    the new worker
 * @param balancer  the balancer that the worker belongs to
 * @param conf      current proxy server configuration
 * @param url       url containing worker name
 * @param do_malloc true if shared struct should be malloced
 * @return          error message or NULL if successful (*worker is new worker)
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_proxy_define_worker</name><argument_list>(<argument>apr_pool_t *p</argument>,
                                             <argument>proxy_worker **worker</argument>,
                                             <argument>proxy_balancer *balancer</argument>,
                                             <argument>proxy_server_conf *conf</argument>,
                                             <argument>const char *url</argument>,
                                             <argument>int do_malloc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Share a defined proxy worker via shm
 * @param worker  worker to be shared
 * @param shm     location of shared info
 * @param i       index into shm
 * @return        APR_SUCCESS or error code
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_proxy_share_worker</name><argument_list>(<argument>proxy_worker *worker</argument>,
                                                  <argument>proxy_worker_shared *shm</argument>,
                                                  <argument>int i</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Initialize the worker by setting up worker connection pool and mutex
 * @param worker worker to initialize
 * @param s      current server record
 * @param p      memory pool used for mutex and connection pool
 * @return       APR_SUCCESS or error code
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_initialize_worker</name><argument_list>(<argument><expr><name>proxy_worker</name> *<name>worker</name></expr></argument>,
                                                       <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>,
                                                       <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Verifies valid balancer name (eg: balancer://foo)
 * @param name  name to test
 * @param i     number of chars to test; 0 for all.
 * @return      true/false
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_proxy_valid_balancer_name</name><argument_list>(<argument>char *name</argument>, <argument>int i</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/**
 * Get the balancer from proxy configuration
 * @param p     memory pool used for temporary storage while finding balancer
 * @param conf  current proxy server configuration
 * @param url   url to find the worker from; must have balancer:// prefix
 * @param careactive true if we care if the balancer is active or not
 * @return      proxy_balancer or NULL if not found
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>proxy_balancer *</argument>)</argument_list></macro> <macro><name>ap_proxy_get_balancer</name><argument_list>(<argument>apr_pool_t *p</argument>,
                                                      <argument>proxy_server_conf *conf</argument>,
                                                      <argument>const char *url</argument>,
                                                      <argument>int careactive</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Update the balancer's vhost related fields
 * @param p     memory pool used for temporary storage while finding balancer
 * @param balancer  balancer to be updated
 * @param url   url to find vhost info
 * @return      error string or NULL if OK
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_update_balancer</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                               <argument><expr><name>proxy_balancer</name> *<name>balancer</name></expr></argument>,
                                               <argument><expr>const <name>char</name> *<name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Define and Allocate space for the balancer to proxy configuration
 * @param p      memory pool to allocate balancer from
 * @param balancer the new balancer
 * @param conf   current proxy server configuration
 * @param url    url containing balancer name
 * @param alias  alias/fake-path to this balancer
 * @param do_malloc true if shared struct should be malloced
 * @return       error message or NULL if successful
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <macro><name>ap_proxy_define_balancer</name><argument_list>(<argument>apr_pool_t *p</argument>,
                                               <argument>proxy_balancer **balancer</argument>,
                                               <argument>proxy_server_conf *conf</argument>,
                                               <argument>const char *url</argument>,
                                               <argument>const char *alias</argument>,
                                               <argument>int do_malloc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Share a defined proxy balancer via shm
 * @param balancer  balancer to be shared
 * @param shm       location of shared info
 * @param i         index into shm
 * @return          APR_SUCCESS or error code
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_proxy_share_balancer</name><argument_list>(<argument>proxy_balancer *balancer</argument>,
                                                    <argument>proxy_balancer_shared *shm</argument>,
                                                    <argument>int i</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Initialize the balancer as needed
 * @param balancer balancer to initialize
 * @param s        current server record
 * @param p        memory pool used for mutex and connection pool
 * @return         APR_SUCCESS or error code
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_initialize_balancer</name><argument_list>(<argument><expr><name>proxy_balancer</name> *<name>balancer</name></expr></argument>,
                                                         <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>,
                                                         <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Find the shm of the worker as needed
 * @param storage slotmem provider
 * @param slot    slotmem instance
 * @param worker  worker to find
 * @param index   pointer to index within slotmem of worker
 * @return        pointer to shm of worker, or NULL
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>proxy_worker_shared *</argument>)</argument_list></macro> <macro><name>ap_proxy_find_workershm</name><argument_list>(<argument>ap_slotmem_provider_t *storage</argument>,
                                                             <argument>ap_slotmem_instance_t *slot</argument>,
                                                             <argument>proxy_worker *worker</argument>,
                                                             <argument>unsigned int *index</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Find the shm of the balancer as needed
 * @param storage  slotmem provider
 * @param slot     slotmem instance
 * @param balancer balancer of shm to find
 * @param index    pointer to index within slotmem of balancer
 * @return         pointer to shm of balancer, or NULL
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>proxy_balancer_shared *</argument>)</argument_list></macro> <macro><name>ap_proxy_find_balancershm</name><argument_list>(<argument>ap_slotmem_provider_t *storage</argument>,
                                                                 <argument>ap_slotmem_instance_t *slot</argument>,
                                                                 <argument>proxy_balancer *balancer</argument>,
                                                                 <argument>unsigned int *index</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Get the most suitable worker and/or balancer for the request
 * @param worker   worker used for processing request
 * @param balancer balancer used for processing request
 * @param r        current request
 * @param conf     current proxy server configuration
 * @param url      request url that balancer can rewrite.
 * @return         OK or  HTTP_XXX error
 * @note It calls balancer pre_request hook if the url starts with balancer://
 * The balancer then rewrites the url to particular worker, like http://host:port
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_pre_request</name><argument_list>(<argument><expr><name>proxy_worker</name> **<name>worker</name></expr></argument>,
                                        <argument><expr><name>proxy_balancer</name> **<name>balancer</name></expr></argument>,
                                        <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                        <argument><expr><name>proxy_server_conf</name> *<name>conf</name></expr></argument>,
                                        <argument><expr><name>char</name> **<name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Post request worker and balancer cleanup
 * @param worker   worker used for processing request
 * @param balancer balancer used for processing request
 * @param r        current request
 * @param conf     current proxy server configuration
 * @return         OK or  HTTP_XXX error
 * @note Whenever the pre_request is called, the post_request has to be
 * called too.
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_post_request</name><argument_list>(<argument><expr><name>proxy_worker</name> *<name>worker</name></expr></argument>,
                                         <argument><expr><name>proxy_balancer</name> *<name>balancer</name></expr></argument>,
                                         <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                         <argument><expr><name>proxy_server_conf</name> *<name>conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Determine backend hostname and port
 * @param p       memory pool used for processing
 * @param r       current request
 * @param conf    current proxy server configuration
 * @param worker  worker used for processing request
 * @param conn    proxy connection struct
 * @param uri     processed uri
 * @param url     request url
 * @param proxyname are we connecting directly or via a proxy
 * @param proxyport proxy host port
 * @param server_portstr Via headers server port, must be non-NULL
 * @param server_portstr_size size of the server_portstr buffer; must
 * be at least one, even if the protocol doesn't use this
 * @return         OK or HTTP_XXX error
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_proxy_determine_connection</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>request_rec *r</argument>,
                                                 <argument>proxy_server_conf *conf</argument>,
                                                 <argument>proxy_worker *worker</argument>,
                                                 <argument>proxy_conn_rec *conn</argument>,
                                                 <argument>apr_uri_t *uri</argument>,
                                                 <argument>char **url</argument>,
                                                 <argument>const char *proxyname</argument>,
                                                 <argument>apr_port_t proxyport</argument>,
                                                 <argument>char *server_portstr</argument>,
                                                 <argument>int server_portstr_size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Mark a worker for retry
 * @param proxy_function calling proxy scheme (http, ajp, ...)
 * @param worker  worker used for retrying
 * @param s       current server record
 * @return        OK if marked for retry, DECLINED otherwise
 * @note The error status of the worker will cleared if the retry interval has
 * elapsed since the last error.
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>ap_proxy_retry_worker</name></expr></argument>,
        <argument><expr>(const <name>char</name> *<name>proxy_function</name>, <name>proxy_worker</name> *<name>worker</name>, <name>server_rec</name> *<name>s</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Acquire a connection from worker connection pool
 * @param proxy_function calling proxy scheme (http, ajp, ...)
 * @param conn    acquired connection
 * @param worker  worker used for obtaining connection
 * @param s       current server record
 * @return        OK or HTTP_XXX error
 * @note If the connection limit has been reached, the function will
 * block until a connection becomes available or the timeout has
 * elapsed.
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_acquire_connection</name><argument_list>(<argument><expr>const <name>char</name> *<name>proxy_function</name></expr></argument>,
                                               <argument><expr><name>proxy_conn_rec</name> **<name>conn</name></expr></argument>,
                                               <argument><expr><name>proxy_worker</name> *<name>worker</name></expr></argument>,
                                               <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Release a connection back to worker connection pool
 * @param proxy_function calling proxy scheme (http, ajp, ...)
 * @param conn    acquired connection
 * @param s       current server record
 * @return        OK or HTTP_XXX error
 * @note The connection will be closed if conn-&gt;close_on_release is set
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_release_connection</name><argument_list>(<argument><expr>const <name>char</name> *<name>proxy_function</name></expr></argument>,
                                               <argument><expr><name>proxy_conn_rec</name> *<name>conn</name></expr></argument>,
                                               <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_CHECK_CONN_EMPTY</name></cpp:macro> <cpp:value>(1 &lt;&lt; 0)</cpp:value></cpp:define>
<comment type="block">/**
 * Check a connection to the backend
 * @param scheme calling proxy scheme (http, ajp, ...)
 * @param conn   acquired connection
 * @param server current server record
 * @param max_blank_lines how many blank lines to consume,
 *                        or zero for none (considered data)
 * @param flags  PROXY_CHECK_* bitmask
 * @return APR_SUCCESS: connection established,
 *         APR_ENOTEMPTY: connection established with data,
 *         APR_ENOSOCKET: not connected,
 *         APR_EINVAL: worker in error state (unusable),
 *         other: connection closed/aborted (remotely)
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_proxy_check_connection</name><argument_list>(<argument>const char *scheme</argument>,
                                                      <argument>proxy_conn_rec *conn</argument>,
                                                      <argument>server_rec *server</argument>,
                                                      <argument>unsigned max_blank_lines</argument>,
                                                      <argument>int flags</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Make a connection to the backend
 * @param proxy_function calling proxy scheme (http, ajp, ...)
 * @param conn    acquired connection
 * @param worker  connection worker
 * @param s       current server record
 * @return        OK or HTTP_XXX error
 * @note In case the socket already exists for conn, just check the link
 * status.
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_connect_backend</name><argument_list>(<argument><expr>const <name>char</name> *<name>proxy_function</name></expr></argument>,
                                            <argument><expr><name>proxy_conn_rec</name> *<name>conn</name></expr></argument>,
                                            <argument><expr><name>proxy_worker</name> *<name>worker</name></expr></argument>,
                                            <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Make a connection to a Unix Domain Socket (UDS) path
 * @param sock     UDS to connect
 * @param uds_path UDS path to connect to
 * @param p        pool to make the sock addr
 * @return         APR_SUCCESS or error status
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_connect_uds</name><argument_list>(<argument><expr><name>apr_socket_t</name> *<name>sock</name></expr></argument>,
                                                 <argument><expr>const <name>char</name> *<name>uds_path</name></expr></argument>,
                                                 <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Make a connection record for backend connection
 * @param proxy_function calling proxy scheme (http, ajp, ...)
 * @param conn    acquired connection
 * @param c       client connection record
 * @param s       current server record
 * @return        OK or HTTP_XXX error
 * @note The function will return immediately if conn-&gt;connection
 * is already set,
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_connection_create</name><argument_list>(<argument><expr>const <name>char</name> *<name>proxy_function</name></expr></argument>,
                                              <argument><expr><name>proxy_conn_rec</name> *<name>conn</name></expr></argument>,
                                              <argument><expr><name>conn_rec</name> *<name>c</name></expr></argument>, <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Determine if proxy connection can potentially be reused at the
 * end of this request.
 * @param conn proxy connection
 * @return non-zero if reusable, 0 otherwise
 * @note Even if this function returns non-zero, the connection may
 * be subsequently marked for closure.
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_connection_reusable</name><argument_list>(<argument><expr><name>proxy_conn_rec</name> *<name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Signal the upstream chain that the connection to the backend broke in the
 * middle of the response. This is done by sending an error bucket with
 * status HTTP_BAD_GATEWAY and an EOS bucket up the filter chain.
 * @param r       current request record of client request
 * @param brigade The brigade that is sent through the output filter chain
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_backend_broke</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                           <argument><expr><name>apr_bucket_brigade</name> *<name>brigade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Return a hash based on the passed string
 * @param str     string to produce hash from
 * @param method  hashing method to use
 * @return        hash as unsigned int
 */</comment>

<typedef>typedef <type><enum>enum <block>{ <decl><name>PROXY_HASHFUNC_DEFAULT</name></decl>, <decl><name>PROXY_HASHFUNC_APR</name></decl>,  <decl><name>PROXY_HASHFUNC_FNV</name></decl> }</block></enum></type> <name>proxy_hash_t</name>;</typedef>

<macro><name>PROXY_DECLARE</name><argument_list>(<argument>unsigned int</argument>)</argument_list></macro> <macro><name>ap_proxy_hashfunc</name><argument_list>(<argument>const char *str</argument>, <argument>proxy_hash_t method</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/**
 * Set/unset the worker status bitfield depending on flag
 * @param c    flag
 * @param set  set or unset bit
 * @param w    worker to use
 * @return     APR_SUCCESS if valid flag
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_proxy_set_wstatus</name><argument_list>(<argument>char c</argument>, <argument>int set</argument>, <argument>proxy_worker *w</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>


<comment type="block">/**
 * Create readable representation of worker status bitfield
 * @param p  pool
 * @param w  worker to use
 * @return   string representation of status
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_parse_wstatus</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>proxy_worker</name> *<name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/**
 * Sync balancer and workers based on any updates w/i shm
 * @param b  balancer to check/update member list of
 * @param s  server rec
 * @param conf config
 * @return   APR_SUCCESS if all goes well
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_sync_balancer</name><argument_list>(<argument><expr><name>proxy_balancer</name> *<name>b</name></expr></argument>,
                                                   <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>,
                                                   <argument><expr><name>proxy_server_conf</name> *<name>conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<comment type="block">/**
 * Find the matched alias for this request and setup for proxy handler
 * @param r     request
 * @param ent   proxy_alias record
 * @param dconf per-dir config or NULL
 * @return      DECLINED, DONE or OK if matched
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_trans_match</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                        <argument>struct <expr><name>proxy_alias</name> *<name>ent</name></expr></argument>,
                                        <argument><expr><name>proxy_dir_conf</name> *<name>dconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Create a HTTP request header brigade,  old_cl_val and old_te_val as required.
 * @param p               pool
 * @param header_brigade  header brigade to use/fill
 * @param r               request
 * @param p_conn          proxy connection rec
 * @param worker          selected worker
 * @param conf            per-server proxy config
 * @param uri             uri
 * @param url             url
 * @param server_portstr  port as string
 * @param old_cl_val      stored old content-len val
 * @param old_te_val      stored old TE val
 * @return                OK or HTTP_EXPECTATION_FAILED
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_create_hdrbrgd</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                           <argument><expr><name>apr_bucket_brigade</name> *<name>header_brigade</name></expr></argument>,
                                           <argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                           <argument><expr><name>proxy_conn_rec</name> *<name>p_conn</name></expr></argument>,
                                           <argument><expr><name>proxy_worker</name> *<name>worker</name></expr></argument>,
                                           <argument><expr><name>proxy_server_conf</name> *<name>conf</name></expr></argument>,
                                           <argument><expr><name>apr_uri_t</name> *<name>uri</name></expr></argument>,
                                           <argument><expr><name>char</name> *<name>url</name></expr></argument>, <argument><expr><name>char</name> *<name>server_portstr</name></expr></argument>,
                                           <argument><expr><name>char</name> **<name>old_cl_val</name></expr></argument>,
                                           <argument><expr><name>char</name> **<name>old_te_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * @param bucket_alloc  bucket allocator
 * @param r             request
 * @param p_conn        proxy connection
 * @param origin        connection rec of origin
 * @param  bb           brigade to send to origin
 * @param  flush        flush
 * @return              status (OK)
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_proxy_pass_brigade</name><argument_list>(<argument>apr_bucket_alloc_t *bucket_alloc</argument>,
                                         <argument>request_rec *r</argument>, <argument>proxy_conn_rec *p_conn</argument>,
                                         <argument>conn_rec *origin</argument>, <argument>apr_bucket_brigade *bb</argument>,
                                         <argument>int flush</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Clear the headers referenced by the Connection header from the given
 * table, and remove the Connection header.
 * @param r request
 * @param headers table of headers to clear
 * @return 1 if "close" was present, 0 otherwise.
 */</comment>
<expr_stmt><expr><call><name>APR_DECLARE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>ap_proxy_clear_connection</name></expr></argument>,
        <argument><expr>(<name>request_rec</name> *<name>r</name>, <name>apr_table_t</name> *<name>headers</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * @param socket        socket to test
 * @return              TRUE if socket is connected/active
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_is_socket_connected</name><argument_list>(<argument><expr><name>apr_socket_t</name> *<name>socket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_LBMETHOD</name></cpp:macro> <cpp:value>"proxylbmethod"</cpp:value></cpp:define>

<comment type="block">/* The number of dynamic workers that can be added when reconfiguring.
 * If this limit is reached you must stop and restart the server.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROXY_DYNAMIC_BALANCER_LIMIT</name></cpp:macro>    <cpp:value>16</cpp:value></cpp:define>

<comment type="block">/**
 * Calculate maximum number of workers in scoreboard.
 * @return  number of workers to allocate in the scoreboard
 */</comment>
<function_decl><type><name>int</name></type> <name>ap_proxy_lb_workers</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return the port number of a known scheme (eg: http -&gt; 80).
 * @param scheme        scheme to test
 * @return              port number or 0 if unknown
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_port_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_port_of_scheme</name><argument_list>(<argument><expr>const <name>char</name> *<name>scheme</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Return the name of the health check method (eg: "OPTIONS").
 * @param method        method enum
 * @return              name of method
 */</comment>
<macro><name>PROXY_DECLARE</name> <argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_proxy_show_hcmethod</name><argument_list>(<argument>hcmethod_t method</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Strip a unix domain socket (UDS) prefix from the input URL
 * @param p             pool to allocate result from
 * @param url           a URL potentially prefixed with a UDS path
 * @return              URL with the UDS prefix removed
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_de_socketfy</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Transform buckets from one bucket allocator to another one by creating a
 * transient bucket for each data bucket and let it use the data read from
 * the old bucket. Metabuckets are transformed by just recreating them.
 * Attention: Currently only the following bucket types are handled:
 *
 * All data buckets
 * FLUSH
 * EOS
 *
 * If an other bucket type is found its type is logged as a debug message
 * and APR_EGENERAL is returned.
 *
 * @param r     request_rec of the actual request. Used for logging purposes
 * @param from  the bucket brigade to take the buckets from
 * @param to    the bucket brigade to store the transformed buckets
 * @return      apr_status_t of the operation. Either APR_SUCCESS or
 *              APR_EGENERAL
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_proxy_buckets_lifetime_transform</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>,
                                                      <argument><expr><name>apr_bucket_brigade</name> *<name>from</name></expr></argument>,
                                                      <argument><expr><name>apr_bucket_brigade</name> *<name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * Sends all data that can be read non blocking from the input filter chain of
 * c_i and send it down the output filter chain of c_o. For reading it uses
 * the bucket brigade bb_i which should be created from the bucket allocator
 * associated with c_i. For sending through the output filter chain it uses
 * the bucket brigade bb_o which should be created from the bucket allocator
 * associated with c_o. In order to get the buckets from bb_i to bb_o
 * ap_proxy_buckets_lifetime_transform is used.
 *
 * @param r     request_rec of the actual request. Used for logging purposes
 * @param c_i   inbound connection conn_rec
 * @param c_o   outbound connection conn_rec
 * @param bb_i  bucket brigade for pulling data from the inbound connection
 * @param bb_o  bucket brigade for sending data through the outbound connection
 * @param name  string for logging from where data was pulled
 * @param sent  if not NULL will be set to 1 if data was sent through c_o
 * @param bsize maximum amount of data pulled in one iteration from c_i
 * @param after if set flush data on c_o only once after the loop
 * @return      apr_status_t of the operation. Could be any error returned from
 *              either the input filter chain of c_i or the output filter chain
 *              of c_o. APR_EPIPE if the outgoing connection was aborted.
 */</comment>
<macro><name>PROXY_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_proxy_transfer_between_connections</name><argument_list>(
                                                       <argument>request_rec *r</argument>,
                                                       <argument>conn_rec *c_i</argument>,
                                                       <argument>conn_rec *c_o</argument>,
                                                       <argument>apr_bucket_brigade *bb_i</argument>,
                                                       <argument>apr_bucket_brigade *bb_o</argument>,
                                                       <argument>const char *name</argument>,
                                                       <argument>int *sent</argument>,
                                                       <argument>apr_off_t bsize</argument>,
                                                       <argument>int after</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>module</name> <name>PROXY_DECLARE_DATA</name></type> <name>proxy_module</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*MOD_PROXY_H*/</comment>
<comment type="block">/** @} */</comment>
</unit>
