<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/examples/mod_example_ipc.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 *  mod_example_ipc -- Apache sample module
 *
 * This module illustrates the use in an Apache 2.x module of the Interprocess
 * Communications routines that come with APR. It is example code, and not meant
 * to be used in a production server.
 *
 * To play with this sample module first compile it into a DSO file and install
 * it into Apache's modules directory by running:
 *
 *    $ /path/to/apache2/bin/apxs -c -i mod_example_ipc.c
 *
 * Then activate it in Apache's httpd.conf file for instance for the URL
 * /example_ipc in as follows:
 *
 *    #   httpd.conf
 *    LoadModule example_ipc_module modules/mod_example_ipc.so
 *    &lt;Location /example_ipc&gt;
 *    SetHandler example_ipc
 *    &lt;/Location&gt;
 *
 * Then restart Apache via
 *
 *    $ /path/to/apache2/bin/apachectl restart
 *
 * The module allocates a counter in shared memory, which is incremented by the
 * request handler under a mutex. After installation, activate the handler by
 * hitting the URL configured above with ab at various concurrency levels to see
 * how mutex contention affects server performance.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_SYS_TYPES_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTML_HEADER</name></cpp:macro> <cpp:value>"&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Mod_example_IPC Status Page " \
                    "&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Mod_example_IPC Status&lt;/h1&gt;\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTML_FOOTER</name></cpp:macro> <cpp:value>"&lt;/body&gt;\n&lt;/html&gt;\n"</cpp:value></cpp:define>

<comment type="block">/* Number of microseconds to camp out on the mutex */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CAMPOUT</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<comment type="block">/* Maximum number of times we camp out before giving up */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCAMP</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<comment type="block">/* Number of microseconds the handler sits on the lock once acquired. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SLEEPYTIME</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<decl_stmt><decl><type><name>apr_shm_t</name> *</type><name>exipc_shm</name></decl>;</decl_stmt> <comment type="block">/* Pointer to shared memory block */</comment>
<decl_stmt><decl><type><name>char</name> *</type><name>shmfilename</name></decl>;</decl_stmt> <comment type="block">/* Shared memory file name, used on some systems */</comment>
<decl_stmt><decl><type><name>apr_global_mutex_t</name> *</type><name>exipc_mutex</name></decl>;</decl_stmt> <comment type="block">/* Lock around shared memory segment access */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>exipc_mutex_type</name> <init>= <expr>"example-ipc-shm"</expr></init></decl>;</decl_stmt>

<comment type="block">/* Data structure for shared memory block */</comment>
<typedef>typedef <type><struct>struct <name>exipc_data</name> <block>{
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>counter</name></decl>;</decl_stmt>
    <comment type="block">/* More fields if necessary */</comment>
}</block></struct></type> <name>exipc_data</name>;</typedef>

<comment type="block">/*
 * Clean up the shared memory block. This function is registered as
 * cleanup function for the configuration pool, which gets called
 * on restarts. It assures that the new children will not talk to a stale
 * shared memory segment.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>shm_cleanup_wrapper</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>exipc_shm</name></expr>)</condition><then>
        <return>return <expr><call><name>apr_shm_destroy</name><argument_list>(<argument><expr><name>exipc_shm</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This routine is called in the parent; we must register our
 * mutex type before the config is processed so that users can
 * adjust the mutex settings using the Mutex directive.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>exipc_pre_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_mutex_register</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>exipc_mutex_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_LOCK_DEFAULT</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This routine is called in the parent, so we'll set up the shared
 * memory segment and mutex here.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>exipc_post_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>exipc_data</name> *</type><name>base</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tempdir</name></decl>;</decl_stmt>


    <comment type="block">/*
     * Do nothing if we are not creating the final configuration.
     * The parent process gets initialized a couple of times as the
     * server starts up, and we don't want to create any more mutexes
     * and shared memory segments than we're actually going to use.
     */</comment>
    <if>if <condition>(<expr><call><name>ap_state_query</name><argument_list>(<argument><expr><name>AP_SQ_MAIN_STATE</name></expr></argument>)</argument_list></call> == <name>AP_SQ_MS_CREATE_PRE_CONFIG</name></expr>)</condition><then>
        <return>return <expr><name>OK</name></expr>;</return></then></if>

    <comment type="block">/*
     * The shared memory allocation routines take a file name.
     * Depending on system-specific implementation of these
     * routines, that file may or may not actually be created. We'd
     * like to store those files in the operating system's designated
     * temporary directory, which APR can point us to.
     */</comment>
    <expr_stmt><expr><name>rs</name> = <call><name>apr_temp_dir_get</name><argument_list>(<argument><expr>&amp;<name>tempdir</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>APR_SUCCESS</name> != <name>rs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02992</expr></argument>)</argument_list></call>
                     "Failed to find temporary directory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Create the shared memory segment */</comment>

    <comment type="block">/*
     * Create a unique filename using our pid. This information is
     * stashed in the global variable so the children inherit it.
     */</comment>
    <expr_stmt><expr><name>shmfilename</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr>"%s/httpd_shm.%ld"</expr></argument>, <argument><expr><name>tempdir</name></expr></argument>,
                               <argument><expr>(<name>long</name> <name>int</name>)<call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now create that segment */</comment>
    <expr_stmt><expr><name>rs</name> = <call><name>apr_shm_create</name><argument_list>(<argument><expr>&amp;<name>exipc_shm</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>exipc_data</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                        <argument><expr>(const <name>char</name> *) <name>shmfilename</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>APR_SUCCESS</name> != <name>rs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02993</expr></argument>)</argument_list></call>
                     "Failed to create shared memory segment on file %s"</expr></argument>,
                     <argument><expr><name>shmfilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Created it, now let's zero it out */</comment>
    <expr_stmt><expr><name>base</name> = (<name>exipc_data</name> *)<call><name>apr_shm_baseaddr_get</name><argument_list>(<argument><expr><name>exipc_shm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>base</name>-&gt;<name>counter</name></name> = 0</expr>;</expr_stmt>

    <comment type="block">/* Create global mutex */</comment>

    <expr_stmt><expr><name>rs</name> = <call><name>ap_global_mutex_create</name><argument_list>(<argument><expr>&amp;<name>exipc_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>exipc_mutex_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>s</name></expr></argument>, <argument><expr><name>pconf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>APR_SUCCESS</name> != <name>rs</name></expr>)</condition><then> <block>{
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Destroy the shm segment when the configuration pool gets destroyed. This
     * happens on server restarts. The parent will then (above) allocate a new
     * shm segment that the new children will bind to.
     */</comment>
    <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>shm_cleanup_wrapper</name></expr></argument>,
                              <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This routine gets called when a child inits. We use it to attach
 * to the shared memory segment, and reinitialize the mutex.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exipc_child_init</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rs</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Re-open the mutex for the child. Note we're reusing
     * the mutex pointer global here.
     */</comment>
    <expr_stmt><expr><name>rs</name> = <call><name>apr_global_mutex_child_init</name><argument_list>(<argument><expr>&amp;<name>exipc_mutex</name></expr></argument>,
                                     <argument><expr><call><name>apr_global_mutex_lockfile</name><argument_list>(<argument><expr><name>exipc_mutex</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>APR_SUCCESS</name> != <name>rs</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02994</expr></argument>)</argument_list></call>
                     "Failed to reopen mutex %s in child"</expr></argument>,
                     <argument><expr><name>exipc_mutex_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* There's really nothing else we can do here, since This
         * routine doesn't return a status. If this ever goes wrong,
         * it will turn Apache into a fork bomb. Let's hope it never
         * will.
         */</comment>
        <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Ugly, but what else? */</comment>
    }</block></then></if>
}</block></function>

<comment type="block">/* The sample content handler */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>exipc_handler</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>gotlock</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>camped</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>startcamp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>timecamped</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>exipc_data</name> *</type><name>base</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>handler</name></name></expr></argument>, <argument><expr>"example_ipc"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * The main function of the handler, aside from sending the
     * status page to the client, is to increment the counter in
     * the shared memory segment. This action needs to be mutexed
     * out using the global mutex.
     */</comment>

    <comment type="block">/*
     * First, acquire the lock. This code is a lot more involved than
     * it usually needs to be, because the process based trylock
     * routine is not implemented on unix platforms. I left it in to
     * show how it would work if trylock worked, and for situations
     * and platforms where trylock works.
     */</comment>
    <for>for (<init><expr><name>camped</name> = 0</expr>, <expr><name>timecamped</name> = 0</expr>;</init> <condition><expr><name>camped</name> &lt; <name>MAXCAMP</name></expr>;</condition> <incr><expr><name>camped</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>rs</name> = <call><name>apr_global_mutex_trylock</name><argument_list>(<argument><expr><name>exipc_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>APR_STATUS_IS_EBUSY</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>CAMPOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>APR_SUCCESS</name> == <name>rs</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>gotlock</name> = 1</expr>;</expr_stmt>
            <break>break;</break> <comment type="block">/* Get out of the loop */</comment>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOTIMPL</name><argument_list>(<argument><expr><name>rs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* If it's not implemented, just hang in the mutex. */</comment>
            <expr_stmt><expr><name>startcamp</name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>rs</name> = <call><name>apr_global_mutex_lock</name><argument_list>(<argument><expr><name>exipc_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>timecamped</name> = <call>(<name>apr_int64_t</name>) <argument_list>(<argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call> - <name>startcamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>APR_SUCCESS</name> == <name>rs</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>gotlock</name> = 1</expr>;</expr_stmt>
                <break>break;</break> <comment type="block">/* Out of the loop */</comment>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* Some error, log and bail */</comment>
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02995</expr></argument>)</argument_list></call>
                             "Child %ld failed to acquire lock"</expr></argument>,
                             <argument><expr>(<name>long</name> <name>int</name>)<call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break> <comment type="block">/* Out of the loop without having the lock */</comment>
            }</block></else></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Some other error, log and bail */</comment>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02996</expr></argument>)</argument_list></call>
                         "Child %ld failed to try and acquire lock"</expr></argument>,
                         <argument><expr>(<name>long</name> <name>int</name>)<call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break> <comment type="block">/* Out of the loop without having the lock */</comment>
        }</block></else></if></else></if></else></if>

        <comment type="block">/*
         * The only way to get to this point is if the trylock worked
         * and returned BUSY. So, bump the time and try again
         */</comment>
        <expr_stmt><expr><name>timecamped</name> += <name>CAMPOUT</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_NOTICE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03187</expr></argument>)</argument_list></call>
                     "Child %ld camping out on mutex for %" <name>APR_INT64_T_FMT</name>
                     " microseconds"</expr></argument>,
                     <argument><expr>(<name>long</name> <name>int</name>) <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>timecamped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for> <comment type="block">/* Lock acquisition loop */</comment>

    <comment type="block">/* Sleep for a millisecond to make it a little harder for
     * httpd children to acquire the lock.
     */</comment>
    <expr_stmt><expr><call><name>apr_sleep</name><argument_list>(<argument><expr><name>SLEEPYTIME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>content_type</name></name> = "text/html"</expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>header_only</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr><name>HTML_HEADER</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>gotlock</name></expr>)</condition><then> <block>{
            <comment type="block">/* Increment the counter */</comment>
            <expr_stmt><expr><name>base</name> = (<name>exipc_data</name> *)<call><name>apr_shm_baseaddr_get</name><argument_list>(<argument><expr><name>exipc_shm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>base</name>-&gt;<name>counter</name></name>++</expr>;</expr_stmt>
            <comment type="block">/* Send a page with our pid and the new value of the counter. */</comment>
            <expr_stmt><expr><call><name>ap_rprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"&lt;p&gt;Lock acquired after %ld microseoncds.&lt;/p&gt;\n"</expr></argument>,
                       <argument><expr>(<name>long</name> <name>int</name>) <name>timecamped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;table border=\"1\"&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_rprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"&lt;tr&gt;&lt;td&gt;Child pid:&lt;/td&gt;&lt;td&gt;%d&lt;/td&gt;&lt;/tr&gt;\n"</expr></argument>,
                       <argument><expr>(<name>int</name>) <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_rprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"&lt;tr&gt;&lt;td&gt;Counter:&lt;/td&gt;&lt;td&gt;%u&lt;/td&gt;&lt;/tr&gt;\n"</expr></argument>,
                       <argument><expr>(<name>unsigned</name> <name>int</name>)<name><name>base</name>-&gt;<name>counter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr>"&lt;/table&gt;\n"</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/*
             * Send a page saying that we couldn't get the lock. Don't say
             * what the counter is, because without the lock the value could
             * race.
             */</comment>
            <expr_stmt><expr><call><name>ap_rprintf</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"&lt;p&gt;Child %d failed to acquire lock "
                       "after camping out for %d microseconds.&lt;/p&gt;\n"</expr></argument>,
                       <argument><expr>(<name>int</name>) <call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr>(<name>int</name>) <name>timecamped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>ap_rputs</name><argument_list>(<argument><expr><name>HTML_FOOTER</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if> <comment type="block">/* r-&gt;header_only */</comment>

    <comment type="block">/* Release the lock */</comment>
    <if>if <condition>(<expr><name>gotlock</name></expr>)</condition><then>
        <expr_stmt><expr><name>rs</name> = <call><name>apr_global_mutex_unlock</name><argument_list>(<argument><expr><name>exipc_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <comment type="block">/* Swallowing the result because what are we going to do with it at
     * this stage?
     */</comment>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exipc_register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_hook_pre_config</name><argument_list>(<argument><expr><name>exipc_pre_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_post_config</name><argument_list>(<argument><expr><name>exipc_post_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_child_init</name><argument_list>(<argument><expr><name>exipc_child_init</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_handler</name><argument_list>(<argument><expr><name>exipc_handler</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Dispatch list for API hooks */</comment>
<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>example_ipc</name></expr></argument>)</argument_list></call> = <block>{
    <expr><name>STANDARD20_MODULE_STUFF</name></expr>,
    <expr><name>NULL</name></expr>,                  <comment type="block">/* create per-dir    config structures */</comment>
    <expr><name>NULL</name></expr>,                  <comment type="block">/* merge  per-dir    config structures */</comment>
    <expr><name>NULL</name></expr>,                  <comment type="block">/* create per-server config structures */</comment>
    <expr><name>NULL</name></expr>,                  <comment type="block">/* merge  per-server config structures */</comment>
    <expr><name>NULL</name></expr>,                  <comment type="block">/* table of config file commands       */</comment>
    <expr><name>exipc_register_hooks</name></expr>   <comment type="block">/* register hooks                      */</comment>
}</block></expr>;</expr_stmt>
</unit>
