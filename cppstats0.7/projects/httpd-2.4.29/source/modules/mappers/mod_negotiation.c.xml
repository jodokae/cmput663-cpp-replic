<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/mappers/mod_negotiation.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * mod_negotiation.c: keeps track of MIME types the client is willing to
 * accept, and contains code to handle type arbitration.
 *
 * rst
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_file_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_script.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAP_FILE_MAGIC_TYPE</name></cpp:macro> <cpp:value>"application/x-type-map"</cpp:value></cpp:define>

<comment type="block">/* Commands --- configuring document caching on a per (virtual?)
 * server basis...
 */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>forcelangpriority</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>language_priority</name></decl>;</decl_stmt>
}</block></struct></type> <name>neg_dir_config</name>;</typedef>

<comment type="block">/* forcelangpriority flags
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLP_UNDEF</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>    <comment type="block">/* Same as FLP_DEFAULT, but base overrides */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLP_NONE</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>    <comment type="block">/* Return 406, HTTP_NOT_ACCEPTABLE */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLP_PREFER</name></cpp:macro>   <cpp:value>2</cpp:value></cpp:define>    <comment type="block">/* Use language_priority rather than MC */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLP_FALLBACK</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>    <comment type="block">/* Use language_priority rather than NA */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLP_DEFAULT</name></cpp:macro>  <cpp:value>FLP_PREFER</cpp:value></cpp:define>

<comment type="block">/* env evaluation
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISCARD_ALL_ENCODINGS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>  <comment type="block">/* no-gzip */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISCARD_ALL_BUT_HTML</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>  <comment type="block">/* gzip-only-text/html */</comment>

<decl_stmt><decl><type><name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>negotiation_module</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_neg_dir_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dummy</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>neg_dir_config</name> *</type><name>new</name> <init>= <expr>(<name>neg_dir_config</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                                        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>neg_dir_config</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>new</name>-&gt;<name>forcelangpriority</name></name> = <name>FLP_UNDEF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>language_priority</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>new</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>merge_neg_dir_configs</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>basev</name></decl></param>, <param><decl><type><name>void</name> *</type><name>addv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>neg_dir_config</name> *</type><name>base</name> <init>= <expr>(<name>neg_dir_config</name> *) <name>basev</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>neg_dir_config</name> *</type><name>add</name> <init>= <expr>(<name>neg_dir_config</name> *) <name>addv</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>neg_dir_config</name> *</type><name>new</name> <init>= <expr>(<name>neg_dir_config</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                                        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>neg_dir_config</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* give priority to the config in the subdirectory */</comment>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>forcelangpriority</name></name> = (<name><name>add</name>-&gt;<name>forcelangpriority</name></name> != <name>FLP_UNDEF</name>)
                                ? <name><name>add</name>-&gt;<name>forcelangpriority</name></name>
                                : <name><name>base</name>-&gt;<name>forcelangpriority</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>language_priority</name></name> = <name><name>add</name>-&gt;<name>language_priority</name></name>
                                ? <name><name>add</name>-&gt;<name>language_priority</name></name>
                                : <name><name>base</name>-&gt;<name>language_priority</name></name></expr>;</expr_stmt>
    <return>return <expr><name>new</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_language_priority</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>n_</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lang</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>neg_dir_config</name> *</type><name>n</name> <init>= <expr><name>n_</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>langp</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>n</name>-&gt;<name>language_priority</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>n</name>-&gt;<name>language_priority</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><name>langp</name> = (const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>n</name>-&gt;<name>language_priority</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>langp</name> = <name>lang</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>set_force_priority</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>n_</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>w</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>neg_dir_config</name> *</type><name>n</name> <init>= <expr><name>n_</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"None"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>n</name>-&gt;<name>forcelangpriority</name></name> &amp; ~<name>FLP_NONE</name></expr>)</condition><then> <block>{
            <return>return <expr>"Cannot combine ForceLanguagePriority options with None"</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>n</name>-&gt;<name>forcelangpriority</name></name> = <name>FLP_NONE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"Prefer"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>n</name>-&gt;<name>forcelangpriority</name></name> &amp; <name>FLP_NONE</name></expr>)</condition><then> <block>{
            <return>return <expr>"Cannot combine ForceLanguagePriority options None and "
                   "Prefer"</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>n</name>-&gt;<name>forcelangpriority</name></name> |= <name>FLP_PREFER</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"Fallback"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>n</name>-&gt;<name>forcelangpriority</name></name> &amp; <name>FLP_NONE</name></expr>)</condition><then> <block>{
            <return>return <expr>"Cannot combine ForceLanguagePriority options None and "
                   "Fallback"</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>n</name>-&gt;<name>forcelangpriority</name></name> |= <name>FLP_FALLBACK</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Invalid ForceLanguagePriority option "</expr></argument>,
                           <argument><expr><name>w</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if></else></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cache_negotiated_docs</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                         <param><decl><type><name>int</name></type> <name>arg</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_set_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>negotiation_module</name></expr></argument>,
                         <argument><expr>(<name>arg</name> ? "Cache" : <name>NULL</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_cache_negotiated_docs</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>module_config</name></name></expr></argument>,
                                 <argument><expr>&amp;<name>negotiation_module</name></expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>negotiation_cmds</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><call><name>AP_INIT_FLAG</name><argument_list>(<argument><expr>"CacheNegotiatedDocs"</expr></argument>, <argument><expr><name>cache_negotiated_docs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
                 <argument><expr>"Either 'on' or 'off' (default)"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_ITERATE</name><argument_list>(<argument><expr>"LanguagePriority"</expr></argument>, <argument><expr><name>set_language_priority</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                    <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                    <argument><expr>"space-delimited list of MIME language abbreviations"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_ITERATE</name><argument_list>(<argument><expr>"ForceLanguagePriority"</expr></argument>, <argument><expr><name>set_force_priority</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                    <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                    <argument><expr>"Force LanguagePriority elections, either None, or "
                    "Fallback and/or Prefer"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Record of available info on a media type specified by the client
 * (we also use 'em for encodings and languages)
 */</comment>

<typedef>typedef <type><struct>struct <name>accept_rec</name> <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>                 <comment type="block">/* MUST be lowercase */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>quality</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>level</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>charset</name></decl>;</decl_stmt>              <comment type="block">/* for content-type only */</comment>
}</block></struct></type> <name>accept_rec</name>;</typedef>

<comment type="block">/*
 * Record of available info on a particular variant
 *
 * Note that a few of these fields are updated by the actual negotiation
 * code.  These are:
 *
 * level_matched --- initialized to zero.  Set to the value of level
 *             if the client actually accepts this media type at that
 *             level (and *not* if it got in on a wildcard).  See level_cmp
 *             below.
 * mime_stars -- initialized to zero.  Set to the number of stars
 *               present in the best matching Accept header element.
 *               1 for star/star, 2 for type/star and 3 for
 *               type/subtype.
 *
 * definite -- initialized to 1.  Set to 0 if there is a match which
 *             makes the variant non-definite according to the rules
 *             in rfc2296.
 */</comment>

<typedef>typedef <type><struct>struct <name>var_rec</name> <block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>sub_req</name></decl>;</decl_stmt>       <comment type="block">/* May be NULL (is, for map files) */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mime_type</name></decl>;</decl_stmt>      <comment type="block">/* MUST be lowercase */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file_name</name></decl>;</decl_stmt>      <comment type="block">/* Set to 'this' (for map file body content) */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>body</name></decl>;</decl_stmt>             <comment type="block">/* Only for map file body content */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>content_encoding</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>content_languages</name></decl>;</decl_stmt> <comment type="block">/* list of lang. for this variant */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>content_charset</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>description</name></decl>;</decl_stmt>

    <comment type="block">/* The next five items give the quality values for the dimensions
     * of negotiation for this variant. They are obtained from the
     * appropriate header lines, except for source_quality, which
     * is obtained from the variant itself (the 'qs' parameter value
     * from the variant's mime-type). Apart from source_quality,
     * these values are set when we find the quality for each variant
     * (see best_match()). source_quality is set from the 'qs' parameter
     * of the variant description or mime type: see set_mime_fields().
     */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>lang_quality</name></decl>;</decl_stmt>         <comment type="block">/* quality of this variant's language */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>encoding_quality</name></decl>;</decl_stmt>     <comment type="block">/* ditto encoding */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>charset_quality</name></decl>;</decl_stmt>      <comment type="block">/* ditto charset */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>mime_type_quality</name></decl>;</decl_stmt>    <comment type="block">/* ditto media type */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>source_quality</name></decl>;</decl_stmt>       <comment type="block">/* source quality for this variant */</comment>

    <comment type="block">/* Now some special values */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>level</name></decl>;</decl_stmt>                <comment type="block">/* Auxiliary to content-type... */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>bytes</name></decl>;</decl_stmt>            <comment type="block">/* content length, if known */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>lang_index</name></decl>;</decl_stmt>             <comment type="block">/* Index into LanguagePriority list */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>is_pseudo_html</name></decl>;</decl_stmt>         <comment type="block">/* text/html, *or* the INCLUDES_MAGIC_TYPEs */</comment>

    <comment type="block">/* Above are all written-once properties of the variant.  The
     * three fields below are changed during negotiation:
     */</comment>

    <decl_stmt><decl><type><name>float</name></type> <name>level_matched</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>mime_stars</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>definite</name></decl>;</decl_stmt>
}</block></struct></type> <name>var_rec</name>;</typedef>

<comment type="block">/* Something to carry around the state of negotiation (and to keep
 * all of this thread-safe)...
 */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>neg_dir_config</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>dir_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>accept_q</name></decl>;</decl_stmt>               <comment type="block">/* 1 if an Accept item has a q= param */</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>default_lang_quality</name></decl>;</decl_stmt> <comment type="block">/* fiddle lang q for variants with no lang */</comment>

    <comment type="block">/* the array pointers below are NULL if the corresponding accept
     * headers are not present
     */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>accepts</name></decl>;</decl_stmt>            <comment type="block">/* accept_recs */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>accept_encodings</name></decl>;</decl_stmt>   <comment type="block">/* accept_recs */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>accept_charsets</name></decl>;</decl_stmt>    <comment type="block">/* accept_recs */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>accept_langs</name></decl>;</decl_stmt>       <comment type="block">/* accept_recs */</comment>

    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>avail_vars</name></decl>;</decl_stmt>         <comment type="block">/* available variants */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>count_multiviews_variants</name></decl>;</decl_stmt>    <comment type="block">/* number of variants found on disk */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>is_transparent</name></decl>;</decl_stmt>       <comment type="block">/* 1 if this resource is trans. negotiable */</comment>

    <decl_stmt><decl><type><name>int</name></type> <name>dont_fiddle_headers</name></decl>;</decl_stmt>  <comment type="block">/* 1 if we may not fiddle with accept hdrs */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ua_supports_trans</name></decl>;</decl_stmt>    <comment type="block">/* 1 if ua supports trans negotiation */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>send_alternates</name></decl>;</decl_stmt>      <comment type="block">/* 1 if we want to send an Alternates header */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>may_choose</name></decl>;</decl_stmt>           <comment type="block">/* 1 if we may choose a variant for the client */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>use_rvsa</name></decl>;</decl_stmt>             <comment type="block">/* 1 if we must use RVSA/1.0 negotiation algo */</comment>
}</block></struct></type> <name>negotiation_state</name>;</typedef>

<comment type="block">/* A few functions to manipulate var_recs.
 * Cleaning out the fields...
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clean_var_rec</name><parameter_list>(<param><decl><type><name>var_rec</name> *</type><name>mime_info</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>sub_req</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>mime_type</name></name> = ""</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>file_name</name></name> = ""</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>body</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>content_encoding</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>content_languages</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>content_charset</name></name> = ""</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>description</name></name> = ""</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>is_pseudo_html</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>level</name></name> = 0.0f</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>level_matched</name></name> = 0.0f</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>bytes</name></name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>lang_index</name></name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>mime_stars</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>definite</name></name> = 1</expr>;</expr_stmt>

    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>charset_quality</name></name> = 1.0f</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>encoding_quality</name></name> = 1.0f</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>lang_quality</name></name> = 1.0f</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>mime_type_quality</name></name> = 1.0f</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>mime_info</name>-&gt;<name>source_quality</name></name> = 0.0f</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Initializing the relevant fields of a variant record from the
 * accept_info read out of its content-type, one way or another.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_mime_fields</name><parameter_list>(<param><decl><type><name>var_rec</name> *</type><name>var</name></decl></param>, <param><decl><type><name>accept_rec</name> *</type><name>mime_info</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>var</name>-&gt;<name>mime_type</name></name> = <name><name>mime_info</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name>-&gt;<name>source_quality</name></name> = <name><name>mime_info</name>-&gt;<name>quality</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name>-&gt;<name>level</name></name> = <name><name>mime_info</name>-&gt;<name>level</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>var</name>-&gt;<name>content_charset</name></name> = <name><name>mime_info</name>-&gt;<name>charset</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>var</name>-&gt;<name>is_pseudo_html</name></name> = (!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>var</name>-&gt;<name>mime_type</name></name></expr></argument>, <argument><expr>"text/html"</expr></argument>)</argument_list></call>
                           || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>var</name>-&gt;<name>mime_type</name></name></expr></argument>, <argument><expr><name>INCLUDES_MAGIC_TYPE</name></expr></argument>)</argument_list></call>
                           || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>var</name>-&gt;<name>mime_type</name></name></expr></argument>, <argument><expr><name>INCLUDES_MAGIC_TYPE3</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Create a variant list validator in r using info from vlistr. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_vlist_validator</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>vlistr</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Calculating the variant list validator is similar to
     * calculating an etag for the source of the variant list
     * information, so we use ap_make_etag().  Note that this
     * validator can be 'weak' in extreme case.
     */</comment>
    <expr_stmt><expr><call><name>ap_update_mtime</name><argument_list>(<argument><expr><name>vlistr</name></expr></argument>, <argument><expr><name><name>vlistr</name>-&gt;<name>finfo</name>.<name>mtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>vlist_validator</name></name> = <call><name>ap_make_etag</name><argument_list>(<argument><expr><name>vlistr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ap_set_etag will later take r-&gt;vlist_validator into account
     * when creating the etag header
     */</comment>
}</block></function>


<comment type="block">/*****************************************************************
 *
 * Parsing (lists of) media types and their parameters, as seen in
 * HTTPD header lines and elsewhere.
 */</comment>

<comment type="block">/*
 * parse quality value. atof(3) is not well-usable here, because it
 * depends on the locale (argh).
 *
 * However, RFC 2616 states:
 * 3.9 Quality Values
 *
 * [...] HTTP/1.1 applications MUST NOT generate more than three digits
 * after the decimal point. User configuration of these values SHOULD also
 * be limited in this fashion.
 *
 *     qvalue         = ( "0" [ "." 0*3DIGIT ] )
 *                    | ( "1" [ "." 0*3("0") ] )
 *
 * This is quite easy. If the supplied string doesn't match the above
 * definition (loosely), we simply return 1 (same as if there's no qvalue)
 */</comment>

<function><type><specifier>static</specifier> <name>float</name></type> <name>atoq</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name>string</name> || !*<name>string</name></expr>)</condition><then> <block>{
        <return>return  <expr>1.0f</expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>string</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>string</name></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* be tolerant and accept qvalues without leading zero
     * (also for backwards compat, where atof() was in use)
     */</comment>
    <if>if <condition>(<expr>*<name>string</name> != '.' &amp;&amp; *<name>string</name>++ != '0'</expr>)</condition><then> <block>{
        <return>return <expr>1.0f</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>*<name>string</name> == '.'</expr>)</condition><then> <block>{
        <comment type="block">/* better only one division later, than dealing with fscking
         * IEEE format 0.1 factors ...
         */</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>*++<name>string</name> &gt;= '0' &amp;&amp; *<name>string</name> &lt;= '9'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>i</name> += (*<name>string</name> - '0') * 100</expr>;</expr_stmt>

            <if>if <condition>(<expr>*++<name>string</name> &gt;= '0' &amp;&amp; *<name>string</name> &lt;= '9'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>i</name> += (*<name>string</name> - '0') * 10</expr>;</expr_stmt>

                <if>if <condition>(<expr>*++<name>string</name> &gt; '0' &amp;&amp; *<name>string</name> &lt;= '9'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>i</name> += (*<name>string</name> - '0')</expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>

        <return>return <expr>(<name>float</name>)<name>i</name> / 1000.0f</expr>;</return>
    }</block></then></if>

    <return>return <expr>0.0f</expr>;</return>
}</block></function>

<comment type="block">/*
 * Get a single mime type entry --- one media type and parameters;
 * enter the values we recognize into the argument accept_rec
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>get_entry</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>accept_rec</name> *</type><name>result</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>accept_line</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>result</name>-&gt;<name>quality</name></name> = 1.0f</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>level</name></name> = 0.0f</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>result</name>-&gt;<name>charset</name></name> = ""</expr>;</expr_stmt>

    <comment type="block">/*
     * Note that this handles what I gather is the "old format",
     *
     *    Accept: text/html text/plain moo/zot
     *
     * without any compatibility kludges --- if the token after the
     * MIME type begins with a semicolon, we know we're looking at parms,
     * otherwise, we know we aren't.  (So why all the pissing and moaning
     * in the CERN server code?  I must be missing something).
     */</comment>

    <expr_stmt><expr><name><name>result</name>-&gt;<name>name</name></name> = <call><name>ap_get_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>accept_line</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* You want case insensitive,
                                       * you'll *get* case insensitive.
                                       */</comment>

    <comment type="block">/* KLUDGE!!! Default HTML to level 2.0 unless the browser
     * *explicitly* says something else.
     */</comment>

    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"text/html"</expr></argument>)</argument_list></call> &amp;&amp; (<name><name>result</name>-&gt;<name>level</name></name> == 0.0)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>result</name>-&gt;<name>level</name></name> = 2.0f</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>INCLUDES_MAGIC_TYPE</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>result</name>-&gt;<name>level</name></name> = 2.0f</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>INCLUDES_MAGIC_TYPE3</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>result</name>-&gt;<name>level</name></name> = 3.0f</expr>;</expr_stmt>
    }</block></then></if></else></if></else></if>

    <while>while <condition>(<expr>*<name>accept_line</name> == ';'</expr>)</condition> <block>{
        <comment type="block">/* Parameters ... */</comment>

        <decl_stmt><decl><type><name>char</name> *</type><name>parm</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>

        <expr_stmt><expr>++<name>accept_line</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>parm</name> = <call><name>ap_get_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>accept_line</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Look for 'var = value' --- and make sure the var is in lcase. */</comment>

        <for>for (<init><expr><name>cp</name> = <name>parm</name></expr>;</init> <condition><expr>(*<name>cp</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call> &amp;&amp; *<name>cp</name> != '=')</expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>) <block>{
            <expr_stmt><expr>*<name>cp</name> = <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <if>if <condition>(<expr>!*<name>cp</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>           <comment type="block">/* No '='; just ignore it. */</comment>
        }</block></then></if>

        <expr_stmt><expr>*<name>cp</name>++ = '\0'</expr>;</expr_stmt>           <comment type="block">/* Delimit var */</comment>
        <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call> || *<name>cp</name> == '='</expr>)</condition> <block>{
            <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr>*<name>cp</name> == '"'</expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
            <for>for (<init><expr><name>end</name> = <name>cp</name></expr>;</init>
                 <condition><expr>(*<name>end</name> &amp;&amp; *<name>end</name> != '\n' &amp;&amp; *<name>end</name> != '\r' &amp;&amp; *<name>end</name> != '\"')</expr>;</condition>
                 <incr><expr><name>end</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
        }</block></then>
        <else>else <block>{
            <for>for (<init><expr><name>end</name> = <name>cp</name></expr>;</init> <condition><expr>(*<name>end</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call>)</expr>;</condition> <incr><expr><name>end</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
        }</block></else></if>
        <if>if <condition>(<expr>*<name>end</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>end</name> = '\0'</expr>;</expr_stmt>        <comment type="block">/* strip ending quote or return */</comment>
        }</block></then></if>
        <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>parm</name><index>[<expr>0</expr>]</index></name> == 'q'
            &amp;&amp; (<name><name>parm</name><index>[<expr>1</expr>]</index></name> == '\0' || (<name><name>parm</name><index>[<expr>1</expr>]</index></name> == 's' &amp;&amp; <name><name>parm</name><index>[<expr>2</expr>]</index></name> == '\0'))</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>result</name>-&gt;<name>quality</name></name> = <call><name>atoq</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>parm</name><index>[<expr>0</expr>]</index></name> == 'l' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr>&amp;<name><name>parm</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>"evel"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>result</name>-&gt;<name>level</name></name> = (<name>float</name>)<call><name>atoi</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>parm</name></expr></argument>, <argument><expr>"charset"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>result</name>-&gt;<name>charset</name></name> = <name>cp</name></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if>
    }</block></while>

    <if>if <condition>(<expr>*<name>accept_line</name> == ','</expr>)</condition><then> <block>{
        <expr_stmt><expr>++<name>accept_line</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>accept_line</name></expr>;</return>
}</block></function>

<comment type="block">/*****************************************************************
 *
 * Dealing with header lines ...
 *
 * Accept, Accept-Charset, Accept-Language and Accept-Encoding
 * are handled by do_header_line() - they all have the same
 * basic structure of a list of items of the format
 *    name; q=N; charset=TEXT
 *
 * where charset is only valid in Accept.
 */</comment>

<function><type><specifier>static</specifier> <name>apr_array_header_t</name> *</type><name>do_header_line</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>accept_line</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>accept_recs</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>accept_line</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>accept_recs</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>40</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>accept_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr>*<name>accept_line</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>accept_rec</name> *</type><name>new</name> <init>= <expr>(<name>accept_rec</name> *) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>accept_recs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>accept_line</name> = <call><name>get_entry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>new</name></expr></argument>, <argument><expr><name>accept_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>accept_recs</name></expr>;</return>
}</block></function>

<comment type="block">/* Given the text of the Content-Languages: line from the var map file,
 * return an array containing the languages of this variant
 */</comment>

<function><type><specifier>static</specifier> <name>apr_array_header_t</name> *</type><name>do_languages_line</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                             <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>lang_line</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>lang_recs</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>lang_line</name></expr>)</condition><then> <block>{
        <return>return <expr><name>lang_recs</name></expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr>**<name>lang_line</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>char</name> **</type><name>new</name> <init>= <expr>(<name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>lang_recs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr>*<name>new</name> = <call><name>ap_get_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>lang_line</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr>*<name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>**<name>lang_line</name> == ',' || **<name>lang_line</name> == ';'</expr>)</condition><then> <block>{
            <expr_stmt><expr>++(*<name>lang_line</name>)</expr>;</expr_stmt>
        }</block></then></if>
    }</block></while>

    <return>return <expr><name>lang_recs</name></expr>;</return>
}</block></function>

<comment type="block">/*****************************************************************
 *
 * Handling header lines from clients...
 */</comment>

<function><type><specifier>static</specifier> <name>negotiation_state</name> *</type><name>parse_accept_headers</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>negotiation_state</name> *</type><name>new</name> <init>=
        <expr>(<name>negotiation_state</name> *) <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>negotiation_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>accept_rec</name> *</type><name>elts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>hdrs</name> <init>= <expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>new</name>-&gt;<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>conf</name></name> = (<name>neg_dir_config</name> *)<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                       <argument><expr>&amp;<name>negotiation_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>new</name>-&gt;<name>dir_name</name></name> = <call><name>ap_make_dirstr_parent</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>new</name>-&gt;<name>accepts</name></name> = <call><name>do_header_line</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>, <argument><expr>"Accept"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* calculate new-&gt;accept_q value */</comment>
    <if>if <condition>(<expr><name><name>new</name>-&gt;<name>accepts</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>elts</name> = (<name>accept_rec</name> *) <name><name>new</name>-&gt;<name>accepts</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>new</name>-&gt;<name>accepts</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>elts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>quality</name> &lt; 1.0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>new</name>-&gt;<name>accept_q</name></name> = 1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <expr_stmt><expr><name><name>new</name>-&gt;<name>accept_encodings</name></name> =
        <call><name>do_header_line</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>, <argument><expr>"Accept-Encoding"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>accept_langs</name></name> =
        <call><name>do_header_line</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>, <argument><expr>"Accept-Language"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>accept_charsets</name></name> =
        <call><name>do_header_line</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>, <argument><expr>"Accept-Charset"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* This is possibly overkill for some servers, heck, we have
     * only 33 index.html variants in docs/docroot (today).
     * Make this configurable?
     */</comment>
    <expr_stmt><expr><name><name>new</name>-&gt;<name>avail_vars</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>40</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>var_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>new</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>parse_negotiate_header</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>negotiate</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Negotiate"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>tok</name></decl>;</decl_stmt>

    <comment type="block">/* First, default to no TCN, no Alternates, and the original Apache
     * negotiation algorithm with fiddles for broken browser configs.
     *
     * To save network bandwidth, we do not configure to send an
     * Alternates header to the user agent by default.  User
     * agents that want an Alternates header for agent-driven
     * negotiation will have to request it by sending an
     * appropriate Negotiate header.
     */</comment>
    <expr_stmt><expr><name><name>neg</name>-&gt;<name>ua_supports_trans</name></name>   = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neg</name>-&gt;<name>send_alternates</name></name>     = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neg</name>-&gt;<name>may_choose</name></name>          = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neg</name>-&gt;<name>use_rvsa</name></name>            = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>negotiate</name></expr>)</condition><then>
        <return>return;</return></then></if>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>negotiate</name></expr></argument>, <argument><expr>"trans"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* Lynx 2.7 and 2.8 send 'negotiate: trans' even though they
         * do not support transparent content negotiation, so for Lynx we
         * ignore the negotiate header when its contents are exactly "trans".
         * If future versions of Lynx ever need to say 'negotiate: trans',
         * they can send the equivalent 'negotiate: trans, trans' instead
         * to avoid triggering the workaround below.
         */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ua</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"User-Agent"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ua</name> &amp;&amp; (<call><name>strncmp</name><argument_list>(<argument><expr><name>ua</name></expr></argument>, <argument><expr>"Lynx"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
            <return>return;</return></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>neg</name>-&gt;<name>may_choose</name></name> = 0</expr>;</expr_stmt>  <comment type="block">/* An empty Negotiate would require 300 response */</comment>

    <while>while <condition>(<expr>(<name>tok</name> = <call><name>ap_get_list_item</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>negotiate</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{

        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>"trans"</expr></argument>)</argument_list></call> == 0 ||
            <call><name>strcmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>"vlist"</expr></argument>)</argument_list></call> == 0 ||
            <call><name>strcmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>"guess-small"</expr></argument>)</argument_list></call> == 0 ||
            <call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>tok</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> ||
            <call><name>strcmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{

            <comment type="block">/* The user agent supports transparent negotiation */</comment>
            <expr_stmt><expr><name><name>neg</name>-&gt;<name>ua_supports_trans</name></name> = 1</expr>;</expr_stmt>

            <comment type="block">/* Send-alternates could be configurable, but note
             * that it must be 1 if we have 'vlist' in the
             * negotiate header.
             */</comment>
            <expr_stmt><expr><name><name>neg</name>-&gt;<name>send_alternates</name></name> = 1</expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr>"1.0"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <comment type="block">/* we may use the RVSA/1.0 algorithm, configure for it */</comment>
                <expr_stmt><expr><name><name>neg</name>-&gt;<name>may_choose</name></name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>neg</name>-&gt;<name>use_rvsa</name></name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>tok</name><index>[<expr>0</expr>]</index></name> == '*'</expr>)</condition><then> <block>{
                <comment type="block">/* we may use any variant selection algorithm, configure
                 * to use the Apache algorithm
                 */</comment>
                <expr_stmt><expr><name><name>neg</name>-&gt;<name>may_choose</name></name> = 1</expr>;</expr_stmt>

                <comment type="block">/* We disable header fiddles on the assumption that a
                 * client sending Negotiate knows how to send correct
                 * headers which don't need fiddling.
                 */</comment>
                <expr_stmt><expr><name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name> = 1</expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></then></if>
    }</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEG_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00680</expr></argument>)</argument_list></call>
            "dont_fiddle_headers=%d use_rvsa=%d ua_supports_trans=%d "
            "send_alternates=%d, may_choose=%d"</expr></argument>,
            <argument><expr><name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>use_rvsa</name></name></expr></argument>,
            <argument><expr><name><name>neg</name>-&gt;<name>ua_supports_trans</name></name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>send_alternates</name></name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>may_choose</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

}</block></function>

<comment type="block">/* Sometimes clients will give us no Accept info at all; this routine sets
 * up the standard default for that case, and also arranges for us to be
 * willing to run a CGI script if we find one.  (In fact, we set up to
 * dramatically prefer CGI scripts in cases where that's appropriate,
 * e.g., POST or when URI includes query args or extra path info).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>maybe_add_default_accepts</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>,
                                      <param><decl><type><name>int</name></type> <name>prefer_scripts</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>accept_rec</name> *</type><name>new_accept</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>accepts</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>neg</name>-&gt;<name>accepts</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>accept_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>new_accept</name> = (<name>accept_rec</name> *) <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>accepts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>new_accept</name>-&gt;<name>name</name></name> = "*/*"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_accept</name>-&gt;<name>quality</name></name> = 1.0f</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>new_accept</name>-&gt;<name>level</name></name> = 0.0f</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>new_accept</name> = (<name>accept_rec</name> *) <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>accepts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>new_accept</name>-&gt;<name>name</name></name> = <name>CGI_MAGIC_TYPE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>use_rvsa</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>new_accept</name>-&gt;<name>quality</name></name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>new_accept</name>-&gt;<name>quality</name></name> = <name>prefer_scripts</name> ? 2.0f : 0.001f</expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name><name>new_accept</name>-&gt;<name>level</name></name> = 0.0f</expr>;</expr_stmt>
}</block></function>

<comment type="block">/*****************************************************************
 *
 * Parsing type-map files, in Roy's meta/http format augmented with
 * #-comments.
 */</comment>

<comment type="block">/* Reading RFC822-style header lines, ignoring #-comments and
 * handling continuations.
 */</comment>

<enum>enum <name>header_state</name> <block>{
    <decl><name>header_eof</name></decl>, <decl><name>header_seen</name></decl>, <decl><name>header_sep</name></decl>
}</block>;</enum>

<enum><specifier>static</specifier> enum <name>header_state</name> <name>get_header_line</name><expr_stmt><expr>(<name>char</name> *<name>buffer</name>, <name>int</name> <name>len</name>, <name>apr_file_t</name> *<name>map</name>)
<block>{
    <expr><name>char</name> *<name>buf_end</name> = <name>buffer</name> + <name>len</name></expr>;
    <expr><name>char</name> *<name>cp</name></expr>;
    <expr><name>char</name> <name>c</name></expr>;

    <comment type="block">/* Get a noncommented line */</comment>

    <do>do <block>{
        <if>if <condition>(<expr><call><name>apr_file_gets</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>MAX_STRING_LEN</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>header_eof</name></expr>;</return>
        <expr_stmt/></block></then></if></block></do>}</block></expr></expr_stmt></enum>
    } while <expr_stmt><expr>(<name><name>buffer</name><index>[<expr>0</expr>]</index></name> == '#')</expr>;</expr_stmt>

    <comment type="block">/* If blank, just return it --- this ends information on this variant */</comment>

    <for>for (<init><expr><name>cp</name> = <name>buffer</name></expr>;</init> <condition><expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>) <block>{
        <continue>continue;</continue>
    }</block></for>

    <if>if <condition>(<expr>*<name>cp</name> == '\0'</expr>)</condition><then> <block>{
        <return>return <expr><name>header_sep</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If non-blank, go looking for header lines, but note that we still
     * have to treat comments specially...
     */</comment>

    <expr_stmt><expr><name>cp</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We need to shortcut the rest of this block following the Body:
     * tag - we will not look for continutation after this line.
     */</comment>
    <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"Body:"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>header_seen</name></expr>;</return></then></if>

    <while>while <condition>(<expr><call><name>apr_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call> != <name>APR_EOF</name></expr>)</condition> <block>{
        <if>if <condition>(<expr><name>c</name> == '#'</expr>)</condition><then> <block>{
            <comment type="block">/* Comment line */</comment>
            <while>while <condition>(<expr><call><name>apr_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call> != <name>APR_EOF</name> &amp;&amp; <name>c</name> != '\n'</expr>)</condition> <block>{
                <continue>continue;</continue>
            }</block></while>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Leading whitespace.  POSSIBLE continuation line
             * Also, possibly blank --- if so, we ungetc() the final newline
             * so that we will pick up the blank line the next time 'round.
             */</comment>

            <while>while <condition>(<expr><name>c</name> != '\n' &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <if>if <condition>(<expr><call><name>apr_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
            }</block></while>

            <expr_stmt><expr><call><name>apr_file_ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
                <return>return <expr><name>header_seen</name></expr>;</return>     <comment type="block">/* Blank line */</comment>
            }</block></then></if>

            <comment type="block">/* Continuation */</comment>

            <while>while <condition>(   <expr><name>cp</name> &lt; <name>buf_end</name> - 2
                   &amp;&amp; (<call><name>apr_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call>) != <name>APR_EOF</name>
                   &amp;&amp; <name>c</name> != '\n'</expr>)</condition> <block>{
                <expr_stmt><expr>*<name>cp</name>++ = <name>c</name></expr>;</expr_stmt>
            }</block></while>

            <expr_stmt><expr>*<name>cp</name>++ = '\n'</expr>;</expr_stmt>
            <expr_stmt><expr>*<name>cp</name> = '\0'</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{

            <comment type="block">/* Line beginning with something other than whitespace */</comment>

            <expr_stmt><expr><call><name>apr_file_ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>header_seen</name></expr>;</return>
        }</block></else></if></else></if>
    }</block></while>

    <return>return <expr><name>header_seen</name></expr>;</return>
}

static <function><type><name>apr_off_t</name></type> <name>get_body</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tag</name></decl></param>,
                          <param><decl><type><name>apr_file_t</name> *</type><name>map</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>endbody</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bodylen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>pos</name></decl>;</decl_stmt>


    <comment type="block">/* We are at the first character following a body:tag\n entry
     * Suck in the body, then backspace to the first char after the
     * closing tag entry.  If we fail to read, find the tag or back
     * up then we have a hosed file, so give up already
     */</comment>
    <expr_stmt><expr>--*<name>len</name></expr>;</expr_stmt> <comment type="block">/* Reserve space for '\0' */</comment>
    <if>if <condition>(<expr><call><name>apr_file_read</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name><name>buffer</name><index>[<expr>*<name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

    <expr_stmt><expr><name>endbody</name> = <call><name>ap_strstr</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>endbody</name></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>bodylen</name> = <name>endbody</name> - <name>buffer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>endbody</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Skip all the trailing cruft after the end tag to the next line */</comment>
    <while>while <condition>(<expr>*<name>endbody</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>*<name>endbody</name> == '\n'</expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>endbody</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr>++<name>endbody</name></expr>;</expr_stmt>
    }</block></while>

    <expr_stmt><expr><name>pos</name> = -<call>(<name>apr_off_t</name>)<argument_list>(<argument><expr>*<name>len</name> - (<name>endbody</name> - <name>buffer</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>apr_file_seek</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>APR_CUR</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Give the caller back the actual body's file offset and length */</comment>
    <expr_stmt><expr>*<name>len</name> = <name>bodylen</name></expr>;</expr_stmt>
    <return>return <expr><name>pos</name> - (<name>endbody</name> - <name>buffer</name>)</expr>;</return>
}</block></function>


<comment type="block">/* Stripping out RFC822 comments */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>strip_paren_comments</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>hdr</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Hmmm... is this correct?  In Roy's latest draft, (comments) can nest! */</comment>
    <comment type="block">/* Nope, it isn't correct.  Fails to handle backslash escape as well.    */</comment>

    <while>while <condition>(<expr>*<name>hdr</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>*<name>hdr</name> == '"'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>hdr</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>hdr</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <return>return;</return>
            }</block></then></if>
            <expr_stmt><expr>++<name>hdr</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>hdr</name> == '('</expr>)</condition><then> <block>{
            <while>while <condition>(<expr>*<name>hdr</name> &amp;&amp; *<name>hdr</name> != ')'</expr>)</condition> <block>{
                <expr_stmt><expr>*<name>hdr</name>++ = ' '</expr>;</expr_stmt>
            }</block></while>

            <if>if <condition>(<expr>*<name>hdr</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>hdr</name>++ = ' '</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>hdr</name></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></while>
}</block></function>

<comment type="block">/* Getting to a header body from the header */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>lcase_header_name_return_body</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>header</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>cp</name> <init>= <expr><name>header</name></expr></init></decl>;</decl_stmt>

    <for>for ( <init>;</init> <condition><expr>*<name>cp</name> &amp;&amp; *<name>cp</name> != ':'</expr> ;</condition> <incr><expr>++<name>cp</name></expr></incr>) <block>{
        <expr_stmt><expr>*<name>cp</name> = <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <if>if <condition>(<expr>!*<name>cp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00681</expr></argument>)</argument_list></call>
                      "Syntax error in type map, no ':' in %s for header %s"</expr></argument>,
                      <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <do>do <block>{
        <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
    }</block> while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

    <if>if <condition>(<expr>!*<name>cp</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00682</expr></argument>)</argument_list></call>
                      "Syntax error in type map --- no header body: %s for %s"</expr></argument>,
                      <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>cp</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_type_map</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>map</name></decl></param>, <param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>,
                         <param><decl><type><name>request_rec</name> *</type><name>rr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>neg</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>map_</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <enum>enum <name>header_state</name> <name>hstate</name>;</enum>
    <decl_stmt><decl><type>struct <name>var_rec</name></type> <name>mime_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>has_content</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>map</name></expr>)</condition><then>
        <expr_stmt><expr><name>map</name> = &amp;<name>map_</name></expr>;</expr_stmt></then></if>

    <comment type="block">/* We are not using multiviews */</comment>
    <expr_stmt><expr><name><name>neg</name>-&gt;<name>count_multiviews_variants</name></name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>status</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>rr</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00683</expr></argument>)</argument_list></call>
                      "cannot access type map file: %s"</expr></argument>, <argument><expr><name><name>rr</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOTDIR</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> || <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>HTTP_NOT_FOUND</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>clean_var_rec</name><argument_list>(<argument><expr>&amp;<name>mime_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>has_content</name> = 0</expr>;</expr_stmt>

    <do>do <block>{
        <expr_stmt><expr><name>hstate</name> = <call><name>get_header_line</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>MAX_STRING_LEN</name></expr></argument>, <argument><expr>*<name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>hstate</name> == <name>header_seen</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>body1</name> <init>= <expr><call><name>lcase_header_name_return_body</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>r</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>body</name></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>body1</name> == <name>NULL</name></expr>)</condition><then> <block>{
                <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><call><name>strip_paren_comments</name><argument_list>(<argument><expr><name>body1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>body</name> = <name>body1</name></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"uri:"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>mime_info</name>.<name>file_name</name></name> = <call><name>ap_get_token</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>body</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"content-type:"</expr></argument>, <argument><expr>13</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type>struct <name>accept_rec</name></type> <name>accept_info</name></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>get_entry</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>accept_info</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>set_mime_fields</name><argument_list>(<argument><expr>&amp;<name>mime_info</name></expr></argument>, <argument><expr>&amp;<name>accept_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>has_content</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"content-length:"</expr></argument>, <argument><expr>15</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>errp</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_off_t</name></type> <name>number</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>body1</name> = <call><name>ap_get_token</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>body</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>number</name></expr></argument>, <argument><expr><name>body1</name></expr></argument>, <argument><expr>&amp;<name>errp</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name>
                    || *<name>errp</name> || <name>number</name> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00684</expr></argument>)</argument_list></call>
                                  "Parse error in type map, Content-Length: "
                                  "'%s' in %s is invalid."</expr></argument>,
                                  <argument><expr><name>body1</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name><name>mime_info</name>.<name>bytes</name></name> = <name>number</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>has_content</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"content-language:"</expr></argument>, <argument><expr>17</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>mime_info</name>.<name>content_languages</name></name> = <call><name>do_languages_line</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>,
                                                                <argument><expr>&amp;<name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>has_content</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"content-encoding:"</expr></argument>, <argument><expr>17</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>mime_info</name>.<name>content_encoding</name></name> = <call><name>ap_get_token</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>body</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>has_content</name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"description:"</expr></argument>, <argument><expr>12</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>desc</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>

                <for>for (<init><expr><name>cp</name> = <name>desc</name></expr>;</init> <condition><expr>*<name>cp</name></expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>) <block>{
                    <if>if <condition>(<expr>*<name>cp</name>=='\n'</expr>)</condition><then> <expr_stmt><expr>*<name>cp</name>=' '</expr>;</expr_stmt></then></if>
                }</block></for>
                <if>if <condition>(<expr><name>cp</name>&gt;<name>desc</name></expr>)</condition><then> <expr_stmt><expr>*(<name>cp</name>-1)=0</expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name><name>mime_info</name>.<name>description</name></name> = <name>desc</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"body:"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>tag</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> *</type><name>eol</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name>MAX_STRING_LEN</name></expr></init></decl>;</decl_stmt>
                <while>while <condition>(<expr>--<name>eol</name> &gt;= <name>tag</name> &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>eol</name></expr></argument>)</argument_list></call></expr>)</condition>
                    <expr_stmt><expr>*<name>eol</name> = '\0'</expr>;</expr_stmt></while>
                <if>if <condition>(<expr>(<name><name>mime_info</name>.<name>body</name></name> = <call><name>get_body</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr>*<name>map</name></expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00685</expr></argument>)</argument_list></call>
                                  "Syntax error in type map, no end tag '%s'"
                                  "found in %s for Body: content."</expr></argument>,
                                  <argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name><name>mime_info</name>.<name>bytes</name></name> = <name>len</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>mime_info</name>.<name>file_name</name></name> = <call><name>apr_filepath_name_get</name><argument_list>(<argument><expr><name><name>rr</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if></else></if></else></if></else></if></else></if></else></if>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr>*<name><name>mime_info</name>.<name>file_name</name></name> &amp;&amp; <name>has_content</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>void</name> *</type><name>new_var</name> <init>= <expr><call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>avail_vars</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_var</name></expr></argument>, <argument><expr>(<name>void</name> *) &amp;<name>mime_info</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>var_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name>clean_var_rec</name><argument_list>(<argument><expr>&amp;<name>mime_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>has_content</name> = 0</expr>;</expr_stmt>
        }</block></else></if>
    }</block> while <condition>(<expr><name>hstate</name> != <name>header_eof</name></expr>)</condition>;</do>

    <if>if <condition>(<expr><name>map_</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>map_</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>set_vlist_validator</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/* Sort function used by read_types_multi. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>variantsortf</name><parameter_list>(<param><decl><type><name>var_rec</name> *</type><name>a</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* First key is the source quality, sort in descending order. */</comment>

    <comment type="block">/* XXX: note that we currently implement no method of setting the
     * source quality for multiviews variants, so we are always comparing
     * 1.0 to 1.0 for now
     */</comment>
    <if>if <condition>(<expr><name><name>a</name>-&gt;<name>source_quality</name></name> &lt; <name><name>b</name>-&gt;<name>source_quality</name></name></expr>)</condition><then>
        <return>return <expr>1</expr>;</return></then></if>
    <if>if <condition>(<expr><name><name>a</name>-&gt;<name>source_quality</name></name> &gt; <name><name>b</name>-&gt;<name>source_quality</name></name></expr>)</condition><then>
        <return>return <expr>-1</expr>;</return></then></if>

    <comment type="block">/* Second key is the variant name */</comment>
    <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>file_name</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>file_name</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*****************************************************************
 *
 * Same as read_type_map, except we use a filtered directory listing
 * as the map...
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_types_multi</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>neg</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> *</type><name>filp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>prefix_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_dir_t</name> *</type><name>dirp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>dirent</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>var_rec</name></type> <name>mime_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>accept_rec</name></type> <name>accept_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>new_var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>anymatch</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>clean_var_rec</name><argument_list>(<argument><expr>&amp;<name>mime_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proxyreq</name></name> || !<name><name>r</name>-&gt;<name>filename</name></name>
                    || !<call><name>ap_os_is_path_absolute</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Only absolute paths here */</comment>
    <if>if <condition>(<expr>!(<name>filp</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>++<name>filp</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>prefix_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>filp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>status</name> = <call><name>apr_dir_open</name><argument_list>(<argument><expr>&amp;<name>dirp</name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>dir_name</name></name></expr></argument>,
                               <argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00686</expr></argument>)</argument_list></call>
                    "cannot read directory for multi: %s"</expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>dir_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr><call><name>apr_dir_read</name><argument_list>(<argument><expr>&amp;<name>dirent</name></expr></argument>, <argument><expr><name>APR_FINFO_DIRENT</name></expr></argument>, <argument><expr><name>dirp</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>exception_list</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>request_rec</name> *</type><name>sub_req</name></decl>;</decl_stmt>

        <comment type="block">/* Do we have a match? */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASE_BLIND_FILESYSTEM</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>filp</name></expr></argument>, <argument><expr><name>prefix_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>, <argument><expr><name>filp</name></expr></argument>, <argument><expr><name>prefix_len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <continue>continue;</continue>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>dirent</name>.<name>name</name><index>[<expr><name>prefix_len</name></expr>]</index></name> != '.'</expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* Don't negotiate directories and other unusual files
         * Really shouldn't see anything but DIR/LNK/REG here,
         * and we aught to discover if the LNK was interesting.
         *
         * Of course, this only helps platforms that capture the
         * the filetype in apr_dir_read(), which most can once
         * they are optimized with some magic [it's known to the
         * dirent, not associated to the inode, on most FS's.]
         */</comment>
        <if>if <condition>(<expr>(<name><name>dirent</name>.<name>valid</name></name> &amp; <name>APR_FINFO_TYPE</name>) &amp;&amp; (<name><name>dirent</name>.<name>filetype</name></name> == <name>APR_DIR</name>)</expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <comment type="block">/* Ok, something's here.  Maybe nothing useful.  Remember that
         * we tried, if we completely fail, so we can reject the request!
         */</comment>
        <expr_stmt><expr><name>anymatch</name> = 1</expr>;</expr_stmt>

        <comment type="block">/* See if it's something which we have access to, and which
         * has a known type and encoding.
         */</comment>
        <expr_stmt><expr><name>sub_req</name> = <call><name>ap_sub_req_lookup_dirent</name><argument_list>(<argument><expr>&amp;<name>dirent</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>AP_SUBREQ_MERGE_ARGS</name></expr></argument>,
                                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Double check, we still don't multi-resolve non-ordinary files
         */</comment>
        <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>finfo</name>.<name>filetype</name></name> != <name>APR_REG</name></expr>)</condition><then> <block>{
            <comment type="block">/* XXX sub req not destroyed -- may be a bug/unintentional ? */</comment>
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* If it has a handler, we'll pretend it's a CGI script,
         * since that's a good indication of the sort of thing it
         * might be doing.
         */</comment>
        <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>handler</name></name> &amp;&amp; !<name><name>sub_req</name>-&gt;<name>content_type</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>sub_req</name></expr></argument>, <argument><expr><name>CGI_MAGIC_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/*
         * mod_mime will _always_ provide us the base name in the
         * ap-mime-exception-list, if it processed anything.  If
         * this list is empty, give up immediately, there was
         * nothing interesting.  For example, looking at the files
         * readme.txt and readme.foo, we will throw away .foo if
         * it's an insignificant file (e.g. did not identify a
         * language, charset, encoding, content type or handler,)
         */</comment>
        <expr_stmt><expr><name>exception_list</name> =
            (<name>apr_array_header_t</name> *)<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>sub_req</name>-&gt;<name>notes</name></name></expr></argument>,
                                                <argument><expr>"ap-mime-exceptions-list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>exception_list</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>sub_req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* Each unregonized bit better match our base name, in sequence.
         * A test of index.html.foo will match index.foo or index.html.foo,
         * but it will never transpose the segments and allow index.foo.html
         * because that would introduce too much CPU consumption.  Better that
         * we don't attempt a many-to-many match here.
         */</comment>
        <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>nexcept</name> <init>= <expr><name><name>exception_list</name>-&gt;<name>nelts</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> **</type><name>cur_except</name> <init>= <expr>(<name>char</name>**)<name><name>exception_list</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> *</type><name>segstart</name> <init>= <expr><name>filp</name></expr></init>, *<name>segend</name></decl>, <decl><type ref="prev"/><name>saveend</name></decl>;</decl_stmt>

            <while>while <condition>(<expr>*<name>segstart</name> &amp;&amp; <name>nexcept</name></expr>)</condition> <block>{
                <if>if <condition>(<expr>!(<name>segend</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>segstart</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call>)</expr>)</condition><then>
                    <expr_stmt><expr><name>segend</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>segstart</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                <expr_stmt><expr><name>saveend</name> = *<name>segend</name></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>segend</name> = '\0'</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CASE_BLIND_FILESYSTEM</name></cpp:ifdef>
                <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>segstart</name></expr></argument>, <argument><expr>*<name>cur_except</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>segstart</name></expr></argument>, <argument><expr>*<name>cur_except</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                    <expr_stmt><expr>--<name>nexcept</name></expr>;</expr_stmt>
                    <expr_stmt><expr>++<name>cur_except</name></expr>;</expr_stmt>
                }</block></then></if>

                <if>if <condition>(<expr>!<name>saveend</name></expr>)</condition><then>
                    <break>break;</break></then></if>

                <expr_stmt><expr>*<name>segend</name> = <name>saveend</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>segstart</name> = <name>segend</name> + 1</expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>nexcept</name></expr>)</condition><then> <block>{
                <comment type="block">/* Something you don't know is, something you don't know...
                 */</comment>
                <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>sub_req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
        }</block></while>

        <comment type="block">/*
         * If we failed the subrequest, or don't
         * know what we are serving, then continue.
         */</comment>
        <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>status</name></name> != <name>HTTP_OK</name> || (!<name><name>sub_req</name>-&gt;<name>content_type</name></name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>sub_req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* If it's a map file, we use that instead of the map
         * we're building...
         */</comment>
        <if>if <condition>(<expr>((<name><name>sub_req</name>-&gt;<name>content_type</name></name>) &amp;&amp;
             !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>sub_req</name>-&gt;<name>content_type</name></name></expr></argument>, <argument><expr><name>MAP_FILE_MAGIC_TYPE</name></expr></argument>)</argument_list></call>) ||
            ((<name><name>sub_req</name>-&gt;<name>handler</name></name>) &amp;&amp;
             !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>sub_req</name>-&gt;<name>handler</name></name></expr></argument>, <argument><expr>"type-map"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{

            <expr_stmt><expr><call><name>apr_dir_close</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name> = 0</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>status</name></name> != <name>HTTP_OK</name></expr>)</condition><then> <block>{
                <return>return <expr><name><name>sub_req</name>-&gt;<name>status</name></name></expr>;</return>
            }</block></then></if>
            <return>return <expr><call><name>read_type_map</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>sub_req</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Have reasonable variant --- gather notes. */</comment>

        <expr_stmt><expr><name><name>mime_info</name>.<name>sub_req</name></name> = <name>sub_req</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>mime_info</name>.<name>file_name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>dirent</name>.<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>content_encoding</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>mime_info</name>.<name>content_encoding</name></name> = <name><name>sub_req</name>-&gt;<name>content_encoding</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>content_languages</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>mime_info</name>.<name>content_languages</name></name> = <name><name>sub_req</name>-&gt;<name>content_languages</name></name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>get_entry</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>accept_info</name></expr></argument>, <argument><expr><name><name>sub_req</name>-&gt;<name>content_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>set_mime_fields</name><argument_list>(<argument><expr>&amp;<name>mime_info</name></expr></argument>, <argument><expr>&amp;<name>accept_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>new_var</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>avail_vars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_var</name></expr></argument>, <argument><expr>(<name>void</name> *) &amp;<name>mime_info</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>var_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>neg</name>-&gt;<name>count_multiviews_variants</name></name>++</expr>;</expr_stmt>

        <expr_stmt><expr><call><name>clean_var_rec</name><argument_list>(<argument><expr>&amp;<name>mime_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>

    <expr_stmt><expr><call><name>apr_dir_close</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We found some file names that matched.  None could be served.
     * Rather than fall out to autoindex or some other mapper, this
     * request must die.
     */</comment>
    <if>if <condition>(<expr><name>anymatch</name> &amp;&amp; !<name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00687</expr></argument>)</argument_list></call>
                      "Negotiation: discovered file(s) matching request: %s"
                      " (None could be negotiated)."</expr></argument>,
                      <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_NOT_FOUND</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>set_vlist_validator</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Sort the variants into a canonical order.  The negotiation
     * result sometimes depends on the order of the variants.  By
     * sorting the variants into a canonical order, rather than using
     * the order in which readdir() happens to return them, we ensure
     * that the negotiation result will be consistent over filesystem
     * backup/restores and over all mirror sites.
     */</comment>

    <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr>(<name>void</name> *) <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr></argument>,
          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>var_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>(<call><call><name>int</name> <argument_list>(<argument><expr>*</expr></argument>)</argument_list></call><argument_list>(<argument><expr>const <name>void</name> *</expr></argument>, <argument><expr>const <name>void</name> *</expr></argument>)</argument_list></call>) <name>variantsortf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></then></if>


<comment type="block">/*****************************************************************
 * And now for the code you've been waiting for... actually
 * finding a match to the client's requirements.
 */</comment>

<comment type="block">/* Matching MIME types ... the star/star and foo/star commenting conventions
 * are implemented here.  (You know what I mean by star/star, but just
 * try mentioning those three characters in a C comment).  Using strcmp()
 * is legit, because everything has already been smashed to lowercase.
 *
 * Note also that if we get an exact match on the media type, we update
 * level_matched for use in level_cmp below...
 *
 * We also give a value for mime_stars, which is used later. It should
 * be 1 for star/star, 2 for type/star and 3 for type/subtype.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mime_match</name><parameter_list>(<param><decl><type><name>accept_rec</name> *</type><name>accept_r</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>avail</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>accept_type</name> <init>= <expr><name><name>accept_r</name>-&gt;<name>name</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>avail_type</name> <init>= <expr><name><name>avail</name>-&gt;<name>mime_type</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>accept_type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>len</name> == 1 &amp;&amp; <name><name>accept_type</name><index>[<expr>0</expr>]</index></name> == '*')
            || (<name>len</name> == 3 &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name>accept_type</name></expr></argument>, <argument><expr>"*/*"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="block">/* Anything matches star or star/star */</comment>
        <if>if <condition>(<expr><name><name>avail</name>-&gt;<name>mime_stars</name></name> &lt; 1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>avail</name>-&gt;<name>mime_stars</name></name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr>1</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>len</name> &gt; 2 &amp;&amp; <name><name>accept_type</name><index>[<expr><name>len</name> - 2</expr>]</index></name> == '/'
                     &amp;&amp; <name><name>accept_type</name><index>[<expr><name>len</name> - 1</expr>]</index></name> == '*'
                     &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name>accept_type</name></expr></argument>, <argument><expr><name>avail_type</name></expr></argument>, <argument><expr><name>len</name> - 2</expr></argument>)</argument_list></call>
                     &amp;&amp; <name><name>avail_type</name><index>[<expr><name>len</name> - 2</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
        <comment type="block">/* Any subtype matches for type/star */</comment>
        <if>if <condition>(<expr><name><name>avail</name>-&gt;<name>mime_stars</name></name> &lt; 2</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>avail</name>-&gt;<name>mime_stars</name></name> = 2</expr>;</expr_stmt>
        }</block></then></if>
        <return>return <expr>1</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>accept_type</name></expr></argument>, <argument><expr><name>avail_type</name></expr></argument>)</argument_list></call>
             || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>accept_type</name></expr></argument>, <argument><expr>"text/html"</expr></argument>)</argument_list></call>
                 &amp;&amp; (!<call><name>strcmp</name><argument_list>(<argument><expr><name>avail_type</name></expr></argument>, <argument><expr><name>INCLUDES_MAGIC_TYPE</name></expr></argument>)</argument_list></call>
                     || !<call><name>strcmp</name><argument_list>(<argument><expr><name>avail_type</name></expr></argument>, <argument><expr><name>INCLUDES_MAGIC_TYPE3</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>accept_r</name>-&gt;<name>level</name></name> &gt;= <name><name>avail</name>-&gt;<name>level</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>avail</name>-&gt;<name>level_matched</name></name> = <name><name>avail</name>-&gt;<name>level</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>avail</name>-&gt;<name>mime_stars</name></name> = 3</expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if></else></if></else></if>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/* This code implements a piece of the tie-breaking algorithm between
 * variants of equal quality.  This piece is the treatment of variants
 * of the same base media type, but different levels.  What we want to
 * return is the variant at the highest level that the client explicitly
 * claimed to accept.
 *
 * If all the variants available are at a higher level than that, or if
 * the client didn't say anything specific about this media type at all
 * and these variants just got in on a wildcard, we prefer the lowest
 * level, on grounds that that's the one that the client is least likely
 * to choke on.
 *
 * (This is all motivated by treatment of levels in HTML --- we only
 * want to give level 3 to browsers that explicitly ask for it; browsers
 * that don't, including HTTP/0.9 browsers that only get the implicit
 * "Accept: * / *" [space added to avoid confusing cpp --- no, that
 * syntax doesn't really work] should get HTML2 if available).
 *
 * (Note that this code only comes into play when we are choosing among
 * variants of equal quality, where the draft standard gives us a fair
 * bit of leeway about what to do.  It ain't specified by the standard;
 * rather, it is a choice made by this server about what to do in cases
 * where the standard does not specify a unique course of action).
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>level_cmp</name><parameter_list>(<param><decl><type><name>var_rec</name> *</type><name>var1</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>var2</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Levels are only comparable between matching media types */</comment>

    <if>if <condition>(<expr><name><name>var1</name>-&gt;<name>is_pseudo_html</name></name> &amp;&amp; !<name><name>var2</name>-&gt;<name>is_pseudo_html</name></name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>var1</name>-&gt;<name>is_pseudo_html</name></name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>var1</name>-&gt;<name>mime_type</name></name></expr></argument>, <argument><expr><name><name>var2</name>-&gt;<name>mime_type</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <comment type="block">/* The result of the above if statements is that, if we get to
     * here, both variants have the same mime_type or both are
     * pseudo-html.
     */</comment>

    <comment type="block">/* Take highest level that matched, if either did match. */</comment>

    <if>if <condition>(<expr><name><name>var1</name>-&gt;<name>level_matched</name></name> &gt; <name><name>var2</name>-&gt;<name>level_matched</name></name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>var1</name>-&gt;<name>level_matched</name></name> &lt; <name><name>var2</name>-&gt;<name>level_matched</name></name></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Neither matched.  Take lowest level, if there's a difference. */</comment>

    <if>if <condition>(<expr><name><name>var1</name>-&gt;<name>level</name></name> &lt; <name><name>var2</name>-&gt;<name>level</name></name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>var1</name>-&gt;<name>level</name></name> &gt; <name><name>var2</name>-&gt;<name>level</name></name></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Tied */</comment>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Finding languages.  The main entry point is set_language_quality()
 * which is called for each variant. It sets two elements in the
 * variant record:
 *    language_quality  - the 'q' value of the 'best' matching language
 *                        from Accept-Language: header (HTTP/1.1)
 *    lang_index    -     Non-negotiated language priority, using
 *                        position of language on the Accept-Language:
 *                        header, if present, else LanguagePriority
 *                        directive order.
 *
 * When we do the variant checking for best variant, we use language
 * quality first, and if a tie, language_index next (this only applies
 * when _not_ using the RVSA/1.0 algorithm). If using the RVSA/1.0
 * algorithm, lang_index is never used.
 *
 * set_language_quality() calls find_lang_index() and find_default_index()
 * to set lang_index.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_lang_index</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>accept_langs</name></decl></param>, <param><decl><type><name>char</name> *</type><name>lang</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>alang</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>lang</name> || !<name>accept_langs</name></expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>alang</name> = (const <name>char</name> **) <name><name>accept_langs</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>accept_langs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr>*<name>alang</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr>*<name>alang</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>i</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>alang</name> += (<name><name>accept_langs</name>-&gt;<name>elt_size</name></name> / <sizeof>sizeof<argument_list>(<argument><expr><name>char</name>*</expr></argument>)</argument_list></sizeof>)</expr>;</expr_stmt>
    }</block></for>

    <return>return <expr>-1</expr>;</return>
}</block></function>

<comment type="block">/* set_default_lang_quality() sets the quality we apply to variants
 * which have no language assigned to them. If none of the variants
 * have a language, we are not negotiating on language, so all are
 * acceptable, and we set the default q value to 1.0. However if
 * some of the variants have languages, we set this default to 0.0001.
 * The value of this default will be applied to all variants with
 * no explicit language -- which will have the effect of making them
 * acceptable, but only if no variants with an explicit language
 * are acceptable. The default q value set here is assigned to variants
 * with no language type in set_language_quality().
 *
 * Note that if using the RVSA/1.0 algorithm, we don't use this
 * fiddle.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_default_lang_quality</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>var_rec</name> *</type><name>avail_recs</name> <init>= <expr>(<name>var_rec</name> *) <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>var_rec</name> *</type><name>variant</name> <init>= <expr>&amp;<name><name>avail_recs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>content_languages</name></name> &amp;&amp;
                <name><name>variant</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>neg</name>-&gt;<name>default_lang_quality</name></name> = 0.0001f</expr>;</expr_stmt>
                <return>return;</return>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <expr_stmt><expr><name><name>neg</name>-&gt;<name>default_lang_quality</name></name> = 1.0f</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Set the language_quality value in the variant record. Also
 * assigns lang_index for ForceLanguagePriority.
 *
 * To find the language_quality value, we look for the 'q' value
 * of the 'best' matching language on the Accept-Language
 * header. The 'best' match is the language on Accept-Language
 * header which matches the language of this variant either fully,
 * or as far as the prefix marker (-). If two or more languages
 * match, use the longest string from the Accept-Language header
 * (see HTTP/1.1 [14.4])
 *
 * When a variant has multiple languages, we find the 'best'
 * match for each variant language tag as above, then select the
 * one with the highest q value. Because both the accept-header
 * and variant can have multiple languages, we now have a hairy
 * loop-within-a-loop here.
 *
 * If the variant has no language and we have no Accept-Language
 * items, leave the quality at 1.0 and return.
 *
 * If the variant has no language, we use the default as set by
 * set_default_lang_quality() (1.0 if we are not negotiating on
 * language, 0.001 if we are).
 *
 * Following the setting of the language quality, we drop through to
 * set the old 'lang_index'. This is set based on either the order
 * of the languages on the Accept-Language header, or the
 * order on the LanguagePriority directive. This is only used
 * in the negotiation if the language qualities tie.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_language_quality</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>forcepriority</name> <init>= <expr><name><name>neg</name>-&gt;<name>conf</name>-&gt;<name>forcelangpriority</name></name></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>forcepriority</name> == <name>FLP_UNDEF</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>forcepriority</name> = <name>FLP_DEFAULT</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>variant</name>-&gt;<name>content_languages</name></name> || !<name><name>variant</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* This variant has no content-language, so use the default
         * quality factor for variants with no content-language
         * (previously set by set_default_lang_quality()).
         * Leave the factor alone (it remains at 1.0) when we may not fiddle
         * with the headers.
         */</comment>
        <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>lang_quality</name></name> = <name><name>neg</name>-&gt;<name>default_lang_quality</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>accept_langs</name></name></expr>)</condition><then> <block>{
            <return>return;</return>             <comment type="block">/* no accept-language header */</comment>
        }</block></then></if>
        <return>return;</return>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* Variant has one (or more) languages.  Look for the best
         * match. We do this by going through each language on the
         * variant description looking for a match on the
         * Accept-Language header. The best match is the longest
         * matching language on the header. The final result is the
         * best q value from all the languages on the variant
         * description.
         */</comment>

        <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>accept_langs</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* no accept-language header makes the variant indefinite */</comment>
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>definite</name></name> = 0</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{    <comment type="block">/* There is an accept-language with 0 or more items */</comment>
            <decl_stmt><decl><type><name>accept_rec</name> *</type><name>accs</name> <init>= <expr>(<name>accept_rec</name> *) <name><name>neg</name>-&gt;<name>accept_langs</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>accept_rec</name> *</type><name>best</name> <init>= <expr><name>NULL</name></expr></init>, *<name>star</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>accept_rec</name> *</type><name>bestthistag</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> *</type><name>lang</name></decl>, *<decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>float</name></type> <name>fiddle_q</name> <init>= <expr>0.0f</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>any_match_on_star</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>alen</name></decl>, <decl><type ref="prev"/><name>longest_lang_range_len</name></decl>;</decl_stmt>

            <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>variant</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
                <expr_stmt><expr><name>p</name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bestthistag</name> = <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>longest_lang_range_len</name> = 0</expr>;</expr_stmt>

                <comment type="block">/* lang is the variant's language-tag, which is the one
                 * we are allowed to use the prefix of in HTTP/1.1
                 */</comment>
                <expr_stmt><expr><name>lang</name> = (<call>(<name>char</name> **) <argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>content_languages</name>-&gt;<name>elts</name></name></expr></argument>)</argument_list></call>)<index>[<expr><name>j</name></expr>]</index></expr>;</expr_stmt>

                <comment type="block">/* now find the best (i.e. longest) matching
                 * Accept-Language header language. We put the best match
                 * for this tag in bestthistag. We cannot update the
                 * overall best (based on q value) because the best match
                 * for this tag is the longest language item on the accept
                 * header, not necessarily the highest q.
                 */</comment>
                <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>neg</name>-&gt;<name>accept_langs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                    <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>accs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <if>if <condition>(<expr>!<name>star</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>star</name> = &amp;<name><name>accs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                        }</block></then></if>
                        <continue>continue;</continue>
                    }</block></then></if>
                    <comment type="block">/* Find language. We match if either the variant
                     * language tag exactly matches the language range
                     * from the accept header, or a prefix of the variant
                     * language tag up to a '-' character matches the
                     * whole of the language range in the Accept-Language
                     * header.  Note that HTTP/1.x allows any number of
                     * '-' characters in a tag or range, currently only
                     * tags with zero or one '-' characters are defined
                     * for general use (see rfc1766).
                     *
                     * We only use language range in the Accept-Language
                     * header the best match for the variant language tag
                     * if it is longer than the previous best match.
                     */</comment>

                    <expr_stmt><expr><name>alen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>accs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr>(<call><name>strlen</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call> &gt;= <name>alen</name>) &amp;&amp;
                        !<call><name>strncmp</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>accs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>)</argument_list></call> &amp;&amp;
                        ((<name><name>lang</name><index>[<expr><name>alen</name></expr>]</index></name> == 0) || (<name><name>lang</name><index>[<expr><name>alen</name></expr>]</index></name> == '-'))</expr> )</condition><then> <block>{

                        <if>if <condition>(<expr><name>alen</name> &gt; <name>longest_lang_range_len</name></expr>)</condition><then> <block>{
                            <expr_stmt><expr><name>longest_lang_range_len</name> = <name>alen</name></expr>;</expr_stmt>
                            <expr_stmt><expr><name>bestthistag</name> = &amp;<name><name>accs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if>

                    <if>if <condition>(<expr>!<name>bestthistag</name> &amp;&amp; !<name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name></expr>)</condition><then> <block>{
                        <comment type="block">/* The next bit is a fiddle. Some browsers might
                         * be configured to send more specific language
                         * ranges than desirable. For example, an
                         * Accept-Language of en-US should never match
                         * variants with languages en or en-GB. But US
                         * English speakers might pick en-US as their
                         * language choice.  So this fiddle checks if the
                         * language range has a prefix, and if so, it
                         * matches variants which match that prefix with a
                         * priority of 0.001. So a request for en-US would
                         * match variants of types en and en-GB, but at
                         * much lower priority than matches of en-US
                         * directly, or of any other language listed on
                         * the Accept-Language header. Note that this
                         * fiddle does not handle multi-level prefixes.
                         */</comment>
                        <if>if <condition>(<expr>(<name>p</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>accs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr>'-'</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>int</name></type> <name>plen</name> <init>= <expr><name>p</name> - <name><name>accs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></init></decl>;</decl_stmt>

                            <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>accs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>fiddle_q</name> = 0.001f</expr>;</expr_stmt>
                            }</block></then></if>
                        }</block></then></if>
                    }</block></then></if>
                }</block></for>
                <comment type="block">/* Finished looking at Accept-Language headers, the best
                 * (longest) match is in bestthistag, or NULL if no match
                 */</comment>
                <if>if <condition>(<expr>!<name>best</name> ||
                    (<name>bestthistag</name> &amp;&amp; <name><name>bestthistag</name>-&gt;<name>quality</name></name> &gt; <name><name>best</name>-&gt;<name>quality</name></name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>best</name> = <name>bestthistag</name></expr>;</expr_stmt>
                }</block></then></if>

                <comment type="block">/* See if the tag matches on a * in the Accept-Language
                 * header. If so, record this fact for later use
                 */</comment>
                <if>if <condition>(<expr>!<name>bestthistag</name> &amp;&amp; <name>star</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>any_match_on_star</name> = 1</expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>

            <comment type="block">/* If one of the language tags of the variant matched on *, we
             * need to see if its q is better than that of any non-* match
             * on any other tag of the variant.  If so the * match takes
             * precedence and the overall match is not definite.
             */</comment>
            <if>if <condition>( <expr><name>any_match_on_star</name> &amp;&amp;
                ((<name>best</name> &amp;&amp; <name><name>star</name>-&gt;<name>quality</name></name> &gt; <name><name>best</name>-&gt;<name>quality</name></name>) ||
                 (!<name>best</name>))</expr> )</condition><then> <block>{
                <expr_stmt><expr><name>best</name> = <name>star</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>variant</name>-&gt;<name>definite</name></name> = 0</expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name><name>variant</name>-&gt;<name>lang_quality</name></name> = <name>best</name> ? <name><name>best</name>-&gt;<name>quality</name></name> : <name>fiddle_q</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>

    <comment type="block">/* Handle the ForceDefaultLanguage overrides, based on the best match
     * to LanguagePriority order.  The best match is the lowest index of
     * any LanguagePriority match.
     */</comment>
    <if>if <condition>(<expr>((<name>forcepriority</name> &amp; <name>FLP_PREFER</name>)
             &amp;&amp; (<name><name>variant</name>-&gt;<name>lang_index</name></name> &lt; 0))
     || ((<name>forcepriority</name> &amp; <name>FLP_FALLBACK</name>)
             &amp;&amp; !<name><name>variant</name>-&gt;<name>lang_quality</name></name>)</expr>)</condition><then>
    <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>bestidx</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>variant</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
        <block>{
            <comment type="block">/* lang is the variant's language-tag, which is the one
             * we are allowed to use the prefix of in HTTP/1.1
             */</comment>
            <decl_stmt><decl><type><name>char</name> *</type><name>lang</name> <init>= <expr>(<call>(<name>char</name> **) <argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>content_languages</name>-&gt;<name>elts</name></name></expr></argument>)</argument_list></call>)<index>[<expr><name>j</name></expr>]</index></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

            <comment type="block">/* If we wish to fallback or
             * we use our own LanguagePriority index.
             */</comment>
            <expr_stmt><expr><name>idx</name> = <call><name>find_lang_index</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>conf</name>-&gt;<name>language_priority</name></name></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>idx</name> &gt;= 0) &amp;&amp; ((<name>bestidx</name> == -1) || (<name>idx</name> &lt; <name>bestidx</name>))</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>bestidx</name> = <name>idx</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>

        <if>if <condition>(<expr><name>bestidx</name> &gt;= 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>lang_quality</name></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>forcepriority</name> &amp; <name>FLP_PREFER</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>variant</name>-&gt;<name>lang_index</name></name> = <name>bestidx</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then>
            <else>else <block>{
                <if>if <condition>(<expr><name>forcepriority</name> &amp; <name>FLP_FALLBACK</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>variant</name>-&gt;<name>lang_index</name></name> = <name>bestidx</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>variant</name>-&gt;<name>lang_quality</name></name> = .0001f</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>variant</name>-&gt;<name>definite</name></name> = 0</expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/* Determining the content length --- if the map didn't tell us,
 * we have to do a stat() and remember for next time.
 */</comment>

<function><type><specifier>static</specifier> <name>apr_off_t</name></type> <name>find_content_length</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>statb</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>bytes</name></name> &lt; 0</expr>)</condition><then> <block>{
        <if>if <condition>(   <expr><name><name>variant</name>-&gt;<name>sub_req</name></name>
            &amp;&amp; (<name><name>variant</name>-&gt;<name>sub_req</name>-&gt;<name>finfo</name>.<name>valid</name></name> &amp; <name>APR_FINFO_SIZE</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>bytes</name></name> = <name><name>variant</name>-&gt;<name>sub_req</name>-&gt;<name>finfo</name>.<name>size</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>fullname</name> <init>= <expr><call><name>ap_make_full_path</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>dir_name</name></name></expr></argument>,
                                               <argument><expr><name><name>variant</name>-&gt;<name>file_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>statb</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>,
                         <argument><expr><name>APR_FINFO_SIZE</name></expr></argument>, <argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>variant</name>-&gt;<name>bytes</name></name> = <name><name>statb</name>.<name>size</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

    <return>return <expr><name><name>variant</name>-&gt;<name>bytes</name></name></expr>;</return>
}</block></function>

<comment type="block">/* For a given variant, find the best matching Accept: header
 * and assign the Accept: header's quality value to the
 * mime_type_quality field of the variant, for later use in
 * determining the best matching variant.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_accept_quality</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>accept_rec</name> *</type><name>accept_recs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>q</name> <init>= <expr>0.0f</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>q_definite</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <comment type="block">/* if no Accept: header, leave quality alone (will
     * remain at the default value of 1)
     *
     * XXX: This if is currently never true because of the effect of
     * maybe_add_default_accepts().
     */</comment>
    <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>accepts</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>mime_type</name></name> &amp;&amp; *<name><name>variant</name>-&gt;<name>mime_type</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>definite</name></name> = 0</expr>;</expr_stmt></then></if>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name>accept_recs</name> = (<name>accept_rec</name> *) <name><name>neg</name>-&gt;<name>accepts</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Go through each of the ranges on the Accept: header,
     * looking for the 'best' match with this variant's
     * content-type. We use the best match's quality
     * value (from the Accept: header) for this variant's
     * mime_type_quality field.
     *
     * The best match is determined like this:
     *    type/type is better than type/ * is better than * / *
     *    if match is type/type, use the level mime param if available
     */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>neg</name>-&gt;<name>accepts</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{

        <decl_stmt><decl><type><name>accept_rec</name> *</type><name>type</name> <init>= <expr>&amp;<name><name>accept_recs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>prev_mime_stars</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>prev_mime_stars</name> = <name><name>variant</name>-&gt;<name>mime_stars</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<call><name>mime_match</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <continue>continue;</continue>           <comment type="block">/* didn't match the content type at all */</comment>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* did match - see if there were less or more stars than
             * in previous match
             */</comment>
            <if>if <condition>(<expr><name>prev_mime_stars</name> == <name><name>variant</name>-&gt;<name>mime_stars</name></name></expr>)</condition><then> <block>{
                <continue>continue;</continue>       <comment type="block">/* more stars =&gt; not as good a match */</comment>
            }</block></then></if>
        }</block></else></if>

        <comment type="block">/* If we are allowed to mess with the q-values
         * and have no explicit q= parameters in the accept header,
         * make wildcards very low, so we have a low chance
         * of ending up with them if there's something better.
         */</comment>

        <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name> &amp;&amp; !<name><name>neg</name>-&gt;<name>accept_q</name></name> &amp;&amp;
            <name><name>variant</name>-&gt;<name>mime_stars</name></name> == 1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>q</name> = 0.01f</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name> &amp;&amp; !<name><name>neg</name>-&gt;<name>accept_q</name></name> &amp;&amp;
                 <name><name>variant</name>-&gt;<name>mime_stars</name></name> == 2</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>q</name> = 0.02f</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>q</name> = <name><name>type</name>-&gt;<name>quality</name></name></expr>;</expr_stmt>
        }</block></else></if></else></if>

        <expr_stmt><expr><name>q_definite</name> = (<name><name>variant</name>-&gt;<name>mime_stars</name></name> == 3)</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name><name>variant</name>-&gt;<name>mime_type_quality</name></name> = <name>q</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>variant</name>-&gt;<name>definite</name></name> = <name><name>variant</name>-&gt;<name>definite</name></name> &amp;&amp; <name>q_definite</name></expr>;</expr_stmt>

}</block></function>

<comment type="block">/* For a given variant, find the 'q' value of the charset given
 * on the Accept-Charset line. If no charsets are listed,
 * assume value of '1'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>set_charset_quality</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>accept_rec</name> *</type><name>accept_recs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>charset</name> <init>= <expr><name><name>variant</name>-&gt;<name>content_charset</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>accept_rec</name> *</type><name>star</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* if no Accept-Charset: header, leave quality alone (will
     * remain at the default value of 1)
     */</comment>
    <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>accept_charsets</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>charset</name> &amp;&amp; *<name>charset</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>definite</name></name> = 0</expr>;</expr_stmt></then></if>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name>accept_recs</name> = (<name>accept_rec</name> *) <name><name>neg</name>-&gt;<name>accept_charsets</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>charset</name> == <name>NULL</name> || !*<name>charset</name></expr>)</condition><then> <block>{
        <comment type="block">/* Charset of variant not known */</comment>

        <comment type="block">/* if not a text / * type, leave quality alone */</comment>
        <if>if <condition>(<expr>!(!<call><name>strncmp</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>mime_type</name></name></expr></argument>, <argument><expr>"text/"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call>
              || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>mime_type</name></name></expr></argument>, <argument><expr><name>INCLUDES_MAGIC_TYPE</name></expr></argument>)</argument_list></call>
              || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>mime_type</name></name></expr></argument>, <argument><expr><name>INCLUDES_MAGIC_TYPE3</name></expr></argument>)</argument_list></call>
              )</expr>)</condition><then>
            <return>return;</return></then></if>

        <comment type="block">/* Don't go guessing if we are in strict header mode,
         * e.g. when running the rvsa, as any guess won't be reflected
         * in the variant list or content-location headers.
         */</comment>
        <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>dont_fiddle_headers</name></name></expr>)</condition><then>
            <return>return;</return></then></if>

        <expr_stmt><expr><name>charset</name> = "iso-8859-1"</expr>;</expr_stmt> <comment type="block">/* The default charset for HTTP text types */</comment>
    }</block></then></if>

    <comment type="block">/*
     * Go through each of the items on the Accept-Charset header,
     * looking for a match with this variant's charset. If none
     * match, charset is unacceptable, so set quality to 0.
     */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>neg</name>-&gt;<name>accept_charsets</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{

        <decl_stmt><decl><type><name>accept_rec</name> *</type><name>type</name> <init>= <expr>&amp;<name><name>accept_recs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>charset</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>charset_quality</name></name> = <name><name>type</name>-&gt;<name>quality</name></name></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>star</name> = <name>type</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></for>
    <comment type="block">/* No explicit match */</comment>
    <if>if <condition>(<expr><name>star</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>variant</name>-&gt;<name>charset_quality</name></name> = <name><name>star</name>-&gt;<name>quality</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>variant</name>-&gt;<name>definite</name></name> = 0</expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>
    <comment type="block">/* If this variant is in charset iso-8859-1, the default is 1.0 */</comment>
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>charset</name></expr></argument>, <argument><expr>"iso-8859-1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>variant</name>-&gt;<name>charset_quality</name></name> = 1.0f</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>variant</name>-&gt;<name>charset_quality</name></name> = 0.0f</expr>;</expr_stmt>
    }</block></else></if>
}</block></function>


<comment type="block">/* is_identity_encoding is included for back-compat, but does anyone
 * use 7bit, 8bin or binary in their var files??
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_identity_encoding</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>enc</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>(!<name>enc</name> || !<name><name>enc</name><index>[<expr>0</expr>]</index></name> || !<call><name>strcmp</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>"7bit"</expr></argument>)</argument_list></call> || !<call><name>strcmp</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>"8bit"</expr></argument>)</argument_list></call>
            || !<call><name>strcmp</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>"binary"</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<comment type="block">/*
 * set_encoding_quality determines whether the encoding for a particular
 * variant is acceptable for the user-agent.
 *
 * The rules for encoding are that if the user-agent does not supply
 * any Accept-Encoding header, then all encodings are allowed but a
 * variant with no encoding should be preferred.
 * If there is an empty Accept-Encoding header, then no encodings are
 * acceptable. If there is a non-empty Accept-Encoding header, then
 * any of the listed encodings are acceptable, as well as no encoding
 * unless the "identity" encoding is specifically excluded.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>set_encoding_quality</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>accept_rec</name> *</type><name>accept_recs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>enc</name> <init>= <expr><name><name>variant</name>-&gt;<name>content_encoding</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>accept_rec</name> *</type><name>star</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>value_if_not_found</name> <init>= <expr>0.0f</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>accept_encodings</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* We had no Accept-Encoding header, assume that all
         * encodings are acceptable with a low quality,
         * but we prefer no encoding if available.
         */</comment>
        <if>if <condition>(<expr>!<name>enc</name> || <call><name>is_identity_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> = 1.0f</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> = 0.5f</expr>;</expr_stmt></else></if>

        <return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>enc</name> || <call><name>is_identity_encoding</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>enc</name> = "identity"</expr>;</expr_stmt>
        <expr_stmt><expr><name>value_if_not_found</name> = 0.0001f</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>accept_recs</name> = (<name>accept_rec</name> *) <name><name>neg</name>-&gt;<name>accept_encodings</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

    <comment type="block">/* Go through each of the encodings on the Accept-Encoding: header,
     * looking for a match with our encoding. x- prefixes are ignored.
     */</comment>
    <if>if <condition>(<expr><name><name>enc</name><index>[<expr>0</expr>]</index></name> == 'x' &amp;&amp; <name><name>enc</name><index>[<expr>1</expr>]</index></name> == '-'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>enc</name> += 2</expr>;</expr_stmt>
    }</block></then></if>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>neg</name>-&gt;<name>accept_encodings</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{

        <decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><name><name>accept_recs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == 'x' &amp;&amp; <name><name>name</name><index>[<expr>1</expr>]</index></name> == '-'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>name</name> += 2</expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> = <name><name>accept_recs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>quality</name></expr>;</expr_stmt>
            <return>return;</return>
        }</block></then></if>

        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>star</name> = &amp;<name><name>accept_recs</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>

    }</block></for>
    <comment type="block">/* No explicit match */</comment>
    <if>if <condition>(<expr><name>star</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> = <name><name>star</name>-&gt;<name>quality</name></name></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* Encoding not found on Accept-Encoding: header, so it is
     * _not_ acceptable unless it is the identity (no encoding)
     */</comment>
    <expr_stmt><expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> = <name>value_if_not_found</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*************************************************************
 * Possible results of the variant selection algorithm
 */</comment>
<enum>enum <name>algorithm_results</name> <block>{
    <decl><name>alg_choice</name> <init>= <expr>1</expr></init></decl>,              <comment type="block">/* choose variant */</comment>
    <decl><name>alg_list</name></decl>                     <comment type="block">/* list variants */</comment>
}</block>;</enum>

<comment type="block">/* Below is the 'best_match' function. It returns an int, which has
 * one of the two values alg_choice or alg_list, which give the result
 * of the variant selection algorithm.  alg_list means that no best
 * variant was found by the algorithm, alg_choice means that a best
 * variant was found and should be returned.  The list/choice
 * terminology comes from TCN (rfc2295), but is used in a more generic
 * way here.  The best variant is returned in *pbest. best_match has
 * two possible algorithms for determining the best variant: the
 * RVSA/1.0 algorithm (from RFC2296), and the standard Apache
 * algorithm. These are split out into separate functions
 * (is_variant_better_rvsa() and is_variant_better()).  Selection of
 * one is through the neg-&gt;use_rvsa flag.
 *
 * The call to best_match also creates full information, including
 * language, charset, etc quality for _every_ variant. This is needed
 * for generating a correct Vary header, and can be used for the
 * Alternates header, the human-readable list responses and 406 errors.
 */</comment>

<comment type="block">/* Firstly, the RVSA/1.0 (HTTP Remote Variant Selection Algorithm
 * v1.0) from rfc2296.  This is the algorithm that goes together with
 * transparent content negotiation (TCN).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>is_variant_better_rvsa</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>,
                                  <param><decl><type><name>var_rec</name> *</type><name>best</name></decl></param>, <param><decl><type><name>float</name> *</type><name>p_bestq</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>float</name></type> <name>bestq</name> <init>= <expr>*<name>p_bestq</name></expr></init>, <name>q</name></decl>;</decl_stmt>

    <comment type="block">/* TCN does not cover negotiation on content-encoding.  For now,
     * we ignore the encoding unless it was explicitly excluded.
     */</comment>
    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> == 0.0f</expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <expr_stmt><expr><name>q</name> = <name><name>variant</name>-&gt;<name>mime_type_quality</name></name> *
        <name><name>variant</name>-&gt;<name>source_quality</name></name> *
        <name><name>variant</name>-&gt;<name>charset_quality</name></name> *
        <name><name>variant</name>-&gt;<name>lang_quality</name></name></expr>;</expr_stmt>

   <comment type="block">/* RFC 2296 calls for the result to be rounded to 5 decimal places,
    * but we don't do that because it serves no useful purpose other
    * than to ensure that a remote algorithm operates on the same
    * precision as ours.  That is silly, since what we obviously want
    * is for the algorithm to operate on the best available precision
    * regardless of who runs it.  Since the above calculation may
    * result in significant variance at 1e-12, rounding would be bogus.
    */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEG_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00688</expr></argument>)</argument_list></call>
           "Variant: file=%s type=%s lang=%s sourceq=%1.3f "
           "mimeq=%1.3f langq=%1.3f charq=%1.3f encq=%1.3f "
           "q=%1.5f definite=%d"</expr></argument>,
            <argument><expr>(<name><name>variant</name>-&gt;<name>file_name</name></name> ? <name><name>variant</name>-&gt;<name>file_name</name></name> : "")</expr></argument>,
            <argument><expr>(<name><name>variant</name>-&gt;<name>mime_type</name></name> ? <name><name>variant</name>-&gt;<name>mime_type</name></name> : "")</expr></argument>,
            <argument><expr>(<name><name>variant</name>-&gt;<name>content_languages</name></name>
             ? <call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>variant</name>-&gt;<name>content_languages</name></name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call>
             : "")</expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>source_quality</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>mime_type_quality</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>lang_quality</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>charset_quality</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name></expr></argument>,
            <argument><expr><name>q</name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>definite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name>q</name> &lt;= 0.0f</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>q</name> &gt; <name>bestq</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>q</name> == <name>bestq</name></expr>)</condition><then> <block>{
        <comment type="block">/* If the best variant's encoding is of lesser quality than
         * this variant, then we prefer this variant
         */</comment>
        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> &gt; <name><name>best</name>-&gt;<name>encoding_quality</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* Negotiation algorithm as used by previous versions of Apache
 * (just about).
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_variant_better</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>, <param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>,
                             <param><decl><type><name>var_rec</name> *</type><name>best</name></decl></param>, <param><decl><type><name>float</name> *</type><name>p_bestq</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>float</name></type> <name>bestq</name> <init>= <expr>*<name>p_bestq</name></expr></init>, <name>q</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>levcmp</name></decl>;</decl_stmt>

    <comment type="block">/* For non-transparent negotiation, server can choose how
     * to handle the negotiation. We'll use the following in
     * order: content-type, language, content-type level, charset,
     * content encoding, content length.
     *
     * For each check, we have three possible outcomes:
     *   This variant is worse than current best: return 0
     *   This variant is better than the current best:
     *          assign this variant's q to *p_bestq, and return 1
     *   This variant is just as desirable as the current best:
     *          drop through to the next test.
     *
     * This code is written in this long-winded way to allow future
     * customisation, either by the addition of additional
     * checks, or to allow the order of the checks to be determined
     * by configuration options (e.g. we might prefer to check
     * language quality _before_ content type).
     */</comment>

    <comment type="block">/* First though, eliminate this variant if it is not
     * acceptable by type, charset, encoding or language.
     */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NEG_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_STARTUP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00689</expr></argument>)</argument_list></call>
           "Variant: file=%s type=%s lang=%s sourceq=%1.3f "
           "mimeq=%1.3f langq=%1.3f langidx=%d charq=%1.3f encq=%1.3f "</expr></argument>,
            <argument><expr>(<name><name>variant</name>-&gt;<name>file_name</name></name> ? <name><name>variant</name>-&gt;<name>file_name</name></name> : "")</expr></argument>,
            <argument><expr>(<name><name>variant</name>-&gt;<name>mime_type</name></name> ? <name><name>variant</name>-&gt;<name>mime_type</name></name> : "")</expr></argument>,
            <argument><expr>(<name><name>variant</name>-&gt;<name>content_languages</name></name>
             ? <call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>variant</name>-&gt;<name>content_languages</name></name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call>
             : "")</expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>source_quality</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>mime_type_quality</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>lang_quality</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>lang_index</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>charset_quality</name></name></expr></argument>,
            <argument><expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> == 0.0f ||
        <name><name>variant</name>-&gt;<name>lang_quality</name></name> == 0.0f ||
        <name><name>variant</name>-&gt;<name>source_quality</name></name> == 0.0f ||
        <name><name>variant</name>-&gt;<name>charset_quality</name></name> == 0.0f ||
        <name><name>variant</name>-&gt;<name>mime_type_quality</name></name> == 0.0f</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>               <comment type="block">/* don't consider unacceptables */</comment>
    }</block></then></if>

    <expr_stmt><expr><name>q</name> = <name><name>variant</name>-&gt;<name>mime_type_quality</name></name> * <name><name>variant</name>-&gt;<name>source_quality</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>q</name> == 0.0 || <name>q</name> &lt; <name>bestq</name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>q</name> &gt; <name>bestq</name> || !<name>best</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* language */</comment>
    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>lang_quality</name></name> &lt; <name><name>best</name>-&gt;<name>lang_quality</name></name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>lang_quality</name></name> &gt; <name><name>best</name>-&gt;<name>lang_quality</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* if language qualities were equal, try the LanguagePriority stuff */</comment>
    <if>if <condition>(<expr><name><name>best</name>-&gt;<name>lang_index</name></name> != -1 &amp;&amp;
        (<name><name>variant</name>-&gt;<name>lang_index</name></name> == -1 || <name><name>variant</name>-&gt;<name>lang_index</name></name> &gt; <name><name>best</name>-&gt;<name>lang_index</name></name>)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>lang_index</name></name> != -1 &amp;&amp;
        (<name><name>best</name>-&gt;<name>lang_index</name></name> == -1 || <name><name>variant</name>-&gt;<name>lang_index</name></name> &lt; <name><name>best</name>-&gt;<name>lang_index</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* content-type level (sometimes used with text/html, though we
     * support it on other types too)
     */</comment>
    <expr_stmt><expr><name>levcmp</name> = <call><name>level_cmp</name><argument_list>(<argument><expr><name>variant</name></expr></argument>, <argument><expr><name>best</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>levcmp</name> == -1</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>levcmp</name> == 1</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* charset */</comment>
    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>charset_quality</name></name> &lt; <name><name>best</name>-&gt;<name>charset_quality</name></name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <comment type="block">/* If the best variant's charset is ISO-8859-1 and this variant has
     * the same charset quality, then we prefer this variant
     */</comment>

    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>charset_quality</name></name> &gt; <name><name>best</name>-&gt;<name>charset_quality</name></name> ||
        ((<name><name>variant</name>-&gt;<name>content_charset</name></name> != <name>NULL</name> &amp;&amp;
          *<name><name>variant</name>-&gt;<name>content_charset</name></name> != '\0' &amp;&amp;
          <call><name>strcmp</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>content_charset</name></name></expr></argument>, <argument><expr>"iso-8859-1"</expr></argument>)</argument_list></call> != 0) &amp;&amp;
         (<name><name>best</name>-&gt;<name>content_charset</name></name> == <name>NULL</name> ||
          *<name><name>best</name>-&gt;<name>content_charset</name></name> == '\0' ||
          <call><name>strcmp</name><argument_list>(<argument><expr><name><name>best</name>-&gt;<name>content_charset</name></name></expr></argument>, <argument><expr>"iso-8859-1"</expr></argument>)</argument_list></call> == 0))</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Prefer the highest value for encoding_quality.
     */</comment>
    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> &lt; <name><name>best</name>-&gt;<name>encoding_quality</name></name></expr>)</condition><then> <block>{
       <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>encoding_quality</name></name> &gt; <name><name>best</name>-&gt;<name>encoding_quality</name></name></expr>)</condition><then> <block>{
       <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
       <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* content length if all else equal */</comment>
    <if>if <condition>(<expr><call><name>find_content_length</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>)</argument_list></call> &gt;= <call><name>find_content_length</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>best</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <comment type="block">/* ok, to get here means every thing turned out equal, except
     * we have a shorter content length, so use this variant
     */</comment>
    <expr_stmt><expr>*<name>p_bestq</name> = <name>q</name></expr>;</expr_stmt>
    <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* figure out, whether a variant is in a specific language
 * it returns also false, if the variant has no language.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>variant_has_language</name><parameter_list>(<param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lang</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* fast exit */</comment>
    <if>if <condition>(   <expr>!<name>lang</name>
        || !<name><name>variant</name>-&gt;<name>content_languages</name></name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>content_languages</name></name></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* check for environment variables 'no-gzip' and
 * 'gzip-only-text/html' to get a behaviour similar
 * to mod_deflate
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>discard_variant_by_env</name><parameter_list>(<param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>, <param><decl><type><name>int</name></type> <name>discard</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(   <expr><call><name>is_identity_encoding</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>content_encoding</name></name></expr></argument>)</argument_list></call>
        || !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>content_encoding</name></name></expr></argument>, <argument><expr>"identity"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <return>return <expr>(   (<name>discard</name> == <name>DISCARD_ALL_ENCODINGS</name>)
            || (<name>discard</name> == <name>DISCARD_ALL_BUT_HTML</name>
                &amp;&amp; (!<name><name>variant</name>-&gt;<name>mime_type</name></name>
                    || <call><name>strncmp</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>mime_type</name></name></expr></argument>, <argument><expr>"text/html"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call>)))</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>best_match</name><parameter_list>(<param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>, <param><decl><type><name>var_rec</name> **</type><name>pbest</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>var_rec</name> *</type><name>best</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>bestq</name> <init>= <expr>0.0f</expr></init></decl>;</decl_stmt>
    <enum>enum <name>algorithm_results</name> <name>algorithm_result</name>;</enum>
    <decl_stmt><decl><type><name>int</name></type> <name>may_discard</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>var_rec</name> *</type><name>avail_recs</name> <init>= <expr>(<name>var_rec</name> *) <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* fetch request dependent variables
     * prefer-language: prefer a certain language.
     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>preferred_language</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>,
                                                   <argument><expr>"prefer-language"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* no-gzip: do not send encoded documents */</comment>
    <if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"no-gzip"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>may_discard</name> = <name>DISCARD_ALL_ENCODINGS</name></expr>;</expr_stmt>
    }</block></then>

    <comment type="block">/* gzip-only-text/html: send encoded documents only
     * if they are text/html. (no-gzip has a higher priority).
     */</comment>
    <else>else <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>env_value</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>neg</name>-&gt;<name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>,
                                              <argument><expr>"gzip-only-text/html"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>env_value</name> &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>env_value</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>may_discard</name> = <name>DISCARD_ALL_BUT_HTML</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

    <expr_stmt><expr><call><name>set_default_lang_quality</name><argument_list>(<argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Find the 'best' variant
     * We run the loop possibly twice: if "prefer-language"
     * environment variable is set but we did not find an appropriate
     * best variant. In that case forget the preferred language and
     * negotiate over all variants.
     */</comment>

    <do>do <block>{
        <expr_stmt><expr><name>best</name> = <name>NULL</name></expr>;</expr_stmt>

        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>var_rec</name> *</type><name>variant</name> <init>= <expr>&amp;<name><name>avail_recs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* if this variant is encoded somehow and there are special
             * variables set, we do not negotiate it. see above.
             */</comment>
            <if>if <condition>(   <expr><name>may_discard</name>
                &amp;&amp; <call><name>discard_variant_by_env</name><argument_list>(<argument><expr><name>variant</name></expr></argument>, <argument><expr><name>may_discard</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <comment type="block">/* if a language is preferred, but the current variant
             * is not in that language, then drop it for now
             */</comment>
            <if>if <condition>(   <expr><name>preferred_language</name>
                &amp;&amp; !<call><name>variant_has_language</name><argument_list>(<argument><expr><name>variant</name></expr></argument>, <argument><expr><name>preferred_language</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <comment type="block">/* Find all the relevant 'quality' values from the
             * Accept... headers, and store in the variant.  This also
             * prepares for sending an Alternates header etc so we need to
             * do it even if we do not actually plan to find a best
             * variant.
             */</comment>
            <expr_stmt><expr><call><name>set_accept_quality</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* accept the preferred language, even when it's not listed within
             * the Accept-Language header
             */</comment>
            <if>if <condition>(<expr><name>preferred_language</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>variant</name>-&gt;<name>lang_quality</name></name> = 1.0f</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>variant</name>-&gt;<name>definite</name></name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>set_language_quality</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><call><name>set_encoding_quality</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>set_charset_quality</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Only do variant selection if we may actually choose a
             * variant for the client
             */</comment>
            <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>may_choose</name></name></expr>)</condition><then> <block>{

                <comment type="block">/* Now find out if this variant is better than the current
                 * best, either using the RVSA/1.0 algorithm, or Apache's
                 * internal server-driven algorithm. Presumably other
                 * server-driven algorithms are possible, and could be
                 * implemented here.
                 */</comment>

                <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>use_rvsa</name></name></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><call><name>is_variant_better_rvsa</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr>&amp;<name>bestq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>best</name> = <name>variant</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then>
                <else>else <block>{
                    <if>if <condition>(<expr><call><name>is_variant_better</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>, <argument><expr><name>best</name></expr></argument>, <argument><expr>&amp;<name>bestq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>best</name> = <name>variant</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></else></if>
            }</block></then></if>
        }</block></for>

        <comment type="block">/* We now either have a best variant, or no best variant */</comment>

        <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>use_rvsa</name></name></expr>)</condition><then>    <block>{
            <comment type="block">/* calculate result for RVSA/1.0 algorithm:
             * only a choice response if the best variant has q&gt;0
             * and is definite
             */</comment>
            <expr_stmt><expr><name>algorithm_result</name> = (<name>best</name> &amp;&amp; <name><name>best</name>-&gt;<name>definite</name></name>) &amp;&amp; (<name>bestq</name> &gt; 0) ?
                                <name>alg_choice</name> : <name>alg_list</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* calculate result for Apache negotiation algorithm */</comment>
            <expr_stmt><expr><name>algorithm_result</name> = <name>bestq</name> &gt; 0 ? <name>alg_choice</name> : <name>alg_list</name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/* run the loop again, if the "prefer-language" got no clear result */</comment>
        <if>if <condition>(<expr><name>preferred_language</name> &amp;&amp; (!<name>best</name> || <name>algorithm_result</name> != <name>alg_choice</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>preferred_language</name> = <name>NULL</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <break>break;</break>
    }</block> while <condition>(<expr>1</expr>)</condition>;</do>

    <comment type="block">/* Returning a choice response with a non-neighboring variant is a
     * protocol security error in TCN (see rfc2295).  We do *not*
     * verify here that the variant and URI are neighbors, even though
     * we may return alg_choice.  We depend on the environment (the
     * caller) to only declare the resource transparently negotiable if
     * all variants are neighbors.
     */</comment>
    <expr_stmt><expr>*<name>pbest</name> = <name>best</name></expr>;</expr_stmt>
    <return>return <expr><name>algorithm_result</name></expr>;</return>
}</block></function>

<comment type="block">/* Sets response headers for a negotiated response.
 * neg-&gt;is_transparent determines whether a transparently negotiated
 * response or a plain `server driven negotiation' response is
 * created.   Applicable headers are Alternates, Vary, and TCN.
 *
 * The Vary header we create is sometimes longer than is required for
 * the correct caching of negotiated results by HTTP/1.1 caches.  For
 * example if we have 3 variants x.html, x.ps.en and x.ps.nl, and if
 * the Accept: header assigns a 0 quality to .ps, then the results of
 * the two server-side negotiation algorithms we currently implement
 * will never depend on Accept-Language so we could return `Vary:
 * negotiate, accept' instead of the longer 'Vary: negotiate, accept,
 * accept-language' which the code below will return.  A routine for
 * computing the exact minimal Vary header would be a huge pain to code
 * and maintain though, especially because we need to take all possible
 * twiddles in the server-side negotiation algorithms into account.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>set_neg_headers</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>,
                            <param><decl><type><name>int</name></type> <name>alg_result</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>hdrs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>var_rec</name> *</type><name>avail_recs</name> <init>= <expr>(<name>var_rec</name> *) <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sample_type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sample_language</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sample_encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sample_charset</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>lang</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>qstr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>arr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_vlist_array</name> <init>= <expr>(<name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name> * 21)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>first_variant</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>vary_by_type</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>vary_by_language</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>vary_by_charset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>vary_by_encoding</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* In order to avoid O(n^2) memory copies in building Alternates,
     * we preallocate a apr_table_t with the maximum substrings possible,
     * fill it with the variant list, and then concatenate the entire array.
     * Note that if you change the number of substrings pushed, you also
     * need to change the calculation of max_vlist_array above.
     */</comment>
    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>send_alternates</name></name> &amp;&amp; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>arr</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>max_vlist_array</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>arr</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

    <comment type="block">/* Put headers into err_headers_out, since send_http_header()
     * outputs both headers_out and err_headers_out.
     */</comment>
    <expr_stmt><expr><name>hdrs</name> = <name><name>r</name>-&gt;<name>err_headers_out</name></name></expr>;</expr_stmt>

    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>var_rec</name> *</type><name>variant</name> <init>= <expr>&amp;<name><name>avail_recs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>content_languages</name></name> &amp;&amp; <name><name>variant</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>lang</name> = <call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>variant</name>-&gt;<name>content_languages</name></name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>lang</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/* Calculate Vary by looking for any difference between variants */</comment>

        <if>if <condition>(<expr><name>first_variant</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>sample_type</name>     = <name><name>variant</name>-&gt;<name>mime_type</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sample_charset</name>  = <name><name>variant</name>-&gt;<name>content_charset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sample_language</name> = <name>lang</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>sample_encoding</name> = <name><name>variant</name>-&gt;<name>content_encoding</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr>!<name>vary_by_type</name> &amp;&amp;
                <call><name>strcmp</name><argument_list>(<argument><expr><name>sample_type</name> ? <name>sample_type</name> : ""</expr></argument>,
                       <argument><expr><name><name>variant</name>-&gt;<name>mime_type</name></name> ? <name><name>variant</name>-&gt;<name>mime_type</name></name> : ""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>vary_by_type</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>!<name>vary_by_charset</name> &amp;&amp;
                <call><name>strcmp</name><argument_list>(<argument><expr><name>sample_charset</name> ? <name>sample_charset</name> : ""</expr></argument>,
                       <argument><expr><name><name>variant</name>-&gt;<name>content_charset</name></name> ?
                       <name><name>variant</name>-&gt;<name>content_charset</name></name> : ""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>vary_by_charset</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>!<name>vary_by_language</name> &amp;&amp;
                <call><name>strcmp</name><argument_list>(<argument><expr><name>sample_language</name> ? <name>sample_language</name> : ""</expr></argument>,
                       <argument><expr><name>lang</name> ? <name>lang</name> : ""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>vary_by_language</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>!<name>vary_by_encoding</name> &amp;&amp;
                <call><name>strcmp</name><argument_list>(<argument><expr><name>sample_encoding</name> ? <name>sample_encoding</name> : ""</expr></argument>,
                       <argument><expr><name><name>variant</name>-&gt;<name>content_encoding</name></name> ?
                       <name><name>variant</name>-&gt;<name>content_encoding</name></name> : ""</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>vary_by_encoding</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
        <expr_stmt><expr><name>first_variant</name> = 0</expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name><name>neg</name>-&gt;<name>send_alternates</name></name></expr>)</condition><then>
            <continue>continue;</continue></then></if>

        <comment type="block">/* Generate the string components for this Alternates entry */</comment>

        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "{\""</expr>;</expr_stmt>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <call><name>ap_escape_path_segment</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>variant</name>-&gt;<name>file_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "\" "</expr>;</expr_stmt>

        <expr_stmt><expr><name>qstr</name> = (<name>char</name> *) <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>qstr</name></expr></argument>, <argument><expr>6</expr></argument>, <argument><expr>"%1.3f"</expr></argument>, <argument><expr><name><name>variant</name>-&gt;<name>source_quality</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Strip trailing zeros (saves those valuable network bytes) */</comment>
        <if>if <condition>(<expr><name><name>qstr</name><index>[<expr>4</expr>]</index></name> == '0'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>qstr</name><index>[<expr>4</expr>]</index></name> = '\0'</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>qstr</name><index>[<expr>3</expr>]</index></name> == '0'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>qstr</name><index>[<expr>3</expr>]</index></name> = '\0'</expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>qstr</name><index>[<expr>2</expr>]</index></name> == '0'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>qstr</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name>qstr</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>mime_type</name></name> &amp;&amp; *<name><name>variant</name>-&gt;<name>mime_type</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = " {type "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name><name>variant</name>-&gt;<name>mime_type</name></name></expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "}"</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>content_charset</name></name> &amp;&amp; *<name><name>variant</name>-&gt;<name>content_charset</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = " {charset "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name><name>variant</name>-&gt;<name>content_charset</name></name></expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "}"</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>lang</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = " {language "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name>lang</name></expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "}"</expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>content_encoding</name></name> &amp;&amp; *<name><name>variant</name>-&gt;<name>content_encoding</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* Strictly speaking, this is non-standard, but so is TCN */</comment>

            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = " {encoding "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name><name>variant</name>-&gt;<name>content_encoding</name></name></expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "}"</expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Note that the Alternates specification (in rfc2295) does
         * not require that we include {length x}, so we could omit it
         * if determining the length is too expensive.  We currently
         * always include it though.
         *
         * If the variant is a CGI script, find_content_length would
         * return the length of the script, not the output it
         * produces, so we check for the presence of a handler and if
         * there is one we don't add a length.
         *
         * XXX: TODO: This check does not detect a CGI script if we
         * get the variant from a type map.  This needs to be fixed
         * (without breaking things if the type map specifies a
         * content-length, which currently leads to the correct result).
         */</comment>
        <if>if <condition>(<expr>!(<name><name>variant</name>-&gt;<name>sub_req</name></name> &amp;&amp; <name><name>variant</name>-&gt;<name>sub_req</name>-&gt;<name>handler</name></name>)
            &amp;&amp; (<name>len</name> = <call><name>find_content_length</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>variant</name></expr></argument>)</argument_list></call>) &gt;= 0</expr>)</condition><then> <block>{

            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = " {length "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <call><name>apr_off_t_toa</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                                   <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "}"</expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "}"</expr>;</expr_stmt>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = ", "</expr>;</expr_stmt> <comment type="block">/* trimmed below */</comment>
    }</block></for>

    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>send_alternates</name></name> &amp;&amp; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>arr</name>-&gt;<name>nelts</name></name>--</expr>;</expr_stmt>                                 <comment type="block">/* remove last comma */</comment>
        <expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>, <argument><expr>"Alternates"</expr></argument>,
                        <argument><expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>arr</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>is_transparent</name></name> || <name>vary_by_type</name> || <name>vary_by_language</name> ||
        <name>vary_by_charset</name> || <name>vary_by_encoding</name></expr>)</condition><then> <block>{

        <expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>, <argument><expr>"Vary"</expr></argument>, <argument><expr>2 + <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
            <argument><expr><name><name>neg</name>-&gt;<name>is_transparent</name></name> ? ", negotiate"       : ""</expr></argument>,
            <argument><expr><name>vary_by_type</name>        ? ", accept"          : ""</expr></argument>,
            <argument><expr><name>vary_by_language</name>    ? ", accept-language" : ""</expr></argument>,
            <argument><expr><name>vary_by_charset</name>     ? ", accept-charset"  : ""</expr></argument>,
            <argument><expr><name>vary_by_encoding</name>    ? ", accept-encoding" : ""</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>is_transparent</name></name></expr>)</condition><then> <block>{ <comment type="block">/* Create TCN response header */</comment>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>, <argument><expr>"TCN"</expr></argument>,
                      <argument><expr><name>alg_result</name> == <name>alg_list</name> ? "list" : "choice"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/**********************************************************************
 *
 * Return an HTML list of variants. This is output as part of the
 * choice response or 406 status body.
 */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>make_variant_list</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>arr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>max_vlist_array</name> <init>= <expr>(<name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name> * 15) + 2</expr></init></decl>;</decl_stmt>

    <comment type="block">/* In order to avoid O(n^2) memory copies in building the list,
     * we preallocate a apr_table_t with the maximum substrings possible,
     * fill it with the variant list, and then concatenate the entire array.
     */</comment>
    <expr_stmt><expr><name>arr</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>max_vlist_array</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "Available variants:\n&lt;ul&gt;\n"</expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>var_rec</name> *</type><name>variant</name> <init>= <expr>&amp;((<name>var_rec</name> *) <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>elts</name></name>)<index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><name><name>variant</name>-&gt;<name>file_name</name></name> ? <name><name>variant</name>-&gt;<name>file_name</name></name> : ""</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>languages</name> <init>= <expr><name><name>variant</name>-&gt;<name>content_languages</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>description</name> <init>= <expr><name><name>variant</name>-&gt;<name>description</name></name>
                                    ? <name><name>variant</name>-&gt;<name>description</name></name>
                                    : ""</expr></init></decl>;</decl_stmt>

        <comment type="block">/* The format isn't very neat, and it would be nice to make
         * the tags human readable (eg replace 'language en' with 'English').
         * Note that if you change the number of substrings pushed, you also
         * need to change the calculation of max_vlist_array above.
         */</comment>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "&lt;li&gt;&lt;a href=\""</expr>;</expr_stmt>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <call><name>ap_escape_path_segment</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "\"&gt;"</expr>;</expr_stmt>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <call><name>ap_escape_html</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "&lt;/a&gt; "</expr>;</expr_stmt>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name>description</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>mime_type</name></name> &amp;&amp; *<name><name>variant</name>-&gt;<name>mime_type</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = ", type "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name><name>variant</name>-&gt;<name>mime_type</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>languages</name> &amp;&amp; <name><name>languages</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = ", language "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                       <argument><expr><name>languages</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>content_charset</name></name> &amp;&amp; *<name><name>variant</name>-&gt;<name>content_charset</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = ", charset "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name><name>variant</name>-&gt;<name>content_charset</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>content_encoding</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = ", encoding "</expr>;</expr_stmt>
            <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = <name><name>variant</name>-&gt;<name>content_encoding</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "&lt;/li&gt;\n"</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr>*((const <name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call>) = "&lt;/ul&gt;\n"</expr>;</expr_stmt>

    <return>return <expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>arr</name></expr></argument>, <argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>store_variant_list</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name/></name>main == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"variant-list"</expr></argument>, <argument><expr><call><name>make_variant_list</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name/></name>main-&gt;<name>notes</name></expr></argument>, <argument><expr>"variant-list"</expr></argument>,
                      <argument><expr><call><name>make_variant_list</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name/></name>main</expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/* Called if we got a "Choice" response from the variant selection algorithm.
 * It checks the result of the chosen variant to see if it
 * is itself negotiated (if so, return error HTTP_VARIANT_ALSO_VARIES).
 * Otherwise, add the appropriate headers to the current response.
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>setup_choice_response</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>,
                                 <param><decl><type><name>var_rec</name> *</type><name>variant</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>sub_req</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sub_vary</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>variant</name>-&gt;<name>sub_req</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>sub_req</name> = <call><name>ap_sub_req_lookup_file</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>file_name</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>status</name> = <name><name>sub_req</name>-&gt;<name>status</name></name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>status</name> != <name>HTTP_OK</name> &amp;&amp;
            !<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>sub_req</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"TCN"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>sub_req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>status</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>variant</name>-&gt;<name>sub_req</name></name> = <name>sub_req</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>sub_req</name> = <name><name>variant</name>-&gt;<name>sub_req</name></name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* The variant selection algorithm told us to return a "Choice"
     * response. This is the normal variant response, with
     * some extra headers. First, ensure that the chosen
     * variant did or will not itself engage in transparent negotiation.
     * If not, set the appropriate headers, and fall through to
     * the normal variant handling
     */</comment>

    <comment type="block">/* This catches the error that a transparent type map selects a
     * transparent multiviews resource as the best variant.
     *
     * XXX: We do not signal an error if a transparent type map
     * selects a _non_transparent multiviews resource as the best
     * variant, because we can generate a legal negotiation response
     * in this case.  In this case, the vlist_validator of the
     * nontransparent subrequest will be lost however.  This could
     * lead to cases in which a change in the set of variants or the
     * negotiation algorithm of the nontransparent resource is never
     * propagated up to a HTTP/1.1 cache which interprets Vary.  To be
     * completely on the safe side we should return HTTP_VARIANT_ALSO_VARIES
     * for this type of recursive negotiation too.
     */</comment>
    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>is_transparent</name></name> &amp;&amp;
        <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>sub_req</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"TCN"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>HTTP_VARIANT_ALSO_VARIES</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* This catches the error that a transparent type map recursively
     * selects, as the best variant, another type map which itself
     * causes transparent negotiation to be done.
     *
     * XXX: Actually, we catch this error by catching all cases of
     * type map recursion.  There are some borderline recursive type
     * map arrangements which would not produce transparent
     * negotiation protocol errors or lack of cache propagation
     * problems, but such arrangements are very hard to detect at this
     * point in the control flow, so we do not bother to single them
     * out.
     *
     * Recursive type maps imply a recursive arrangement of negotiated
     * resources which is visible to outside clients, and this is not
     * supported by the transparent negotiation caching protocols, so
     * if we are to have generic support for recursive type maps, we
     * have to create some configuration setting which makes all type
     * maps non-transparent when recursion is enabled.  Also, if we
     * want recursive type map support which ensures propagation of
     * type map changes into HTTP/1.1 caches that handle Vary, we
     * would have to extend the current mechanism for generating
     * variant list validators.
     */</comment>
    <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>handler</name></name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>sub_req</name>-&gt;<name>handler</name></name></expr></argument>, <argument><expr>"type-map"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <return>return <expr><name>HTTP_VARIANT_ALSO_VARIES</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* This adds an appropriate Variant-Vary header if the subrequest
     * is a multiviews resource.
     *
     * XXX: TODO: Note that this does _not_ handle any Vary header
     * returned by a CGI if sub_req is a CGI script, because we don't
     * see that Vary header yet at this point in the control flow.
     * This won't cause any cache consistency problems _unless_ the
     * CGI script also returns a Cache-Control header marking the
     * response as cacheable.  This needs to be fixed, also there are
     * problems if a CGI returns an Etag header which also need to be
     * fixed.
     */</comment>
    <if>if <condition>(<expr>(<name>sub_vary</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>sub_req</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"Variant-Vary"</expr></argument>, <argument><expr><name>sub_vary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Move the subreq Vary header into the main request to
         * prevent having two Vary headers in the response, which
         * would be legal but strange.
         */</comment>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>, <argument><expr><name>sub_vary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>sub_req</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"Content-Location"</expr></argument>,
                  <argument><expr><call><name>ap_escape_path_segment</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>variant</name>-&gt;<name>file_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>set_neg_headers</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>alg_choice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <comment type="block">/* add Alternates and Vary */</comment>

    <comment type="block">/* Still to do by caller: add Expires */</comment>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/****************************************************************
 *
 * Executive...
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>do_negotiation</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl></param>,
                          <param><decl><type><name>var_rec</name> **</type><name>bestp</name></decl></param>, <param><decl><type><name>int</name></type> <name>prefer_scripts</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>var_rec</name> *</type><name>avail_recs</name> <init>= <expr>(<name>var_rec</name> *) <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>alg_result</name></decl>;</decl_stmt>              <comment type="block">/* result of variant selection algorithm */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <comment type="block">/* Decide if resource is transparently negotiable */</comment>

    <comment type="block">/* GET or HEAD? (HEAD has same method number as GET) */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_GET</name></expr>)</condition><then> <block>{

        <comment type="block">/* maybe this should be configurable, see also the comment
         * about recursive type maps in setup_choice_response()
         */</comment>
        <expr_stmt><expr><name><name>neg</name>-&gt;<name>is_transparent</name></name> = 1</expr>;</expr_stmt>

        <comment type="block">/* We can't be transparent if we are a map file in the middle
         * of the request URI.
         */</comment>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>path_info</name></name> &amp;&amp; *<name><name>r</name>-&gt;<name>path_info</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>neg</name>-&gt;<name>is_transparent</name></name> = 0</expr>;</expr_stmt></then></if>

        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>var_rec</name> *</type><name>variant</name> <init>= <expr>&amp;<name><name>avail_recs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* We can't be transparent, because of internal
             * assumptions in best_match(), if there is a
             * non-neighboring variant.  We can have a non-neighboring
             * variant when processing a type map.
             */</comment>
            <if>if <condition>(<expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>file_name</name></name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name><name>neg</name>-&gt;<name>is_transparent</name></name> = 0</expr>;</expr_stmt></then></if>

            <comment type="block">/* We can't be transparent, because of the behavior
             * of variant typemap bodies.
             */</comment>
            <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>body</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>neg</name>-&gt;<name>is_transparent</name></name> = 0</expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>is_transparent</name></name></expr>)</condition><then>  <block>{
        <expr_stmt><expr><call><name>parse_negotiate_header</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{ <comment type="block">/* configure negotiation on non-transparent resource */</comment>
        <expr_stmt><expr><name><name>neg</name>-&gt;<name>may_choose</name></name> = 1</expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>maybe_add_default_accepts</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>prefer_scripts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>alg_result</name> = <call><name>best_match</name><argument_list>(<argument><expr><name>neg</name></expr></argument>, <argument><expr><name>bestp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* alg_result is one of
     *   alg_choice: a best variant is chosen
     *   alg_list: no best variant is chosen
     */</comment>

    <if>if <condition>(<expr><name>alg_result</name> == <name>alg_list</name></expr>)</condition><then> <block>{
        <comment type="block">/* send a list response or HTTP_NOT_ACCEPTABLE error response  */</comment>

        <expr_stmt><expr><name><name>neg</name>-&gt;<name>send_alternates</name></name> = 1</expr>;</expr_stmt> <comment type="block">/* always include Alternates header */</comment>
        <expr_stmt><expr><call><name>set_neg_headers</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>alg_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>store_variant_list</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>is_transparent</name></name> &amp;&amp; <name><name>neg</name>-&gt;<name>ua_supports_trans</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* XXX todo: expires? cachability? */</comment>

            <comment type="block">/* Some HTTP/1.0 clients are known to choke when they get
             * a 300 (multiple choices) response without a Location
             * header.  However the 300 code response we are about
             * to generate will only reach 1.0 clients which support
             * transparent negotiation, and they should be OK. The
             * response should never reach older 1.0 clients, even if
             * we have CacheNegotiatedDocs enabled, because no 1.0
             * proxy cache (we know of) will cache and return 300
             * responses (they certainly won't if they conform to the
             * HTTP/1.0 specification).
             */</comment>
            <return>return <expr><name>HTTP_MULTIPLE_CHOICES</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>!*<name>bestp</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00690</expr></argument>)</argument_list></call>
                          "no acceptable variant: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_NOT_ACCEPTABLE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Variant selection chose a variant */</comment>

    <comment type="block">/* XXX todo: merge the two cases in the if statement below */</comment>
    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>is_transparent</name></name></expr>)</condition><then> <block>{

        <if>if <condition>(<expr>(<name>res</name> = <call><name>setup_choice_response</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr>*<name>bestp</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then> <block>{
            <return>return <expr><name>res</name></expr>;</return> <comment type="block">/* return if error */</comment>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>set_neg_headers</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>alg_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Make sure caching works - Vary should handle HTTP/1.1, but for
     * HTTP/1.0, we can't allow caching at all.
     */</comment>

    <comment type="block">/* XXX: Note that we only set r-&gt;no_cache to 1, which causes
     * Expires: &lt;now&gt; to be added, when responding to a HTTP/1.0
     * client.  If we return the response to a 1.1 client, we do not
     * add Expires &lt;now&gt;, because doing so would degrade 1.1 cache
     * performance by preventing re-use of the response without prior
     * revalidation.  On the other hand, if the 1.1 client is a proxy
     * which was itself contacted by a 1.0 client, or a proxy cache
     * which can be contacted later by 1.0 clients, then we currently
     * rely on this 1.1 proxy to add the Expires: &lt;now&gt; when it
     * forwards the response.
     *
     * XXX: TODO: Find out if the 1.1 spec requires proxies and
     * tunnels to add Expires: &lt;now&gt; when forwarding the response to
     * 1.0 clients.  I (kh) recall it is rather vague on this point.
     * Testing actual 1.1 proxy implementations would also be nice. If
     * Expires: &lt;now&gt; is not added by proxies then we need to always
     * include Expires: &lt;now&gt; ourselves to ensure correct caching, but
     * this would degrade HTTP/1.1 cache efficiency unless we also add
     * Cache-Control: max-age=N, which we currently don't.
     *
     * Roy: No, we are not going to screw over HTTP future just to
     *      ensure that people who can't be bothered to upgrade their
     *      clients will always receive perfect server-side negotiation.
     *      Hell, those clients are sending bogus accept headers anyway.
     *
     *      Manual setting of cache-control/expires always overrides this
     *      automated kluge, on purpose.
     */</comment>

    <if>if <condition>(<expr>(!<call><name>do_cache_negotiated_docs</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call>
         &amp;&amp; (<name><name>r</name>-&gt;<name>proto_num</name></name> &lt; <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call>))
         &amp;&amp; <name><name>neg</name>-&gt;<name>count_multiviews_variants</name></name> != 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>no_cache</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_map_file</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>var_rec</name> *</type><name>best</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>udir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_req</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>handler</name></name></expr></argument>, <argument><expr><name>MAP_FILE_MAGIC_TYPE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>handler</name></name></expr></argument>, <argument><expr>"type-map"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>neg</name> = <call><name>parse_accept_headers</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>res</name> = <call><name>read_type_map</name><argument_list>(<argument><expr>&amp;<name>map</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr><name>res</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>res</name> = <call><name>do_negotiation</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr>&amp;<name>best</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then> <block>{
        <return>return <expr><name>res</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>best</name>-&gt;<name>body</name></name></expr>)</condition><then>
    <block>{
        <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ap_allow_standard_methods</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>REPLACE_ALLOW</name></expr></argument>, <argument><expr><name>M_GET</name></expr></argument>, <argument><expr><name>M_OPTIONS</name></expr></argument>,
                                  <argument><expr><name>M_POST</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* XXX: ?
         * if (r-&gt;method_number == M_OPTIONS) {
         *    return ap_send_http_options(r);
         *}
         */</comment>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> != <name>M_GET</name> &amp;&amp; <name><name>r</name>-&gt;<name>method_number</name></name> != <name>M_POST</name></expr>)</condition><then> <block>{
            <return>return <expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* ### These may be implemented by adding some 'extra' info
         *     of the file offset onto the etag
         * ap_update_mtime(r, r-&gt;finfo.mtime);
         * ap_set_last_modified(r);
         * ap_set_etag(r);
         */</comment>
        <expr_stmt><expr><call><name>ap_set_accept_ranges</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_set_content_length</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>best</name>-&gt;<name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* set MIME type and charset as negotiated */</comment>
        <if>if <condition>(<expr><name><name>best</name>-&gt;<name>mime_type</name></name> &amp;&amp; *<name><name>best</name>-&gt;<name>mime_type</name></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>best</name>-&gt;<name>content_charset</name></name> &amp;&amp; *<name><name>best</name>-&gt;<name>content_charset</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                   <argument><expr><name><name>best</name>-&gt;<name>mime_type</name></name></expr></argument>,
                                                   <argument><expr>"; charset="</expr></argument>,
                                                   <argument><expr><name><name>best</name>-&gt;<name>content_charset</name></name></expr></argument>,
                                                   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>best</name>-&gt;<name>mime_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>

        <comment type="block">/* set Content-language(s) as negotiated */</comment>
        <if>if <condition>(<expr><name><name>best</name>-&gt;<name>content_languages</name></name> &amp;&amp; <name><name>best</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>content_languages</name></name> = <call><name>apr_array_copy</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                                  <argument><expr><name><name>best</name>-&gt;<name>content_languages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* set Content-Encoding as negotiated */</comment>
        <if>if <condition>(<expr><name><name>best</name>-&gt;<name>content_encoding</name></name> &amp;&amp; *<name><name>best</name>-&gt;<name>content_encoding</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>content_encoding</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                              <argument><expr><name><name>best</name>-&gt;<name>content_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr>(<name>res</name> = <call><name>ap_meets_conditions</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>) != <name>OK</name></expr>)</condition><then> <block>{
            <return>return <expr><name>res</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>(<name>res</name> = <call><name>ap_discard_request_body</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>) != <name>OK</name></expr>)</condition><then> <block>{
            <return>return <expr><name>res</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>apr_brigade_insert_file</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>best</name>-&gt;<name>body</name></name></expr></argument>, <argument><expr><name><name>best</name>-&gt;<name>bytes</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><call><name>ap_pass_brigade_fchk</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>path_info</name></name> &amp;&amp; *<name><name>r</name>-&gt;<name>path_info</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* remove any path_info from the end of the uri before trying
         * to change the filename.  r-&gt;path_info from the original
         * request is passed along on the redirect.
         */</comment>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>uri</name><index>[<expr><call><name>ap_find_path_info</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>path_info</name></name></expr></argument>)</argument_list></call></expr>]</index></name> = '\0'</expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>udir</name> = <call><name>ap_make_dirstr_parent</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>udir</name> = <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>udir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>path_info</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>new_req</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>udir</name></expr></argument>, <argument><expr><name><name>best</name>-&gt;<name>file_name</name></name></expr></argument>,
                                  <argument><expr><name><name>r</name>-&gt;<name>path_info</name></name></expr></argument>, <argument><expr>"?"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>new_req</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>udir</name></expr></argument>, <argument><expr><name><name>best</name>-&gt;<name>file_name</name></name></expr></argument>,
                                  <argument><expr>"?"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>new_req</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>udir</name></expr></argument>, <argument><expr><name><name>best</name>-&gt;<name>file_name</name></name></expr></argument>,
                              <argument><expr><name><name>r</name>-&gt;<name>path_info</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><call><name>ap_internal_redirect</name><argument_list>(<argument><expr><name>new_req</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>handle_multi</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>negotiation_state</name> *</type><name>neg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>var_rec</name> *</type><name>best</name></decl>, *<decl><type ref="prev"/><name>avail_recs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>sub_req</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>filetype</name></name> != <name>APR_NOFILE</name>
        || !(<call><name>ap_allow_options</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp; <name>OPT_MULTI</name>)</expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>neg</name> = <call><name>parse_accept_headers</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>res</name> = <call><name>read_types_multi</name><argument_list>(<argument><expr><name>neg</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
      <label><name>return_from_multi</name>:</label>
        <comment type="block">/* free all allocated memory from subrequests */</comment>
        <expr_stmt><expr><name>avail_recs</name> = (<name>var_rec</name> *) <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
            <decl_stmt><decl><type><name>var_rec</name> *</type><name>variant</name> <init>= <expr>&amp;<name><name>avail_recs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
            <if>if <condition>(<expr><name><name>variant</name>-&gt;<name>sub_req</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>sub_req</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
        <return>return <expr><name>res</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>res</name> = <call><name>do_negotiation</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>neg</name></expr></argument>, <argument><expr>&amp;<name>best</name></expr></argument>,
                         <argument><expr>(<name><name>r</name>-&gt;<name>method_number</name></name> != <name>M_GET</name>) || <name><name>r</name>-&gt;<name>args</name></name> ||
                         (<name><name>r</name>-&gt;<name>path_info</name></name> &amp;&amp; *<name><name>r</name>-&gt;<name>path_info</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then>
        <goto>goto <name>return_from_multi</name>;</goto></then></if>

    <if>if <condition>(<expr>!(<name>sub_req</name> = <name><name>best</name>-&gt;<name>sub_req</name></name>)</expr>)</condition><then> <block>{
        <comment type="block">/* We got this out of a map file, so we don't actually have
         * a sub_req structure yet.  Get one now.
         */</comment>

        <expr_stmt><expr><name>sub_req</name> = <call><name>ap_sub_req_lookup_file</name><argument_list>(<argument><expr><name><name>best</name>-&gt;<name>file_name</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>status</name></name> != <name>HTTP_OK</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>res</name> = <name><name>sub_req</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>sub_req</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <goto>goto <name>return_from_multi</name>;</goto>
        }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>sub_req</name>-&gt;<name>args</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>sub_req</name>-&gt;<name>args</name></name> = <name><name>r</name>-&gt;<name>args</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* now do a "fast redirect" ... promotes the sub_req into the main req */</comment>
    <expr_stmt><expr><call><name>ap_internal_fast_redirect</name><argument_list>(<argument><expr><name>sub_req</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* give no advise for time on this subrequest.  Perhaps we
     * should tally the last mtime among all variants, and date
     * the most recent, but that could confuse the proxies.
     */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>mtime</name></name> = 0</expr>;</expr_stmt>

    <comment type="block">/* clean up all but our favorite variant, since that sub_req
     * is now merged into the main request!
     */</comment>
    <expr_stmt><expr><name>avail_recs</name> = (<name>var_rec</name> *) <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>neg</name>-&gt;<name>avail_vars</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>var_rec</name> *</type><name>variant</name> <init>= <expr>&amp;<name><name>avail_recs</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>variant</name> != <name>best</name> &amp;&amp; <name><name>variant</name>-&gt;<name>sub_req</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name><name>variant</name>-&gt;<name>sub_req</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<comment type="block">/**********************************************************************
 * There is a problem with content-encoding, as some clients send and
 * expect an x- token (e.g. x-gzip) while others expect the plain token
 * (i.e. gzip). To try and deal with this as best as possible we do
 * the following: if the client sent an Accept-Encoding header and it
 * contains a plain token corresponding to the content encoding of the
 * response, then set content encoding using the plain token. Else if
 * the A-E header contains the x- token use the x- token in the C-E
 * header. Else don't do anything.
 *
 * Note that if no A-E header was sent, or it does not contain a token
 * compatible with the final content encoding, then the token in the
 * C-E header will be whatever was specified in the AddEncoding
 * directive.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>fix_encoding</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>enc</name> <init>= <expr><name><name>r</name>-&gt;<name>content_encoding</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>x_enc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>accept_encodings</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>accept_rec</name> *</type><name>accept_recs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>enc</name> || !*<name>enc</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>enc</name><index>[<expr>0</expr>]</index></name> == 'x' &amp;&amp; <name><name>enc</name><index>[<expr>1</expr>]</index></name> == '-'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>enc</name> += 2</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>accept_encodings</name> = <call><name>do_header_line</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
             <argument><expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Accept-Encoding"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>accept_recs</name> = (<name>accept_rec</name> *) <name><name>accept_encodings</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>accept_encodings</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><name><name>accept_recs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>content_encoding</name></name> = <name>name</name></expr>;</expr_stmt>
            <return>return <expr><name>OK</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == 'x' &amp;&amp; <name><name>name</name><index>[<expr>1</expr>]</index></name> == '-' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name>+2</expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>x_enc</name> = <name>name</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr><name>x_enc</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>content_encoding</name></name> = <name>x_enc</name></expr>;</expr_stmt>
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_hook_fixups</name><argument_list>(<argument><expr><name>fix_encoding</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_type_checker</name><argument_list>(<argument><expr><name>handle_multi</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>APR_HOOK_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_handler</name><argument_list>(<argument><expr><name>handle_map_file</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>NULL</name></expr></argument>,<argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>negotiation</name></expr></argument>)</argument_list></call> =
<block>{
    <expr><name>STANDARD20_MODULE_STUFF</name></expr>,
    <expr><name>create_neg_dir_config</name></expr>,      <comment type="block">/* dir config creator */</comment>
    <expr><name>merge_neg_dir_configs</name></expr>,      <comment type="block">/* dir merger --- default is to override */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* server config */</comment>
    <expr><name>NULL</name></expr>,                       <comment type="block">/* merge server config */</comment>
    <expr><name>negotiation_cmds</name></expr>,           <comment type="block">/* command apr_table_t */</comment>
    <expr><name>register_hooks</name></expr>              <comment type="block">/* register hooks */</comment>
}</block></expr>;</expr_stmt></block></while></block></function>
</unit>
