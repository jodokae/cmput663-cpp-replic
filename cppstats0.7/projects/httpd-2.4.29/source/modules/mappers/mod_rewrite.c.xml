<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/mappers/mod_rewrite.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*                       _                            _ _
 *   _ __ ___   ___   __| |    _ __ _____      ___ __(_) |_ ___
 *  | '_ ` _ \ / _ \ / _` |   | '__/ _ \ \ /\ / / '__| | __/ _ \
 *  | | | | | | (_) | (_| |   | | |  __/\ V  V /| |  | | ||  __/
 *  |_| |_| |_|\___/ \__,_|___|_|  \___| \_/\_/ |_|  |_|\__\___|
 *                       |_____|
 *
 *  URL Rewriting Module
 *
 *  This module uses a rule-based rewriting engine (based on a
 *  regular-expression parser) to rewrite requested URLs on the fly.
 *
 *  It supports an unlimited number of additional rule conditions (which can
 *  operate on a lot of variables, even on HTTP headers) for granular
 *  matching and even external database lookups (either via plain text
 *  tables, DBM hash files or even external processes) for advanced URL
 *  substitution.
 *
 *  It operates on the full URLs (including the PATH_INFO part) both in
 *  per-server context (httpd.conf) and per-dir context (.htaccess) and even
 *  can generate QUERY_STRING parts on result.   The rewriting result finally
 *  can lead to internal subprocessing, external request redirection or even
 *  to internal proxy throughput.
 *
 *  This module was originally written in April 1996 and
 *  gifted exclusively to the The Apache Software Foundation in July 1997 by
 *
 *      Ralf S. Engelschall
 *      rse engelschall.com
 *      www.engelschall.com
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_signal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_global_mutex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_dbm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_dbd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_dbd.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_mutex.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_MEMFUNC</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_IOVEC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<comment type="block">/* XXX: Do we really need these headers? */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_SYS_TYPES_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STDARG_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STDLIB_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_CTYPE_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_NETINET_IN_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_mutex.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_ssl.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_rewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_expr.h"</cpp:file></cpp:include>

<expr_stmt><expr>static <call><call><name>ap_dbd_t</name> *<argument_list>(<argument><expr>*<name>dbd_acquire</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>request_rec</name>*</expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr>static <call><call><name>void</name> <argument_list>(<argument><expr>*<name>dbd_prepare</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>server_rec</name>*</expr></argument>, <argument><expr>const <name>char</name>*</expr></argument>, <argument><expr>const <name>char</name>*</expr></argument>)</argument_list></call> = <name>NULL</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name>*</type> <name>really_last_key</name> <init>= <expr>"rewrite_really_last"</expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * in order to improve performance on running production systems, you
 * may strip all rewritelog code entirely from mod_rewrite by using the
 * -DREWRITELOG_DISABLED compiler option.
 *
 * DO NOT USE THIS OPTION FOR PUBLIC BINARY RELEASES. Otherwise YOU are
 * responsible for answering all the mod_rewrite questions out there.
 */</comment>
<comment type="block">/* If logging is limited to APLOG_DEBUG or lower, disable rewrite log, too */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>  <name>APLOG_MAX_LOGLEVEL</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive>     <expr><name>APLOG_MAX_LOGLEVEL</name> &lt; <name>APLOG_TRACE1</name></expr></cpp:if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>REWRITELOG_DISABLED</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWRITELOG_DISABLED</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>REWRITELOG_DISABLED</name></cpp:ifndef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rewritelog</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do_rewritelog x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWRITELOG_MODE</name></cpp:macro>  <cpp:value>( APR_UREAD | APR_UWRITE | APR_GREAD | APR_WREAD )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWRITELOG_FLAGS</name></cpp:macro> <cpp:value>( APR_WRITE | APR_APPEND | APR_CREATE )</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* !REWRITELOG_DISABLED */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>rewritelog</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* REWRITELOG_DISABLED */</comment>

<comment type="block">/* remembered mime-type for [T=...] */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWRITE_FORCED_MIMETYPE_NOTEVAR</name></cpp:macro> <cpp:value>"rewrite-forced-mimetype"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWRITE_FORCED_HANDLER_NOTEVAR</name></cpp:macro>  <cpp:value>"rewrite-forced-handler"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENVVAR_SCRIPT_URL</name></cpp:macro> <cpp:value>"SCRIPT_URL"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDIRECT_ENVVAR_SCRIPT_URL</name></cpp:macro> <cpp:value>"REDIRECT_" ENVVAR_SCRIPT_URL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENVVAR_SCRIPT_URI</name></cpp:macro> <cpp:value>"SCRIPT_URI"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDFLAG_NONE</name></cpp:macro>               <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDFLAG_NOCASE</name></cpp:macro>             <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDFLAG_NOTMATCH</name></cpp:macro>           <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDFLAG_ORNEXT</name></cpp:macro>             <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDFLAG_NOVARY</name></cpp:macro>             <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_NONE</name></cpp:macro>               <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_FORCEREDIRECT</name></cpp:macro>      <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_LASTRULE</name></cpp:macro>           <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_NEWROUND</name></cpp:macro>           <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_CHAIN</name></cpp:macro>              <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_IGNOREONSUBREQ</name></cpp:macro>     <cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_NOTMATCH</name></cpp:macro>           <cpp:value>(1&lt;&lt;6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_PROXY</name></cpp:macro>              <cpp:value>(1&lt;&lt;7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_PASSTHROUGH</name></cpp:macro>        <cpp:value>(1&lt;&lt;8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_QSAPPEND</name></cpp:macro>           <cpp:value>(1&lt;&lt;9)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_NOCASE</name></cpp:macro>             <cpp:value>(1&lt;&lt;10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_NOESCAPE</name></cpp:macro>           <cpp:value>(1&lt;&lt;11)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_NOSUB</name></cpp:macro>              <cpp:value>(1&lt;&lt;12)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_STATUS</name></cpp:macro>             <cpp:value>(1&lt;&lt;13)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_ESCAPEBACKREF</name></cpp:macro>      <cpp:value>(1&lt;&lt;14)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_DISCARDPATHINFO</name></cpp:macro>    <cpp:value>(1&lt;&lt;15)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_QSDISCARD</name></cpp:macro>          <cpp:value>(1&lt;&lt;16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_END</name></cpp:macro>                <cpp:value>(1&lt;&lt;17)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_ESCAPENOPLUS</name></cpp:macro>       <cpp:value>(1&lt;&lt;18)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RULEFLAG_QSLAST</name></cpp:macro>             <cpp:value>(1&lt;&lt;19)</cpp:value></cpp:define>

<comment type="block">/* return code of the rewrite rule
 * the result may be escaped - or not
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTION_NORMAL</name></cpp:macro>               <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTION_NOESCAPE</name></cpp:macro>             <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTION_STATUS</name></cpp:macro>               <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPTYPE_TXT</name></cpp:macro>                 <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPTYPE_DBM</name></cpp:macro>                 <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPTYPE_PRG</name></cpp:macro>                 <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPTYPE_INT</name></cpp:macro>                 <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPTYPE_RND</name></cpp:macro>                 <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPTYPE_DBD</name></cpp:macro>                 <cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAPTYPE_DBD_CACHE</name></cpp:macro>           <cpp:value>(1&lt;&lt;6)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENGINE_DISABLED</name></cpp:macro>             <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENGINE_ENABLED</name></cpp:macro>              <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_NONE</name></cpp:macro>                 <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_INHERIT</name></cpp:macro>              <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_INHERIT_BEFORE</name></cpp:macro>       <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_NOSLASH</name></cpp:macro>              <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_ANYURI</name></cpp:macro>               <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_MERGEBASE</name></cpp:macro>            <cpp:value>(1&lt;&lt;5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_INHERIT_DOWN</name></cpp:macro>         <cpp:value>(1&lt;&lt;6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_INHERIT_DOWN_BEFORE</name></cpp:macro>  <cpp:value>(1&lt;&lt;7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_IGNORE_INHERIT</name></cpp:macro>       <cpp:value>(1&lt;&lt;8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_IGNORE_CONTEXT_INFO</name></cpp:macro>  <cpp:value>(1&lt;&lt;9)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPTION_LEGACY_PREFIX_DOCROOT</name></cpp:macro> <cpp:value>(1&lt;&lt;10)</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RAND_MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RAND_MAX</name></cpp:macro> <cpp:value>32767</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* max cookie size in rfc 2109 */</comment>
<comment type="block">/* XXX: not used at all. We should do a check somewhere and/or cut the cookie */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_COOKIE_LEN</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<comment type="block">/* max line length (incl.\n) in text rewrite maps */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>REWRITE_MAX_TXT_MAP_LINE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWRITE_MAX_TXT_MAP_LINE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* buffer length for prg rewrite maps */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>REWRITE_PRG_MAP_BUF</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWRITE_PRG_MAP_BUF</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* for better readbility */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_CURLY</name></cpp:macro>  <cpp:value>'{'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHT_CURLY</name></cpp:macro> <cpp:value>'}'</cpp:value></cpp:define>

<comment type="block">/*
 * expansion result items on the stack to save some cycles
 *
 * (5 == about 2 variables like "foo%{var}bar%{var}baz")
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALL_EXPANSION</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
 * check that a subrequest won't cause infinite recursion
 *
 * either not in a subrequest, or in a subrequest
 * and URIs aren't NULL and sub/main URIs differ
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>subreq_ok</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(!r-&gt;main || \
    (r-&gt;main-&gt;uri &amp;&amp; r-&gt;uri &amp;&amp; strcmp(r-&gt;main-&gt;uri, r-&gt;uri)))</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>REWRITE_MAX_ROUNDS</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REWRITE_MAX_ROUNDS</name></cpp:macro> <cpp:value>32000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                 Types and Structures
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>datafile</name></decl>;</decl_stmt>          <comment type="block">/* filename for map data files         */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dbmtype</name></decl>;</decl_stmt>           <comment type="block">/* dbm type for dbm map data files     */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>checkfile</name></decl>;</decl_stmt>         <comment type="block">/* filename to check for map existence */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cachename</name></decl>;</decl_stmt>         <comment type="block">/* for cached maps (txt/rnd/dbm)       */</comment>
    <decl_stmt><decl><type><name>int</name></type>   <name>type</name></decl>;</decl_stmt>                    <comment type="block">/* the type of the map                 */</comment>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fpin</name></decl>;</decl_stmt>              <comment type="block">/* in  file pointer for program maps   */</comment>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fpout</name></decl>;</decl_stmt>             <comment type="block">/* out file pointer for program maps   */</comment>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fperr</name></decl>;</decl_stmt>             <comment type="block">/* err file pointer for program maps   */</comment>
    <function_decl><type><name>char</name> *</type>(*<name>func</name>)<parameter_list>(<param><decl><type><name>request_rec</name> *</type></decl></param>,   <comment type="block">/* function pointer for internal maps  */</comment>
                  <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
    <decl_stmt><decl><type><name>char</name> **</type><name>argv</name></decl>;</decl_stmt>                   <comment type="block">/* argv of the external rewrite map    */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dbdq</name></decl>;</decl_stmt>              <comment type="block">/* SQL SELECT statement for rewritemap */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>checkfile2</name></decl>;</decl_stmt>        <comment type="block">/* filename to check for map existence
                                      NULL if only one file               */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl>;</decl_stmt>              <comment type="block">/* run RewriteMap program as this user */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>group</name></decl>;</decl_stmt>             <comment type="block">/* run RewriteMap program as this group */</comment>
}</block></struct></type> <name>rewritemap_entry</name>;</typedef>

<comment type="block">/* special pattern types for RewriteCond */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>CONDPAT_REGEX</name> <init>= <expr>0</expr></init></decl>,
    <decl><name>CONDPAT_FILE_EXISTS</name></decl>,
    <decl><name>CONDPAT_FILE_SIZE</name></decl>,
    <decl><name>CONDPAT_FILE_LINK</name></decl>,
    <decl><name>CONDPAT_FILE_DIR</name></decl>,
    <decl><name>CONDPAT_FILE_XBIT</name></decl>,
    <decl><name>CONDPAT_LU_URL</name></decl>,
    <decl><name>CONDPAT_LU_FILE</name></decl>,
    <decl><name>CONDPAT_STR_LT</name></decl>,
    <decl><name>CONDPAT_STR_LE</name></decl>,
    <decl><name>CONDPAT_STR_EQ</name></decl>,
    <decl><name>CONDPAT_STR_GT</name></decl>,
    <decl><name>CONDPAT_STR_GE</name></decl>,
    <decl><name>CONDPAT_INT_LT</name></decl>,
    <decl><name>CONDPAT_INT_LE</name></decl>,
    <decl><name>CONDPAT_INT_EQ</name></decl>,
    <decl><name>CONDPAT_INT_GT</name></decl>,
    <decl><name>CONDPAT_INT_GE</name></decl>,
    <decl><name>CONDPAT_AP_EXPR</name></decl>
}</block></enum></type> <name>pattern_type</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>char</name>           *</type><name>input</name></decl>;</decl_stmt>   <comment type="block">/* Input string of RewriteCond   */</comment>
    <decl_stmt><decl><type><name>char</name>           *</type><name>pattern</name></decl>;</decl_stmt> <comment type="block">/* the RegExp pattern string     */</comment>
    <decl_stmt><decl><type><name>ap_regex_t</name>     *</type><name>regexp</name></decl>;</decl_stmt>  <comment type="block">/* the precompiled regexp        */</comment>
    <decl_stmt><decl><type><name>ap_expr_info_t</name> *</type><name>expr</name></decl>;</decl_stmt>    <comment type="block">/* the compiled ap_expr          */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>flags</name></decl>;</decl_stmt>   <comment type="block">/* Flags which control the match */</comment>
    <decl_stmt><decl><type><name>pattern_type</name></type>    <name>ptype</name></decl>;</decl_stmt>   <comment type="block">/* pattern type                  */</comment>
    <decl_stmt><decl><type><name>int</name></type>             <name>pskip</name></decl>;</decl_stmt>   <comment type="block">/* back-index to display pattern */</comment>
}</block></struct></type> <name>rewritecond_entry</name>;</typedef>

<comment type="block">/* single linked list for env vars and cookies */</comment>
<typedef>typedef <type><struct>struct <name>data_item</name> <block>{
    <decl_stmt><decl><type>struct <name>data_item</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>
}</block></struct></type> <name>data_item</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rewriteconds</name></decl>;</decl_stmt><comment type="block">/* the corresponding RewriteCond entries */</comment>
    <decl_stmt><decl><type><name>char</name>      *</type><name>pattern</name></decl>;</decl_stmt>              <comment type="block">/* the RegExp pattern string             */</comment>
    <decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>regexp</name></decl>;</decl_stmt>              <comment type="block">/* the RegExp pattern compilation        */</comment>
    <decl_stmt><decl><type><name>char</name>      *</type><name>output</name></decl>;</decl_stmt>               <comment type="block">/* the Substitution string               */</comment>
    <decl_stmt><decl><type><name>int</name></type>        <name>flags</name></decl>;</decl_stmt>                <comment type="block">/* Flags which control the substitution  */</comment>
    <decl_stmt><decl><type><name>char</name>      *</type><name>forced_mimetype</name></decl>;</decl_stmt>      <comment type="block">/* forced MIME type of substitution      */</comment>
    <decl_stmt><decl><type><name>char</name>      *</type><name>forced_handler</name></decl>;</decl_stmt>       <comment type="block">/* forced content handler of subst.      */</comment>
    <decl_stmt><decl><type><name>int</name></type>        <name>forced_responsecode</name></decl>;</decl_stmt>  <comment type="block">/* forced HTTP response status           */</comment>
    <decl_stmt><decl><type><name>data_item</name> *</type><name>env</name></decl>;</decl_stmt>                  <comment type="block">/* added environment variables           */</comment>
    <decl_stmt><decl><type><name>data_item</name> *</type><name>cookie</name></decl>;</decl_stmt>               <comment type="block">/* added cookies                         */</comment>
    <decl_stmt><decl><type><name>int</name></type>        <name>skip</name></decl>;</decl_stmt>                 <comment type="block">/* number of next rules to skip          */</comment>
    <decl_stmt><decl><type><name>int</name></type>        <name>maxrounds</name></decl>;</decl_stmt>            <comment type="block">/* limit on number of loops with N flag  */</comment>
    <decl_stmt><decl><type><name>char</name>       *</type><name>escapes</name></decl>;</decl_stmt>             <comment type="block">/* specific backref escapes              */</comment>
}</block></struct></type> <name>rewriterule_entry</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type>           <name>state</name></decl>;</decl_stmt>              <comment type="block">/* the RewriteEngine state            */</comment>
    <decl_stmt><decl><type><name>int</name></type>           <name>options</name></decl>;</decl_stmt>            <comment type="block">/* the RewriteOption state            */</comment>
    <decl_stmt><decl><type><name>apr_hash_t</name>         *</type><name>rewritemaps</name></decl>;</decl_stmt>  <comment type="block">/* the RewriteMap entries             */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rewriteconds</name></decl>;</decl_stmt> <comment type="block">/* the RewriteCond entries (temp.)    */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rewriterules</name></decl>;</decl_stmt> <comment type="block">/* the RewriteRule entries            */</comment>
    <decl_stmt><decl><type><name>server_rec</name>   *</type><name>server</name></decl>;</decl_stmt>             <comment type="block">/* the corresponding server indicator */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>state_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>options_set</name>:1</expr>;</expr_stmt>
}</block></struct></type> <name>rewrite_server_conf</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type>           <name>state</name></decl>;</decl_stmt>              <comment type="block">/* the RewriteEngine state           */</comment>
    <decl_stmt><decl><type><name>int</name></type>           <name>options</name></decl>;</decl_stmt>            <comment type="block">/* the RewriteOption state           */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rewriteconds</name></decl>;</decl_stmt> <comment type="block">/* the RewriteCond entries (temp.)   */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rewriterules</name></decl>;</decl_stmt> <comment type="block">/* the RewriteRule entries           */</comment>
    <decl_stmt><decl><type><name>char</name>         *</type><name>directory</name></decl>;</decl_stmt>          <comment type="block">/* the directory where it applies    */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>   *</type><name>baseurl</name></decl>;</decl_stmt>            <comment type="block">/* the base-URL  where it applies    */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>state_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>options_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>baseurl_set</name>:1</expr>;</expr_stmt>
}</block></struct></type> <name>rewrite_perdir_conf</name>;</typedef>

<comment type="block">/* the (per-child) cache structures.
 */</comment>
<typedef>typedef <type><struct>struct <name>cache</name> <block>{
    <decl_stmt><decl><type><name>apr_pool_t</name>         *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_t</name>         *</type><name>maps</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
    <decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>cache</name>;</typedef>

<comment type="block">/* cached maps contain an mtime for the whole map and live in a subpool
 * of the cachep-&gt;pool. That makes it easy to forget them if necessary.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>mtime</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
}</block></struct></type> <name>cachedmap</name>;</typedef>

<comment type="block">/* the regex structure for the
 * substitution of backreferences
 */</comment>
<typedef>typedef <type><struct>struct <name>backrefinfo</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_regmatch_t</name></type> <name><name>regmatch</name><index>[<expr><name>AP_MAX_REG_MATCH</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>backrefinfo</name>;</typedef>

<comment type="block">/* single linked list used for
 * variable expansion
 */</comment>
<typedef>typedef <type><struct>struct <name>result_list</name> <block>{
    <decl_stmt><decl><type>struct <name>result_list</name> *</type><name>next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl>;</decl_stmt>
}</block></struct></type> <name>result_list</name>;</typedef>

<comment type="block">/* context structure for variable lookup and expansion
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>  *</type><name>uri</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>  *</type><name>vary_this</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>  *</type><name>vary</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>        *</type><name>perdir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>backrefinfo</name></type> <name>briRR</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>backrefinfo</name></type> <name>briRC</name></decl>;</decl_stmt>
}</block></struct></type> <name>rewrite_ctx</name>;</typedef>

<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                 static module data
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<comment type="block">/* the global module structure */</comment>
<decl_stmt><decl><type><name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>rewrite_module</name></decl>;</decl_stmt>

<comment type="block">/* rewritemap int: handler function registry */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_hash_t</name> *</type><name>mapfunc_hash</name></decl>;</decl_stmt>

<comment type="block">/* the cache */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>cache</name> *</type><name>cachep</name></decl>;</decl_stmt>

<comment type="block">/* whether proxy module is available or not */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>proxy_available</name></decl>;</decl_stmt>

<comment type="block">/* Locks/Mutexes */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_global_mutex_t</name> *</type><name>rewrite_mapr_lock_acquire</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>rewritemap_mutex_type</name> <init>= <expr>"rewrite-map"</expr></init></decl>;</decl_stmt>

<comment type="block">/* Optional functions imported from mod_ssl when loaded: */</comment>
<expr_stmt><expr>static <call><name>APR_OPTIONAL_FN_TYPE</name><argument_list>(<argument><expr><name>ssl_var_lookup</name></expr></argument>)</argument_list></call> *<name>rewrite_ssl_lookup</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr>static <call><name>APR_OPTIONAL_FN_TYPE</name><argument_list>(<argument><expr><name>ssl_is_https</name></expr></argument>)</argument_list></call> *<name>rewrite_is_https</name> = <name>NULL</name></expr>;</expr_stmt>
<function_decl><type><specifier>static</specifier> <name>char</name> *</type><name>escape_backref</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>escapeme</name></decl></param>, <param><decl><type><name>int</name></type> <name>noplus</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |              rewriting logfile support
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>REWRITELOG_DISABLED</name></cpp:ifndef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_rewritelog</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>, <param><decl><type><name>char</name> *</type><name>perdir</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
        __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>,<param/></parameter_list>4,5</function_decl>)))<empty_stmt>;</empty_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_rewritelog</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>, <param><decl><type><name>char</name> *</type><name>perdir</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>logline</name></decl>, *<decl><type ref="prev"/><name>text</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rhost</name></decl>, *<decl><type ref="prev"/><name>rname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>redir</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>req</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>APLOG_R_IS_LEVEL</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name> + <name>level</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return;</return></then></if>

    <expr_stmt><expr><name>rhost</name> = <call><name>ap_get_useragent_host</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>REMOTE_NOLOOKUP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rname</name> = <call><name>ap_get_remote_logname</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for (<init><expr><name>redir</name>=0</expr>, <expr><name>req</name>=<name>r</name></expr>;</init> <condition><expr><name><name>req</name>-&gt;<name>prev</name></name></expr>;</condition> <incr><expr><name>req</name> = <name><name>req</name>-&gt;<name>prev</name></name></expr></incr>) <block>{
        <expr_stmt><expr>++<name>redir</name></expr>;</expr_stmt>
    }</block></for>

    <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>text</name> = <call><name>apr_pvsprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>logline</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%s %s %s [%s/sid#%pp][rid#%pp/%s%s%s] "
                                    "%s%s%s%s"</expr></argument>,
                           <argument><expr><name>rhost</name> ? <name>rhost</name> : "UNKNOWN-HOST"</expr></argument>,
                           <argument><expr><name>rname</name> ? <name>rname</name> : "-"</expr></argument>,
                           <argument><expr><name><name>r</name>-&gt;<name>user</name></name> ? (*<name><name>r</name>-&gt;<name>user</name></name> ? <name><name>r</name>-&gt;<name>user</name></name> : "\"\"") : "-"</expr></argument>,
                           <argument><expr><call><name>ap_get_server_name</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call>(<name>void</name> *)<argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr>(<name>void</name> *)<name>r</name></expr></argument>,
                           <argument><expr><name><name>r</name>-&gt;<name/></name>main ? "subreq" : "initial"</expr></argument>,
                           <argument><expr><name>redir</name> ? "/redir#" : ""</expr></argument>,
                           <argument><expr><name>redir</name> ? <call><name>apr_itoa</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>redir</name></expr></argument>)</argument_list></call> : ""</expr></argument>,
                           <argument><expr><name>perdir</name> ? "[perdir " : ""</expr></argument>,
                           <argument><expr><name>perdir</name> ? <name>perdir</name> : ""</expr></argument>,
                           <argument><expr><name>perdir</name> ? "] ": ""</expr></argument>,
                           <argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>AP_REWRITE_LOG</name><argument_list>(<argument><expr>(<name>uintptr_t</name>)<name>r</name></expr></argument>, <argument><expr><name>level</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name/></name>main ? 0 : 1</expr></argument>, <argument><expr>(<name>char</name> *)<call><name>ap_get_server_name</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>logline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Intentional no APLOGNO */</comment>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name> + <name>level</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>logline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !REWRITELOG_DISABLED */</comment>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                URI and path functions
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<comment type="block">/* return number of chars of the scheme (incl. '://')
 * if the URI is absolute (includes a scheme etc.)
 * otherwise 0.
 * If supportqs is not NULL, we return a whether or not
 * the scheme supports a query string or not.
 *
 * NOTE: If you add new schemes here, please have a
 *       look at escape_absolute_uri and splitout_queryargs.
 *       Not every scheme takes query strings and some schemes
 *       may be handled in a special way.
 *
 * XXX: we may consider a scheme registry, perhaps with
 *      appropriate escape callbacks to allow other modules
 *      to extend mod_rewrite at runtime.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>is_absolute_uri</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>uri</name></decl></param>, <param><decl><type><name>int</name> *</type><name>supportsqs</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>, *<decl><type ref="prev"/><name>sqs</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sqs</name> = (<name>supportsqs</name> ? <name>supportsqs</name> : &amp;<name>dummy</name>)</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>sqs</name> = 0</expr>;</expr_stmt>
    <comment type="block">/* fast exit */</comment>
    <if>if <condition>(<expr>*<name>uri</name> == '/' || <call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call> &lt;= 5</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <switch>switch <condition>(<expr>*<name>uri</name>++</expr>)</condition> <block>{
    <case>case <expr>'a'</expr>:
    </case><case>case <expr>'A'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"jp://"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{        <comment type="block">/* ajp://    */</comment>
          <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
          <return>return <expr>6</expr>;</return>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr>'b'</expr>:
    </case><case>case <expr>'B'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"alancer://"</expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{   <comment type="block">/* balancer:// */</comment>
          <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
          <return>return <expr>11</expr>;</return>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr>'f'</expr>:
    </case><case>case <expr>'F'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"tp://"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{        <comment type="block">/* ftp://    */</comment>
            <return>return <expr>6</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"cgi://"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{       <comment type="block">/* fcgi://   */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>7</expr>;</return>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr>'g'</expr>:
    </case><case>case <expr>'G'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"opher://"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{     <comment type="block">/* gopher:// */</comment>
            <return>return <expr>9</expr>;</return>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr>'h'</expr>:
    </case><case>case <expr>'H'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"ttp://"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{       <comment type="block">/* http://   */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>7</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"ttps://"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ <comment type="block">/* https://  */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>8</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"2://"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{    <comment type="block">/* h2://     */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>5</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"2c://"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{   <comment type="block">/* h2c://    */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>6</expr>;</return>
        }</block></then></if></else></if></else></if></else></if>
        <break>break;</break>

    </case><case>case <expr>'l'</expr>:
    </case><case>case <expr>'L'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"dap://"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{       <comment type="block">/* ldap://   */</comment>
            <return>return <expr>7</expr>;</return>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr>'m'</expr>:
    </case><case>case <expr>'M'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"ailto:"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{       <comment type="block">/* mailto:   */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>7</expr>;</return>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr>'n'</expr>:
    </case><case>case <expr>'N'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"ews:"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{         <comment type="block">/* news:     */</comment>
            <return>return <expr>5</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"ntp://"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="block">/* nntp://   */</comment>
            <return>return <expr>7</expr>;</return>
        }</block></then></if></else></if>
        <break>break;</break>

    </case><case>case <expr>'s'</expr>:
    </case><case>case <expr>'S'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"cgi://"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{       <comment type="block">/* scgi://   */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>7</expr>;</return>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr>'w'</expr>:
    </case><case>case <expr>'W'</expr>:
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"s://"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{        <comment type="block">/* ws://     */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>5</expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"ss://"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{  <comment type="block">/* wss://    */</comment>
            <expr_stmt><expr>*<name>sqs</name> = 1</expr>;</expr_stmt>
            <return>return <expr>6</expr>;</return>
        }</block></then></if></else></if>
        <break>break;</break>
    </case>}</block></switch>

    <return>return <expr>0</expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>c2x_table</name><index>[]</index></name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>unsigned</name> <name>char</name> *</type><name>c2x</name><parameter_list>(<param><decl><type><name>unsigned</name></type> <name>what</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name></type> <name>prefix</name></decl></param>,
                                     <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>where</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
    <expr_stmt><expr><name>what</name> = <call><name>apr_xlate_conv_byte</name><argument_list>(<argument><expr><name>ap_hdrs_to_ascii</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/*APR_CHARSET_EBCDIC*/</comment>
    <expr_stmt><expr>*<name>where</name>++ = <name>prefix</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>where</name>++ = <name><name>c2x_table</name><index>[<expr><name>what</name> &gt;&gt; 4</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>where</name>++ = <name><name>c2x_table</name><index>[<expr><name>what</name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
    <return>return <expr><name>where</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Escapes a backreference in a similar way as php's urlencode does.
 * Based on ap_os_escape_path in server/util.c
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>escape_backref</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>escapeme</name></decl></param>, <param><decl><type><name>int</name></type> <name>noplus</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>copy</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>3 * <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 3</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>s</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>path</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>d</name> <init>= <expr>(<name>unsigned</name> <name>char</name> *)<name>copy</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>c</name></decl>;</decl_stmt>

    <while>while <condition>(<expr>(<name>c</name> = *<name>s</name>)</expr>)</condition> <block>{
        <if>if <condition>(<expr>!<name>escapeme</name></expr>)</condition><then> <block>{ 
            <if>if <condition>(<expr><call><name>apr_isalnum</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> || <name>c</name> == '_'</expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>d</name>++ = <name>c</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>c</name> == ' ' &amp;&amp; !<name>noplus</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>d</name>++ = '+'</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>d</name> = <call><name>c2x</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>'%'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then>
        <else>else <block>{ 
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>esc</name> <init>= <expr><name>escapeme</name></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr>*<name>esc</name></expr>)</condition> <block>{ 
                <if>if <condition>(<expr><name>c</name> == *<name>esc</name></expr>)</condition><then> <block>{ 
                    <if>if <condition>(<expr><name>c</name> == ' ' &amp;&amp; !<name>noplus</name></expr>)</condition><then> <block>{ 
                        <expr_stmt><expr>*<name>d</name>++ = '+'</expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{ 
                        <expr_stmt><expr><name>d</name> = <call><name>c2x</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr>'%'</expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr>++<name>esc</name></expr>;</expr_stmt>
            }</block></while>
            <if>if <condition>(<expr>!*<name>esc</name></expr>)</condition><then> <block>{ 
                <expr_stmt><expr>*<name>d</name>++ = <name>c</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
        <expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr>*<name>d</name> = '\0'</expr>;</expr_stmt>
    <return>return <expr><name>copy</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * escape absolute uri, which may or may not be path oriented.
 * So let's handle them differently.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>escape_absolute_uri</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>uri</name></decl></param>, <param><decl><type><name>unsigned</name></type> <name>scheme</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>

    <comment type="block">/* be safe.
     * NULL should indicate elsewhere, that something's wrong
     */</comment>
    <if>if <condition>(<expr>!<name>scheme</name> || <call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call> &lt; <name>scheme</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>cp</name> = <name>uri</name> + <name>scheme</name></expr>;</expr_stmt>

    <comment type="block">/* scheme with authority part? */</comment>
    <if>if <condition>(<expr><name><name>cp</name><index>[<expr>-1</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
        <comment type="block">/* skip host part */</comment>
        <while>while <condition>(<expr>*<name>cp</name> &amp;&amp; *<name>cp</name> != '/'</expr>)</condition> <block>{
            <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* nothing after the hostpart. ready! */</comment>
        <if>if <condition>(<expr>!*<name>cp</name> || !*++<name>cp</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="block">/* remember the hostname stuff */</comment>
        <expr_stmt><expr><name>scheme</name> = <name>cp</name> - <name>uri</name></expr>;</expr_stmt>

        <comment type="block">/* special thing for ldap.
         * The parts are separated by question marks. From RFC 2255:
         *     ldapurl = scheme "://" [hostport] ["/"
         *               [dn ["?" [attributes] ["?" [scope]
         *               ["?" [filter] ["?" extensions]]]]]]
         */</comment>
        <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr>"ldap"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name><name>token</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>token</name><index>[<expr>0</expr>]</index></name> = <name>cp</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr>*<name>cp</name> &amp;&amp; <name>c</name> &lt; 4</expr>)</condition> <block>{
                <if>if <condition>(<expr>*<name>cp</name> == '?'</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>token</name><index>[<expr>++<name>c</name></expr>]</index></name> = <name>cp</name> + 1</expr>;</expr_stmt>
                    <expr_stmt><expr>*<name>cp</name> = '\0'</expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
            }</block></while>

            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><call><name>ap_escape_uri</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>token</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr>(<name>c</name> &gt;= 1) ? "?" : <name>NULL</name></expr></argument>,
                               <argument><expr>(<name>c</name> &gt;= 1) ? <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>token</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></argument>,
                               <argument><expr>(<name>c</name> &gt;= 2) ? "?" : <name>NULL</name></expr></argument>,
                               <argument><expr>(<name>c</name> &gt;= 2) ? <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>token</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></argument>,
                               <argument><expr>(<name>c</name> &gt;= 3) ? "?" : <name>NULL</name></expr></argument>,
                               <argument><expr>(<name>c</name> &gt;= 3) ? <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>token</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></argument>,
                               <argument><expr>(<name>c</name> &gt;= 4) ? "?" : <name>NULL</name></expr></argument>,
                               <argument><expr>(<name>c</name> &gt;= 4) ? <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>token</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Nothing special here. Apply normal escaping. */</comment>
    <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>scheme</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>ap_escape_uri</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * split out a QUERY_STRING part from
 * the current URI string
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>splitout_queryargs</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name></type> <name>qsappend</name></decl></param>, <param><decl><type><name>int</name></type> <name>qsdiscard</name></decl></param>, 
                               <param><decl><type><name>int</name></type> <name>qslast</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>split</name></decl>;</decl_stmt>

    <comment type="block">/* don't touch, unless it's a scheme for which a query string makes sense.
     * See RFC 1738 and RFC 2368.
     */</comment>
    <if>if <condition>(<expr><call><name>is_absolute_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>&amp;<name>split</name></expr></argument>)</argument_list></call>
        &amp;&amp; !<name>split</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>args</name></name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* forget the query that's still flying around */</comment>
        <return>return;</return>
    }</block></then></if>

    <if>if <condition>( <expr><name>qsdiscard</name></expr> )</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>args</name></name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* Discard query string */</comment>
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name>NULL</name>, "discarding query string")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>q</name> = <name>qslast</name> ? <call><name>ap_strrchr</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>'?'</expr></argument>)</argument_list></call> : <call><name>ap_strchr</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>'?'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>q</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>olduri</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>olduri</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>q</name>++ = '\0'</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>qsappend</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>*<name>q</name></expr>)</condition><then> <block>{ 
                <expr_stmt><expr><name><name>r</name>-&gt;<name>args</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr>"&amp;"</expr></argument> , <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>args</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name></name></expr>)</condition><then> <block>{ 
           <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
           <if>if <condition>(<expr>!<name>len</name></expr>)</condition><then> <block>{
               <expr_stmt><expr><name><name>r</name>-&gt;<name>args</name></name> = <name>NULL</name></expr>;</expr_stmt>
           }</block></then>
           <else>else <if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name><index>[<expr><name>len</name>-1</expr>]</index></name> == '&amp;'</expr>)</condition><then> <block>{
               <expr_stmt><expr><name><name>r</name>-&gt;<name>args</name><index>[<expr><name>len</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
           }</block></then></if></else></if>
        }</block></then></if>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 3, <name>NULL</name>, "split uri=%s -&gt; uri=%s, args=%s", <name>olduri</name>,
                    <name><name>r</name>-&gt;<name>filename</name></name>, <name><name>r</name>-&gt;<name>args</name></name> ? <name><name>r</name>-&gt;<name>args</name></name> : "&lt;none&gt;")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return;</return>
}</block></function>

<comment type="block">/*
 * strip 'http[s]://ourhost/' from URI
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>reduce_uri</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>l</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cp</name> = (<name>char</name> *)<call><name>ap_http_scheme</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>l</name>  = <call><name>strlen</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(   <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call> &gt; <name>l</name>+3
        &amp;&amp; <call><name>strncasecmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call> == 0
        &amp;&amp; <name><name>r</name>-&gt;<name>filename</name><index>[<expr><name>l</name></expr>]</index></name>   == ':'
        &amp;&amp; <name><name>r</name>-&gt;<name>filename</name><index>[<expr><name>l</name>+1</expr>]</index></name> == '/'
        &amp;&amp; <name><name>r</name>-&gt;<name>filename</name><index>[<expr><name>l</name>+2</expr>]</index></name> == '/'</expr> )</condition><then> <block>{

        <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>port</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>portp</name></decl>, *<decl><type ref="prev"/><name>host</name></decl>, *<decl><type ref="prev"/><name>url</name></decl>, *<decl><type ref="prev"/><name>scratch</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>scratch</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* our scratchpad */</comment>

        <comment type="block">/* cut the hostname and port out of the URI */</comment>
        <expr_stmt><expr><name>cp</name> = <name>host</name> = <name>scratch</name> + <name>l</name> + 3</expr>;</expr_stmt>    <comment type="block">/* 3 == strlen("://") */</comment>
        <while>while <condition>(<expr>*<name>cp</name> &amp;&amp; *<name>cp</name> != '/' &amp;&amp; *<name>cp</name> != ':'</expr>)</condition> <block>{
            <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr>*<name>cp</name> == ':'</expr>)</condition><then> <block>{      <comment type="block">/* additional port given */</comment>
            <expr_stmt><expr>*<name>cp</name>++ = '\0'</expr>;</expr_stmt>
            <expr_stmt><expr><name>portp</name> = <name>cp</name></expr>;</expr_stmt>
            <while>while <condition>(<expr>*<name>cp</name> &amp;&amp; *<name>cp</name> != '/'</expr>)</condition> <block>{
                <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr>*<name>cp</name> = '\0'</expr>;</expr_stmt>

            <expr_stmt><expr><name>port</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>portp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>url</name> = <name><name>r</name>-&gt;<name>filename</name></name> + (<name>cp</name> - <name>scratch</name>)</expr>;</expr_stmt>
            <if>if <condition>(<expr>!*<name>url</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>url</name> = "/"</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>cp</name> == '/'</expr>)</condition><then> <block>{ <comment type="block">/* default port */</comment>
            <expr_stmt><expr>*<name>cp</name> = '\0'</expr>;</expr_stmt>

            <expr_stmt><expr><name>port</name> = <call><name>ap_default_port</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>url</name> = <name><name>r</name>-&gt;<name>filename</name></name> + (<name>cp</name> - <name>scratch</name>)</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>port</name> = <call><name>ap_default_port</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>url</name> = "/"</expr>;</expr_stmt>
        }</block></else></if></else></if>

        <comment type="block">/* now check whether we could reduce it to a local path... */</comment>
        <if>if <condition>(<expr><call><name>ap_matches_request_vhost</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>host</name></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>conf</name> <init>= 
                <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 3, <name>NULL</name>, "reduce %s -&gt; %s", <name><name>r</name>-&gt;<name>filename</name></name>, <name>url</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* remember that the uri was reduced */</comment>
            <if>if<condition>(<expr>!(<name><name>conf</name>-&gt;<name>options</name></name> &amp; <name>OPTION_LEGACY_PREFIX_DOCROOT</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"mod_rewrite_uri_reduced"</expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <return>return;</return>
}</block></function>

<comment type="block">/*
 * add 'http[s]://ourhost[:ourport]/' to URI
 * if URI is still not fully qualified
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fully_qualify_uri</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_CONNECT</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>is_absolute_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>thisserver</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>thisport</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>port</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>thisserver</name> = <call><name>ap_get_server_name_for_url</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>port</name> = <call><name>ap_get_server_port</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>thisport</name> = <call><name>ap_is_default_port</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call>
                   ? ""
                   : <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>":%u"</expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%s://%s%s%s%s"</expr></argument>,
                                   <argument><expr><call><name>ap_http_scheme</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>thisserver</name></expr></argument>, <argument><expr><name>thisport</name></expr></argument>,
                                   <argument><expr>(*<name><name>r</name>-&gt;<name>filename</name></name> == '/') ? "" : "/"</expr></argument>,
                                   <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <return>return;</return>
}</block></function>

<comment type="block">/*
 * stat() only the first segment of a path
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>prefix_stat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>curpath</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>slash</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>statpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_filepath_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr>&amp;<name>curpath</name></expr></argument>, <argument><expr><name>APR_FILEPATH_TRUENAME</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <comment type="block">/* let's recognize slashes only, the mod_rewrite semantics are opaque
     * enough.
     */</comment>
    <if>if <condition>(<expr>(<name>slash</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>curpath</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_filepath_merge</name><argument_list>(<argument><expr>&amp;<name>statpath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                                <argument><expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>curpath</name></expr></argument>,
                                             <argument><expr><call>(<name>apr_size_t</name>)<argument_list>(<argument><expr><name>slash</name> - <name>curpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>APR_FILEPATH_NOTABOVEROOT</name> |
                                <name>APR_FILEPATH_NOTRELATIVE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_filepath_merge</name><argument_list>(<argument><expr>&amp;<name>statpath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>curpath</name></expr></argument>,
                                <argument><expr><name>APR_FILEPATH_NOTABOVEROOT</name> |
                                <name>APR_FILEPATH_NOTRELATIVE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>sb</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>statpath</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 * substitute the prefix path 'match' in 'input' with 'subst' (RewriteBase)
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>subst_prefix_path</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>input</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>match</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>subst</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>len</name> &amp;&amp; <name><name>match</name><index>[<expr><name>len</name> - 1</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
        <expr_stmt><expr>--<name>len</name></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>match</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>input</name><index>[<expr><name>len</name>++</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>slen</name></decl>, <decl><type ref="prev"/><name>outlen</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>output</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "strip matching prefix: %s -&gt; %s", <name>input</name>,
                    <name>input</name>+<name>len</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>slen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>slen</name> &amp;&amp; <name><name>subst</name><index>[<expr><name>slen</name> - 1</expr>]</index></name> != '/'</expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>slen</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><name>outlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> + <name>slen</name> - <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>output</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>outlen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* don't forget the \0 */</comment>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>subst</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>slen</name> &amp;&amp; !<name><name>output</name><index>[<expr><name>slen</name>-1</expr>]</index></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>output</name><index>[<expr><name>slen</name>-1</expr>]</index></name> = '/'</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>output</name>+<name>slen</name></expr></argument>, <argument><expr><name>input</name>+<name>len</name></expr></argument>, <argument><expr><name>outlen</name> - <name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>output</name><index>[<expr><name>outlen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 4, <name>NULL</name>, "add subst prefix: %s -&gt; %s", <name>input</name>+<name>len</name>,
                    <name>output</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>output</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* prefix didn't match */</comment>
    <return>return <expr><name>input</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                    caching support
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_cache_value</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>apr_time_t</name></type> <name>t</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>,
                            <param><decl><type><name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cachedmap</name> *</type><name>map</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>cachep</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
        <expr_stmt><expr><call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>map</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>maps</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>map</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name><name>cachep</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
                <expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <return>return;</return>
            }</block></then></if>

            <expr_stmt><expr><name>map</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cachedmap</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>map</name>-&gt;<name>pool</name></name> = <name>p</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>map</name>-&gt;<name>entries</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>map</name>-&gt;<name>mtime</name></name> = <name>t</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>maps</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>map</name>-&gt;<name>mtime</name></name> != <name>t</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>map</name>-&gt;<name>entries</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>map</name>-&gt;<name>mtime</name></name> = <name>t</name></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <comment type="block">/* Now we should have a valid map-&gt;entries hash, where we
         * can store our value.
         *
         * We need to copy the key and the value into OUR pool,
         * so that we don't leave it during the r-&gt;pool cleanup.
         */</comment>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>entries</name></name></expr></argument>,
                     <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                     <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
        <expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

    <return>return;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>get_cache_value</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>apr_time_t</name></type> <name>t</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cachedmap</name> *</type><name>map</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>cachep</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
        <expr_stmt><expr><call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>map</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>maps</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>map</name></expr>)</condition><then> <block>{
            <comment type="block">/* if this map is outdated, forget it. */</comment>
            <if>if <condition>(<expr><name><name>map</name>-&gt;<name>mtime</name></name> != <name>t</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_pool_clear</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>map</name>-&gt;<name>entries</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>map</name>-&gt;<name>mtime</name></name> = <name>t</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>map</name>-&gt;<name>entries</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>val</name></expr>)</condition><then> <block>{
                    <comment type="block">/* copy the cached value into the supplied pool,
                     * where it belongs (r-&gt;pool usually)
                     */</comment>
                    <expr_stmt><expr><name>val</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
        <expr_stmt><expr><call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>

    <return>return <expr><name>val</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>init_cache</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>cachep</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>apr_pool_create</name><argument_list>(<argument><expr>&amp;<name><name>cachep</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>cachep</name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* turns off cache */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>cachep</name>-&gt;<name>maps</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>cachep</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
    <expr_stmt><expr>(<name>void</name>)<call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;(<name><name>cachep</name>-&gt;<name>lock</name></name>)</expr></argument>, <argument><expr><name>APR_THREAD_MUTEX_DEFAULT</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr>1</expr>;</return>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                    Map Functions
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<comment type="block">/*
 * General Note: key is already a fresh string, created (expanded) just
 * for the purpose to be passed in here. So one can modify key itself.
 */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>rewrite_mapfunc_toupper</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_str_toupper</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>key</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>rewrite_mapfunc_tolower</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>key</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>rewrite_mapfunc_escape</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>rewrite_mapfunc_unescape</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_unescape_url</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>key</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>select_random_value_part</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <comment type="block">/* count number of distinct values */</comment>
    <while>while <condition>(<expr>(<name>p</name> = <call><name>ap_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>'|'</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>n</name></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name>n</name> &gt; 1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>n</name> = <call><name>ap_random_pick</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* extract it from the whole string */</comment>
        <while>while <condition>(<expr>--<name>n</name> &amp;&amp; (<name>value</name> = <call><name>ap_strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>'|'</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>value</name></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{ <comment type="block">/* should not be NULL, but ... */</comment>
            <expr_stmt><expr><name>p</name> = <call><name>ap_strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>'|'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>p</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>value</name></expr>;</return>
}</block></function>

<comment type="block">/* child process code */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>rewrite_child_errfn</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_status_t</name></type> <name>err</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>desc</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00653</expr></argument>)</argument_list></call> "%s"</expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>rewritemap_program_child</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>progname</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>,
                                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>group</name></decl></param>,
                                             <param><decl><type><name>apr_file_t</name> **</type><name>fpout</name></decl></param>,
                                             <param><decl><type><name>apr_file_t</name> **</type><name>fpin</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_procattr_t</name> *</type><name>procattr</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_proc_t</name> *</type><name>procnew</name></decl>;</decl_stmt>

    <if>if <condition>(   <expr><name>APR_SUCCESS</name> == (<name>rc</name>=<call><name>apr_procattr_create</name><argument_list>(<argument><expr>&amp;<name>procattr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call>)
        &amp;&amp; <name>APR_SUCCESS</name> == (<name>rc</name>=<call><name>apr_procattr_io_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>,
                                                  <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>, <argument><expr><name>APR_NO_PIPE</name></expr></argument>)</argument_list></call>)
        &amp;&amp; <name>APR_SUCCESS</name> == (<name>rc</name>=<call><name>apr_procattr_dir_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>,
                                             <argument><expr><call><name>ap_make_dirstr_parent</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>)
        &amp;&amp; (!<name>user</name> || <name>APR_SUCCESS</name> == (<name>rc</name>=<call><name>apr_procattr_user_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call>))
        &amp;&amp; (!<name>group</name> || <name>APR_SUCCESS</name> == (<name>rc</name>=<call><name>apr_procattr_group_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call>))
        &amp;&amp; <name>APR_SUCCESS</name> == (<name>rc</name>=<call><name>apr_procattr_cmdtype_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>APR_PROGRAM</name></expr></argument>)</argument_list></call>)
        &amp;&amp; <name>APR_SUCCESS</name> == (<name>rc</name>=<call><name>apr_procattr_child_errfn_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>,
                                                           <argument><expr><name>rewrite_child_errfn</name></expr></argument>)</argument_list></call>)
        &amp;&amp; <name>APR_SUCCESS</name> == (<name>rc</name>=<call><name>apr_procattr_error_check_set</name><argument_list>(<argument><expr><name>procattr</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{

        <expr_stmt><expr><name>procnew</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>procnew</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>apr_proc_create</name><argument_list>(<argument><expr><name>procnew</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>(const <name>char</name> **)<name>argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>procattr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rc</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_pool_note_subprocess</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>procnew</name></expr></argument>, <argument><expr><name>APR_KILL_AFTER_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>fpin</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>(*<name>fpin</name>) = <name><name>procnew</name>-&gt;<name>in</name></name></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>fpout</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>(*<name>fpout</name>) = <name><name>procnew</name>-&gt;<name>out</name></name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr>(<name>rc</name>)</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>run_rewritemap_programs</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*  If the engine isn't turned on,
     *  don't even try to do anything.
     */</comment>
    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>state</name></name> == <name>ENGINE_DISABLED</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>rewritemaps</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)<block>{
        <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fpin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fpout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>rewritemap_entry</name> *</type><name>map</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>map</name> = <name>val</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>map</name>-&gt;<name>type</name></name> != <name>MAPTYPE_PRG</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>
        <if>if <condition>(<expr>!(<name><name>map</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name>) || !*(<name><name>map</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name>) || <name><name>map</name>-&gt;<name>fpin</name></name> || <name><name>map</name>-&gt;<name>fpout</name></name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><name>rc</name> = <call><name>rewritemap_program_child</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>map</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>map</name>-&gt;<name>argv</name></name></expr></argument>,
                                      <argument><expr><name><name>map</name>-&gt;<name>user</name></name></expr></argument>, <argument><expr><name><name>map</name>-&gt;<name>group</name></name></expr></argument>,
                                      <argument><expr>&amp;<name>fpout</name></expr></argument>, <argument><expr>&amp;<name>fpin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name> || <name>fpin</name> == <name>NULL</name> || <name>fpout</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00654</expr></argument>)</argument_list></call>
                         "mod_rewrite: could not start RewriteMap "
                         "program %s"</expr></argument>, <argument><expr><name><name>map</name>-&gt;<name>checkfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rc</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>map</name>-&gt;<name>fpin</name></name>  = <name>fpin</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>map</name>-&gt;<name>fpout</name></name> = <name>fpout</name></expr>;</expr_stmt>
    }</block></for>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                  Lookup functions
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>lookup_map_txtfile</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>line</name><index>[<expr><name>REWRITE_MAX_TXT_MAP_LINE</name> + 1</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* +1 for \0 */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>, *<decl><type ref="prev"/><name>keylast</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>APR_READ</name>|<name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                            <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00655</expr></argument>)</argument_list></call>
                      "mod_rewrite: can't open text RewriteMap file %s"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>keylast</name> = <name>key</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>value</name> = <name>NULL</name></expr>;</expr_stmt>
    <while>while <condition>(<expr><call><name>apr_file_gets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

        <comment type="block">/* ignore comments and lines starting with whitespaces */</comment>
        <if>if <condition>(<expr>*<name>line</name> == '#' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>line</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <expr_stmt><expr><name>p</name> = <name>line</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>c</name> = <name>key</name></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>c</name> &lt; <name>keylast</name> &amp;&amp; *<name>p</name> == *<name>c</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
            <expr_stmt><expr>++<name>c</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* key doesn't match - ignore. */</comment>
        <if>if <condition>(<expr><name>c</name> != <name>keylast</name> || !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* jump to the value */</comment>
        <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* no value? ignore */</comment>
        <if>if <condition>(<expr>!*<name>p</name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* extract the value and return. */</comment>
        <expr_stmt><expr><name>c</name> = <name>p</name></expr>;</expr_stmt>
        <while>while <condition>(<expr>*<name>p</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name>value</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> - <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    }</block></while>
    <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>value</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>lookup_map_dbmfile</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dbmtype</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_dbm_t</name> *</type><name>dbmfp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>dbmkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_datum_t</name></type> <name>dbmval</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>rv</name> = <call><name>apr_dbm_open_ex</name><argument_list>(<argument><expr>&amp;<name>dbmfp</name></expr></argument>, <argument><expr><name>dbmtype</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>APR_DBM_READONLY</name></expr></argument>,
                              <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00656</expr></argument>)</argument_list></call>
                      "mod_rewrite: can't open DBM RewriteMap %s"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>dbmkey</name>.<name>dptr</name></name>  = <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dbmkey</name>.<name>dsize</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>apr_dbm_fetch</name><argument_list>(<argument><expr><name>dbmfp</name></expr></argument>, <argument><expr><name>dbmkey</name></expr></argument>, <argument><expr>&amp;<name>dbmval</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name> &amp;&amp; <name><name>dbmval</name>.<name>dptr</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>value</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>dbmval</name>.<name>dptr</name></name></expr></argument>, <argument><expr><name><name>dbmval</name>.<name>dsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>value</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>apr_dbm_close</name><argument_list>(<argument><expr><name>dbmfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>value</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>lookup_map_dbd</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_dbd_prepared_t</name> *</type><name>stmt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_dbd_results_t</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_dbd_row_t</name> *</type><name>row</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_dbd_t</name> *</type><name>db</name> <init>= <expr><call><name>dbd_acquire</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>db</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02963</expr></argument>)</argument_list></call>
                      "rewritemap: No db handle available! "
                      "Check your database access"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
   }</block></then></if>

    <expr_stmt><expr><name>stmt</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>prepared</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_dbd_pvselect</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>driver</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>handle</name></name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>,
                          <argument><expr><name>stmt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>errmsg</name> = <call><name>apr_dbd_error</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>driver</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>handle</name></name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00657</expr></argument>)</argument_list></call>
                      "rewritemap: error %s querying for %s"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
    <while>while <condition>(<expr>(<name>rv</name> = <call><name>apr_dbd_get_row</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>driver</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr>&amp;<name>row</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call>) == 0</expr>)</condition> <block>{
        <expr_stmt><expr>++<name>n</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ret</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                              <argument><expr><call><name>apr_dbd_get_entry</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>driver</name></name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* randomise crudely amongst multiple results */</comment>
            <if>if <condition>(<expr>(<name>double</name>)<call><name>rand</name><argument_list>()</argument_list></call> &lt; (<name>double</name>)<name>RAND_MAX</name>/(<name>double</name>)<name>n</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>ret</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                  <argument><expr><call><name>apr_dbd_get_entry</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>driver</name></name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></while>
    <if>if <condition>(<expr><name>rv</name> != -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>errmsg</name> = <call><name>apr_dbd_error</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>driver</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>handle</name></name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00658</expr></argument>)</argument_list></call>
                      "rewritemap: error %s looking up %s"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{
    <case>case <expr>0</expr>:
        <return>return <expr><name>NULL</name></expr>;</return>
    </case><case>case <expr>1</expr>:
        <return>return <expr><name>ret</name></expr>;</return>
    </case><default>default:
        <comment type="block">/* what's a fair rewritelog level for this? */</comment>
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 3, <name>NULL</name>, "Multiple values found for %s", <name>key</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>ret</name></expr>;</return>
    </default>}</block></switch>
}</block></function>

<function><type><specifier>static</specifier> <name>char</name> *</type><name>lookup_map_program</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>fpin</name></decl></param>,
                                <param><decl><type><name>apr_file_t</name> *</type><name>fpout</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nbytes</name></decl>, <decl><type ref="prev"/><name>combined_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol</name> <init>= <expr><name>APR_EOL_STR</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>eolc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>found_nl</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>result_list</name> *</type><name>buflist</name> <init>= <expr><name>NULL</name></expr></init>, *<name>curbuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NO_WRITEV</name></cpp:ifndef>
    <decl_stmt><decl><type>struct <name>iovec</name></type> <name><name>iova</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>niov</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* when `RewriteEngine off' was used in the per-server
     * context then the rewritemap-programs were not spawned.
     * In this case using such a map (usually in per-dir context)
     * is useless because it is not available.
     *
     * newlines in the key leave bytes in the pipe and cause
     * bad things to happen (next map lookup will use the chars
     * after the \n instead of the new key etc etc - in other words,
     * the Rewritemap falls out of sync with the requests).
     */</comment>
    <if>if <condition>(<expr><name>fpin</name> == <name>NULL</name> || <name>fpout</name> == <name>NULL</name> || <call><name>ap_strchr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>'\n'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* take the lock */</comment>
    <if>if <condition>(<expr><name>rewrite_mapr_lock_acquire</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_global_mutex_lock</name><argument_list>(<argument><expr><name>rewrite_mapr_lock_acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00659</expr></argument>)</argument_list></call>
                          "apr_global_mutex_lock(rewrite_mapr_lock_acquire) "
                          "failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* Maybe this should be fatal? */</comment>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* write out the request key */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NO_WRITEV</name></cpp:ifdef>
    <expr_stmt><expr><name>nbytes</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* XXX: error handling */</comment>
    <expr_stmt><expr><call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>nbytes</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_file_write_full</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>iova</name><index>[<expr>0</expr>]</index></name>.<name>iov_base</name> = <name>key</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iova</name><index>[<expr>0</expr>]</index></name>.<name>iov_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iova</name><index>[<expr>1</expr>]</index></name>.<name>iov_base</name> = "\n"</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>iova</name><index>[<expr>1</expr>]</index></name>.<name>iov_len</name> = 1</expr>;</expr_stmt>

    <expr_stmt><expr><name>niov</name> = 2</expr>;</expr_stmt>
    <comment type="block">/* XXX: error handling */</comment>
    <expr_stmt><expr><call><name>apr_file_writev_full</name><argument_list>(<argument><expr><name>fpin</name></expr></argument>, <argument><expr><name>iova</name></expr></argument>, <argument><expr><name>niov</name></expr></argument>, <argument><expr>&amp;<name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>REWRITE_PRG_MAP_BUF</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* read in the response value */</comment>
    <expr_stmt><expr><name>nbytes</name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_file_read</name><argument_list>(<argument><expr><name>fpout</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <do>do <block>{
        <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
        <while>while <condition>(<expr><name>nbytes</name> == 1 &amp;&amp; (<name>i</name> &lt; <name>REWRITE_PRG_MAP_BUF</name>)</expr>)</condition> <block>{
            <if>if <condition>(<expr><name>c</name> == <name><name>eol</name><index>[<expr><name>eolc</name></expr>]</index></name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<name><name>eol</name><index>[<expr>++<name>eolc</name></expr>]</index></name></expr>)</condition><then> <block>{
                    <comment type="block">/* remove eol from the buffer */</comment>
                    <expr_stmt><expr>--<name>eolc</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>i</name> &lt; <name>eolc</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>curbuf</name>-&gt;<name>len</name></name> -= <name>eolc</name>-<name>i</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <expr_stmt><expr><name>i</name> -= <name>eolc</name></expr>;</expr_stmt>
                    }</block></else></if>
                    <expr_stmt><expr>++<name>found_nl</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
            }</block></then>

            <comment type="block">/* only partial (invalid) eol sequence -&gt; reset the counter */</comment>
            <else>else <if>if <condition>(<expr><name>eolc</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>eolc</name> = 0</expr>;</expr_stmt>
            }</block></then>

            <comment type="block">/* catch binary mode, e.g. on Win32 */</comment>
            <else>else <if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
                <expr_stmt><expr>++<name>found_nl</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if></else></if></else></if>

            <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_file_read</name><argument_list>(<argument><expr><name>fpout</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

        <comment type="block">/* well, if there wasn't a newline yet, we need to read further */</comment>
        <if>if <condition>(<expr><name>buflist</name> || (<name>nbytes</name> == 1 &amp;&amp; !<name>found_nl</name>)</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>buflist</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>curbuf</name> = <name>buflist</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>buflist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>i</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>curbuf</name>-&gt;<name>next</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>buflist</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>curbuf</name> = <name><name>curbuf</name>-&gt;<name>next</name></name></expr>;</expr_stmt>

            }</block></then></if></else></if>
            <expr_stmt><expr><name><name>curbuf</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>i</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>curbuf</name>-&gt;<name>string</name></name> = <name>buf</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curbuf</name>-&gt;<name>len</name></name> = <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>combined_len</name> += <name>i</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>REWRITE_PRG_MAP_BUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr><name>nbytes</name> == 1 &amp;&amp; !<name>found_nl</name></expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>
        }</block></then></if>

        <break>break;</break>
    }</block> while <condition>(<expr>1</expr>)</condition>;</do>

    <comment type="block">/* concat the stuff */</comment>
    <if>if <condition>(<expr><name>buflist</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>p</name> = <name>buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>combined_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* \0 */</comment>
        <while>while <condition>(<expr><name>buflist</name></expr>)</condition> <block>{
            <if>if <condition>(<expr><name><name>buflist</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>buflist</name>-&gt;<name>string</name></name></expr></argument>, <argument><expr><name><name>buflist</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> += <name><name>buflist</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>buflist</name> = <name><name>buflist</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> = <name>combined_len</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* give the lock back */</comment>
    <if>if <condition>(<expr><name>rewrite_mapr_lock_acquire</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_global_mutex_unlock</name><argument_list>(<argument><expr><name>rewrite_mapr_lock_acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00660</expr></argument>)</argument_list></call>
                          "apr_global_mutex_unlock(rewrite_mapr_lock_acquire) "
                          "failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return> <comment type="block">/* Maybe this should be fatal? */</comment>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* catch the "failed" case */</comment>
    <if>if <condition>(<expr><name>i</name> == 4 &amp;&amp; !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"NULL"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>buf</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * generic map lookup
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>lookup_map</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewritemap_entry</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>st</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="block">/* get map configuration */</comment>
    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>s</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>conf</name>-&gt;<name>rewritemaps</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* map doesn't exist */</comment>
    <if>if <condition>(<expr>!<name>s</name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <switch>switch <condition>(<expr><name><name>s</name>-&gt;<name>type</name></name></expr>)</condition> <block>{
    <comment type="block">/*
     * Text file map (perhaps random)
     */</comment>
    <case>case <expr><name>MAPTYPE_RND</name></expr>:
    </case><case>case <expr><name>MAPTYPE_TXT</name></expr>:
        <expr_stmt><expr><name>rv</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>checkfile</name></name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00661</expr></argument>)</argument_list></call>
                          "mod_rewrite: can't access text RewriteMap file %s"</expr></argument>,
                          <argument><expr><name><name>s</name>-&gt;<name>checkfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>value</name> = <call><name>get_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr><name><name>st</name>.<name>mtime</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 6, <name>NULL</name>,
                        "cache lookup FAILED, forcing new map lookup")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>value</name> = <call><name>lookup_map_txtfile</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>datafile</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "map lookup FAILED: map=%s[txt] key=%s",
                            <name>name</name>, <name>key</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>set_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr><name><name>st</name>.<name>mtime</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>,"map lookup OK: map=%s[txt] key=%s -&gt; val=%s",
                        <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>set_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr><name><name>st</name>.<name>mtime</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>,5,<name>NULL</name>,"cache lookup OK: map=%s[txt] key=%s -&gt; val=%s",
                        <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name><name>s</name>-&gt;<name>type</name></name> == <name>MAPTYPE_RND</name> &amp;&amp; *<name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>value</name> = <call><name>select_random_value_part</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "randomly chosen the subvalue `%s'",<name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr>*<name>value</name> ? <name>value</name> : <name>NULL</name></expr>;</return>

    <comment type="block">/*
     * DBM file map
     */</comment>
    </case><case>case <expr><name>MAPTYPE_DBM</name></expr>:
        <expr_stmt><expr><name>rv</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>checkfile</name></name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00662</expr></argument>)</argument_list></call>
                          "mod_rewrite: can't access DBM RewriteMap file %s"</expr></argument>,
                          <argument><expr><name><name>s</name>-&gt;<name>checkfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if<condition>(<expr><name><name>s</name>-&gt;<name>checkfile2</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>st2</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>rv</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>st2</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>checkfile2</name></name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00663</expr></argument>)</argument_list></call>
                              "mod_rewrite: can't access DBM RewriteMap "
                              "file %s"</expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>checkfile2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if<condition>(<expr><name><name>st2</name>.<name>mtime</name></name> &gt; <name><name>st</name>.<name>mtime</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>st</name>.<name>mtime</name></name> = <name><name>st2</name>.<name>mtime</name></name></expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></then></if></else></if>
        <if>if<condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>value</name> = <call><name>get_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr><name><name>st</name>.<name>mtime</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 6, <name>NULL</name>,
                        "cache lookup FAILED, forcing new map lookup")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>value</name> = <call><name>lookup_map_dbmfile</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>datafile</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>dbmtype</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "map lookup FAILED: map=%s[dbm] key=%s",
                            <name>name</name>, <name>key</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>set_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr><name><name>st</name>.<name>mtime</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "map lookup OK: map=%s[dbm] key=%s -&gt; "
                        "val=%s", <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>set_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr><name><name>st</name>.<name>mtime</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>value</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "cache lookup OK: map=%s[dbm] key=%s -&gt; val=%s",
                    <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>*<name>value</name> ? <name>value</name> : <name>NULL</name></expr>;</return>

    <comment type="block">/*
     * SQL map without cache
     */</comment>
    </case><case>case <expr><name>MAPTYPE_DBD</name></expr>:
        <expr_stmt><expr><name>value</name> = <call><name>lookup_map_dbd</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>dbdq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "SQL map lookup FAILED: map %s key=%s",
                        <name>name</name>, <name>key</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "SQL map lookup OK: map %s key=%s, val=%s",
                   <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>value</name></expr>;</return>

    <comment type="block">/*
     * SQL map with cache
     */</comment>
    </case><case>case <expr><name>MAPTYPE_DBD_CACHE</name></expr>:
        <expr_stmt><expr><name>value</name> = <call><name>get_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 6, <name>NULL</name>,
                        "cache lookup FAILED, forcing new map lookup")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>value</name> = <call><name>lookup_map_dbd</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>dbdq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "SQL map lookup FAILED: map %s key=%s",
                            <name>name</name>, <name>key</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>set_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>NULL</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "SQL map lookup OK: map %s key=%s, val=%s",
                        <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>set_cache_value</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>cachename</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>value</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "cache lookup OK: map=%s[SQL] key=%s, val=%s",
                    <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>*<name>value</name> ? <name>value</name> : <name>NULL</name></expr>;</return>

    <comment type="block">/*
     * Program file map
     */</comment>
    </case><case>case <expr><name>MAPTYPE_PRG</name></expr>:
        <expr_stmt><expr><name>value</name> = <call><name>lookup_map_program</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>fpin</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>fpout</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5,<name>NULL</name>,"map lookup FAILED: map=%s key=%s", <name>name</name>,
                        <name>key</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "map lookup OK: map=%s key=%s -&gt; val=%s",
                    <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>value</name></expr>;</return>

    <comment type="block">/*
     * Internal Map
     */</comment>
    </case><case>case <expr><name>MAPTYPE_INT</name></expr>:
        <expr_stmt><expr><name>value</name> = <call><name><name>s</name>-&gt;<name>func</name></name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5,<name>NULL</name>,"map lookup FAILED: map=%s key=%s", <name>name</name>,
                        <name>key</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "map lookup OK: map=%s key=%s -&gt; val=%s",
                    <name>name</name>, <name>key</name>, <name>value</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>value</name></expr>;</return>
    </case>}</block></switch>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * lookup a HTTP header and set VARY note
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>lookup_header</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Skip the 'Vary: Host' header combination
     * as indicated in rfc7231 section-7.1.4
     */</comment>
    <if>if <condition>(<expr><name>val</name> &amp;&amp; <call><name>strcasecmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"Host"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>vary_this</name></name> = <name><name>ctx</name>-&gt;<name>vary_this</name></name>
                         ? <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>vary_this</name></name></expr></argument>, <argument><expr>", "</expr></argument>,
                                       <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                         : <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>val</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * lookahead helper function
 * Determine the correct URI path in perdir context
 */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type><name>la_u</name><parameter_list>(<param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>conf</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>*<name><name>ctx</name>-&gt;<name>uri</name></name> == '/'</expr>)</condition><then> <block>{
        <return>return <expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>baseurl</name></name>
                                     ? <name><name>conf</name>-&gt;<name>baseurl</name></name> : <name><name>conf</name>-&gt;<name>directory</name></name></expr></argument>,
                       <argument><expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * generic variable lookup
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>lookup_variable</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>var</name></decl></param>, <param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>varlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* fast exit */</comment>
    <if>if <condition>(<expr><name>varlen</name> &lt; 4</expr>)</condition><then> <block>{
        <return>return <expr>""</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>

    <comment type="block">/* fast tests for variable length variables (sic) first */</comment>
    <if>if <condition>(<expr><name><name>var</name><index>[<expr>3</expr>]</index></name> == ':'</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>var</name><index>[<expr>4</expr>]</index></name> &amp;&amp; !<call><name>strncasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"ENV"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>var</name> += 4</expr>;</expr_stmt>
            <expr_stmt><expr><name>result</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>getenv</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>var</name><index>[<expr>4</expr>]</index></name> &amp;&amp; !<call><name>strncasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SSL"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call> &amp;&amp; <name>rewrite_ssl_lookup</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>result</name> = <call><name>rewrite_ssl_lookup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>,
                                        <argument><expr><name>var</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>var</name><index>[<expr>4</expr>]</index></name> == ':'</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>var</name><index>[<expr>5</expr>]</index></name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>request_rec</name> *</type><name>rr</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTP"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>lookup_header</name><argument_list>(<argument><expr><name>var</name>+5</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"LA-U"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>uri</name></name> &amp;&amp; <call><name>subreq_ok</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>path</name> = <name><name>ctx</name>-&gt;<name>perdir</name></name> ? <call><name>la_u</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call> : <name><name>ctx</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_lookup_uri</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>r</name></name> = <name>rr</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>lookup_variable</name><argument_list>(<argument><expr><name>var</name>+5</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "lookahead: path=%s var=%s "
                                "-&gt; val=%s", <name>path</name>, <name>var</name>+5, <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <return>return <expr>(<name>char</name> *)<name>result</name></expr>;</return>
                }</block></then></if>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"LA-F"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>uri</name></name> &amp;&amp; <call><name>subreq_ok</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>path</name> = <name><name>ctx</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>perdir</name></name> &amp;&amp; *<name>path</name> == '/'</expr>)</condition><then> <block>{
                        <comment type="block">/* sigh, the user wants a file based subrequest, but
                         * we can't do one, since we don't know what the file
                         * path is! In this case behave like LA-U.
                         */</comment>
                        <expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_lookup_uri</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <block>{
                        <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>perdir</name></name></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>conf</name></decl>;</decl_stmt>

                            <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                        <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                            <expr_stmt><expr><name>path</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>directory</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                               <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>

                        <expr_stmt><expr><name>rr</name> = <call><name>ap_sub_req_lookup_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>

                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>r</name></name> = <name>rr</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>result</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>lookup_variable</name><argument_list>(<argument><expr><name>var</name>+5</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "lookahead: path=%s var=%s "
                                "-&gt; val=%s", <name>path</name>, <name>var</name>+5, <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <return>return <expr>(<name>char</name> *)<name>result</name></expr>;</return>
                }</block></then></if>
            }</block></then></if></else></if></else></if>
        }</block></then></if>
    }</block></then>

    <comment type="block">/* well, do it the hard way */</comment>
    <else>else <block>{
        <decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>tm</name></decl>;</decl_stmt>

        <comment type="block">/* can't do this above, because of the getenv call */</comment>
        <expr_stmt><expr><call><name>ap_str_toupper</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <switch>switch <condition>(<expr><name>varlen</name></expr>)</condition> <block>{
        <case>case  <expr>4</expr>:
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"TIME"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>result</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%04d%02d%02d%02d%02d%02d"</expr></argument>,
                                      <argument><expr><name><name>tm</name>.<name>tm_year</name></name>+1900</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_mon</name></name>+1</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_mday</name></name></expr></argument>,
                                      <argument><expr><name><name>tm</name>.<name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_min</name></name></expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "RESULT='%s'", <name>result</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>(<name>char</name> *)<name>result</name></expr>;</return>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"IPV6"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_IPV6</name></expr></cpp:if>
                <decl_stmt><decl><type><name>apr_sockaddr_t</name> *</type><name>addr</name> <init>= <expr><name><name>r</name>-&gt;<name>useragent_addr</name></name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>flag</name> = (<name><name>addr</name>-&gt;<name>family</name></name> == <name>AF_INET6</name> &amp;&amp;
                        !<call><name>IN6_IS_ADDR_V4MAPPED</name><argument_list>(<argument><expr>(struct <name>in6_addr</name> *)<name><name>addr</name>-&gt;<name>ipaddr_ptr</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "IPV6='%s'", <name>flag</name> ? "on" : "off")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "IPV6='off' (IPv6 is not enabled)")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <expr_stmt><expr><name>result</name> = (<name>flag</name> ? "on" : "off")</expr>;</expr_stmt>
            }</block></then></if></else></if>
            <break>break;</break>

        </case><case>case  <expr>5</expr>:
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTPS"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>flag</name> <init>= <expr><name>rewrite_is_https</name> &amp;&amp; <call><name>rewrite_is_https</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>flag</name> ? "on" : "off"</expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
            <break>break;</break>

        </case><case>case  <expr>8</expr>:
            <switch>switch <condition>(<expr><name><name>var</name><index>[<expr>6</expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr>'A'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"TIME_DAY"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'E'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"TIME_SEC"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'I'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"TIME_MIN"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'O'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"TIME_MON"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_mon</name></name>+1</expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
                <break>break;</break>
            </case>}</block></switch>
            <break>break;</break>

        </case><case>case  <expr>9</expr>:
            <switch>switch <condition>(<expr><name><name>var</name><index>[<expr>7</expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr>'A'</expr>:
                <if>if <condition>(<expr><name><name>var</name><index>[<expr>8</expr>]</index></name> == 'Y' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"TIME_WDAY"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_wday</name></name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"TIME_YEAR"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%04d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_year</name></name>+1900</expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if></else></if>
                <break>break;</break>

            </case><case>case <expr>'E'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"IS_SUBREQ"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = (<name><name>r</name>-&gt;<name/></name>main ? "true" : "false")</expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'F'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"PATH_INFO"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>path_info</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'P'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"AUTH_TYPE"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>ap_auth_type</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'S'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTP_HOST"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>lookup_header</name><argument_list>(<argument><expr>"Host"</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'U'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"TIME_HOUR"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_time_exp_lt</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%02d"</expr></argument>, <argument><expr><name><name>tm</name>.<name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
                <break>break;</break>
            </case>}</block></switch>
            <break>break;</break>

        </case><case>case <expr>11</expr>:
            <switch>switch <condition>(<expr><name><name>var</name><index>[<expr>8</expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr>'A'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SERVER_NAME"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>ap_get_server_name_for_url</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'D'</expr>:
                <if>if <condition>(<expr>*<name>var</name> == 'R' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REMOTE_ADDR"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>useragent_ip</name></name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SERVER_ADDR"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>local_ip</name></name></expr>;</expr_stmt>
                }</block></then></if></else></if>
                <break>break;</break>

            </case><case>case <expr>'E'</expr>:
                <if>if <condition>(<expr>*<name>var</name> == 'H' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTP_ACCEPT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>lookup_header</name><argument_list>(<argument><expr>"Accept"</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"THE_REQUEST"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>the_request</name></name></expr>;</expr_stmt>
                }</block></then></if></else></if>
                <break>break;</break>

            </case><case>case <expr>'I'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"API_VERSION"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%d:%d"</expr></argument>,
                                        <argument><expr><name>MODULE_MAGIC_NUMBER_MAJOR</name></expr></argument>,
                                        <argument><expr><name>MODULE_MAGIC_NUMBER_MINOR</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'K'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTP_COOKIE"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>lookup_header</name><argument_list>(<argument><expr>"Cookie"</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'O'</expr>:
                <if>if <condition>(<expr>*<name>var</name> == 'S' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SERVER_PORT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%u"</expr></argument>, <argument><expr><call><name>ap_get_server_port</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then>
                <else>else <if>if <condition>(<expr><name><name>var</name><index>[<expr>7</expr>]</index></name> == 'H' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REMOTE_HOST"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>ap_get_remote_host</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>,<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                <argument><expr><name>REMOTE_NAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REMOTE_PORT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <return>return <expr><call><name>apr_itoa</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>useragent_addr</name>-&gt;<name>port</name></name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then></if></else></if></else></if>
                <break>break;</break>

            </case><case>case <expr>'S'</expr>:
                <if>if <condition>(<expr>*<name>var</name> == 'R' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REMOTE_USER"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>user</name></name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SCRIPT_USER"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = "&lt;unknown&gt;"</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>valid</name></name> &amp; <name>APR_FINFO_USER</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>apr_uid_name_get</name><argument_list>(<argument><expr>(<name>char</name> **)&amp;<name>result</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>user</name></name></expr></argument>,
                                         <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if></else></if>
                <break>break;</break>

            </case><case>case <expr>'U'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REQUEST_URI"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
            </case>}</block></switch>
            <break>break;</break>

        </case><case>case <expr>12</expr>:
            <switch>switch <condition>(<expr><name><name>var</name><index>[<expr>3</expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr>'I'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SCRIPT_GROUP"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = "&lt;unknown&gt;"</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>finfo</name>.<name>valid</name></name> &amp; <name>APR_FINFO_GROUP</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>apr_gid_name_get</name><argument_list>(<argument><expr>(<name>char</name> **)&amp;<name>result</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>finfo</name>.<name>group</name></name></expr></argument>,
                                         <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'O'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REMOTE_IDENT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>ap_get_remote_logname</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'P'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTP_REFERER"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>lookup_header</name><argument_list>(<argument><expr>"Referer"</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'R'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"QUERY_STRING"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>args</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'V'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SERVER_ADMIN"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>server</name>-&gt;<name>server_admin</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
            </case>}</block></switch>
            <break>break;</break>

        </case><case>case <expr>13</expr>:
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"DOCUMENT_ROOT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>ap_document_root</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>

        </case><case>case <expr>14</expr>:
            <if>if <condition>(<expr>*<name>var</name> == 'H' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTP_FORWARDED"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>lookup_header</name><argument_list>(<argument><expr>"Forwarded"</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>*<name>var</name> == 'C' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"CONTEXT_PREFIX"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>ap_context_prefix</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>var</name><index>[<expr>8</expr>]</index></name> == 'M' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REQUEST_METHOD"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>method</name></name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REQUEST_SCHEME"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>ap_http_scheme</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if></else></if></else></if>
            <break>break;</break>

        </case><case>case <expr>15</expr>:
            <switch>switch <condition>(<expr><name><name>var</name><index>[<expr>7</expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr>'E'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTP_USER_AGENT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>lookup_header</name><argument_list>(<argument><expr>"User-Agent"</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'F'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SCRIPT_FILENAME"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>filename</name></name></expr>;</expr_stmt> <comment type="block">/* same as request_filename (16) */</comment>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'P'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SERVER_PROTOCOL"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>protocol</name></name></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>

            </case><case>case <expr>'S'</expr>:
                <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"SERVER_SOFTWARE"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>result</name> = <call><name>ap_get_server_banner</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
            </case>}</block></switch>
            <break>break;</break>

        </case><case>case <expr>16</expr>:
            <if>if <condition>(<expr>*<name>var</name> == 'C' &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"CONN_REMOTE_ADDR"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>client_ip</name></name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"REQUEST_FILENAME"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <name><name>r</name>-&gt;<name>filename</name></name></expr>;</expr_stmt> <comment type="block">/* same as script_filename (15) */</comment>
            }</block></then></if></else></if>
            <break>break;</break>

        </case><case>case <expr>21</expr>:
            <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"HTTP_PROXY_CONNECTION"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>lookup_header</name><argument_list>(<argument><expr>"Proxy-Connection"</expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr>"CONTEXT_DOCUMENT_ROOT"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>result</name> = <call><name>ap_context_document_root</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if></else></if>
            <break>break;</break>
        </case>}</block></switch>
    }</block></else></if></else></if>

    <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>result</name> ? <name>result</name> : ""</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                 Expansion functions
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<comment type="block">/*
 * Bracketed expression handling
 * s points after the opening bracket
 */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>char</name> *</type><name>find_closing_curly</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>depth</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>depth</name> = 1</expr>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>s</name> == <name>RIGHT_CURLY</name> &amp;&amp; --<name>depth</name> == 0</expr>)</condition><then> <block>{
            <return>return <expr><name>s</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>s</name> == <name>LEFT_CURLY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>depth</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>char</name> *</type><name>find_char_in_curlies</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>unsigned</name></type> <name>depth</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>depth</name> = 1</expr>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr>++<name>s</name></expr></incr>) <block>{
        <if>if <condition>(<expr>*<name>s</name> == <name>c</name> &amp;&amp; <name>depth</name> == 1</expr>)</condition><then> <block>{
            <return>return <expr><name>s</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>s</name> == <name>RIGHT_CURLY</name> &amp;&amp; --<name>depth</name> == 0</expr>)</condition><then> <block>{
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>*<name>s</name> == <name>LEFT_CURLY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>depth</name></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if>
    }</block></for>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* perform all the expansions on the input string
 * putting the result into a new string
 *
 * for security reasons this expansion must be performed in a
 * single pass, otherwise an attacker can arrange for the result
 * of an earlier expansion to include expansion specifiers that
 * are interpreted by a later expansion, producing results that
 * were not intended by the administrator.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>do_expand</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>input</name></decl></param>, <param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>rewriterule_entry</name> *</type><name>entry</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>result_list</name> *</type><name>result</name></decl>, *<decl><type ref="prev"/><name>current</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>result_list</name></type> <name><name>sresult</name><index>[<expr><name>SMALL_EXPANSION</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>spc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>span</name></decl>, <decl><type ref="prev"/><name>inputlen</name></decl>, <decl><type ref="prev"/><name>outlen</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>span</name> = <call><name>strcspn</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr>"\\$%"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>inputlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* fast exit */</comment>
    <if>if <condition>(<expr><name>inputlen</name> == <name>span</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>inputlen</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* well, actually something to do */</comment>
    <expr_stmt><expr><name>result</name> = <name>current</name> = &amp;(<name><name>sresult</name><index>[<expr><name>spc</name>++</expr>]</index></name>)</expr>;</expr_stmt>

    <expr_stmt><expr><name>p</name> = <name>input</name> + <name>span</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>input</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>span</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>outlen</name> = <name>span</name></expr>;</expr_stmt>

    <comment type="block">/* loop for specials */</comment>
    <do>do <block>{
        <comment type="block">/* prepare next entry */</comment>
        <if>if <condition>(<expr><name><name>current</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = (<name>spc</name> &lt; <name>SMALL_EXPANSION</name>)
                            ? &amp;(<name><name>sresult</name><index>[<expr><name>spc</name>++</expr>]</index></name>)
                            : (<name>result_list</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>result_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* escaped character */</comment>
        <if>if <condition>(<expr>*<name>p</name> == '\\'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr>++<name>outlen</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name><name>p</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>p</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = ++<name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>

        <comment type="block">/* variable or map lookup */</comment>
        <else>else <if>if <condition>(<expr><name><name>p</name><index>[<expr>1</expr>]</index></name> == '{'</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>endp</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>endp</name> = <call><name>find_closing_curly</name><argument_list>(<argument><expr><name>p</name>+2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>endp</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = 2</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>outlen</name> += 2</expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> += 2</expr>;</expr_stmt>
            }</block></then>

            <comment type="block">/* variable lookup */</comment>
            <else>else <if>if <condition>(<expr>*<name>p</name> == '%'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>p</name> = <call><name>lookup_variable</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>p</name>+2</expr></argument>, <argument><expr><name>endp</name>-<name>p</name>-2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>span</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>span</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>p</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>outlen</name> += <name>span</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> = <name>endp</name> + 1</expr>;</expr_stmt>
            }</block></then>

            <comment type="block">/* map lookup */</comment>
            <else>else <block>{     <comment type="block">/* *p == '$' */</comment>
                <decl_stmt><decl><type><name>char</name> *</type><name>key</name></decl>;</decl_stmt>

                <comment type="block">/*
                 * To make rewrite maps useful, the lookup key and
                 * default values must be expanded, so we make
                 * recursive calls to do the work. For security
                 * reasons we must never expand a string that includes
                 * verbatim data from the network. The recursion here
                 * isn't a problem because the result of expansion is
                 * only passed to lookup_map() so it cannot be
                 * re-expanded, only re-looked-up. Another way of
                 * looking at it is that the recursion is entirely
                 * driven by the syntax of the nested curly brackets.
                 */</comment>

                <expr_stmt><expr><name>key</name> = <call><name>find_char_in_curlies</name><argument_list>(<argument><expr><name>p</name>+2</expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr>!<name>key</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = 2</expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>p</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>outlen</name> += 2</expr>;</expr_stmt>
                    <expr_stmt><expr><name>p</name> += 2</expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <decl_stmt><decl><type><name>char</name> *</type><name>map</name></decl>, *<decl><type ref="prev"/><name>dflt</name></decl>;</decl_stmt>

                    <expr_stmt><expr><name>map</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>p</name>+2</expr></argument>, <argument><expr><name>endp</name>-<name>p</name>-2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>key</name> = <name>map</name> + (<name>key</name>-<name>p</name>-2)</expr>;</expr_stmt>
                    <expr_stmt><expr>*<name>key</name>++ = '\0'</expr>;</expr_stmt>
                    <expr_stmt><expr><name>dflt</name> = <call><name>find_char_in_curlies</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>'|'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>dflt</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr>*<name>dflt</name>++ = '\0'</expr>;</expr_stmt>
                    }</block></then></if>

                    <comment type="block">/* reuse of key variable as result */</comment>
                    <expr_stmt><expr><name>key</name> = <call><name>lookup_map</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><call><name>do_expand</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr>!<name>key</name> &amp;&amp; <name>dflt</name> &amp;&amp; *<name>dflt</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>key</name> = <call><name>do_expand</name><argument_list>(<argument><expr><name>dflt</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>

                    <if>if <condition>(<expr><name>key</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>span</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>span</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>key</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name>outlen</name> += <name>span</name></expr>;</expr_stmt>
                    }</block></then></if>

                    <expr_stmt><expr><name>p</name> = <name>endp</name> + 1</expr>;</expr_stmt>
                }</block></else></if>
            }</block></else></if></else></if>
        }</block></then>

        <comment type="block">/* backreference */</comment>
        <else>else <if>if <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>p</name><index>[<expr>1</expr>]</index></name> - '0'</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>backrefinfo</name> *</type><name>bri</name> <init>= <expr>(*<name>p</name> == '$') ? &amp;<name><name>ctx</name>-&gt;<name>briRR</name></name> : &amp;<name><name>ctx</name>-&gt;<name>briRC</name></name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* see ap_pregsub() in server/util.c */</comment>
            <if>if <condition>(<expr><name><name>bri</name>-&gt;<name>source</name></name> &amp;&amp; <name>n</name> &lt; <name>AP_MAX_REG_MATCH</name>
                &amp;&amp; <name><name>bri</name>-&gt;<name>regmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_eo</name> &gt; <name><name>bri</name>-&gt;<name>regmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_so</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>span</name> = <name><name>bri</name>-&gt;<name>regmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_eo</name> - <name><name>bri</name>-&gt;<name>regmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_so</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>entry</name> &amp;&amp; (<name><name>entry</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_ESCAPEBACKREF</name>)</expr>)</condition><then> <block>{
                    <comment type="block">/* escape the backreference */</comment>
                    <decl_stmt><decl><type><name>char</name> *</type><name>tmp2</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
                    <expr_stmt><expr><name>tmp</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>bri</name>-&gt;<name>source</name></name> + <name><name>bri</name>-&gt;<name>regmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_so</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>tmp2</name> = <call><name>escape_backref</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>escapes</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_ESCAPENOPLUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name><name>ctx</name>-&gt;<name>r</name></name>, 5, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "escaping backreference '%s' to '%s'",
                            <name>tmp</name>, <name>tmp2</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>span</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>tmp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>tmp2</name></expr>;</expr_stmt>
                }</block></then> <else>else <block>{
                    <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>span</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name><name>bri</name>-&gt;<name>source</name></name> + <name><name>bri</name>-&gt;<name>regmatch</name><index>[<expr><name>n</name></expr>]</index></name>.<name>rm_so</name></expr>;</expr_stmt>
                }</block></else></if>

                <expr_stmt><expr><name>outlen</name> += <name>span</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>p</name> += 2</expr>;</expr_stmt>
        }</block></then>

        <comment type="block">/* not for us, just copy it */</comment>
        <else>else <block>{
            <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = 1</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>p</name>++</expr>;</expr_stmt>
            <expr_stmt><expr>++<name>outlen</name></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>

        <comment type="block">/* check the remainder */</comment>
        <if>if <condition>(<expr>*<name>p</name> &amp;&amp; (<name>span</name> = <call><name>strcspn</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"\\$%"</expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>current</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = (<name>spc</name> &lt; <name>SMALL_EXPANSION</name>)
                                ? &amp;(<name><name>sresult</name><index>[<expr><name>spc</name>++</expr>]</index></name>)
                                : (<name>result_list</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>result_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>current</name> = <name><name>current</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>current</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name><name>current</name>-&gt;<name>len</name></name> = <name>span</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current</name>-&gt;<name>string</name></name> = <name>p</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> += <name>span</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>outlen</name> += <name>span</name></expr>;</expr_stmt>
        }</block></then></if>

    }</block> while <condition>(<expr><name>p</name> &lt; <name>input</name>+<name>inputlen</name></expr>)</condition>;</do>

    <comment type="block">/* assemble result */</comment>
    <expr_stmt><expr><name>c</name> = <name>p</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>outlen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* don't forget the \0 */</comment>
    <do>do <block>{
        <if>if <condition>(<expr><name><name>result</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_assert</name><argument_list>(<argument><expr><name>c</name>+<name><name>result</name>-&gt;<name>len</name></name> &lt;= <name>p</name>+<name>outlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* XXX: can be removed after
                                                   * extensive testing and
                                                   * review
                                                   */</comment>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>string</name></name></expr></argument>, <argument><expr><name><name>result</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>c</name> += <name><name>result</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>result</name> = <name><name>result</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>result</name></expr>)</condition>;</do>

    <expr_stmt><expr><name><name>p</name><index>[<expr><name>outlen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

    <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * perform all the expansions on the environment variables
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>do_expand_env</name><parameter_list>(<param><decl><type><name>data_item</name> *</type><name>env</name></decl></param>, <param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>env</name></expr>)</condition> <block>{
        <expr_stmt><expr><name>name</name> = <call><name>do_expand</name><argument_list>(<argument><expr><name><name>env</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>name</name> == '!'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>name</name>++</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name><name>ctx</name>-&gt;<name>r</name></name>, 5, <name>NULL</name>, "unsetting env variable '%s'", <name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr>(<name>val</name> = <call><name>ap_strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>val</name>++ = '\0'</expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><name>val</name> = ""</expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><call><name>apr_table_set</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name><name>ctx</name>-&gt;<name>r</name></name>, 5, <name>NULL</name>, "setting env variable '%s' to '%s'",
                        <name>name</name>, <name>val</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>env</name> = <name><name>env</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>

    <return>return;</return>
}</block></function>

<comment type="block">/*
 * perform all the expansions on the cookies
 *
 * TODO: use cached time similar to how logging does it
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>add_cookie</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>val</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>domain</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>expires</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>secure</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>httponly</name></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> *</type><name>tok_cntx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>cookie</name></decl>;</decl_stmt>
    <comment type="block">/* long-standing default, but can't use ':' in a cookie */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name> <init>= <expr>":"</expr></init></decl>;</decl_stmt> 

    <comment type="block">/* opt-in to ; separator if first character is a ; */</comment>
    <if>if <condition>(<expr><name>s</name> &amp;&amp; *<name>s</name> == ';'</expr>)</condition><then> <block>{ 
        <expr_stmt><expr><name>sep</name> = ";"</expr>;</expr_stmt> 
        <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>var</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>val</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>domain</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>var</name> &amp;&amp; <name>val</name> &amp;&amp; <name>domain</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>request_rec</name> *</type><name>rmain</name> <init>= <expr><name>r</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>notename</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>void</name> *</type><name>data</name></decl>;</decl_stmt>

        <while>while <condition>(<expr><name><name>rmain</name>-&gt;<name/></name>main</expr>)</condition> <block>{
            <expr_stmt><expr><name>rmain</name> = <name><name>rmain</name>-&gt;<name/></name>main</expr>;</expr_stmt>
        }</block></while>

        <expr_stmt><expr><name>notename</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>rmain</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr>"_rewrite"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr><name>notename</name></expr></argument>, <argument><expr><name><name>rmain</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>data</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>exp_time</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>expires</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>path</name> = <name>expires</name> ? <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>secure</name> = <name>path</name> ? <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>httponly</name> = <name>secure</name> ? <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>expires</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>tms</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>long</name></type> <name>exp_min</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>exp_min</name> = <call><name>atol</name><argument_list>(<argument><expr><name>expires</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>exp_min</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_time_exp_gmt</name><argument_list>(<argument><expr>&amp;<name>tms</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name>
                                     + <call><name>apr_time_from_sec</name><argument_list>(<argument><expr>(60 * <name>exp_min</name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>exp_time</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%s, %.2d-%s-%.4d "
                                                     "%.2d:%.2d:%.2d GMT"</expr></argument>,
                                           <argument><expr><name><name>apr_day_snames</name><index>[<expr><name><name>tms</name>.<name>tm_wday</name></name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>tms</name>.<name>tm_mday</name></name></expr></argument>,
                                           <argument><expr><name><name>apr_month_snames</name><index>[<expr><name><name>tms</name>.<name>tm_mon</name></name></expr>]</index></name></expr></argument>,
                                           <argument><expr><name><name>tms</name>.<name>tm_year</name></name>+1900</expr></argument>,
                                           <argument><expr><name><name>tms</name>.<name>tm_hour</name></name></expr></argument>, <argument><expr><name><name>tms</name>.<name>tm_min</name></name></expr></argument>, <argument><expr><name><name>tms</name>.<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>

            <expr_stmt><expr><name>cookie</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>rmain</name>-&gt;<name>pool</name></name></expr></argument>,
                                 <argument><expr><name>var</name></expr></argument>, <argument><expr>"="</expr></argument>, <argument><expr><name>val</name></expr></argument>,
                                 <argument><expr>"; path="</expr></argument>, <argument><expr><name>path</name> ? <name>path</name> : "/"</expr></argument>,
                                 <argument><expr>"; domain="</expr></argument>, <argument><expr><name>domain</name></expr></argument>,
                                 <argument><expr><name>expires</name> ? (<name>exp_time</name> ? "; expires=" : "")
                                 : <name>NULL</name></expr></argument>,
                                 <argument><expr><name>expires</name> ? (<name>exp_time</name> ? <name>exp_time</name> : "")
                                 : <name>NULL</name></expr></argument>,
                                 <argument><expr>(<name>secure</name> &amp;&amp; (!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>secure</name></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call>
                                             || !<call><name>strcmp</name><argument_list>(<argument><expr><name>secure</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call>
                                             || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>secure</name></expr></argument>,
                                                            <argument><expr>"secure"</expr></argument>)</argument_list></call>)) ?
                                  "; secure" : <name>NULL</name></expr></argument>,
                                 <argument><expr>(<name>httponly</name> &amp;&amp; (!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>httponly</name></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call>
                                               || !<call><name>strcmp</name><argument_list>(<argument><expr><name>httponly</name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call>
                                               || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>httponly</name></expr></argument>,
                                                              <argument><expr>"HttpOnly"</expr></argument>)</argument_list></call>)) ?
                                  "; HttpOnly" : <name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>apr_table_addn</name><argument_list>(<argument><expr><name><name>rmain</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"Set-Cookie"</expr></argument>, <argument><expr><name>cookie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr>"set"</expr></argument>, <argument><expr><name>notename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>rmain</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>rmain</name>, 5, <name>NULL</name>, "setting cookie '%s'", <name>cookie</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>rmain</name>, 5, <name>NULL</name>, "skipping already set cookie '%s'",
                        <name>var</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <return>return;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_expand_cookie</name><parameter_list>(<param><decl><type><name>data_item</name> *</type><name>cookie</name></decl></param>, <param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <while>while <condition>(<expr><name>cookie</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>add_cookie</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>do_expand</name><argument_list>(<argument><expr><name><name>cookie</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>cookie</name> = <name><name>cookie</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>

    <return>return;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_USER</name></expr></cpp:if>
<comment type="block">/*
 * Expand tilde-paths (/~user) through Unix /etc/passwd
 * database information (or other OS-specific database)
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type><name>expand_tildepaths</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>char</name> *</type><name>uri</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>uri</name> &amp;&amp; *<name>uri</name> == '/' &amp;&amp; <name><name>uri</name><index>[<expr>1</expr>]</index></name> == '~'</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>user</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>p</name> = <name>user</name> = <name>uri</name> + 2</expr>;</expr_stmt>
        <while>while <condition>(<expr>*<name>p</name> &amp;&amp; *<name>p</name> != '/'</expr>)</condition> <block>{
            <expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr><name>p</name> &gt; <name>user</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>homedir</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>user</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name>p</name>-<name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>apr_uid_homepath_get</name><argument_list>(<argument><expr>&amp;<name>homedir</name></expr></argument>, <argument><expr><name>user</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>*<name>p</name></expr>)</condition><then> <block>{
                    <comment type="block">/* reuse of user variable */</comment>
                    <expr_stmt><expr><name>user</name> = <name>homedir</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>homedir</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>user</name> &gt;= <name>homedir</name> &amp;&amp; *<name>user</name> == '/'</expr>)</condition><then> <block>{
                        <expr_stmt><expr>*<name>user</name> = '\0'</expr>;</expr_stmt>
                    }</block></then></if>

                    <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>homedir</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></then>
                <else>else <block>{
                    <return>return <expr><name>homedir</name></expr>;</return>
                }</block></else></if>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>uri</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* if APR_HAS_USER */</comment>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |              rewriting lockfile support
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>rewritelock_create</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>

    <comment type="block">/* create the lockfile */</comment>
    <comment type="block">/* XXX See if there are any rewrite map programs before creating
     * the mutex.
     */</comment>
    <expr_stmt><expr><name>rc</name> = <call><name>ap_global_mutex_create</name><argument_list>(<argument><expr>&amp;<name>rewrite_mapr_lock_acquire</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>rewritemap_mutex_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rc</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>rc</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>rewritelock_remove</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* destroy the rewritelock */</comment>
    <if>if <condition>(<expr><name>rewrite_mapr_lock_acquire</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_global_mutex_destroy</name><argument_list>(<argument><expr><name>rewrite_mapr_lock_acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rewrite_mapr_lock_acquire</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |           configuration directive handling
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<comment type="block">/*
 * own command line parser for RewriteRule and RewriteCond,
 * which doesn't have the '\\' problem.
 * (returns true on error)
 *
 * XXX: what an inclined parser. Seems we have to leave it so
 *      for backwards compat. *sigh*
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>parseargline</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>char</name> **</type><name>a1</name></decl></param>, <param><decl><type><name>char</name> **</type><name>a2</name></decl></param>, <param><decl><type><name>char</name> **</type><name>a3</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name>quote</name></decl>;</decl_stmt>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/*
     * determine first argument
     */</comment>
    <expr_stmt><expr><name>quote</name> = (*<name>str</name> == '"' || *<name>str</name> == '\'') ? *<name>str</name>++ : '\0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>a1</name> = <name>str</name></expr>;</expr_stmt>

    <for>for (<init>;</init> <condition><expr>*<name>str</name></expr>;</condition> <incr><expr>++<name>str</name></expr></incr>) <block>{
        <if>if <condition>(<expr>(<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>quote</name>) || (*<name>str</name> == <name>quote</name>)</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <if>if <condition>(<expr>*<name>str</name> == '\\' &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr>!*<name>str</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>str</name>++ = '\0'</expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/*
     * determine second argument
     */</comment>
    <expr_stmt><expr><name>quote</name> = (*<name>str</name> == '"' || *<name>str</name> == '\'') ? *<name>str</name>++ : '\0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>a2</name> = <name>str</name></expr>;</expr_stmt>

    <for>for (<init>;</init> <condition><expr>*<name>str</name></expr>;</condition> <incr><expr>++<name>str</name></expr></incr>) <block>{
        <if>if <condition>(<expr>(<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>quote</name>) || (*<name>str</name> == <name>quote</name>)</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <if>if <condition>(<expr>*<name>str</name> == '\\' &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr>!*<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>a3</name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* 3rd argument is optional */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>str</name>++ = '\0'</expr>;</expr_stmt>

    <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr>!*<name>str</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>a3</name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* 3rd argument is still optional */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * determine third argument
     */</comment>
    <expr_stmt><expr><name>quote</name> = (*<name>str</name> == '"' || *<name>str</name> == '\'') ? *<name>str</name>++ : '\0'</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>a3</name> = <name>str</name></expr>;</expr_stmt>
    <for>for (<init>;</init> <condition><expr>*<name>str</name></expr>;</condition> <incr><expr>++<name>str</name></expr></incr>) <block>{
        <if>if <condition>(<expr>(<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>quote</name>) || (*<name>str</name> == <name>quote</name>)</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <if>if <condition>(<expr>*<name>str</name> == '\\' &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
    }</block></for>
    <expr_stmt><expr>*<name>str</name> = '\0'</expr>;</expr_stmt>

    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>config_server_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>a</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name> = (<name>rewrite_server_conf</name> *)<call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewrite_server_conf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>a</name>-&gt;<name>state</name></name>           = <name>ENGINE_DISABLED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>options</name></name>         = <name>OPTION_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>rewritemaps</name></name>     = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriteconds</name></name>    = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewritecond_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriterules</name></name>    = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewriterule_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>server</name></name>          = <name>s</name></expr>;</expr_stmt>

    <return>return <expr>(<name>void</name> *)<name>a</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>config_server_merge</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>basev</name></decl></param>, <param><decl><type><name>void</name> *</type><name>overridesv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>, *<decl><type ref="prev"/><name>overrides</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name>         = (<name>rewrite_server_conf</name> *)<call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                                   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewrite_server_conf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>base</name>      = (<name>rewrite_server_conf</name> *)<name>basev</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>overrides</name> = (<name>rewrite_server_conf</name> *)<name>overridesv</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>a</name>-&gt;<name>state</name></name> = (<name><name>overrides</name>-&gt;<name>state_set</name></name> == 0) ? <name><name>base</name>-&gt;<name>state</name></name> : <name><name>overrides</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>state_set</name></name> = <name><name>overrides</name>-&gt;<name>state_set</name></name> || <name><name>base</name>-&gt;<name>state_set</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>options</name></name> = (<name><name>overrides</name>-&gt;<name>options_set</name></name> == 0) ? <name><name>base</name>-&gt;<name>options</name></name> : <name><name>overrides</name>-&gt;<name>options</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>options_set</name></name> = <name><name>overrides</name>-&gt;<name>options_set</name></name> || <name><name>base</name>-&gt;<name>options_set</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>a</name>-&gt;<name>server</name></name>  = <name><name>overrides</name>-&gt;<name>server</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_INHERIT</name> ||
            (<name><name>base</name>-&gt;<name>options</name></name> &amp; <name>OPTION_INHERIT_DOWN</name> &amp;&amp;
             !(<name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_IGNORE_INHERIT</name>))</expr>)</condition><then> <block>{
        <comment type="block">/*
         *  local directives override
         *  and anything else is inherited
         */</comment>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewritemaps</name></name>     = <call><name>apr_hash_overlay</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>overrides</name>-&gt;<name>rewritemaps</name></name></expr></argument>,
                                              <argument><expr><name><name>base</name>-&gt;<name>rewritemaps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriteconds</name></name>    = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>overrides</name>-&gt;<name>rewriteconds</name></name></expr></argument>,
                                              <argument><expr><name><name>base</name>-&gt;<name>rewriteconds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriterules</name></name>    = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>overrides</name>-&gt;<name>rewriterules</name></name></expr></argument>,
                                              <argument><expr><name><name>base</name>-&gt;<name>rewriterules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_INHERIT_BEFORE</name> || 
            (<name><name>base</name>-&gt;<name>options</name></name> &amp; <name>OPTION_INHERIT_DOWN_BEFORE</name> &amp;&amp;
             !(<name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_IGNORE_INHERIT</name>))</expr>)</condition><then> <block>{
        <comment type="block">/*
         *  local directives override
         *  and anything else is inherited (preserving order)
         */</comment>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewritemaps</name></name>     = <call><name>apr_hash_overlay</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>rewritemaps</name></name></expr></argument>,
                                              <argument><expr><name><name>overrides</name>-&gt;<name>rewritemaps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriteconds</name></name>    = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>rewriteconds</name></name></expr></argument>,
                                              <argument><expr><name><name>overrides</name>-&gt;<name>rewriteconds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriterules</name></name>    = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>rewriterules</name></name></expr></argument>,
                                              <argument><expr><name><name>overrides</name>-&gt;<name>rewriterules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/*
         *  local directives override
         *  and anything else gets defaults
         */</comment>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewritemaps</name></name>     = <name><name>overrides</name>-&gt;<name>rewritemaps</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriteconds</name></name>    = <name><name>overrides</name>-&gt;<name>rewriteconds</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriterules</name></name>    = <name><name>overrides</name>-&gt;<name>rewriterules</name></name></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <return>return <expr>(<name>void</name> *)<name>a</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>config_perdir_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>a</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name> = (<name>rewrite_perdir_conf</name> *)<call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewrite_perdir_conf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>a</name>-&gt;<name>state</name></name>           = <name>ENGINE_DISABLED</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>options</name></name>         = <name>OPTION_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>baseurl</name></name>         = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriteconds</name></name>    = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewritecond_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriterules</name></name>    = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewriterule_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>a</name>-&gt;<name>directory</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* make sure it has a trailing slash */</comment>
        <if>if <condition>(<expr><name><name>path</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call>-1</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>a</name>-&gt;<name>directory</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>a</name>-&gt;<name>directory</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>

    <return>return <expr>(<name>void</name> *)<name>a</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>config_perdir_merge</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>basev</name></decl></param>, <param><decl><type><name>void</name> *</type><name>overridesv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>base</name></decl>, *<decl><type ref="prev"/><name>overrides</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>a</name>         = (<name>rewrite_perdir_conf</name> *)<call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
                                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewrite_perdir_conf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>base</name>      = (<name>rewrite_perdir_conf</name> *)<name>basev</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>overrides</name> = (<name>rewrite_perdir_conf</name> *)<name>overridesv</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>a</name>-&gt;<name>state</name></name> = (<name><name>overrides</name>-&gt;<name>state_set</name></name> == 0) ? <name><name>base</name>-&gt;<name>state</name></name> : <name><name>overrides</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>state_set</name></name> = <name><name>overrides</name>-&gt;<name>state_set</name></name> || <name><name>base</name>-&gt;<name>state_set</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>options</name></name> = (<name><name>overrides</name>-&gt;<name>options_set</name></name> == 0) ? <name><name>base</name>-&gt;<name>options</name></name> : <name><name>overrides</name>-&gt;<name>options</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>options_set</name></name> = <name><name>overrides</name>-&gt;<name>options_set</name></name> || <name><name>base</name>-&gt;<name>options_set</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_MERGEBASE</name></expr>)</condition><then> <block>{ 
        <expr_stmt><expr><name><name>a</name>-&gt;<name>baseurl</name></name> = (<name><name>overrides</name>-&gt;<name>baseurl_set</name></name> == 0) ? <name><name>base</name>-&gt;<name>baseurl</name></name> : <name><name>overrides</name>-&gt;<name>baseurl</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>baseurl_set</name></name> = <name><name>overrides</name>-&gt;<name>baseurl_set</name></name> || <name><name>base</name>-&gt;<name>baseurl_set</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{ 
        <expr_stmt><expr><name><name>a</name>-&gt;<name>baseurl</name></name> = <name><name>overrides</name>-&gt;<name>baseurl</name></name></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><name><name>a</name>-&gt;<name>directory</name></name>  = <name><name>overrides</name>-&gt;<name>directory</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_INHERIT</name> ||
            (<name><name>base</name>-&gt;<name>options</name></name> &amp; <name>OPTION_INHERIT_DOWN</name> &amp;&amp;
             !(<name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_IGNORE_INHERIT</name>))</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriteconds</name></name> = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>overrides</name>-&gt;<name>rewriteconds</name></name></expr></argument>,
                                           <argument><expr><name><name>base</name>-&gt;<name>rewriteconds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriterules</name></name> = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>overrides</name>-&gt;<name>rewriterules</name></name></expr></argument>,
                                           <argument><expr><name><name>base</name>-&gt;<name>rewriterules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_INHERIT_BEFORE</name> || 
            (<name><name>base</name>-&gt;<name>options</name></name> &amp; <name>OPTION_INHERIT_DOWN_BEFORE</name> &amp;&amp;
             !(<name><name>a</name>-&gt;<name>options</name></name> &amp; <name>OPTION_IGNORE_INHERIT</name>))</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriteconds</name></name>    = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>rewriteconds</name></name></expr></argument>,
                                              <argument><expr><name><name>overrides</name>-&gt;<name>rewriteconds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriterules</name></name>    = <call><name>apr_array_append</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>rewriterules</name></name></expr></argument>,
                                              <argument><expr><name><name>overrides</name>-&gt;<name>rewriterules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriteconds</name></name> = <name><name>overrides</name>-&gt;<name>rewriteconds</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>a</name>-&gt;<name>rewriterules</name></name> = <name><name>overrides</name>-&gt;<name>rewriterules</name></name></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <return>return <expr>(<name>void</name> *)<name>a</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_rewriteengine</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>,
                                     <param><decl><type><name>void</name> *</type><name>in_dconf</name></decl></param>, <param><decl><type><name>int</name></type> <name>flag</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>dconf</name> <init>= <expr><name>in_dconf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>sconf</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sconf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* server command? set both global scope and base directory scope */</comment>
    <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>path</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>sconf</name>-&gt;<name>state</name></name> = (<name>flag</name> ? <name>ENGINE_ENABLED</name> : <name>ENGINE_DISABLED</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sconf</name>-&gt;<name>state_set</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>state</name></name> = <name><name>sconf</name>-&gt;<name>state</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>state_set</name></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <comment type="block">/* directory command? set directory scope only */</comment>
    <else>else <block>{
        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>state</name></name> = (<name>flag</name> ? <name>ENGINE_ENABLED</name> : <name>ENGINE_DISABLED</name>)</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>state_set</name></name> = 1</expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_rewriteoptions</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>,
                                      <param><decl><type><name>void</name> *</type><name>in_dconf</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>option</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr>*<name>option</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>w</name> <init>= <expr><call><name>ap_getword_conf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>temp_pool</name></name></expr></argument>, <argument><expr>&amp;<name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"inherit"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_INHERIT</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"inheritbefore"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_INHERIT_BEFORE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"inheritdown"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_INHERIT_DOWN</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if<condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"inheritdownbefore"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_INHERIT_DOWN_BEFORE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"ignoreinherit"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_IGNORE_INHERIT</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"allownoslash"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_NOSLASH</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strncasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"MaxRedirects="</expr></argument>, <argument><expr>13</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00664</expr></argument>)</argument_list></call>
                         "RewriteOptions: MaxRedirects option has been "
                         "removed in favor of the global "
                         "LimitInternalRecursion directive and will be "
                         "ignored."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"allowanyuri"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_ANYURI</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"mergebase"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_MERGEBASE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"ignorecontextinfo"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_IGNORE_CONTEXT_INFO</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr>"legacyprefixdocroot"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>options</name> |= <name>OPTION_LEGACY_PREFIX_DOCROOT</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteOptions: unknown option '"</expr></argument>,
                               <argument><expr><name>w</name></expr></argument>, <argument><expr>"'"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
    }</block></while>

    <comment type="block">/* server command? set both global scope and base directory scope */</comment>
    <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>path</name></name> == <name>NULL</name></expr>)</condition><then> <block>{ <comment type="block">/* is server command */</comment>
        <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>dconf</name> <init>= <expr><name>in_dconf</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>sconf</name> <init>=
            <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                 <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>sconf</name>-&gt;<name>options</name></name> |= <name>options</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sconf</name>-&gt;<name>options_set</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>options</name></name> |= <name>options</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>options_set</name></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <comment type="block">/* directory command? set directory scope only */</comment>
    <else>else <block>{                  <comment type="block">/* is per-directory command */</comment>
        <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>dconf</name> <init>= <expr><name>in_dconf</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>options</name></name> |= <name>options</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>options_set</name></name> = 1</expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_rewritemap</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dconf</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>a1</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>a2</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>a3</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>sconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewritemap_entry</name> *</type><name>newmap</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>st</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sconf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>newmap</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewritemap_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr>"txt:"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name>fname</name> = <call><name>ap_server_root_relative</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>a2</name>+4</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteMap: bad path to txt map: "</expr></argument>,
                               <argument><expr><name>a2</name>+4</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>type</name></name>      = <name>MAPTYPE_TXT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>datafile</name></name>  = <name>fname</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>checkfile</name></name> = <name>fname</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>cachename</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%pp:%s"</expr></argument>,
                                         <argument><expr>(<name>void</name> *)<name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr>"rnd:"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name>fname</name> = <call><name>ap_server_root_relative</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>a2</name>+4</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteMap: bad path to rnd map: "</expr></argument>,
                               <argument><expr><name>a2</name>+4</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>type</name></name>      = <name>MAPTYPE_RND</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>datafile</name></name>  = <name>fname</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>checkfile</name></name> = <name>fname</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>cachename</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%pp:%s"</expr></argument>,
                                         <argument><expr>(<name>void</name> *)<name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr>"dbm"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>type</name></name> = <name>MAPTYPE_DBM</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>fname</name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>cachename</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%pp:%s"</expr></argument>,
                                         <argument><expr>(<name>void</name> *)<name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>a2</name><index>[<expr>3</expr>]</index></name> == ':'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>newmap</name>-&gt;<name>dbmtype</name></name> = "default"</expr>;</expr_stmt>
            <expr_stmt><expr><name>fname</name> = <name>a2</name>+4</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>a2</name><index>[<expr>3</expr>]</index></name> == '='</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>colon</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>a2</name> + 4</expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>colon</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>newmap</name>-&gt;<name>dbmtype</name></name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>a2</name> + 4</expr></argument>,
                                               <argument><expr><name>colon</name> - (<name>a2</name> + 3) - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>fname</name> = <name>colon</name> + 1</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if>

        <if>if <condition>(<expr>!<name>fname</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteMap: bad map:"</expr></argument>,
                               <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>(<name><name>newmap</name>-&gt;<name>datafile</name></name> = <call><name>ap_server_root_relative</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>,
                                                        <argument><expr><name>fname</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteMap: bad path to dbm map: "</expr></argument>,
                               <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>rv</name> = <call><name>apr_dbm_get_usednames_ex</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>newmap</name>-&gt;<name>dbmtype</name></name></expr></argument>,
                                      <argument><expr><name><name>newmap</name>-&gt;<name>datafile</name></name></expr></argument>, <argument><expr>&amp;<name><name>newmap</name>-&gt;<name>checkfile</name></name></expr></argument>,
                                      <argument><expr>&amp;<name><name>newmap</name>-&gt;<name>checkfile2</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteMap: dbm type "</expr></argument>,
                               <argument><expr><name><name>newmap</name>-&gt;<name>dbmtype</name></name></expr></argument>, <argument><expr>" is invalid"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>(<call><name>strncasecmp</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr>"dbd:"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0)
             || (<call><name>strncasecmp</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr>"fastdbd:"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>dbd_prepare</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr>"RewriteMap types dbd and fastdbd require mod_dbd!"</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr>(<name><name>a2</name><index>[<expr>0</expr>]</index></name> == 'd') || (<name><name>a2</name><index>[<expr>0</expr>]</index></name> == 'D')</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>newmap</name>-&gt;<name>type</name></name> = <name>MAPTYPE_DBD</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>fname</name> = <name>a2</name>+4</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>newmap</name>-&gt;<name>type</name></name> = <name>MAPTYPE_DBD_CACHE</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>fname</name> = <name>a2</name>+8</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newmap</name>-&gt;<name>cachename</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%pp:%s"</expr></argument>,
                                             <argument><expr>(<name>void</name> *)<name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>dbdq</name></name> = <name>a1</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>dbd_prepare</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>newmap</name>-&gt;<name>dbdq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr>"prg:"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_tokenize_to_argv</name><argument_list>(<argument><expr><name>a2</name> + 4</expr></argument>, <argument><expr>&amp;<name><name>newmap</name>-&gt;<name>argv</name></name></expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>fname</name> = <name><name>newmap</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name><name>newmap</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name> = <call><name>ap_server_root_relative</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>,
                                                       <argument><expr><name>fname</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteMap: bad path to prg map: "</expr></argument>,
                               <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>type</name></name>      = <name>MAPTYPE_PRG</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>checkfile</name></name> = <name><name>newmap</name>-&gt;<name>argv</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>a3</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>tok_cntx</name></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>newmap</name>-&gt;<name>user</name></name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>a3</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>newmap</name>-&gt;<name>group</name></name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr>&amp;<name>tok_cntx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name>a2</name></expr></argument>, <argument><expr>"int:"</expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>type</name></name>      = <name>MAPTYPE_INT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>func</name></name>      = (<call><call><name>char</name> *<argument_list>(<argument><expr>*</expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>request_rec</name> *</expr></argument>,<argument><expr><name>char</name> *</expr></argument>)</argument_list></call>)
                            <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mapfunc_hash</name></expr></argument>, <argument><expr><name>a2</name>+4</expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>a2</name>+4</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>newmap</name>-&gt;<name>func</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteMap: internal map not found:"</expr></argument>,
                               <argument><expr><name>a2</name>+4</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <if>if <condition>(<expr>(<name>fname</name> = <call><name>ap_server_root_relative</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>a2</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteMap: bad path to txt map: "</expr></argument>,
                               <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>type</name></name>      = <name>MAPTYPE_TXT</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>datafile</name></name>  = <name>fname</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>checkfile</name></name> = <name>fname</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newmap</name>-&gt;<name>cachename</name></name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%pp:%s"</expr></argument>,
                                         <argument><expr>(<name>void</name> *)<name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if></else></if></else></if></else></if></else></if>

    <if>if <condition>(<expr><name><name>newmap</name>-&gt;<name>checkfile</name></name>
        &amp;&amp; (<call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>st</name></expr></argument>, <argument><expr><name><name>newmap</name>-&gt;<name>checkfile</name></name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>,
                     <argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name>)</expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>,
                           <argument><expr>"RewriteMap: file for map "</expr></argument>, <argument><expr><name>a1</name></expr></argument>,
                           <argument><expr>" not found:"</expr></argument>, <argument><expr><name><name>newmap</name>-&gt;<name>checkfile</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>sconf</name>-&gt;<name>rewritemaps</name></name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>newmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_rewritebase</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>in_dconf</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>a1</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>dconf</name> <init>= <expr><name>in_dconf</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>path</name></name> == <name>NULL</name> || <name>dconf</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr>"RewriteBase: only valid in per-directory config files"</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>a1</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
        <return>return <expr>"RewriteBase: empty URL not allowed"</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name><name>a1</name><index>[<expr>0</expr>]</index></name> != '/'</expr>)</condition><then> <block>{
        <return>return <expr>"RewriteBase: argument is not a valid URL"</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>dconf</name>-&gt;<name>baseurl</name></name> = <name>a1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dconf</name>-&gt;<name>baseurl_set</name></name> = 1</expr>;</expr_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * generic lexer for RewriteRule and RewriteCond flags.
 * The parser will be passed in as a function pointer
 * and called if a flag was found
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_parseflagfield</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>cfg</name></decl></param>, <param><decl><type><name>char</name> *</type><name>key</name></decl></param>,
                                      <param><function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>parse</name>)<parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type></decl></param>,
                                                           <param><decl><type><name>void</name> *</type></decl></param>,
                                                           <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>val</name></decl>, *<decl><type ref="prev"/><name>nextp</name></decl>, *<decl><type ref="prev"/><name>endp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>endp</name> = <name>key</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>key</name> != '[' || *<name>endp</name> != ']'</expr>)</condition><then> <block>{
        <return>return <expr>"bad flag delimiters"</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr>*<name>endp</name> = ','</expr>;</expr_stmt> <comment type="block">/* for simpler parsing */</comment>
    <expr_stmt><expr>++<name>key</name></expr>;</expr_stmt>

    <while>while <condition>(<expr>*<name>key</name></expr>)</condition> <block>{
        <comment type="block">/* skip leading spaces */</comment>
        <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>key</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>key</name></expr>;</expr_stmt>
        }</block></while>

        <if>if <condition>(<expr>!*<name>key</name> || (<name>nextp</name> = <call><name>ap_strchr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{ <comment type="block">/* NULL should not
                                                               * happen, but ...
                                                               */</comment>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* strip trailing spaces */</comment>
        <expr_stmt><expr><name>endp</name> = <name>nextp</name> - 1</expr>;</expr_stmt>
        <while>while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>endp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>--<name>endp</name></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr>*++<name>endp</name> = '\0'</expr>;</expr_stmt>

        <comment type="block">/* split key and val */</comment>
        <expr_stmt><expr><name>val</name> = <call><name>ap_strchr</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>'='</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>val</name></expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>val</name>++ = '\0'</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>val</name> = <name>endp</name></expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>err</name> = <call><name>parse</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
            <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>key</name> = <name>nextp</name> + 1</expr>;</expr_stmt>
    }</block></while>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_rewritecond_setflag</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>_cfg</name></decl></param>,
                                           <param><decl><type><name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewritecond_entry</name> *</type><name>cfg</name> <init>= <expr><name>_cfg</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(   <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"nocase"</expr></argument>)</argument_list></call> == 0
        || <call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"NC"</expr></argument>)</argument_list></call> == 0</expr>    )</condition><then> <block>{
        <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>CONDFLAG_NOCASE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(   <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"ornext"</expr></argument>)</argument_list></call> == 0
             || <call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"OR"</expr></argument>)</argument_list></call> == 0</expr>    )</condition><then> <block>{
        <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>CONDFLAG_ORNEXT</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(   <expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"novary"</expr></argument>)</argument_list></call> == 0
             || <call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"NV"</expr></argument>)</argument_list></call> == 0</expr>    )</condition><then> <block>{
        <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>CONDFLAG_NOVARY</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"unknown flag '"</expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr>"'"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if></else></if>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_rewritecond</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>in_dconf</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>in_str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>dconf</name> <init>= <expr><name>in_dconf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>in_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>sconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewritecond_entry</name> *</type><name>newcond</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>regexp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>a1</name> <init>= <expr><name>NULL</name></expr></init>, *<name>a2</name> <init>= <expr><name>NULL</name></expr></init>, *<name>a3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sconf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*  make a new entry in the internal temporary rewrite rule list */</comment>
    <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>path</name></name> == <name>NULL</name></expr>)</condition><then> <block>{   <comment type="block">/* is server command */</comment>
        <expr_stmt><expr><name>newcond</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>sconf</name>-&gt;<name>rewriteconds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{                     <comment type="block">/* is per-directory command */</comment>
        <expr_stmt><expr><name>newcond</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>dconf</name>-&gt;<name>rewriteconds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* parse the argument line ourself
     * a1 .. a3 are substrings of str, which is a fresh copy
     * of the argument line. So we can use a1 .. a3 without
     * copying them again.
     */</comment>
    <if>if <condition>(<expr><call><name>parseargline</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>, <argument><expr>&amp;<name>a3</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteCond: bad argument line '"</expr></argument>, <argument><expr><name>str</name></expr></argument>,
                           <argument><expr>"'"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* arg1: the input string */</comment>
    <expr_stmt><expr><name><name>newcond</name>-&gt;<name>input</name></name> = <name>a1</name></expr>;</expr_stmt>

    <comment type="block">/* arg3: optional flags field
     * (this has to be parsed first, because we need to
     *  know if the regex should be compiled with ICASE!)
     */</comment>
    <expr_stmt><expr><name><name>newcond</name>-&gt;<name>flags</name></name> = <name>CONDFLAG_NONE</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>a3</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name>err</name> = <call><name>cmd_parseflagfield</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>newcond</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>,
                                      <argument><expr><name>cmd_rewritecond_setflag</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteCond: "</expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* arg2: the pattern */</comment>
    <expr_stmt><expr><name><name>newcond</name>-&gt;<name>pattern</name></name> = <name>a2</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>a2</name> == '!'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>flags</name></name> |= <name>CONDFLAG_NOTMATCH</name></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>a2</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* determine the pattern type */</comment>
    <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_REGEX</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr>"expr"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_AP_EXPR</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>*<name>a2</name> &amp;&amp; <name><name>a2</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>*<name>a2</name> == '-'</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name><name>a2</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
                <switch>switch <condition>(<expr><name><name>a2</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{
                <case>case <expr>'f'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_FILE_EXISTS</name></expr>;</expr_stmt> <break>break;</break>
                </case><case>case <expr>'s'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_FILE_SIZE</name></expr>;</expr_stmt>   <break>break;</break>
                </case><case>case <expr>'d'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_FILE_DIR</name></expr>;</expr_stmt>    <break>break;</break>
                </case><case>case <expr>'x'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_FILE_XBIT</name></expr>;</expr_stmt>   <break>break;</break>
                </case><case>case <expr>'h'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_FILE_LINK</name></expr>;</expr_stmt>   <break>break;</break>
                </case><case>case <expr>'L'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_FILE_LINK</name></expr>;</expr_stmt>   <break>break;</break>
                </case><case>case <expr>'l'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_FILE_LINK</name></expr>;</expr_stmt>   <break>break;</break>
                </case><case>case <expr>'U'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_LU_URL</name></expr>;</expr_stmt>      <break>break;</break>
                </case><case>case <expr>'F'</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_LU_FILE</name></expr>;</expr_stmt>     <break>break;</break>
                </case>}</block></switch>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>a2</name><index>[<expr>3</expr>]</index></name></expr>)</condition><then> <block>{
                <switch>switch <condition>(<expr><name><name>a2</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{
                <case>case <expr>'l'</expr>:
                    <if>if <condition>(<expr><name><name>a2</name><index>[<expr>2</expr>]</index></name> == 't'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>a2</name> += 3</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_INT_LT</name></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name><name>a2</name><index>[<expr>2</expr>]</index></name> == 'e'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>a2</name> += 3</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_INT_LE</name></expr>;</expr_stmt>
                    }</block></then></if></else></if>
                    <break>break;</break>

                </case><case>case <expr>'g'</expr>:
                    <if>if <condition>(<expr><name><name>a2</name><index>[<expr>2</expr>]</index></name> == 't'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>a2</name> += 3</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_INT_GT</name></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name><name>a2</name><index>[<expr>2</expr>]</index></name> == 'e'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>a2</name> += 3</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_INT_GE</name></expr>;</expr_stmt>
                    }</block></then></if></else></if>
                    <break>break;</break>

                </case><case>case <expr>'e'</expr>:
                    <if>if <condition>(<expr><name><name>a2</name><index>[<expr>2</expr>]</index></name> == 'q'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>a2</name> += 3</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_INT_EQ</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <break>break;</break>

                </case><case>case <expr>'n'</expr>:
                    <if>if <condition>(<expr><name><name>a2</name><index>[<expr>2</expr>]</index></name> == 'e'</expr>)</condition><then> <block>{
                        <comment type="block">/* Inversion, ensure !-ne == -eq */</comment>
                        <expr_stmt><expr><name>a2</name> += 3</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_INT_EQ</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>flags</name></name> ^= <name>CONDFLAG_NOTMATCH</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <break>break;</break>
                </case>}</block></switch>
            }</block></then></if></else></if>
        }</block></then>
        <else>else <block>{
            <switch>switch <condition>(<expr>*<name>a2</name></expr>)</condition> <block>{
            <case>case <expr>'&gt;'</expr>: <if>if <condition>(<expr>*++<name>a2</name> == '='</expr>)</condition><then>
                          <expr_stmt><expr>++<name>a2</name></expr>, <expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_STR_GE</name></expr>;</expr_stmt></then>
                      <else>else
                          <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_STR_GT</name></expr>;</expr_stmt></else></if>
                      <break>break;</break>

            </case><case>case <expr>'&lt;'</expr>: <if>if <condition>(<expr>*++<name>a2</name> == '='</expr>)</condition><then>
                          <expr_stmt><expr>++<name>a2</name></expr>, <expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_STR_LE</name></expr>;</expr_stmt></then>
                      <else>else
                          <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_STR_LT</name></expr>;</expr_stmt></else></if>
                      <break>break;</break>

            </case><case>case <expr>'='</expr>: <expr_stmt><expr><name><name>newcond</name>-&gt;<name>ptype</name></name> = <name>CONDPAT_STR_EQ</name></expr>;</expr_stmt>
                      <comment type="block">/* "" represents an empty string */</comment>
                      <if>if <condition>(<expr>*++<name>a2</name> == '"' &amp;&amp; <name><name>a2</name><index>[<expr>1</expr>]</index></name> == '"' &amp;&amp; !<name><name>a2</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then>
                          <expr_stmt><expr><name>a2</name> += 2</expr>;</expr_stmt></then></if>
                      <break>break;</break>
            </case>}</block></switch>
        }</block></else></if>
    }</block></then></if></else></if>

    <if>if <condition>(<expr>(<name><name>newcond</name>-&gt;<name>ptype</name></name> != <name>CONDPAT_REGEX</name>) &amp;&amp;
        (<name><name>newcond</name>-&gt;<name>ptype</name></name> &lt; <name>CONDPAT_STR_LT</name> || <name><name>newcond</name>-&gt;<name>ptype</name></name> &gt; <name>CONDPAT_STR_GE</name>) &amp;&amp;
        (<name><name>newcond</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOCASE</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00665</expr></argument>)</argument_list></call>
                     "RewriteCond: NoCase option for non-regex pattern '%s' "
                     "is not supported and will be ignored. (%s:%d)"</expr></argument>, <argument><expr><name>a2</name></expr></argument>,
                     <argument><expr><name><name>cmd</name>-&gt;<name>directive</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>cmd</name>-&gt;<name>directive</name>-&gt;<name>line_num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>flags</name></name> &amp;= ~<name>CONDFLAG_NOCASE</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name><name>newcond</name>-&gt;<name>pskip</name></name> = <name>a2</name> - <name><name>newcond</name>-&gt;<name>pattern</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newcond</name>-&gt;<name>pattern</name></name> += <name><name>newcond</name>-&gt;<name>pskip</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>newcond</name>-&gt;<name>ptype</name></name> == <name>CONDPAT_REGEX</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>regexp</name> = <call><name>ap_pregcomp</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>a2</name></expr></argument>,
                             <argument><expr><name>AP_REG_EXTENDED</name> | ((<name><name>newcond</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOCASE</name>)
                                             ? <name>AP_REG_ICASE</name> : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>regexp</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteCond: cannot compile regular "
                               "expression '"</expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr>"'"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>regexp</name></name>  = <name>regexp</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>newcond</name>-&gt;<name>ptype</name></name> == <name>CONDPAT_AP_EXPR</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>flags</name> <init>= <expr><name><name>newcond</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOVARY</name> ?
                             <name>AP_EXPR_FLAG_DONT_VARY</name> : 0</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>newcond</name>-&gt;<name>expr</name></name> = <call><name>ap_expr_parse_cmd</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
            <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteCond: cannot compile "
                                "expression \"%s\": %s"</expr></argument>, <argument><expr><name>a2</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if></else></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_rewriterule_setflag</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>_cfg</name></decl></param>,
                                           <param><decl><type><name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewriterule_entry</name> *</type><name>cfg</name> <init>= <expr><name>_cfg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr>*<name>key</name>++</expr>)</condition> <block>{
    <case>case <expr>'b'</expr>:
    </case><case>case <expr>'B'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"ackrefescaping"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_ESCAPEBACKREF</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>val</name> &amp;&amp; *<name>val</name></expr>)</condition><then> <block>{ 
                <expr_stmt><expr><name><name>cfg</name>-&gt;<name>escapes</name></name> = <name>val</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"NP"</expr></argument>)</argument_list></call> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"ackrefernoplus"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{ 
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_ESCAPENOPLUS</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <break>break;</break>
    </case><case>case <expr>'c'</expr>:
    </case><case>case <expr>'C'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"hain"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{           <comment type="block">/* chain */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_CHAIN</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>((*<name>key</name> == 'O' || *<name>key</name> == 'o') &amp;&amp; !<name><name>key</name><index>[<expr>1</expr>]</index></name>)
                 || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"ookie"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{           <comment type="block">/* cookie */</comment>
            <decl_stmt><decl><type><name>data_item</name> *</type><name>cp</name> <init>= <expr><name><name>cfg</name>-&gt;<name>cookie</name></name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<name>cp</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cp</name> = <name><name>cfg</name>-&gt;<name>cookie</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <while>while <condition>(<expr><name><name>cp</name>-&gt;<name>next</name></name></expr>)</condition> <block>{
                    <expr_stmt><expr><name>cp</name> = <name><name>cp</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name><name>cp</name>-&gt;<name>next</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>cp</name> = <name><name>cp</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><name><name>cp</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cp</name>-&gt;<name>data</name></name> = <name>val</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <break>break;</break>
    </case><case>case <expr>'d'</expr>:
    </case><case>case <expr>'D'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"PI"</expr></argument>)</argument_list></call> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>,<argument><expr>"iscardpath"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= (<name>RULEFLAG_DISCARDPATHINFO</name>)</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
    </case><case>case <expr>'e'</expr>:
    </case><case>case <expr>'E'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"nv"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{             <comment type="block">/* env */</comment>
            <decl_stmt><decl><type><name>data_item</name> *</type><name>cp</name> <init>= <expr><name><name>cfg</name>-&gt;<name>env</name></name></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr>!<name>cp</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cp</name> = <name><name>cfg</name>-&gt;<name>env</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <while>while <condition>(<expr><name><name>cp</name>-&gt;<name>next</name></name></expr>)</condition> <block>{
                    <expr_stmt><expr><name>cp</name> = <name><name>cp</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name><name>cp</name>-&gt;<name>next</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>cp</name> = <name><name>cp</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            }</block></else></if>

            <expr_stmt><expr><name><name>cp</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cp</name>-&gt;<name>data</name></name> = <name>val</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"nd"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{                <comment type="block">/* end */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_END</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <break>break;</break>

    </case><case>case <expr>'f'</expr>:
    </case><case>case <expr>'F'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"orbidden"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{       <comment type="block">/* forbidden */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= (<name>RULEFLAG_STATUS</name> | <name>RULEFLAG_NOSUB</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>forced_responsecode</name></name> = <name>HTTP_FORBIDDEN</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr>'g'</expr>:
    </case><case>case <expr>'G'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"one"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{            <comment type="block">/* gone */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= (<name>RULEFLAG_STATUS</name> | <name>RULEFLAG_NOSUB</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>forced_responsecode</name></name> = <name>HTTP_GONE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr>'h'</expr>:
    </case><case>case <expr>'H'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"andler"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{         <comment type="block">/* handler */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>forced_handler</name></name> = <name>val</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
    </case><case>case <expr>'l'</expr>:
    </case><case>case <expr>'L'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"ast"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{            <comment type="block">/* last */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_LASTRULE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr>'n'</expr>:
    </case><case>case <expr>'N'</expr>:
        <if>if <condition>(<expr>((*<name>key</name> == 'E' || *<name>key</name> == 'e') &amp;&amp; !<name><name>key</name><index>[<expr>1</expr>]</index></name>)
            || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"oescape"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{              <comment type="block">/* noescape */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_NOESCAPE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"ext"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{       <comment type="block">/* next */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_NEWROUND</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>val</name> &amp;&amp; *<name>val</name></expr>)</condition><then> <block>{ 
                <expr_stmt><expr><name><name>cfg</name>-&gt;<name>maxrounds</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

        }</block></then>
        <else>else <if>if <condition>(<expr>((*<name>key</name> == 'S' || *<name>key</name> == 's') &amp;&amp; !<name><name>key</name><index>[<expr>1</expr>]</index></name>)
            || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"osubreq"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{              <comment type="block">/* nosubreq */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_IGNOREONSUBREQ</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>((*<name>key</name> == 'C' || *<name>key</name> == 'c') &amp;&amp; !<name><name>key</name><index>[<expr>1</expr>]</index></name>)
            || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"ocase"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{                <comment type="block">/* nocase */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_NOCASE</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if></else></if>
        <break>break;</break>

    </case><case>case <expr>'p'</expr>:
    </case><case>case <expr>'P'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"roxy"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{           <comment type="block">/* proxy */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_PROXY</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr>((*<name>key</name> == 'T' || *<name>key</name> == 't') &amp;&amp; !<name><name>key</name><index>[<expr>1</expr>]</index></name>)
            || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"assthrough"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{           <comment type="block">/* passthrough */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_PASSTHROUGH</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if></else></if>
        <break>break;</break>

    </case><case>case <expr>'q'</expr>:
    </case><case>case <expr>'Q'</expr>:
        <if>if <condition>(   <expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"SA"</expr></argument>)</argument_list></call>
            || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"sappend"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{              <comment type="block">/* qsappend */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_QSAPPEND</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>( <expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"SD"</expr></argument>)</argument_list></call>
                || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"sdiscard"</expr></argument>)</argument_list></call></expr> )</condition><then> <block>{       <comment type="block">/* qsdiscard */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_QSDISCARD</name></expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>( <expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"SL"</expr></argument>)</argument_list></call>
                || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"slast"</expr></argument>)</argument_list></call></expr> )</condition><then> <block>{          <comment type="block">/* qslast */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_QSLAST</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>
        <break>break;</break>

    </case><case>case <expr>'r'</expr>:
    </case><case>case <expr>'R'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"edirect"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{        <comment type="block">/* redirect */</comment>
            <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_FORCEREDIRECT</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>val</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"permanent"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>status</name> = <name>HTTP_MOVED_PERMANENTLY</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"temp"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>status</name> = <name>HTTP_MOVED_TEMPORARILY</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"seeother"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>status</name> = <name>HTTP_SEE_OTHER</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>val</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>status</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name>status</name> != <name>HTTP_INTERNAL_SERVER_ERROR</name></expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>=
                            <expr><call><name>ap_index_of_response</name><argument_list>(<argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                        <if>if <condition>(<expr><call><name>ap_index_of_response</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> == <name>idx</name></expr>)</condition><then> <block>{
                            <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"invalid HTTP "
                                                   "response code '%s' for "
                                                   "flag 'R'"</expr></argument>,
                                                <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
                        }</block></then></if>
                    }</block></then></if>
                    <if>if <condition>(<expr>!<call><name>ap_is_HTTP_REDIRECT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cfg</name>-&gt;<name>flags</name></name> |= (<name>RULEFLAG_STATUS</name> | <name>RULEFLAG_NOSUB</name>)</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if></else></if></else></if></else></if>
                <expr_stmt><expr><name><name>cfg</name>-&gt;<name>forced_responsecode</name></name> = <name>status</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr>'s'</expr>:
    </case><case>case <expr>'S'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"kip"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{            <comment type="block">/* skip */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>skip</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr>'t'</expr>:
    </case><case>case <expr>'T'</expr>:
        <if>if <condition>(<expr>!*<name>key</name> || !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"ype"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{            <comment type="block">/* type */</comment>
            <expr_stmt><expr><name><name>cfg</name>-&gt;<name>forced_mimetype</name></name> = <name>val</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
    </case><default>default:
        <expr_stmt><expr>++<name>error</name></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>

    <if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>"unknown flag '"</expr></argument>, <argument><expr>--<name>key</name></expr></argument>, <argument><expr>"'"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>cmd_rewriterule</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>in_dconf</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>in_str</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>dconf</name> <init>= <expr><name>in_dconf</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>in_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>sconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewriterule_entry</name> *</type><name>newrule</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_regex_t</name> *</type><name>regexp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>a1</name> <init>= <expr><name>NULL</name></expr></init>, *<name>a2</name> <init>= <expr><name>NULL</name></expr></init>, *<name>a3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>sconf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*  make a new entry in the internal rewrite rule list */</comment>
    <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>path</name></name> == <name>NULL</name></expr>)</condition><then> <block>{   <comment type="block">/* is server command */</comment>
        <expr_stmt><expr><name>newrule</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>sconf</name>-&gt;<name>rewriterules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{                     <comment type="block">/* is per-directory command */</comment>
        <expr_stmt><expr><name>newrule</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>dconf</name>-&gt;<name>rewriterules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*  parse the argument line ourself */</comment>
    <if>if <condition>(<expr><call><name>parseargline</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>, <argument><expr>&amp;<name>a3</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteRule: bad argument line '"</expr></argument>, <argument><expr><name>str</name></expr></argument>,
                           <argument><expr>"'"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* arg3: optional flags field */</comment>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>forced_mimetype</name></name>     = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>forced_handler</name></name>      = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>forced_responsecode</name></name> = <name>HTTP_MOVED_TEMPORARILY</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>flags</name></name>  = <name>RULEFLAG_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>env</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>cookie</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>skip</name></name>   = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>maxrounds</name></name> = <name>REWRITE_MAX_ROUNDS</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>a3</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name>err</name> = <call><name>cmd_parseflagfield</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>newrule</name></expr></argument>, <argument><expr><name>a3</name></expr></argument>,
                                      <argument><expr><name>cmd_rewriterule_setflag</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"RewriteRule: "</expr></argument>, <argument><expr><name>err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* arg1: the pattern
     * try to compile the regexp to test if is ok
     */</comment>
    <if>if <condition>(<expr>*<name>a1</name> == '!'</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>newrule</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_NOTMATCH</name></expr>;</expr_stmt>
        <expr_stmt><expr>++<name>a1</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>regexp</name> = <call><name>ap_pregcomp</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>a1</name></expr></argument>, <argument><expr><name>AP_REG_EXTENDED</name> |
                                        ((<name><name>newrule</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NOCASE</name>)
                                         ? <name>AP_REG_ICASE</name> : 0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>regexp</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>,
                           <argument><expr>"RewriteRule: cannot compile regular expression '"</expr></argument>,
                           <argument><expr><name>a1</name></expr></argument>, <argument><expr>"'"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>pattern</name></name> = <name>a1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>regexp</name></name>  = <name>regexp</name></expr>;</expr_stmt>

    <comment type="block">/* arg2: the output string */</comment>
    <expr_stmt><expr><name><name>newrule</name>-&gt;<name>output</name></name> = <name>a2</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>*<name>a2</name> == '-' &amp;&amp; !<name><name>a2</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>newrule</name>-&gt;<name>flags</name></name> |= <name>RULEFLAG_NOSUB</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* now, if the server or per-dir config holds an
     * array of RewriteCond entries, we take it for us
     * and clear the array
     */</comment>
    <if>if <condition>(<expr><name><name>cmd</name>-&gt;<name>path</name></name> == <name>NULL</name></expr>)</condition><then> <block>{  <comment type="block">/* is server command */</comment>
        <expr_stmt><expr><name><name>newrule</name>-&gt;<name>rewriteconds</name></name>   = <name><name>sconf</name>-&gt;<name>rewriteconds</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sconf</name>-&gt;<name>rewriteconds</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>2</expr></argument>,
                                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewritecond_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{                    <comment type="block">/* is per-directory command */</comment>
        <expr_stmt><expr><name><name>newrule</name>-&gt;<name>rewriteconds</name></name>   = <name><name>dconf</name>-&gt;<name>rewriteconds</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dconf</name>-&gt;<name>rewriteconds</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>2</expr></argument>,
                                             <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewritecond_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                  the rewriting engine
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<comment type="block">/* Lexicographic Compare */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>int</name></type> <name>compare_lexicography</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>a</name></decl></param>, <param><decl><type><name>char</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>lena</name></decl>, <decl><type ref="prev"/><name>lenb</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>lena</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lenb</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>lena</name> == <name>lenb</name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>lena</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
            <if>if <condition>(<expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
                <return>return <expr>((<name>unsigned</name> <name>char</name>)<name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> &gt; (<name>unsigned</name> <name>char</name>)<name><name>b</name><index>[<expr><name>i</name></expr>]</index></name>) ? 1 : -1</expr>;</return>
            }</block></then></if>
        }</block></for>

        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <return>return <expr>((<name>lena</name> &gt; <name>lenb</name>) ? 1 : -1)</expr>;</return>
}</block></function>

<comment type="block">/*
 * Apply a single rewriteCond
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_rewrite_cond</name><parameter_list>(<param><decl><type><name>rewritecond_entry</name> *</type><name>p</name></decl></param>, <param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>input</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>sb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>rsub</name></decl>, *<decl><type ref="prev"/><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_regmatch_t</name></type> <name><name>regmatch</name><index>[<expr><name>AP_MAX_REG_MATCH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>basis</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>p</name>-&gt;<name>ptype</name></name> != <name>CONDPAT_AP_EXPR</name></expr>)</condition><then>
        <expr_stmt><expr><name>input</name> = <call><name>do_expand</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>input</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <switch>switch <condition>(<expr><name><name>p</name>-&gt;<name>ptype</name></name></expr>)</condition> <block>{
    <case>case <expr><name>CONDPAT_FILE_EXISTS</name></expr>:
        <if>if <condition>(   <expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
            &amp;&amp; <name><name>sb</name>.<name>filetype</name></name> == <name>APR_REG</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_FILE_SIZE</name></expr>:
        <if>if <condition>(   <expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
            &amp;&amp; <name><name>sb</name>.<name>filetype</name></name> == <name>APR_REG</name> &amp;&amp; <name><name>sb</name>.<name>size</name></name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_FILE_LINK</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
        <if>if <condition>(   <expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name> | <name>APR_FINFO_LINK</name></expr></argument>,
                        <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
            &amp;&amp; <name><name>sb</name>.<name>filetype</name></name> == <name>APR_LNK</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_FILE_DIR</name></expr>:
        <if>if <condition>(   <expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
            &amp;&amp; <name><name>sb</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_FILE_XBIT</name></expr>:
        <if>if <condition>(   <expr><call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>APR_FINFO_PROT</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
            &amp;&amp; (<name><name>sb</name>.<name>protection</name></name> &amp; (<name>APR_UEXECUTE</name> | <name>APR_GEXECUTE</name> | <name>APR_WEXECUTE</name>))</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_LU_URL</name></expr>:
        <if>if <condition>(<expr>*<name>input</name> &amp;&amp; <call><name>subreq_ok</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rsub</name> = <call><name>ap_sub_req_lookup_uri</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>rsub</name>-&gt;<name>status</name></name> &lt; 400</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "RewriteCond URI (-U) check: "
                        "path=%s -&gt; status=%d", <name>input</name>, <name><name>rsub</name>-&gt;<name>status</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_LU_FILE</name></expr>:
        <if>if <condition>(<expr>*<name>input</name> &amp;&amp; <call><name>subreq_ok</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rsub</name> = <call><name>ap_sub_req_lookup_file</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>rsub</name>-&gt;<name>status</name></name> &lt; 300 &amp;&amp;
                <comment type="block">/* double-check that file exists since default result is 200 */</comment>
                <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>sb</name></expr></argument>, <argument><expr><name><name>rsub</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name></expr></argument>,
                         <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rc</name> = 1</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 5, <name>NULL</name>, "RewriteCond file (-F) check: path=%s "
                        "-&gt; file=%s status=%d", <name>input</name>, <name><name>rsub</name>-&gt;<name>filename</name></name>,
                        <name><name>rsub</name>-&gt;<name>status</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>rsub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_STR_GE</name></expr>:
        <expr_stmt><expr><name>basis</name> = 0</expr>;</expr_stmt>
        <goto>goto <name>test_str_g</name>;</goto>
    </case><case>case <expr><name>CONDPAT_STR_GT</name></expr>:
        <expr_stmt><expr><name>basis</name> = 1</expr>;</expr_stmt>
<label><name>test_str_g</name>:</label>
        <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOCASE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rc</name> = (<call><name>strcasecmp</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call> &gt;= <name>basis</name>) ? 1 : 0</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>rc</name> = (<call><name>compare_lexicography</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call> &gt;= <name>basis</name>) ? 1 : 0</expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_STR_LE</name></expr>:
        <expr_stmt><expr><name>basis</name> = 0</expr>;</expr_stmt>
        <goto>goto <name>test_str_l</name>;</goto>
    </case><case>case <expr><name>CONDPAT_STR_LT</name></expr>:
        <expr_stmt><expr><name>basis</name> = -1</expr>;</expr_stmt>
<label><name>test_str_l</name>:</label>
        <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOCASE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rc</name> = (<call><name>strcasecmp</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call> &lt;= <name>basis</name>) ? 1 : 0</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>rc</name> = (<call><name>compare_lexicography</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call> &lt;= <name>basis</name>) ? 1 : 0</expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_STR_EQ</name></expr>:
        <comment type="block">/* Note: the only type where the operator is dropped from p-&gt;pattern */</comment>
        <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOCASE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rc</name> = !<call><name>strcasecmp</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>rc</name> = !<call><name>strcmp</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>

    </case><case>case <expr><name>CONDPAT_INT_GE</name></expr>: <expr_stmt><expr><name>rc</name> = (<call><name>atoi</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> &gt;= <call><name>atoi</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>CONDPAT_INT_GT</name></expr>: <expr_stmt><expr><name>rc</name> = (<call><name>atoi</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> &gt; <call><name>atoi</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>  <break>break;</break>

    </case><case>case <expr><name>CONDPAT_INT_LE</name></expr>: <expr_stmt><expr><name>rc</name> = (<call><name>atoi</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> &lt;= <call><name>atoi</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr><name>CONDPAT_INT_LT</name></expr>: <expr_stmt><expr><name>rc</name> = (<call><name>atoi</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> &lt; <call><name>atoi</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>  <break>break;</break>

    </case><case>case <expr><name>CONDPAT_INT_EQ</name></expr>: <expr_stmt><expr><name>rc</name> = (<call><name>atoi</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> == <call><name>atoi</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt> <break>break;</break>

    </case><case>case <expr><name>CONDPAT_AP_EXPR</name></expr>:
        <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>source</name></decl>;</decl_stmt>
            <expr_stmt><expr><name>rc</name> = <call><name>ap_expr_exec_re</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>expr</name></name></expr></argument>, <argument><expr><name>AP_MAX_REG_MATCH</name></expr></argument>, <argument><expr><name>regmatch</name></expr></argument>,
                                 <argument><expr>&amp;<name>source</name></expr></argument>, <argument><expr>&amp;<name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rc</name> &lt; 0 || <name>err</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>ctx</name>-&gt;<name>perdir</name></name>,
                            "RewriteCond: expr='%s' evaluation failed: %s",
                            <name><name>p</name>-&gt;<name>pattern</name></name> - <name><name>p</name>-&gt;<name>pskip</name></name>, <name>err</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rc</name> = 0</expr>;</expr_stmt>
            }</block></then></if>
            <comment type="block">/* update briRC backref info */</comment>
            <if>if <condition>(<expr><name>rc</name> &amp;&amp; !(<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOTMATCH</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>briRC</name>.<name>source</name></name> = <name>source</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>briRC</name>.<name>regmatch</name></name></expr></argument>, <argument><expr><name>regmatch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regmatch</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block>
        <break>break;</break>
    </case><default>default:
        <comment type="block">/* it is really a regexp pattern, so apply it */</comment>
        <expr_stmt><expr><name>rc</name> = !<call><name>ap_regexec</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>regexp</name></name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>AP_MAX_REG_MATCH</name></expr></argument>, <argument><expr><name>regmatch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* update briRC backref info */</comment>
        <if>if <condition>(<expr><name>rc</name> &amp;&amp; !(<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOTMATCH</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>briRC</name>.<name>source</name></name> = <name>input</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>briRC</name>.<name>regmatch</name></name></expr></argument>, <argument><expr><name>regmatch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regmatch</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <break>break;</break>
    </default>}</block></switch>

    <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOTMATCH</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rc</name> = !<name>rc</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 4, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "RewriteCond: input='%s' pattern='%s'%s "
                "=&gt; %s", <name>input</name>, <name><name>p</name>-&gt;<name>pattern</name></name> - <name><name>p</name>-&gt;<name>pskip</name></name>,
                (<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOCASE</name>) ? " [NC]" : "",
                <name>rc</name> ? "matched" : "not-matched")</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>rc</name></expr>;</return>
}</block></function>

<comment type="block">/* check for forced type and handler */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type> <name>force_type_handler</name><parameter_list>(<param><decl><type><name>rewriterule_entry</name> *</type><name>p</name></decl></param>,
                                          <param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>expanded</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>p</name>-&gt;<name>forced_mimetype</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>expanded</name> = <call><name>do_expand</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>forced_mimetype</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>*<name>expanded</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name><name>ctx</name>-&gt;<name>r</name></name>, 2, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "remember %s to have MIME-type "
                        "'%s'", <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>filename</name></name>, <name>expanded</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>REWRITE_FORCED_MIMETYPE_NOTEVAR</name></expr></argument>,
                           <argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>p</name>-&gt;<name>forced_handler</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>expanded</name> = <call><name>do_expand</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>forced_handler</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>*<name>expanded</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name><name>ctx</name>-&gt;<name>r</name></name>, 2, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "remember %s to have "
                        "Content-handler '%s'", <name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>filename</name></name>, <name>expanded</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>REWRITE_FORCED_HANDLER_NOTEVAR</name></expr></argument>,
                           <argument><expr><name>expanded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * Apply a single RewriteRule
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_rewrite_rule</name><parameter_list>(<param><decl><type><name>rewriterule_entry</name> *</type><name>p</name></decl></param>, <param><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ap_regmatch_t</name></type> <name><name>regmatch</name><index>[<expr><name>AP_MAX_REG_MATCH</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rewriteconds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewritecond_entry</name> *</type><name>conds</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>newuri</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_proxyreq</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>uri</name></name> = <name><name>r</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>perdir</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>dirlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>perdir</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/*
         * Proxy request?
         */</comment>
        <expr_stmt><expr><name>is_proxyreq</name> = (   <name><name>r</name>-&gt;<name>proxyreq</name></name> &amp;&amp; <name><name>r</name>-&gt;<name>filename</name></name>
                       &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"proxy:"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

        <comment type="block">/* Since we want to match against the (so called) full URL, we have
         * to re-add the PATH_INFO postfix
         */</comment>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>path_info</name></name> &amp;&amp; *<name><name>r</name>-&gt;<name>path_info</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 3, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "add path info postfix: %s -&gt; %s%s",
                        <name><name>ctx</name>-&gt;<name>uri</name></name>, <name><name>ctx</name>-&gt;<name>uri</name></name>, <name><name>r</name>-&gt;<name>path_info</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>uri</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>path_info</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Additionally we strip the physical path from the url to match
         * it independent from the underlaying filesystem.
         */</comment>
        <if>if <condition>(<expr>!<name>is_proxyreq</name> &amp;&amp; <call><name>strlen</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call> &gt;= <name>dirlen</name> &amp;&amp;
            !<call><name>strncmp</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>perdir</name></name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 3, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "strip per-dir prefix: %s -&gt; %s",
                        <name><name>ctx</name>-&gt;<name>uri</name></name>, <name><name>ctx</name>-&gt;<name>uri</name></name> + <name>dirlen</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>uri</name></name> = <name><name>ctx</name>-&gt;<name>uri</name></name> + <name>dirlen</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Try to match the URI against the RewriteRule pattern
     * and exit immediately if it didn't apply.
     */</comment>
    <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 3, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "applying pattern '%s' to uri '%s'",
                <name><name>p</name>-&gt;<name>pattern</name></name>, <name><name>ctx</name>-&gt;<name>uri</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rc</name> = !<call><name>ap_regexec</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>regexp</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name>AP_MAX_REG_MATCH</name></expr></argument>, <argument><expr><name>regmatch</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>! (( <name>rc</name> &amp;&amp; !(<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NOTMATCH</name>)) ||
           (!<name>rc</name> &amp;&amp;  (<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NOTMATCH</name>))   )</expr> )</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <comment type="block">/* It matched, wow! Now it's time to prepare the context structure for
     * further processing
     */</comment>
    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>vary_this</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>briRC</name>.<name>source</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NOTMATCH</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>briRR</name>.<name>source</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>briRR</name>.<name>source</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>briRR</name>.<name>regmatch</name></name></expr></argument>, <argument><expr><name>regmatch</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>regmatch</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* Ok, we already know the pattern has matched, but we now
     * additionally have to check for all existing preconditions
     * (RewriteCond) which have to be also true. We do this at
     * this very late stage to avoid unnecessary checks which
     * would slow down the rewriting engine.
     */</comment>
    <expr_stmt><expr><name>rewriteconds</name> = <name><name>p</name>-&gt;<name>rewriteconds</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>conds</name> = (<name>rewritecond_entry</name> *)<name><name>rewriteconds</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rewriteconds</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>rewritecond_entry</name> *</type><name>c</name> <init>= <expr>&amp;<name><name>conds</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>rc</name> = <call><name>apply_rewrite_cond</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * Reset vary_this if the novary flag is set for this condition.
         */</comment>
        <if>if <condition>(<expr><name><name>c</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_NOVARY</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>vary_this</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>c</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_ORNEXT</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>rc</name></expr>)</condition><then> <block>{
                <comment type="block">/* One condition is false, but another can be still true. */</comment>
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>vary_this</name></name> = <name>NULL</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* skip the rest of the chained OR conditions */</comment>
                <while>while <condition>(   <expr><name>i</name> &lt; <name><name>rewriteconds</name>-&gt;<name>nelts</name></name>
                       &amp;&amp; <name><name>c</name>-&gt;<name>flags</name></name> &amp; <name>CONDFLAG_ORNEXT</name></expr>)</condition> <block>{
                    <expr_stmt><expr><name>c</name> = &amp;<name><name>conds</name><index>[<expr>++<name>i</name></expr>]</index></name></expr>;</expr_stmt>
                }</block></while>
            }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>!<name>rc</name></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if></else></if>

        <comment type="block">/* If some HTTP header was involved in the condition, remember it
         * for later use
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>vary_this</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>vary</name></name> = <name><name>ctx</name>-&gt;<name>vary</name></name>
                        ? <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>vary</name></name></expr></argument>, <argument><expr>", "</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>vary_this</name></name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
                        : <name><name>ctx</name>-&gt;<name>vary_this</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>vary_this</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* expand the result */</comment>
    <if>if <condition>(<expr>!(<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NOSUB</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>newuri</name> = <call><name>do_expand</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "rewrite '%s' -&gt; '%s'", <name><name>ctx</name>-&gt;<name>uri</name></name>,
                    <name>newuri</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* expand [E=var:val] and [CO=&lt;cookie&gt;] */</comment>
    <expr_stmt><expr><call><name>do_expand_env</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>env</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>do_expand_cookie</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>cookie</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* non-substitution rules ('RewriteRule &lt;pat&gt; -') end here. */</comment>
    <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NOSUB</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>force_type_handler</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_STATUS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "forcing responsecode %d for %s",
                        <name><name>p</name>-&gt;<name>forced_responsecode</name></name>, <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name><name>p</name>-&gt;<name>forced_responsecode</name></name></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr>2</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Now adjust API's knowledge about r-&gt;filename and r-&gt;args */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <name>newuri</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>perdir</name></name> &amp;&amp; (<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_DISCARDPATHINFO</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>path_info</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>splitout_queryargs</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_QSAPPEND</name></expr></argument>, 
                          <argument><expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_QSDISCARD</name></expr></argument>, 
                          <argument><expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_QSLAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Add the previously stripped per-directory location prefix, unless
     * (1) it's an absolute URL path and
     * (2) it's a full qualified URL
     */</comment>
    <if>if <condition>(   <expr><name><name>ctx</name>-&gt;<name>perdir</name></name> &amp;&amp; !<name>is_proxyreq</name> &amp;&amp; *<name><name>r</name>-&gt;<name>filename</name></name> != '/'
        &amp;&amp; !<call><name>is_absolute_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 3, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "add per-dir prefix: %s -&gt; %s%s",
                    <name><name>r</name>-&gt;<name>filename</name></name>, <name><name>ctx</name>-&gt;<name>perdir</name></name>, <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>perdir</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* If this rule is forced for proxy throughput
     * (`RewriteRule ... ... [P]') then emulate mod_proxy's
     * URL-to-filename handler to be sure mod_proxy is triggered
     * for this URL later in the Apache API. But make sure it is
     * a fully-qualified URL. (If not it is qualified with
     * ourself).
     */</comment>
    <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_PROXY</name></expr>)</condition><then> <block>{
        <comment type="block">/* For rules evaluated in server context, the mod_proxy fixup
         * hook can be relied upon to escape the URI as and when
         * necessary, since it occurs later.  If in directory context,
         * the ordering of the fixup hooks is forced such that
         * mod_proxy comes first, so the URI must be escaped here
         * instead.  See PR 39746, 46428, and other headaches. */</comment>
        <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>perdir</name></name> &amp;&amp; (<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NOESCAPE</name>) == 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>old_filename</name> <init>= <expr><name><name>r</name>-&gt;<name>filename</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "escaped URI in per-dir context "
                        "for proxy, %s -&gt; %s", <name>old_filename</name>, <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>fully_qualify_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "forcing proxy-throughput with %s",
                    <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"proxy:"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* If this rule is explicitly forced for HTTP redirection
     * (`RewriteRule .. .. [R]') then force an external HTTP
     * redirect. But make sure it is a fully-qualified URL. (If
     * not it is qualified with ourself).
     */</comment>
    <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_FORCEREDIRECT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>fully_qualify_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "explicitly forcing redirect with %s",
                    <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name><name>p</name>-&gt;<name>forced_responsecode</name></name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Special Rewriting Feature: Self-Reduction
     * We reduce the URL by stripping a possible
     * http[s]://&lt;ourhost&gt;[:&lt;port&gt;] prefix, i.e. a prefix which
     * corresponds to ourself. This is to simplify rewrite maps
     * and to avoid recursion, etc. When this prefix is not a
     * coincidence then the user has to use [R] explicitly (see
     * above).
     */</comment>
    <expr_stmt><expr><call><name>reduce_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If this rule is still implicitly forced for HTTP
     * redirection (`RewriteRule .. &lt;scheme&gt;://...') then
     * directly force an external HTTP redirect.
     */</comment>
    <if>if <condition>(<expr><call><name>is_absolute_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>ctx</name>-&gt;<name>perdir</name></name>, "implicitly forcing redirect (rc=%d) "
                    "with %s", <name><name>p</name>-&gt;<name>forced_responsecode</name></name>, <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name><name>p</name>-&gt;<name>forced_responsecode</name></name></expr>;</expr_stmt>
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* Finally remember the forced mime-type */</comment>
    <expr_stmt><expr><call><name>force_type_handler</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Puuhhhhhhhh... WHAT COMPLICATED STUFF ;_)
     * But now we're done for this particular rule.
     */</comment>
    <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
 * Apply a complete rule set,
 * i.e. a list of rewrite rules
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_rewrite_list</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>apr_array_header_t</name> *</type><name>rewriterules</name></decl></param>,
                              <param><decl><type><name>char</name> *</type><name>perdir</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewriterule_entry</name> *</type><name>entries</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewriterule_entry</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>changed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewrite_ctx</name> *</type><name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>round</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>ctx</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>perdir</name></name> = <name>perdir</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>r</name></name> = <name>r</name></expr>;</expr_stmt>

    <comment type="block">/*
     *  Iterate over all existing rules
     */</comment>
    <expr_stmt><expr><name>entries</name> = (<name>rewriterule_entry</name> *)<name><name>rewriterules</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>changed</name> = 0</expr>;</expr_stmt>
    <label><name>loop</name>:</label>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rewriterules</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>p</name> = &amp;<name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

        <comment type="block">/*
         *  Ignore this rule on subrequests if we are explicitly
         *  asked to do so or this is a proxy-throughput or a
         *  forced redirect rule.
         */</comment>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name/></name>main != <name>NULL</name> &amp;&amp;
            (<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_IGNOREONSUBREQ</name> ||
             <name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_FORCEREDIRECT</name>    )</expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/*
         *  Apply the current rule.
         */</comment>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>vary</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rc</name> = <call><name>apply_rewrite_rule</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rc</name></expr>)</condition><then> <block>{

            <comment type="block">/* Catch looping rules with pathinfo growing unbounded */</comment>
            <if>if <condition>( <expr><call><name>strlen</name><argument_list>( <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument> )</argument_list></call> &gt; 2*<name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_line</name></name></expr> )</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                              <argument><expr>"RewriteRule '%s' and URI '%s' "
                              "exceeded maximum length (%d)"</expr></argument>, 
                              <argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr>2*<name><name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_line</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</expr_stmt>
                <return>return <expr><name>ACTION_STATUS</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Regardless of what we do next, we've found a match. Check to see
             * if any of the request header fields were involved, and add them
             * to the Vary field of the response.
             */</comment>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>vary</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_merge</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>vary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/*
             * The rule sets the response code (implies match-only)
             */</comment>
            <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_STATUS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>ACTION_STATUS</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/*
             * Indicate a change if this was not a match-only rule.
             */</comment>
            <if>if <condition>(<expr><name>rc</name> != 2</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>changed</name> = ((<name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NOESCAPE</name>)
                           ? <name>ACTION_NOESCAPE</name> : <name>ACTION_NORMAL</name>)</expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/*
             *  Pass-Through Feature (`RewriteRule .. .. [PT]'):
             *  Because the Apache 1.x API is very limited we
             *  need this hack to pass the rewritten URL to other
             *  modules like mod_alias, mod_userdir, etc.
             */</comment>
            <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_PASSTHROUGH</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name>perdir</name>, "forcing '%s' to get passed through "
                           "to next API URI-to-filename handler", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"passthrough:"</expr></argument>,
                                         <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>changed</name> = <name>ACTION_NORMAL</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>

            <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_END</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 8, <name>perdir</name>, "Rule has END flag, no further rewriting for this request")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr>"1"</expr></argument>, <argument><expr><name>really_last_key</name></expr></argument>, <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <comment type="block">/*
             *  Stop processing also on proxy pass-through and
             *  last-rule and new-round flags.
             */</comment>
            <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; (<name>RULEFLAG_PROXY</name> | <name>RULEFLAG_LASTRULE</name>)</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>

            <comment type="block">/*
             *  On "new-round" flag we just start from the top of
             *  the rewriting ruleset again.
             */</comment>
            <if>if <condition>(<expr><name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_NEWROUND</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>++<name>round</name> &gt;= <name><name>p</name>-&gt;<name>maxrounds</name></name></expr>)</condition><then> <block>{ 
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02596</expr></argument>)</argument_list></call>
                                  "RewriteRule '%s' and URI '%s' exceeded "
                                  "maximum number of rounds (%d) via the [N] flag"</expr></argument>, 
                                  <argument><expr><name><name>p</name>-&gt;<name>pattern</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>maxrounds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</expr_stmt>
                    <return>return <expr><name>ACTION_STATUS</name></expr>;</return> 
                }</block></then></if>
                <goto>goto <name>loop</name>;</goto>
            }</block></then></if>

            <comment type="block">/*
             *  If we are forced to skip N next rules, do it now.
             */</comment>
            <if>if <condition>(<expr><name><name>p</name>-&gt;<name>skip</name></name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>s</name> = <name><name>p</name>-&gt;<name>skip</name></name></expr>;</expr_stmt>
                <while>while <condition>(   <expr><name>i</name> &lt; <name><name>rewriterules</name>-&gt;<name>nelts</name></name>
                       &amp;&amp; <name>s</name> &gt; 0</expr>)</condition> <block>{
                    <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
                    <expr_stmt><expr><name>s</name>--</expr>;</expr_stmt>
                }</block></while>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/*
             *  If current rule is chained with next rule(s),
             *  skip all this next rule(s)
             */</comment>
            <while>while <condition>(   <expr><name>i</name> &lt; <name><name>rewriterules</name>-&gt;<name>nelts</name></name>
                   &amp;&amp; <name><name>p</name>-&gt;<name>flags</name></name> &amp; <name>RULEFLAG_CHAIN</name></expr>)</condition> <block>{
                <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>p</name> = &amp;<name><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            }</block></while>
        }</block></else></if>
    }</block></for>
    <return>return <expr><name>changed</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |             Module Initialization Hooks
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>pre_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>APR_OPTIONAL_FN_TYPE</name><argument_list>(<argument><expr><name>ap_register_rewrite_mapfunc</name></expr></argument>)</argument_list></call> *<name>map_pfn_register</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_mutex_register</name><argument_list>(<argument><expr><name>pconf</name></expr></argument>, <argument><expr><name>rewritemap_mutex_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_LOCK_DEFAULT</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* register int: rewritemap handlers */</comment>
    <expr_stmt><expr><name>map_pfn_register</name> = <call><name>APR_RETRIEVE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_register_rewrite_mapfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>map_pfn_register</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>map_pfn_register</name><argument_list>(<argument><expr>"tolower"</expr></argument>, <argument><expr><name>rewrite_mapfunc_tolower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>map_pfn_register</name><argument_list>(<argument><expr>"toupper"</expr></argument>, <argument><expr><name>rewrite_mapfunc_toupper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>map_pfn_register</name><argument_list>(<argument><expr>"escape"</expr></argument>, <argument><expr><name>rewrite_mapfunc_escape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>map_pfn_register</name><argument_list>(<argument><expr>"unescape"</expr></argument>, <argument><expr><name>rewrite_mapfunc_unescape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><name>dbd_acquire</name> = <call><name>APR_RETRIEVE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_dbd_acquire</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dbd_prepare</name> = <call><name>APR_RETRIEVE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_dbd_prepare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>post_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>plog</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>ptemp</name></decl></param>,
                       <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="block">/* check if proxy module is available */</comment>
    <expr_stmt><expr><name>proxy_available</name> = (<call><name>ap_find_linked_module</name><argument_list>(<argument><expr>"mod_proxy.c"</expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>rewritelock_create</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>s</name></expr></argument>, <argument><expr><name>rewritelock_remove</name></expr></argument>,
                              <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if we are not doing the initial config, step through the servers and
     * open the RewriteMap prg:xxx programs,
     */</comment>
    <if>if <condition>(<expr><call><name>ap_state_query</name><argument_list>(<argument><expr><name>AP_SQ_MAIN_STATE</name></expr></argument>)</argument_list></call> == <name>AP_SQ_MS_CREATE_CONFIG</name></expr>)</condition><then> <block>{
        <for>for (<init>;</init> <condition><expr><name>s</name></expr>;</condition> <incr><expr><name>s</name> = <name><name>s</name>-&gt;<name>next</name></name></expr></incr>) <block>{
            <if>if <condition>(<expr><call><name>run_rewritemap_programs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <expr_stmt><expr><name>rewrite_ssl_lookup</name> = <call><name>APR_RETRIEVE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ssl_var_lookup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rewrite_is_https</name> = <call><name>APR_RETRIEVE_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ssl_is_https</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_child</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* get a rid of gcc warning (REWRITELOG_DISABLED) */</comment>

    <if>if <condition>(<expr><name>rewrite_mapr_lock_acquire</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>rv</name> = <call><name>apr_global_mutex_child_init</name><argument_list>(<argument><expr>&amp;<name>rewrite_mapr_lock_acquire</name></expr></argument>,
                 <argument><expr><call><name>apr_global_mutex_lockfile</name><argument_list>(<argument><expr><name>rewrite_mapr_lock_acquire</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00666</expr></argument>)</argument_list></call>
                         "mod_rewrite: could not init rewrite_mapr_lock_acquire"
                         " in child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* create the lookup cache */</comment>
    <if>if <condition>(<expr>!<call><name>init_cache</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_CRIT</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00667</expr></argument>)</argument_list></call>
                     "mod_rewrite: could not init map cache in child"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                     runtime hooks
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<comment type="block">/*
 * URI-to-filename hook
 * [deals with RewriteRules in server context]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hook_uri2file</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>dconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>rewrite_server_conf</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>saved_rulestatus</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>var</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>thisserver</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>thisport</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>thisurl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>port</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rulestatus</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>skipdata</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>oargs</name></decl>;</decl_stmt>

    <comment type="block">/*
     *  retrieve the config structures
     */</comment>
    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>dconf</name> = (<name>rewrite_perdir_conf</name> *)<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                        <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     *  only do something under runtime if the engine is really enabled,
     *  else return immediately!
     */</comment>
    <if>if <condition>(<expr>!<name>dconf</name> || <name><name>dconf</name>-&gt;<name>state</name></name> == <name>ENGINE_DISABLED</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     *  check for the ugly API case of a virtual host section where no
     *  mod_rewrite directives exists. In this situation we became no chance
     *  by the API to setup our default per-server config so we have to
     *  on-the-fly assume we have the default config. But because the default
     *  config has a disabled rewriting engine we are lucky because can
     *  just stop operating now.
     */</comment>
    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>server</name></name> != <name><name>r</name>-&gt;<name>server</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* END flag was used as a RewriteRule flag on this request */</comment>
    <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>skipdata</name></expr></argument>, <argument><expr><name>really_last_key</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>skipdata</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 8, <name>NULL</name>, "Declining, no further rewriting due to END flag")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Unless the anyuri option is set, ensure that the input to the
     * first rule really is a URL-path, avoiding security issues with
     * poorly configured rules.  See CVE-2011-3368, CVE-2011-4317. */</comment>
    <if>if <condition>(<expr>(<name><name>dconf</name>-&gt;<name>options</name></name> &amp; <name>OPTION_ANYURI</name>) == 0
        &amp;&amp; ((<name><name>r</name>-&gt;<name>unparsed_uri</name><index>[<expr>0</expr>]</index></name> == '*' &amp;&amp; <name><name>r</name>-&gt;<name>unparsed_uri</name><index>[<expr>1</expr>]</index></name> == '\0')
            || !<name><name>r</name>-&gt;<name>uri</name></name> || <name><name>r</name>-&gt;<name>uri</name><index>[<expr>0</expr>]</index></name> != '/')</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 8, <name>NULL</name>, "Declining, request-URI '%s' is not a URL-path. "
                    "Consult the manual entry for the RewriteOptions directive "
                    "for options and caveats about matching other strings.",
                    <name><name>r</name>-&gt;<name>uri</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     *  remember the original query string for later check, since we don't
     *  want to apply URL-escaping when no substitution has changed it.
     */</comment>
    <expr_stmt><expr><name>oargs</name> = <name><name>r</name>-&gt;<name>args</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     *  add the SCRIPT_URL variable to the env. this is a bit complicated
     *  due to the fact that apache uses subrequests and internal redirects
     */</comment>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name/></name>main == <name>NULL</name></expr>)</condition><then> <block>{
         <expr_stmt><expr><name>var</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>REDIRECT_ENVVAR_SCRIPT_URL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <if>if <condition>(<expr><name>var</name> == <name>NULL</name></expr>)</condition><then> <block>{
             <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>ENVVAR_SCRIPT_URL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         }</block></then>
         <else>else <block>{
             <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>ENVVAR_SCRIPT_URL</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         }</block></else></if>
    }</block></then>
    <else>else <block>{
         <expr_stmt><expr><name>var</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name/></name>main-&gt;<name>subprocess_env</name></expr></argument>, <argument><expr><name>ENVVAR_SCRIPT_URL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>ENVVAR_SCRIPT_URL</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     *  create the SCRIPT_URI variable for the env
     */</comment>

    <comment type="block">/* add the canonical URI of this URL */</comment>
    <expr_stmt><expr><name>thisserver</name> = <call><name>ap_get_server_name_for_url</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>port</name> = <call><name>ap_get_server_port</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><call><name>ap_is_default_port</name><argument_list>(<argument><expr><name>port</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>thisport</name> = ""</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>thisport</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>":%u"</expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <expr_stmt><expr><name>thisurl</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>ENVVAR_SCRIPT_URL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set the variable */</comment>
    <expr_stmt><expr><name>var</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>ap_http_scheme</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"://"</expr></argument>, <argument><expr><name>thisserver</name></expr></argument>, <argument><expr><name>thisport</name></expr></argument>,
                      <argument><expr><name>thisurl</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr><name>ENVVAR_SCRIPT_URI</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!(<name>saved_rulestatus</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>,<argument><expr>"mod_rewrite_rewritten"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="block">/* if filename was not initially set,
         * we start with the requested URI
         */</comment>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>filename</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name>NULL</name>, "init rewrite engine with requested uri %s",
                        <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name>NULL</name>, "init rewrite engine with passed filename "
                        "%s. Original uri = %s", <name><name>r</name>-&gt;<name>filename</name></name>, <name><name>r</name>-&gt;<name>uri</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/*
         *  now apply the rules ...
         */</comment>
        <expr_stmt><expr><name>rulestatus</name> = <call><name>apply_rewrite_list</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>rewriterules</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"mod_rewrite_rewritten"</expr></argument>,
                       <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,<argument><expr>"%d"</expr></argument>,<argument><expr><name>rulestatus</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name>NULL</name>, "uri already rewritten. Status %s, Uri %s, "
                    "r-&gt;filename %s", <name>saved_rulestatus</name>, <name><name>r</name>-&gt;<name>uri</name></name>, <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>rulestatus</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>saved_rulestatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>rulestatus</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>skip</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>flen</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ACTION_STATUS</name> == <name>rulestatus</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>r</name>-&gt;<name>status</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_OK</name></expr>;</expr_stmt>
            <return>return <expr><name>n</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>flen</name> = <name><name>r</name>-&gt;<name>filename</name></name> ? <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>flen</name> &gt; 6 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"proxy:"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* it should be go on as an internal proxy request */</comment>

            <comment type="block">/* check if the proxy module is enabled, so
             * we can actually use it!
             */</comment>
            <if>if <condition>(<expr>!<name>proxy_available</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00669</expr></argument>)</argument_list></call>
                              "attempt to make remote request from mod_rewrite "
                              "without proxy enabled: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>rulestatus</name> == <name>ACTION_NOESCAPE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"proxy-nocanon"</expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* make sure the QUERY_STRING and
             * PATH_INFO parts get incorporated
             */</comment>
            <if>if <condition>(<expr><name><name>r</name>-&gt;<name>path_info</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                                          <argument><expr><name><name>r</name>-&gt;<name>path_info</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr>(<name><name>r</name>-&gt;<name>args</name></name> != <name>NULL</name>)
                &amp;&amp; ((<name><name>r</name>-&gt;<name>proxyreq</name></name> == <name>PROXYREQ_PROXY</name>)
                    || (<name>rulestatus</name> == <name>ACTION_NOESCAPE</name>))</expr>)</condition><then> <block>{
                <comment type="block">/* see proxy_http:proxy_http_canon() */</comment>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                                          <argument><expr>"?"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* now make sure the request gets handled by the proxy handler */</comment>
            <if>if <condition>(<expr><name>PROXYREQ_NONE</name> == <name><name>r</name>-&gt;<name>proxyreq</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>proxyreq</name></name> = <name>PROXYREQ_REVERSE</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>handler</name></name>  = "proxy-server"</expr>;</expr_stmt>

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "go-ahead with proxy request %s [OK]",
                        <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>OK</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>(<name>skip</name> = <call><name>is_absolute_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

            <comment type="block">/* it was finally rewritten to a remote URL */</comment>

            <if>if <condition>(<expr><name>rulestatus</name> != <name>ACTION_NOESCAPE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "escaping %s for redirect",
                            <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>escape_absolute_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* append the QUERY_STRING part */</comment>
            <if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>escaped_args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>noescape</name> <init>= <expr>(<name>rulestatus</name> == <name>ACTION_NOESCAPE</name> ||
                                (<name>oargs</name> &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>oargs</name></expr></argument>)</argument_list></call>))</expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"?"</expr></argument>,
                                          <argument><expr><name>noescape</name>
                                            ? <name><name>r</name>-&gt;<name>args</name></name>
                                            : (<name>escaped_args</name> =
                                               <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call>)</expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "%s %s to query string for redirect %s",
                            <name>noescape</name> ? "copying" : "escaping",
                            <name><name>r</name>-&gt;<name>args</name></name> ,
                            <name>noescape</name> ? "" : <name>escaped_args</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* determine HTTP redirect response code */</comment>
            <if>if <condition>(<expr><call><name>ap_is_HTTP_REDIRECT</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>n</name> = <name><name>r</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_OK</name></expr>;</expr_stmt> <comment type="block">/* make Apache kernel happy */</comment>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>n</name> = <name>HTTP_MOVED_TEMPORARILY</name></expr>;</expr_stmt>
            }</block></else></if>

            <comment type="block">/* now do the redirection */</comment>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Location"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "redirect to %s [REDIRECT/%d]", <name><name>r</name>-&gt;<name>filename</name></name>,
                        <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>n</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>flen</name> &gt; 12 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"passthrough:"</expr></argument>, <argument><expr>12</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <comment type="block">/*
             * Hack because of underpowered API: passing the current
             * rewritten filename through to other URL-to-filename handlers
             * just as it were the requested URL. This is to enable
             * post-processing by mod_alias, etc.  which always act on
             * r-&gt;uri! The difference here is: We do not try to
             * add the document root
             */</comment>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>uri</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name>+12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>DECLINED</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* it was finally rewritten to a local path */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri_reduced</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* expand "/~user" prefix */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_USER</name></expr></cpp:if>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>expand_tildepaths</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name>NULL</name>, "local path result: %s", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* the filename must be either an absolute local path or an
             * absolute local URL.
             */</comment>
            <if>if <condition>(   <expr>*<name><name>r</name>-&gt;<name>filename</name></name> != '/'
                &amp;&amp; !<call><name>ap_os_is_path_absolute</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* if there is no valid prefix, we call
             * the translator from the core and
             * prefix the filename with document_root
             *
             * NOTICE:
             * We cannot leave out the prefix_stat because
             * - when we always prefix with document_root
             *   then no absolute path can be created, e.g. via
             *   emulating a ScriptAlias directive, etc.
             * - when we always NOT prefix with document_root
             *   then the files under document_root have to
             *   be references directly and document_root
             *   gets never used and will be a dummy parameter -
             *   this is also bad
             *
             * BUT:
             * Under real Unix systems this is no problem,
             * because we only do stat() on the first directory
             * and this gets cached by the kernel for along time!
             */</comment>

            <if>if<condition>(<expr>!(<name><name>conf</name>-&gt;<name>options</name></name> &amp; <name>OPTION_LEGACY_PREFIX_DOCROOT</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>uri_reduced</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"mod_rewrite_uri_reduced"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr>!<call><name>prefix_stat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> || <name>uri_reduced</name> != <name>NULL</name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name> <init>= <expr><name><name>r</name>-&gt;<name>uri</name></name></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>r</name>-&gt;<name>uri</name></name> = <name><name>r</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>res</name> = <call><name>ap_core_translate</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>uri</name></name> = <name>tmp</name></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>res</name> != <name>OK</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "prefixing with document_root of %s"
                                " FAILED", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <return>return <expr><name>res</name></expr>;</return>
                }</block></then></if>

                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name>NULL</name>, "prefixed with document_root to %s",
                            <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "go-ahead with %s [OK]", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>OK</name></expr>;</return>
        }</block></else></if></else></if></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "pass through %s", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * Fixup hook
 * [RewriteRules in directory context]
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hook_fixup</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>rewrite_perdir_conf</name> *</type><name>dconf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>cp2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ccp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rulestatus</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>ofilename</name></decl>, *<decl><type ref="prev"/><name>oargs</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_proxyreq</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>skipdata</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dconf</name> = (<name>rewrite_perdir_conf</name> *)<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                                        <argument><expr>&amp;<name>rewrite_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* if there is no per-dir config we return immediately */</comment>
    <if>if <condition>(<expr><name>dconf</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * only do something under runtime if the engine is really enabled,
     * for this directory, else return immediately!
     */</comment>
    <if>if <condition>(<expr><name><name>dconf</name>-&gt;<name>state</name></name> == <name>ENGINE_DISABLED</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* if there are no real (i.e. no RewriteRule directives!)
       per-dir config of us, we return also immediately */</comment>
    <if>if <condition>(<expr><name><name>dconf</name>-&gt;<name>directory</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Proxy request?
     */</comment>
    <expr_stmt><expr><name>is_proxyreq</name> = (   <name><name>r</name>-&gt;<name>proxyreq</name></name> &amp;&amp; <name><name>r</name>-&gt;<name>filename</name></name>
                   &amp;&amp; !<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"proxy:"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

    <comment type="block">/*
     *  .htaccess file is called before really entering the directory, i.e.:
     *  URL: http://localhost/foo  and .htaccess is located in foo directory
     *  Ignore such attempts, allowing mod_dir to direct the client to the
     *  canonical URL. This can be controlled with the AllowNoSlash option.
     */</comment>
    <if>if <condition>(<expr>!<name>is_proxyreq</name> &amp;&amp; !(<name><name>dconf</name>-&gt;<name>options</name></name> &amp; <name>OPTION_NOSLASH</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>l</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>dconf</name>-&gt;<name>directory</name></name></expr></argument>)</argument_list></call> - 1</expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>filename</name></name> &amp;&amp; <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call> == <name>l</name> &amp;&amp;
            (<name><name>dconf</name>-&gt;<name>directory</name></name>)<index>[<expr><name>l</name></expr>]</index> == '/' &amp;&amp;
            !<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>dconf</name>-&gt;<name>directory</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>DECLINED</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* END flag was used as a RewriteRule flag on this request */</comment>
    <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>skipdata</name></expr></argument>, <argument><expr><name>really_last_key</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>skipdata</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 8, <name><name>dconf</name>-&gt;<name>directory</name></name>, "Declining, no further rewriting due to END flag")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     *  Do the Options check after engine check, so
     *  the user is able to explicitly turn RewriteEngine Off.
     */</comment>
    <if>if <condition>(<expr>!(<call><name>ap_allow_options</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp; (<name>OPT_SYM_LINKS</name> | <name>OPT_SYM_OWNER</name>))</expr>)</condition><then> <block>{
        <comment type="block">/* FollowSymLinks is mandatory! */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00670</expr></argument>)</argument_list></call>
                     "Options FollowSymLinks and SymLinksIfOwnerMatch are both off, "
                     "so the RewriteRule directive is also forbidden "
                     "due to its similar ability to circumvent directory restrictions : "
                     "%s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     *  remember the current filename before rewriting for later check
     *  to prevent deadlooping because of internal redirects
     *  on final URL/filename which can be equal to the initial one.
     *  also, we'll restore original r-&gt;filename if we decline this
     *  request
     */</comment>
    <expr_stmt><expr><name>ofilename</name> = <name><name>r</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>oargs</name> = <name><name>r</name>-&gt;<name>args</name></name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>filename</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>dconf</name>-&gt;<name>directory</name></name>, "init rewrite engine with"
                   " requested uri %s", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     *  now apply the rules ...
     */</comment>
    <expr_stmt><expr><name>rulestatus</name> = <call><name>apply_rewrite_list</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>dconf</name>-&gt;<name>rewriterules</name></name></expr></argument>, <argument><expr><name><name>dconf</name>-&gt;<name>directory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rulestatus</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>unsigned</name></type> <name>skip</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ACTION_STATUS</name> == <name>rulestatus</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>r</name>-&gt;<name>status</name></name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_OK</name></expr>;</expr_stmt>
            <return>return <expr><name>n</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>l</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>l</name> &gt; 6 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"proxy:"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* it should go on as an internal proxy request */</comment>

            <comment type="block">/* make sure the QUERY_STRING and
             * PATH_INFO parts get incorporated
             * (r-&gt;path_info was already appended by the
             * rewriting engine because of the per-dir context!)
             */</comment>
            <if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
                <comment type="block">/* see proxy_http:proxy_http_canon() */</comment>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                                          <argument><expr>"?"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* now make sure the request gets handled by the proxy handler */</comment>
            <if>if <condition>(<expr><name>PROXYREQ_NONE</name> == <name><name>r</name>-&gt;<name>proxyreq</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>proxyreq</name></name> = <name>PROXYREQ_REVERSE</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>handler</name></name>  = "proxy-server"</expr>;</expr_stmt>

            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>dconf</name>-&gt;<name>directory</name></name>, "go-ahead with proxy request "
                        "%s [OK]", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>OK</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr>(<name>skip</name> = <call><name>is_absolute_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition><then> <block>{
            <comment type="block">/* it was finally rewritten to a remote URL */</comment>

            <comment type="block">/* because we are in a per-dir context
             * first try to replace the directory with its base-URL
             * if there is a base-URL available
             */</comment>
            <if>if <condition>(<expr><name><name>dconf</name>-&gt;<name>baseurl</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
                <comment type="block">/* skip 'scheme://' */</comment>
                <expr_stmt><expr><name>cp</name> = <name><name>r</name>-&gt;<name>filename</name></name> + <name>skip</name></expr>;</expr_stmt>

                <if>if <condition>(<expr>(<name>cp</name> = <call><name>ap_strchr</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp; *(++<name>cp</name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>dconf</name>-&gt;<name>directory</name></name>,
                                "trying to replace prefix %s with %s",
                                <name><name>dconf</name>-&gt;<name>directory</name></name>, <name><name>dconf</name>-&gt;<name>baseurl</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <comment type="block">/* I think, that hack needs an explanation:
                     * well, here is it:
                     * mod_rewrite was written for unix systems, were
                     * absolute file-system paths start with a slash.
                     * URL-paths _also_ start with slashes, so they
                     * can be easily compared with system paths.
                     *
                     * the following assumes, that the actual url-path
                     * may be prefixed by the current directory path and
                     * tries to replace the system path with the RewriteBase
                     * URL.
                     * That assumption is true if we use a RewriteRule like
                     *
                     * RewriteRule ^foo bar [R]
                     *
                     * (see apply_rewrite_rule function)
                     * However on systems that don't have a / as system
                     * root this will never match, so we skip the / after the
                     * hostname and compare/substitute only the stuff after it.
                     *
                     * (note that cp was already increased to the right value)
                     */</comment>
                    <expr_stmt><expr><name>cp2</name> = <call><name>subst_prefix_path</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr>(*<name><name>dconf</name>-&gt;<name>directory</name></name> == '/')
                                                   ? <name><name>dconf</name>-&gt;<name>directory</name></name> + 1
                                                   : <name><name>dconf</name>-&gt;<name>directory</name></name></expr></argument>,
                                            <argument><expr><name><name>dconf</name>-&gt;<name>baseurl</name></name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr>*<name>cp</name> = '\0'</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                                                  <argument><expr><name>cp2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></then></if>

            <comment type="block">/* now prepare the redirect... */</comment>
            <if>if <condition>(<expr><name>rulestatus</name> != <name>ACTION_NOESCAPE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>dconf</name>-&gt;<name>directory</name></name>, "escaping %s for redirect",
                            <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>escape_absolute_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* append the QUERY_STRING part */</comment>
            <if>if <condition>(<expr><name><name>r</name>-&gt;<name>args</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>escaped_args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>noescape</name> <init>= <expr>(<name>rulestatus</name> == <name>ACTION_NOESCAPE</name> ||
                                (<name>oargs</name> &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>oargs</name></expr></argument>)</argument_list></call>))</expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"?"</expr></argument>,
                                          <argument><expr><name>noescape</name>
                                            ? <name><name>r</name>-&gt;<name>args</name></name>
                                            : (<name>escaped_args</name> = <call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call>)</expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>dconf</name>-&gt;<name>directory</name></name>, "%s %s to query string for redirect %s",
                            <name>noescape</name> ? "copying" : "escaping",
                            <name><name>r</name>-&gt;<name>args</name></name> ,
                            <name>noescape</name> ? "" : <name>escaped_args</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* determine HTTP redirect response code */</comment>
            <if>if <condition>(<expr><call><name>ap_is_HTTP_REDIRECT</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>n</name> = <name><name>r</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_OK</name></expr>;</expr_stmt> <comment type="block">/* make Apache kernel happy */</comment>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>n</name> = <name>HTTP_MOVED_TEMPORARILY</name></expr>;</expr_stmt>
            }</block></else></if>

            <comment type="block">/* now do the redirection */</comment>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Location"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>dconf</name>-&gt;<name>directory</name></name>, "redirect to %s [REDIRECT/%d]",
                        <name><name>r</name>-&gt;<name>filename</name></name>, <name>n</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>n</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmpfilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
            <comment type="block">/* it was finally rewritten to a local path */</comment>

            <comment type="block">/* if someone used the PASSTHROUGH flag in per-dir
             * context we just ignore it. It is only useful
             * in per-server context
             */</comment>
            <if>if <condition>(<expr><name>l</name> &gt; 12 &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"passthrough:"</expr></argument>, <argument><expr>12</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name>+12</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* the filename must be either an absolute local path or an
             * absolute local URL.
             */</comment>
            <if>if <condition>(   <expr>*<name><name>r</name>-&gt;<name>filename</name></name> != '/'
                &amp;&amp; !<call><name>ap_os_is_path_absolute</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Check for deadlooping:
             * At this point we KNOW that at least one rewriting
             * rule was applied, but when the resulting URL is
             * the same as the initial URL, we are not allowed to
             * use the following internal redirection stuff because
             * this would lead to a deadloop.
             */</comment>
            <if>if <condition>(<expr><name>ofilename</name> != <name>NULL</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>ofilename</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>dconf</name>-&gt;<name>directory</name></name>, "initial URL equal rewritten"
                            " URL: %s [IGNORING REWRITE]", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>OK</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>tmpfilename</name> = <name><name>r</name>-&gt;<name>filename</name></name></expr>;</expr_stmt>

            <comment type="block">/* if there is a valid base-URL then substitute
             * the per-dir prefix with this base-URL if the
             * current filename still is inside this per-dir
             * context. If not then treat the result as a
             * plain URL
             */</comment>
            <if>if <condition>(<expr><name><name>dconf</name>-&gt;<name>baseurl</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>dconf</name>-&gt;<name>directory</name></name>, "trying to replace prefix "
                            "%s with %s", <name><name>dconf</name>-&gt;<name>directory</name></name>, <name><name>dconf</name>-&gt;<name>baseurl</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>subst_prefix_path</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                                                <argument><expr><name><name>dconf</name>-&gt;<name>directory</name></name></expr></argument>,
                                                <argument><expr><name><name>dconf</name>-&gt;<name>baseurl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* if no explicit base-URL exists we assume
                 * that the directory prefix is also a valid URL
                 * for this webserver and only try to remove the
                 * document_root if it is prefix
                 */</comment>
                <if>if <condition>(<expr>(<name>ccp</name> = <call><name>ap_document_root</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
                    <comment type="block">/* strip trailing slash */</comment>
                    <expr_stmt><expr><name>l</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>ccp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>ccp</name><index>[<expr><name>l</name>-1</expr>]</index></name> == '/'</expr>)</condition><then> <block>{
                        <expr_stmt><expr>--<name>l</name></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>ccp</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call> &amp;&amp;
                        <name><name>r</name>-&gt;<name>filename</name><index>[<expr><name>l</name></expr>]</index></name> == '/'</expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2,<name><name>dconf</name>-&gt;<name>directory</name></name>, "strip document_root"
                                    " prefix: %s -&gt; %s", <name><name>r</name>-&gt;<name>filename</name></name>,
                                    <name><name>r</name>-&gt;<name>filename</name></name>+<name>l</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name>+<name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></else></if>

            <comment type="block">/* No base URL, or r-&gt;filename wasn't still under dconf-&gt;directory
             * or, r-&gt;filename wasn't still under the document root. 
             * If there's a context document root AND a context prefix, and 
             * the context document root is a prefix of r-&gt;filename, replace.
             * This allows a relative substitution on a path found by mod_userdir 
             * or mod_alias without baking in a RewriteBase.
             */</comment>
            <if>if <condition>(<expr><name>tmpfilename</name> == <name><name>r</name>-&gt;<name>filename</name></name> &amp;&amp; 
                !(<name><name>dconf</name>-&gt;<name>options</name></name> &amp; <name>OPTION_IGNORE_CONTEXT_INFO</name>)</expr>)</condition><then> <block>{ 
                <if>if <condition>(<expr>(<name>ccp</name> = <call><name>ap_context_document_root</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{ 
                    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name> <init>= <expr><call><name>ap_context_prefix</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                    <if>if <condition>(<expr><name>prefix</name> != <name>NULL</name></expr>)</condition><then> <block>{ 
                        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 2, <name><name>dconf</name>-&gt;<name>directory</name></name>, "trying to replace "
                                    "context docroot %s with context prefix %s",
                                    <name>ccp</name>, <name>prefix</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>subst_prefix_path</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                                <argument><expr><name>ccp</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></then></if>

            <comment type="block">/* now initiate the internal redirect */</comment>
            <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>dconf</name>-&gt;<name>directory</name></name>, "internal redirect with %s "
                        "[INTERNAL REDIRECT]", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"redirect:"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>handler</name></name> = <name>REWRITE_REDIRECT_HANDLER_NAME</name></expr>;</expr_stmt>
            <return>return <expr><name>OK</name></expr>;</return>
        }</block></else></if></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name><name>dconf</name>-&gt;<name>directory</name></name>, "pass through %s", <name><name>r</name>-&gt;<name>filename</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>filename</name></name> = <name>ofilename</name></expr>;</expr_stmt>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></else></if>
}</block></function>

<comment type="block">/*
 * MIME-type hook
 * [T=...,H=...] execution
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>hook_mimetype</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t</name></decl>;</decl_stmt>

    <comment type="block">/* type */</comment>
    <expr_stmt><expr><name>t</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>REWRITE_FORCED_MIMETYPE_NOTEVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>t</name> &amp;&amp; *<name>t</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "force filename %s to have MIME-type '%s'",
                    <name><name>r</name>-&gt;<name>filename</name></name>, <name>t</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* handler */</comment>
    <expr_stmt><expr><name>t</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr><name>REWRITE_FORCED_HANDLER_NOTEVAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>t</name> &amp;&amp; *<name>t</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>rewritelog</name><argument_list>(<argument><expr>(<name>r</name>, 1, <name>NULL</name>, "force filename %s to have the "
                    "Content-handler '%s'", <name><name>r</name>-&gt;<name>filename</name></name>, <name>t</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>r</name>-&gt;<name>handler</name></name> = <name>t</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * "content" handler for internal redirects
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>handler_redirect</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>handler</name></name></expr></argument>, <argument><expr><name>REWRITE_REDIRECT_HANDLER_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* just make sure that we are really meant! */</comment>
    <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"redirect:"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* now do the internal redirect */</comment>
    <expr_stmt><expr><call><name>ap_internal_redirect</name><argument_list>(<argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>filename</name></name>+9</expr></argument>,
                                     <argument><expr><name><name>r</name>-&gt;<name>args</name></name> ? "?" : <name>NULL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* and return gracefully */</comment>
    <return>return <expr><name>OK</name></expr>;</return>
}</block></function>


<comment type="block">/*
 * +-------------------------------------------------------+
 * |                                                       |
 * |                Module paraphernalia
 * |                                                       |
 * +-------------------------------------------------------+
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>command_table</name><index>[]</index></name> <init>= <expr><block>{
    <expr><call><name>AP_INIT_FLAG</name><argument_list>(    <argument><expr>"RewriteEngine"</expr></argument>,   <argument><expr><name>cmd_rewriteengine</name></expr></argument>,  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"On or Off to enable or disable (default) the whole "
                     "rewriting engine"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_ITERATE</name><argument_list>( <argument><expr>"RewriteOptions"</expr></argument>,  <argument><expr><name>cmd_rewriteoptions</name></expr></argument>,  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"List of option strings to set"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_TAKE1</name><argument_list>(   <argument><expr>"RewriteBase"</expr></argument>,     <argument><expr><name>cmd_rewritebase</name></expr></argument>,     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"the base URL of the per-directory context"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_RAW_ARGS</name><argument_list>(<argument><expr>"RewriteCond"</expr></argument>,     <argument><expr><name>cmd_rewritecond</name></expr></argument>,     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"an input string and a to be applied regexp-pattern"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_RAW_ARGS</name><argument_list>(<argument><expr>"RewriteRule"</expr></argument>,     <argument><expr><name>cmd_rewriterule</name></expr></argument>,     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                     <argument><expr>"an URL-applied regexp-pattern and a substitution URL"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_TAKE23</name><argument_list>(   <argument><expr>"RewriteMap"</expr></argument>,      <argument><expr><name>cmd_rewritemap</name></expr></argument>,      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RSRC_CONF</name></expr></argument>,
                     <argument><expr>"a mapname and a filename and options"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ap_register_rewrite_mapfunc</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>rewrite_mapfunc_t</name> *</type><name>func</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>mapfunc_hash</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>(const <name>void</name> *)<name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* fixup after mod_proxy, so that the proxied url will not
     * escaped accidentally by mod_proxy's fixup.
     */</comment>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>aszPre</name><index>[]</index></name><init>=<expr><block>{ <expr>"mod_proxy.c"</expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

    <comment type="block">/* make the hashtable before registering the function, so that
     * other modules are prevented from accessing uninitialized memory.
     */</comment>
    <expr_stmt><expr><name>mapfunc_hash</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_REGISTER_OPTIONAL_FN</name><argument_list>(<argument><expr><name>ap_register_rewrite_mapfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_hook_handler</name><argument_list>(<argument><expr><name>handler_redirect</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_pre_config</name><argument_list>(<argument><expr><name>pre_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_post_config</name><argument_list>(<argument><expr><name>post_config</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_child_init</name><argument_list>(<argument><expr><name>init_child</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_hook_fixups</name><argument_list>(<argument><expr><name>hook_fixup</name></expr></argument>, <argument><expr><name>aszPre</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_fixups</name><argument_list>(<argument><expr><name>hook_mimetype</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_translate_name</name><argument_list>(<argument><expr><name>hook_uri2file</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_FIRST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

    <comment type="block">/* the main config structure */</comment>
<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>rewrite</name></expr></argument>)</argument_list></call> = <block>{
   <expr><name>STANDARD20_MODULE_STUFF</name></expr>,
   <expr><name>config_perdir_create</name></expr>,        <comment type="block">/* create per-dir    config structures */</comment>
   <expr><name>config_perdir_merge</name></expr>,         <comment type="block">/* merge  per-dir    config structures */</comment>
   <expr><name>config_server_create</name></expr>,        <comment type="block">/* create per-server config structures */</comment>
   <expr><name>config_server_merge</name></expr>,         <comment type="block">/* merge  per-server config structures */</comment>
   <expr><name>command_table</name></expr>,               <comment type="block">/* table of config file commands       */</comment>
   <expr><name>register_hooks</name></expr>               <comment type="block">/* register hooks                      */</comment>
}</block></expr>;</expr_stmt>

<comment type="block">/*EOF*/</comment>
</unit>
