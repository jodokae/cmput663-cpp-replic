<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/ssl/ssl_engine_io.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*                      _             _
 *  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
 * | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
 * | | | | | | (_) | (_| |   \__ \__ \ |
 * |_| |_| |_|\___/ \__,_|___|___/___/_|
 *                      |_____|
 *  ssl_engine_io.c
 *  I/O Functions
 */</comment>
                             <comment type="block">/* ``MY HACK: This universe.
                                  Just one little problem:
                                  core keeps dumping.''
                                            -- Unknown    */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ssl_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_ssl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_ssl_openssl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_date.h"</cpp:file></cpp:include>

<expr_stmt><expr><call><name>APR_IMPLEMENT_OPTIONAL_HOOK_RUN_ALL</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>SSL</name></expr></argument>, <argument><expr><name>int</name></expr></argument>, <argument><expr><name>proxy_post_handshake</name></expr></argument>,
                                    <argument><expr>(<name>conn_rec</name> *<name>c</name>,<name>SSL</name> *<name>ssl</name>)</expr></argument>,
                                    <argument><expr>(<name>c</name>,<name>ssl</name>)</expr></argument>,<argument><expr><name>OK</name></expr></argument>,<argument><expr><name>DECLINED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*  _________________________________________________________________
**
**  I/O Hooks
**  _________________________________________________________________
*/</comment>

<comment type="block">/* This file is designed to be the bridge between OpenSSL and httpd.
 * However, we really don't expect anyone (let alone ourselves) to
 * remember what is in this file.  So, first, a quick overview.
 *
 * In this file, you will find:
 * - ssl_io_filter_input    (Apache input filter)
 * - ssl_io_filter_output   (Apache output filter)
 *
 * - bio_filter_in_*        (OpenSSL input filter)
 * - bio_filter_out_*       (OpenSSL output filter)
 *
 * The input chain is roughly:
 *
 * ssl_io_filter_input-&gt;ssl_io_input_read-&gt;SSL_read-&gt;...
 * ...-&gt;bio_filter_in_read-&gt;ap_get_brigade/next-httpd-filter
 *
 * In mortal terminology, we do the following:
 * - Receive a request for data to the SSL input filter
 * - Call a helper function once we know we should perform a read
 * - Call OpenSSL's SSL_read()
 * - SSL_read() will then call bio_filter_in_read
 * - bio_filter_in_read will then try to fetch data from the next httpd filter
 * - bio_filter_in_read will flatten that data and return it to SSL_read
 * - SSL_read will then decrypt the data
 * - ssl_io_input_read will then receive decrypted data as a char* and
 *   ensure that there were no read errors
 * - The char* is placed in a brigade and returned
 *
 * Since connection-level input filters in httpd need to be able to
 * handle AP_MODE_GETLINE calls (namely identifying LF-terminated strings),
 * ssl_io_input_getline which will handle this special case.
 *
 * Due to AP_MODE_GETLINE and AP_MODE_SPECULATIVE, we may sometimes have
 * 'leftover' decoded data which must be setaside for the next read.  That
 * is currently handled by the char_buffer_{read|write} functions.  So,
 * ssl_io_input_read may be able to fulfill reads without invoking
 * SSL_read().
 *
 * Note that the filter context of ssl_io_filter_input and bio_filter_in_*
 * are shared as bio_filter_in_ctx_t.
 *
 * Note that the filter is by choice limited to reading at most
 * AP_IOBUFSIZE (8192 bytes) per call.
 *
 */</comment>

<comment type="block">/* this custom BIO allows us to hook SSL_write directly into
 * an apr_bucket_brigade and use transient buckets with the SSL
 * malloc-ed buffer, rather than copying into a mem BIO.
 * also allows us to pass the brigade as data is being written
 * rather than buffering up the entire response in the mem BIO.
 *
 * when SSL needs to flush (e.g. SSL_accept()), it will call BIO_flush()
 * which will trigger a call to bio_filter_out_ctrl() -&gt; bio_filter_out_flush().
 * so we only need to flush the output ourselves if we receive an
 * EOS or FLUSH bucket. this was not possible with the mem BIO where we
 * had to flush all over the place not really knowing when it was required
 * to do so.
 */</comment>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>SSL</name>                *</type><name>pssl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name>                *</type><name>pbioRead</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name>                *</type><name>pbioWrite</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_filter_t</name>        *</type><name>pInputFilter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_filter_t</name>        *</type><name>pOutputFilter</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name>         *</type><name>config</name></decl>;</decl_stmt>
}</block></struct></type> <name>ssl_filter_ctx_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>    <comment type="block">/* Brigade used as a buffer. */</comment>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>
}</block></struct></type> <name>bio_filter_out_ctx_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>bio_filter_out_ctx_t</name> *</type><name>bio_filter_out_ctx_new</name><parameter_list>(<param><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name></decl></param>,
                                                    <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bio_filter_out_ctx_t</name> *</type><name>outctx</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>outctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>outctx</name>-&gt;<name>filter_ctx</name></name> = <name>filter_ctx</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>outctx</name>-&gt;<name>c</name></name> = <name>c</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>outctx</name>-&gt;<name>bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>outctx</name></expr>;</return>
}</block></function>

<comment type="block">/* Pass an output brigade down the filter stack; returns 1 on success
 * or -1 on failure. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_out_pass</name><parameter_list>(<param><decl><type><name>bio_filter_out_ctx_t</name> *</type><name>outctx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>outctx</name>-&gt;<name>rc</name></name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pOutputFilter</name>-&gt;<name>next</name></name></expr></argument>,
                                 <argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* Fail if the connection was reset: */</comment>
    <if>if <condition>(<expr><name><name>outctx</name>-&gt;<name>rc</name></name> == <name>APR_SUCCESS</name> &amp;&amp; <name><name>outctx</name>-&gt;<name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>outctx</name>-&gt;<name>rc</name></name> = <name>APR_ECONNRESET</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>(<name><name>outctx</name>-&gt;<name>rc</name></name> == <name>APR_SUCCESS</name>) ? 1 : -1</expr>;</return>
}</block></function>

<comment type="block">/* Send a FLUSH bucket down the output filter stack; returns 1 on
 * success, -1 on failure. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_out_flush</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bio_filter_out_ctx_t</name> *</type><name>outctx</name> <init>= <expr>(<name>bio_filter_out_ctx_t</name> *)<call><name>BIO_get_data</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>bio_filter_out_pass</name><argument_list>(<argument><expr><name>outctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_create</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>BIO_set_shutdown</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_set_init</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MODSSL_USE_OPENSSL_PRE_1_1_API</name></expr></cpp:if>
    <comment type="block">/* No setter method for OpenSSL 1.1.0 available,
     * but I can't find any functional use of the
     * "num" field there either.
     */</comment>
    <expr_stmt><expr><name><name>bio</name>-&gt;<name>num</name></name> = -1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>BIO_set_data</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_destroy</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>bio</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <comment type="block">/* nothing to free here.
     * apache will destroy the bucket brigade for us
     */</comment>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_out_read</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><name>char</name> *</type><name>out</name></decl></param>, <param><decl><type><name>int</name></type> <name>outl</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* this is never called */</comment>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_out_write</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bio_filter_out_ctx_t</name> *</type><name>outctx</name> <init>= <expr>(<name>bio_filter_out_ctx_t</name> *)<call><name>BIO_get_data</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>need_flush</name></decl>;</decl_stmt>

    <comment type="block">/* Abort early if the client has initiated a renegotiation. */</comment>
    <if>if <condition>(<expr><name><name>outctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>config</name>-&gt;<name>reneg_state</name></name> == <name>RENEG_ABORT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>outctx</name>-&gt;<name>rc</name></name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* when handshaking we'll have a small number of bytes.
     * max size SSL will pass us here is about 16k.
     * (16413 bytes to be exact)
     */</comment>
    <expr_stmt><expr><call><name>BIO_clear_retry_flags</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Use a transient bucket for the output data - any downstream
     * filter must setaside if necessary. */</comment>
    <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_transient_create</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name>inl</name></expr></argument>, <argument><expr><name><name>outctx</name>-&gt;<name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* In theory, OpenSSL should flush as necessary, but it is known
     * not to do so correctly in some cases (&lt; 0.9.8m; see PR 46952),
     * or on the proxy/client side (after ssl23_client_hello(), e.g.
     * ssl/proxy.t test suite).
     *
     * Historically, this flush call was performed only for an SSLv2
     * connection or for a proxy connection.  Calling _out_flush can
     * be expensive in cases where requests/responses are pipelined,
     * so limit the performance impact to handshake time.
     */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPENSSL_VERSION_NUMBER</name> &lt; 0x0009080df</expr></cpp:if>
     <expr_stmt><expr><name>need_flush</name> = !<call><name>SSL_is_init_finished</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
     <expr_stmt><expr><name>need_flush</name> = <call><name>SSL_in_connect_init</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if <condition>(<expr><name>need_flush</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>bio_filter_out_pass</name><argument_list>(<argument><expr><name>outctx</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <return>return <expr><name>inl</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type> <name>bio_filter_out_ctrl</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><name>int</name></type> <name>cmd</name></decl></param>, <param><decl><type><name>long</name></type> <name>num</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>long</name></type> <name>ret</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bio_filter_out_ctx_t</name> *</type><name>outctx</name> <init>= <expr>(<name>bio_filter_out_ctx_t</name> *)<call><name>BIO_get_data</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>cmd</name></expr>)</condition> <block>{
    <case>case <expr><name>BIO_CTRL_RESET</name></expr>:
    </case><case>case <expr><name>BIO_CTRL_EOF</name></expr>:
    </case><case>case <expr><name>BIO_C_SET_BUF_MEM_EOF_RETURN</name></expr>:
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>outctx</name>-&gt;<name>c</name></name></expr></argument>,
                      <argument><expr>"output bio: unhandled control %d"</expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>BIO_CTRL_WPENDING</name></expr>:
    </case><case>case <expr><name>BIO_CTRL_PENDING</name></expr>:
    </case><case>case <expr><name>BIO_CTRL_INFO</name></expr>:
        <expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>BIO_CTRL_GET_CLOSE</name></expr>:
        <expr_stmt><expr><name>ret</name> = (<name>long</name>)<call><name>BIO_get_shutdown</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>BIO_CTRL_SET_CLOSE</name></expr>:
        <expr_stmt><expr><call><name>BIO_set_shutdown</name><argument_list>(<argument><expr><name>bio</name></expr></argument>, <argument><expr>(<name>int</name>)<name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>BIO_CTRL_FLUSH</name></expr>:
        <expr_stmt><expr><name>ret</name> = <call><name>bio_filter_out_flush</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>BIO_CTRL_DUP</name></expr>:
        <expr_stmt><expr><name>ret</name> = 1</expr>;</expr_stmt>
        <break>break;</break>
        <comment type="block">/* N/A */</comment>
      </case><case>case <expr><name>BIO_C_SET_BUF_MEM</name></expr>:
      </case><case>case <expr><name>BIO_C_GET_BUF_MEM_PTR</name></expr>:
        <comment type="block">/* we don't care */</comment>
      </case><case>case <expr><name>BIO_CTRL_PUSH</name></expr>:
      </case><case>case <expr><name>BIO_CTRL_POP</name></expr>:
      </case><default>default:
        <expr_stmt><expr><name>ret</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch>

    <return>return <expr><name>ret</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_out_gets</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* this is never called */</comment>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_out_puts</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* this is never called */</comment>
    <return>return <expr>-1</expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>char_buffer_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BIO</name> *</type><name>bio_out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char_buffer_t</name></type> <name>cbuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>AP_IOBUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>bio_filter_in_ctx_t</name>;</typedef>

<comment type="block">/*
 * this char_buffer api might seem silly, but we don't need to copy
 * any of this data and we need to remember the length.
 */</comment>

<comment type="block">/* Copy up to INL bytes from the char_buffer BUFFER into IN.  Note
 * that due to the strange way this API is designed/used, the
 * char_buffer object is used to cache a segment of inctx-&gt;buffer, and
 * then this function called to copy (part of) that segment to the
 * beginning of inctx-&gt;buffer.  So the segments to copy cannot be
 * presumed to be non-overlapping, and memmove must be used. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>char_buffer_read</name><parameter_list>(<param><decl><type><name>char_buffer_t</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>char</name> *</type><name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inl</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr>!<name><name>buffer</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>buffer</name>-&gt;<name>length</name></name> &gt; <name>inl</name></expr>)</condition><then> <block>{
        <comment type="block">/* we have enough to fill the caller's buffer */</comment>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name><name>buffer</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>inl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buffer</name>-&gt;<name>value</name></name> += <name>inl</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buffer</name>-&gt;<name>length</name></name> -= <name>inl</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* swallow remainder of the buffer */</comment>
        <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><name><name>buffer</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name><name>buffer</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inl</name> = <name><name>buffer</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buffer</name>-&gt;<name>value</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>buffer</name>-&gt;<name>length</name></name> = 0</expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>inl</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>char_buffer_write</name><parameter_list>(<param><decl><type><name>char_buffer_t</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>char</name> *</type><name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inl</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>buffer</name>-&gt;<name>value</name></name> = <name>in</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name>-&gt;<name>length</name></name> = <name>inl</name></expr>;</expr_stmt>
    <return>return <expr><name>inl</name></expr>;</return>
}</block></function>

<comment type="block">/* This function will read from a brigade and discard the read buckets as it
 * proceeds.  It will read at most *len bytes.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>brigade_consume</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                    <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                    <param><decl><type><name>char</name> *</type><name>c</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>actual</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>str_len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>consume</name></decl>;</decl_stmt>

        <comment type="block">/* Justin points out this is an http-ism that might
         * not fit if brigade_consume is added to APR.  Perhaps
         * apr_bucket_read(eos_bucket) should return APR_EOF?
         * Then this becomes mainline instead of a one-off.
         */</comment>
        <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>status</name> = <name>APR_EOF</name></expr>;</expr_stmt>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* The reason I'm not offering brigade_consume yet
         * across to apr-util is that the following call
         * illustrates how borked that API really is.  For
         * this sort of case (caller provided buffer) it
         * would be much more trivial for apr_bucket_consume
         * to do all the work that follows, based on the
         * particular characteristics of the bucket we are
         * consuming here.
         */</comment>
        <expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>str_len</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* This stream bucket was consumed */</comment>
                <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <break>break;</break>
        }</block></then></if>

        <if>if <condition>(<expr><name>str_len</name> &gt; 0</expr>)</condition><then> <block>{
            <comment type="block">/* Do not block once some data has been consumed */</comment>
            <expr_stmt><expr><name>block</name> = <name>APR_NONBLOCK_READ</name></expr>;</expr_stmt>

            <comment type="block">/* Assure we don't overflow. */</comment>
            <expr_stmt><expr><name>consume</name> = (<name>str_len</name> + <name>actual</name> &gt; *<name>len</name>) ? *<name>len</name> - <name>actual</name> : <name>str_len</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>consume</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>c</name> += <name>consume</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>actual</name> += <name>consume</name></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>consume</name> &gt;= <name><name>b</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* This physical bucket was consumed */</comment>
                <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* Only part of this physical bucket was consumed */</comment>
                <expr_stmt><expr><name><name>b</name>-&gt;<name>start</name></name> += <name>consume</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>b</name>-&gt;<name>length</name></name> -= <name>consume</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <comment type="block">/* This could probably be actual == *len, but be safe from stray
         * photons. */</comment>
        <if>if <condition>(<expr><name>actual</name> &gt;= *<name>len</name></expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
    }</block></while>

    <expr_stmt><expr>*<name>len</name> = <name>actual</name></expr>;</expr_stmt>
    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * this is the function called by SSL_read()
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_in_read</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><name>char</name> *</type><name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inlen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>inl</name> <init>= <expr><name>inlen</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name> <init>= <expr>(<name>bio_filter_in_ctx_t</name> *)<call><name>BIO_get_data</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_read_type_e</name></type> <name>block</name> <init>= <expr><name><name>inctx</name>-&gt;<name>block</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>

    <comment type="block">/* OpenSSL catches this case, so should we. */</comment>
    <if>if <condition>(<expr>!<name>in</name></expr>)</condition><then>
        <return>return <expr>0</expr>;</return></then></if>

    <comment type="block">/* Abort early if the client has initiated a renegotiation. */</comment>
    <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>config</name>-&gt;<name>reneg_state</name></name> == <name>RENEG_ABORT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_ECONNABORTED</name></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>BIO_clear_retry_flags</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>inctx</name>-&gt;<name>bb</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_EOF</name></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

        <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name><name>inctx</name>-&gt;<name>bb</name></name></expr></argument>,
                                   <argument><expr><name>AP_MODE_READBYTES</name></expr></argument>, <argument><expr><name>block</name></expr></argument>,
                                   <argument><expr><name>inl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If the read returns EAGAIN or success with an empty
         * brigade, return an error after setting the retry flag;
         * SSL_read() will then return -1, and SSL_get_error() will
         * indicate SSL_ERROR_WANT_READ. */</comment>
        <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call> || <call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call>
               || (<name><name>inctx</name>-&gt;<name>rc</name></name> == <name>APR_SUCCESS</name> &amp;&amp; <call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>BIO_set_retry_read</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>block</name> == <name>APR_BLOCK_READ</name> 
            &amp;&amp; <call><name>APR_STATUS_IS_TIMEUP</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call>
            &amp;&amp; <call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* don't give up, just return the timeout */</comment>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>rc</name></name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="block">/* Unexpected errors discard the brigade */</comment>
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>inctx</name>-&gt;<name>bb</name></name> = <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <call><name>brigade_consume</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr>&amp;<name>inl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>rc</name></name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr>(<name>int</name>)<name>inl</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call>
            || <call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>BIO_set_retry_read</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>(<name>int</name>)<name>inl</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Unexpected errors and APR_EOF clean out the brigade.
     * Subsequent calls will return APR_EOF.
     */</comment>
    <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>bb</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call> &amp;&amp; <name>inl</name></expr>)</condition><then> <block>{
        <comment type="block">/* Provide the results of this read pass,
         * without resetting the BIO retry_read flag
         */</comment>
        <return>return <expr>(<name>int</name>)<name>inl</name></expr>;</return>
    }</block></then></if>

    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_in_write</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>in</name></decl></param>, <param><decl><type><name>int</name></type> <name>inl</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_in_puts</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bio_filter_in_gets</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>-1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>long</name></type> <name>bio_filter_in_ctrl</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><name>int</name></type> <name>cmd</name></decl></param>, <param><decl><type><name>long</name></type> <name>num</name></decl></param>, <param><decl><type><name>void</name> *</type><name>ptr</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr>-1</expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MODSSL_USE_OPENSSL_PRE_1_1_API</name></expr></cpp:if>
        
<decl_stmt><decl><type><specifier>static</specifier> <name>BIO_METHOD</name></type> <name>bio_filter_out_method</name> <init>= <expr><block>{
    <expr><name>BIO_TYPE_MEM</name></expr>,
    <expr>"APR output filter"</expr>,
    <expr><name>bio_filter_out_write</name></expr>,
    <expr><name>bio_filter_out_read</name></expr>,     <comment type="block">/* read is never called */</comment>
    <expr><name>bio_filter_out_puts</name></expr>,     <comment type="block">/* puts is never called */</comment>
    <expr><name>bio_filter_out_gets</name></expr>,     <comment type="block">/* gets is never called */</comment>
    <expr><name>bio_filter_out_ctrl</name></expr>,
    <expr><name>bio_filter_create</name></expr>,
    <expr><name>bio_filter_destroy</name></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>BIO_METHOD</name></type> <name>bio_filter_in_method</name> <init>= <expr><block>{
    <expr><name>BIO_TYPE_MEM</name></expr>,
    <expr>"APR input filter"</expr>,
    <expr><name>bio_filter_in_write</name></expr>,        <comment type="block">/* write is never called */</comment>
    <expr><name>bio_filter_in_read</name></expr>,
    <expr><name>bio_filter_in_puts</name></expr>,         <comment type="block">/* puts is never called */</comment>
    <expr><name>bio_filter_in_gets</name></expr>,         <comment type="block">/* gets is never called */</comment>
    <expr><name>bio_filter_in_ctrl</name></expr>,         <comment type="block">/* ctrl is never called */</comment>
    <expr><name>bio_filter_create</name></expr>,
    <expr><name>bio_filter_destroy</name></expr>,
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>static</specifier> <name>BIO_METHOD</name> *</type><name>bio_filter_out_method</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>BIO_METHOD</name> *</type><name>bio_filter_in_method</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>init_bio_methods</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name>bio_filter_out_method</name> = <call><name>BIO_meth_new</name><argument_list>(<argument><expr><name>BIO_TYPE_MEM</name></expr></argument>, <argument><expr>"APR output filter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_meth_set_write</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_out_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_meth_set_read</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_out_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* read is never called */</comment>
    <expr_stmt><expr><call><name>BIO_meth_set_puts</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_out_puts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* puts is never called */</comment>
    <expr_stmt><expr><call><name>BIO_meth_set_gets</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_out_gets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* gets is never called */</comment>
    <expr_stmt><expr><call><name>BIO_meth_set_ctrl</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_out_ctrl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_meth_set_create</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_meth_set_destroy</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bio_filter_in_method</name> = <call><name>BIO_meth_new</name><argument_list>(<argument><expr><name>BIO_TYPE_MEM</name></expr></argument>, <argument><expr>"APR input filter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_meth_set_write</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_in_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* write is never called */</comment>
    <expr_stmt><expr><call><name>BIO_meth_set_read</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_in_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_meth_set_puts</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_in_puts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* puts is never called */</comment>
    <expr_stmt><expr><call><name>BIO_meth_set_gets</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_in_gets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* gets is never called */</comment>
    <expr_stmt><expr><call><name>BIO_meth_set_ctrl</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_in_ctrl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* ctrl is never called */</comment>
    <expr_stmt><expr><call><name>BIO_meth_set_create</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_meth_set_destroy</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>, <argument><expr>&amp;<name>bio_filter_destroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>free_bio_methods</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>BIO_meth_free</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>BIO_meth_free</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_input_read</name><parameter_list>(<param><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name></decl></param>,
                                      <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
                                      <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>wanted</name> <init>= <expr>*<name>len</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>len</name> = 0</expr>;</expr_stmt>

    <comment type="block">/* If we have something leftover from last time, try that first. */</comment>
    <if>if <condition>(<expr>(<name>bytes</name> = <call><name>char_buffer_read</name><argument_list>(<argument><expr>&amp;<name><name>inctx</name>-&gt;<name>cbuf</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>wanted</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>len</name> = <name>bytes</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>mode</name></name> == <name>AP_MODE_SPECULATIVE</name></expr>)</condition><then> <block>{
            <comment type="block">/* We want to rollback this read. */</comment>
            <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>value</name></name> -= <name>bytes</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>length</name></name> += <name>bytes</name></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>char_buffer_write</name><argument_list>(<argument><expr>&amp;<name><name>inctx</name>-&gt;<name>cbuf</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>(<name>int</name>)<name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* This could probably be *len == wanted, but be safe from stray
         * photons.
         */</comment>
        <if>if <condition>(<expr>*<name>len</name> &gt;= <name>wanted</name></expr>)</condition><then> <block>{
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>mode</name></name> == <name>AP_MODE_GETLINE</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>APR_ASCII_LF</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Down to a nonblock pattern as we have some data already
             */</comment>
            <expr_stmt><expr><name><name>inctx</name>-&gt;<name>block</name></name> = <name>APR_NONBLOCK_READ</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <while>while <condition>(<expr>1</expr>)</condition> <block>{

        <if>if <condition>(<expr>!<name><name>inctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pssl</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* Ensure a non-zero error code is returned */</comment>
            <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>rc</name></name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_EGENERAL</name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
        }</block></then></if>

        <comment type="block">/* We rely on SSL_get_error() after the read, which requires an empty
         * error queue before the read in order to work properly.
         */</comment>
        <expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* SSL_read may not read because we haven't taken enough data
         * from the stack.  This is where we want to consider all of
         * the blocking and SPECULATIVE semantics
         */</comment>
        <expr_stmt><expr><name>rc</name> = <call><name>SSL_read</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>, <argument><expr><name>buf</name> + <name>bytes</name></expr></argument>, <argument><expr><name>wanted</name> - <name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rc</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>len</name> += <name>rc</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>mode</name></name> == <name>AP_MODE_SPECULATIVE</name></expr>)</condition><then> <block>{
                <comment type="block">/* We want to rollback this read. */</comment>
                <expr_stmt><expr><call><name>char_buffer_write</name><argument_list>(<argument><expr>&amp;<name><name>inctx</name>-&gt;<name>cbuf</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>rc</name> == 0</expr>)</condition><then> <block>{
            <comment type="block">/* If EAGAIN, we will loop given a blocking read,
             * otherwise consider ourselves at EOF.
             */</comment>
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call>
                    || <call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* Already read something, return APR_SUCCESS instead.
                 * On win32 in particular, but perhaps on other kernels,
                 * a blocking call isn't 'always' blocking.
                 */</comment>
                <if>if <condition>(<expr>*<name>len</name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>block</name></name> == <name>APR_NONBLOCK_READ</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
            }</block></then>
            <else>else <block>{
                <if>if <condition>(<expr>*<name>len</name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_EOF</name></expr>;</expr_stmt>
                }</block></else></if>
                <break>break;</break>
            }</block></else></if>
        }</block></then>
        <else>else <comment type="block">/* (rc &lt; 0) */</comment> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>ssl_err</name> <init>= <expr><call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr>(<name>conn_rec</name>*)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>ssl_err</name> == <name>SSL_ERROR_WANT_READ</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * If OpenSSL wants to read more, and we were nonblocking,
                 * report as an EAGAIN.  Otherwise loop, pulling more
                 * data from network filter.
                 *
                 * (This is usually the case when the client forces an SSL
                 * renegotiation which is handled implicitly by OpenSSL.)
                 */</comment>
                <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>

                <if>if <condition>(<expr>*<name>len</name> &gt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>block</name></name> == <name>APR_NONBLOCK_READ</name></expr>)</condition><then> <block>{
                    <break>break;</break>
                }</block></then></if>
                <continue>continue;</continue>  <comment type="block">/* Blocking and nothing yet?  Try again. */</comment>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>ssl_err</name> == <name>SSL_ERROR_SYSCALL</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call>
                        || <call><name>APR_STATUS_IS_EINTR</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="block">/* Already read something, return APR_SUCCESS instead. */</comment>
                    <if>if <condition>(<expr>*<name>len</name> &gt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
                        <break>break;</break>
                    }</block></then></if>
                    <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>block</name></name> == <name>APR_NONBLOCK_READ</name></expr>)</condition><then> <block>{
                        <break>break;</break>
                    }</block></then></if>
                    <continue>continue;</continue>  <comment type="block">/* Blocking and nothing yet?  Try again. */</comment>
                }</block></then>
                <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_TIMEUP</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="block">/* just return it, the calling layer might be fine with it,
                       and we do not want to bloat the log. */</comment>
                }</block></then>
                <else>else <block>{
                    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01991</expr></argument>)</argument_list></call>
                                  "SSL input filter read failed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if></else></if>
            }</block></then>
            <else>else <comment type="block">/* if (ssl_err == SSL_ERROR_SSL) */</comment> <block>{
                <comment type="block">/*
                 * Log SSL errors and any unexpected conditions.
                 */</comment>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01992</expr></argument>)</argument_list></call>
                              "SSL library error %d reading data"</expr></argument>, <argument><expr><name>ssl_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            }</block></else></if></else></if>
            <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>rc</name></name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_EGENERAL</name></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
        }</block></else></if></else></if>
    }</block></while>
    <return>return <expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr>;</return>
}</block></function>

<comment type="block">/* Read a line of input from the SSL input layer into buffer BUF of
 * length *LEN; updating *len to reflect the length of the line
 * including the LF character. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_input_getline</name><parameter_list>(<param><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name></decl></param>,
                                         <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
                                         <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>tmplen</name> <init>= <expr>*<name>len</name></expr></init>, <name>buflen</name> <init>= <expr>*<name>len</name></expr></init>, <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>len</name> = 0</expr>;</expr_stmt>

    <comment type="block">/*
     * in most cases we get all the headers on the first SSL_read.
     * however, in certain cases SSL_read will only get a partial
     * chunk of the headers, so we try to read until LF is seen.
     */</comment>

    <while>while <condition>(<expr><name>tmplen</name> &gt; 0</expr>)</condition> <block>{
        <expr_stmt><expr><name>status</name> = <call><name>ssl_io_input_read</name><argument_list>(<argument><expr><name>inctx</name></expr></argument>, <argument><expr><name>buf</name> + <name>offset</name></expr></argument>, <argument><expr>&amp;<name>tmplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> &amp;&amp; (*<name>len</name> &gt; 0)</expr>)</condition><then> <block>{
                <comment type="block">/* Save the part of the line we already got */</comment>
                <expr_stmt><expr><call><name>char_buffer_write</name><argument_list>(<argument><expr>&amp;<name><name>inctx</name>-&gt;<name>cbuf</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>status</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr>*<name>len</name> += <name>tmplen</name></expr>;</expr_stmt>

        <if>if <condition>(<expr>(<name>pos</name> = <call><name>memchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>APR_ASCII_LF</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>

        <expr_stmt><expr><name>offset</name> += <name>tmplen</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmplen</name> = <name>buflen</name> - <name>offset</name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr><name>pos</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>length</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes</name> <init>= <expr><name>pos</name> - <name>buf</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>bytes</name> += 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>value</name> = <name>buf</name> + <name>bytes</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>length</name> = *<name>len</name> - <name>bytes</name></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>char_buffer_write</name><argument_list>(<argument><expr>&amp;<name><name>inctx</name>-&gt;<name>cbuf</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr>*<name>len</name> = <name>bytes</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_filter_write</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                                     <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bio_filter_out_ctx_t</name> *</type><name>outctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

    <comment type="block">/* write SSL */</comment>
    <if>if <condition>(<expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* We rely on SSL_get_error() after the write, which requires an empty error
     * queue before the write in order to work properly.
     */</comment>
    <expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>outctx</name> = (<name>bio_filter_out_ctx_t</name> *)<call><name>BIO_get_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> = <call><name>SSL_write</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>ssl_err</name> <init>= <expr><call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr>(<name>conn_rec</name>*)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>ssl_err</name> == <name>SSL_ERROR_WANT_WRITE</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If OpenSSL wants to write more, and we were nonblocking,
             * report as an EAGAIN.  Otherwise loop, pushing more
             * data at the network filter.
             *
             * (This is usually the case when the client forces an SSL
             * renegotiation which is handled implicitly by OpenSSL.)
             */</comment>
            <expr_stmt><expr><name><name>outctx</name>-&gt;<name>rc</name></name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>ssl_err</name> == <name>SSL_ERROR_WANT_READ</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * If OpenSSL wants to read during write, and we were
             * nonblocking, set the sense explicitly to read and
             * report as an EAGAIN.
             *
             * (This is usually the case when the client forces an SSL
             * renegotiation which is handled implicitly by OpenSSL.)
             */</comment>
            <expr_stmt><expr><name><name>outctx</name>-&gt;<name>c</name>-&gt;<name>cs</name>-&gt;<name>sense</name></name> = <name>CONN_SENSE_WANT_READ</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>outctx</name>-&gt;<name>rc</name></name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>ssl_err</name> == <name>SSL_ERROR_SYSCALL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name><name>outctx</name>-&gt;<name>rc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01993</expr></argument>)</argument_list></call>
                          "SSL output filter write failed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <comment type="block">/* if (ssl_err == SSL_ERROR_SSL) */</comment> <block>{
            <comment type="block">/*
             * Log SSL errors
             */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name><name>outctx</name>-&gt;<name>rc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01994</expr></argument>)</argument_list></call>
                          "SSL library error %d writing data"</expr></argument>, <argument><expr><name>ssl_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>
        <if>if <condition>(<expr><name><name>outctx</name>-&gt;<name>rc</name></name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>outctx</name>-&gt;<name>rc</name></name> = <name>APR_EGENERAL</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <if>if <condition>(<expr>(<name>apr_size_t</name>)<name>res</name> != <name>len</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>f</name>-&gt;<name>c</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>reason</name> <init>= <expr>"reason unknown"</expr></init></decl>;</decl_stmt>

        <comment type="block">/* XXX: probably a better way to determine this */</comment>
        <if>if <condition>(<expr><call><name>SSL_total_renegotiations</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>reason</name> = "likely due to failed renegotiation"</expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name><name>outctx</name>-&gt;<name>rc</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01995</expr></argument>)</argument_list></call>
                      "failed to write %" <name>APR_SSIZE_T_FMT</name>
                      " of %" <name>APR_SIZE_T_FMT</name> " bytes (%s)"</expr></argument>,
                      <argument><expr><name>len</name> - (<name>apr_size_t</name>)<name>res</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>outctx</name>-&gt;<name>rc</name></name> = <name>APR_EGENERAL</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
    <return>return <expr><name><name>outctx</name>-&gt;<name>rc</name></name></expr>;</return>
}</block></function>

<comment type="block">/* Just use a simple request.  Any request will work for this, because
 * we use a flag in the conn_rec-&gt;conn_vector now.  The fake request just
 * gets the request back to the Apache core so that a response can be sent.
 * Since we use an HTTP/1.x request, we also have to inject the empty line
 * that terminates the headers, or the core will read more data from the
 * socket.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_ON_HTTPS_PORT</name></cpp:macro> \
    <cpp:value>"GET / HTTP/1.0" CRLF</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HTTP_ON_HTTPS_PORT_BUCKET</name><parameter_list>(<param><type><name>alloc</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>apr_bucket_immortal_create(HTTP_ON_HTTPS_PORT, \
                               sizeof(HTTP_ON_HTTPS_PORT) - 1, \
                               alloc)</cpp:value></cpp:define>

<comment type="block">/* Custom apr_status_t error code, used when a plain HTTP request is
 * recevied on an SSL port. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODSSL_ERROR_HTTP_ON_HTTPS</name></cpp:macro> <cpp:value>(APR_OS_START_USERERR + 0)</cpp:value></cpp:define>

<comment type="block">/* Custom apr_status_t error code, used when the proxy cannot
 * establish an outgoing SSL connection. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODSSL_ERROR_BAD_GATEWAY</name></cpp:macro> <cpp:value>(APR_OS_START_USERERR + 1)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ssl_io_filter_disable</name><parameter_list>(<param><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name></decl></param>,
                                  <param><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>ssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>ssl</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>ssl</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>filter_ctx</name>-&gt;<name>pssl</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_filter_error</name><parameter_list>(<param><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name></decl></param>,
                                        <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                        <param><decl><type><name>apr_status_t</name></type> <name>status</name></decl></param>,
                                        <param><decl><type><name>int</name></type> <name>is_init</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>f</name> <init>= <expr><name><name>inctx</name>-&gt;<name>f</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>send_eos</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

    <switch>switch <condition>(<expr><name>status</name></expr>)</condition> <block>{
    <case>case <expr><name>MODSSL_ERROR_HTTP_ON_HTTPS</name></expr>:
            <comment type="block">/* log the situation */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01996</expr></argument>)</argument_list></call>
                         "SSL handshake failed: HTTP spoken on HTTPS port; "
                         "trying to send HTML error page"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name><name>sslconn</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ssl_io_filter_disable</name><argument_list>(<argument><expr><name>sslconn</name></expr></argument>, <argument><expr><name>inctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>is_init</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>non_ssl_request</name></name> = <name>NON_SSL_SEND_REQLINE</name></expr>;</expr_stmt>
                <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>non_ssl_request</name></name> = <name>NON_SSL_SEND_HDR_SEP</name></expr>;</expr_stmt>

            <comment type="block">/* fake the request line */</comment>
            <expr_stmt><expr><name>bucket</name> = <call><name>HTTP_ON_HTTPS_PORT_BUCKET</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>send_eos</name> = 0</expr>;</expr_stmt>
            <break>break;</break>

    </case><case>case <expr><name>MODSSL_ERROR_BAD_GATEWAY</name></expr>:
        <expr_stmt><expr><name>bucket</name> = <call><name>ap_bucket_error_create</name><argument_list>(<argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>pool</name></name></expr></argument>,
                                        <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01997</expr></argument>)</argument_list></call>
                      "SSL handshake failed: sending 502"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>

    </case><default>default:
        <return>return <expr><name>status</name></expr>;</return>
    </default>}</block></switch>

    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>send_eos</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>bucket</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ssl_io_filter</name><index>[]</index></name> <init>= <expr>"SSL/TLS Filter"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ssl_io_buffer</name><index>[]</index></name> <init>= <expr>"SSL/TLS Buffer"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>ssl_io_coalesce</name><index>[]</index></name> <init>= <expr>"SSL/TLS Coalescing Filter"</expr></init></decl>;</decl_stmt>

<comment type="block">/*
 *  Close the SSL part of the socket connection
 *  (called immediately _before_ the socket is closed)
 *  or called with
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ssl_filter_io_shutdown</name><parameter_list>(<param><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name></decl></param>,
                                   <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><name>int</name></type> <name>abortive</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name> <init>= <expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>shutdown_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>loglevel</name> <init>= <expr><name>APLOG_DEBUG</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>logno</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>ssl</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/*
     * Now close the SSL layer of the connection. We've to take
     * the TLSv1 standard into account here:
     *
     * | 7.2.1. Closure alerts
     * |
     * | The client and the server must share knowledge that the connection is
     * | ending in order to avoid a truncation attack. Either party may
     * | initiate the exchange of closing messages.
     * |
     * | close_notify
     * |     This message notifies the recipient that the sender will not send
     * |     any more messages on this connection. The session becomes
     * |     unresumable if any connection is terminated without proper
     * |     close_notify messages with level equal to warning.
     * |
     * | Either party may initiate a close by sending a close_notify alert.
     * | Any data received after a closure alert is ignored.
     * |
     * | Each party is required to send a close_notify alert before closing
     * | the write side of the connection. It is required that the other party
     * | respond with a close_notify alert of its own and close down the
     * | connection immediately, discarding any pending writes. It is not
     * | required for the initiator of the close to wait for the responding
     * | close_notify alert before closing the read side of the connection.
     *
     * This means we've to send a close notify message, but haven't to wait
     * for the close notify of the client. Actually we cannot wait for the
     * close notify of the client because some clients (including Netscape
     * 4.x) don't send one, so we would hang.
     */</comment>

    <comment type="block">/*
     * exchange close notify messages, but allow the user
     * to force the type of handshake via SetEnvIf directive
     */</comment>
    <if>if <condition>(<expr><name>abortive</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>shutdown_type</name> = <name>SSL_SENT_SHUTDOWN</name>|<name>SSL_RECEIVED_SHUTDOWN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = "abortive"</expr>;</expr_stmt>
        <expr_stmt><expr><name>logno</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>01998</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>loglevel</name> = <name>APLOG_INFO</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <switch>switch <condition>(<expr><name><name>sslconn</name>-&gt;<name>shutdown_type</name></name></expr>)</condition> <block>{
      <case>case <expr><name>SSL_SHUTDOWN_TYPE_UNCLEAN</name></expr>:
        <comment type="block">/* perform no close notify handshake at all
           (violates the SSL/TLS standard!) */</comment>
        <expr_stmt><expr><name>shutdown_type</name> = <name>SSL_SENT_SHUTDOWN</name>|<name>SSL_RECEIVED_SHUTDOWN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = "unclean"</expr>;</expr_stmt>
        <expr_stmt><expr><name>logno</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>01999</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><case>case <expr><name>SSL_SHUTDOWN_TYPE_ACCURATE</name></expr>:
        <comment type="block">/* send close notify and wait for clients close notify
           (standard compliant, but usually causes connection hangs) */</comment>
        <expr_stmt><expr><name>shutdown_type</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = "accurate"</expr>;</expr_stmt>
        <expr_stmt><expr><name>logno</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      </case><default>default:
        <comment type="block">/*
         * case SSL_SHUTDOWN_TYPE_UNSET:
         * case SSL_SHUTDOWN_TYPE_STANDARD:
         */</comment>
        <comment type="block">/* send close notify, but don't wait for clients close notify
           (standard compliant and safe, so it's the DEFAULT!) */</comment>
        <expr_stmt><expr><name>shutdown_type</name> = <name>SSL_RECEIVED_SHUTDOWN</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>type</name> = "standard"</expr>;</expr_stmt>
        <expr_stmt><expr><name>logno</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02001</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </default>}</block></switch></else></if>

    <expr_stmt><expr><call><name>SSL_set_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>shutdown_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>modssl_smart_shutdown</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* and finally log the fact that we've closed the connection */</comment>
    <if>if <condition>(<expr><call><name>APLOG_CS_IS_LEVEL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>loglevel</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Intentional no APLOGNO */</comment>
        <comment type="block">/* logno provides APLOGNO */</comment>
        <expr_stmt><expr><call><name>ap_log_cserror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>loglevel</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr>"%sConnection closed to child %ld with %s shutdown "
                       "(server %s)"</expr></argument>,
                       <argument><expr><name>logno</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>,
                       <argument><expr><call><name>ssl_util_vhostid</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* deallocate the SSL connection */</comment>
    <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>ssl</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* so filters know we've been shutdown */</comment>

    <if>if <condition>(<expr><name>abortive</name></expr>)</condition><then> <block>{
        <comment type="block">/* prevent any further I/O */</comment>
        <expr_stmt><expr><name><name>c</name>-&gt;<name>aborted</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_filter_cleanup</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>ssl</name></name> = <name><name>filter_ctx</name>-&gt;<name>pssl</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * The hook is NOT registered with ap_hook_process_connection. Instead, it is
 * called manually from the churn () before it tries to read any data.
 * There is some problem if I accept conn_rec *. Still investigating..
 * Adv. if conn_rec * can be accepted is we can hook this function using the
 * ap_hook_process_connection hook.
 */</comment>

<comment type="block">/* Perform the SSL handshake (whether in client or server mode), if
 * necessary, for the given connection. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_filter_handshake</name><parameter_list>(<param><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name>         <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name> *</type><name>cert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ssl_err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>verify_result</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>server</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><call><name>SSL_is_init_finished</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>server</name> = <name><name>sslconn</name>-&gt;<name>server</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>is_proxy</name></name></expr>)</condition><then> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
        <decl_stmt><decl><type><name>apr_ipsubnet_t</name> *</type><name>ip</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLS_ALPN</name></cpp:ifdef>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>alpn_note</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hostname_note</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>notes</name></name></expr></argument>,
                                                  <argument><expr>"proxy-request-hostname"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>BOOL</name></type> <name>proxy_ssl_check_peer_ok</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>post_handshake_rc</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>sc</name> = <call><name>mySrvConfig</name><argument_list>(<argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLS_ALPN</name></cpp:ifdef>
        <expr_stmt><expr><name>alpn_note</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"proxy-request-alpn-protos"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>alpn_note</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>protos</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>, *<decl><type ref="prev"/><name>p</name></decl>, *<decl><type ref="prev"/><name>last</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>s</name> = <name>protos</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>alpn_note</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>p</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>alpn_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr>(<name>p</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>", "</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call>)</expr>)</condition> <block>{
                <expr_stmt><expr><name>len</name> = <name>last</name> - <name>p</name> - (*<name>last</name>? 1 : 0)</expr>;</expr_stmt> 
                <if>if <condition>(<expr><name>len</name> &gt; 255</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03309</expr></argument>)</argument_list></call>
                                  "ALPN proxy protocol identifier too long: %s"</expr></argument>,
                                  <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr>*<name>s</name>++ = (<name>unsigned</name> <name>char</name>)<name>len</name></expr>;</expr_stmt>
                <while>while <condition>(<expr><name>len</name>--</expr>)</condition> <block>{
                    <expr_stmt><expr>*<name>s</name>++ = *<name>p</name>++</expr>;</expr_stmt>
                }</block></while>
                <expr_stmt><expr><name>p</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, 
                          <argument><expr>"setting alpn protos from '%s', protolen=%d"</expr></argument>, 
                          <argument><expr><name>alpn_note</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>s</name> - <name>protos</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>protos</name> != <name>s</name> &amp;&amp; <call><name>SSL_set_alpn_protos</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>, 
                                                   <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>protos</name></expr></argument>, 
                                                   <argument><expr><name>s</name> - <name>protos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>03310</expr></argument>)</argument_list></call>
                              "error setting alpn protos from '%s'"</expr></argument>, <argument><expr><name>alpn_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined HAVE_TLS_ALPN */</comment>
        <comment type="block">/*
         * Enable SNI for backend requests. Make sure we don't do it for
         * pure SSLv3 connections, and also prevent IP addresses
         * from being included in the SNI extension. (OpenSSL would simply
         * pass them on, but RFC 6066 is quite clear on this: "Literal
         * IPv4 and IPv6 addresses are not permitted".)
         */</comment>
        <if>if <condition>(<expr><name>hostname_note</name> &amp;&amp;
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OPENSSL_NO_SSL3</name></cpp:ifndef>
            <name><name>sc</name>-&gt;<name>proxy</name>-&gt;<name>protocol</name></name> != <name>SSL_PROTOCOL_SSLV3</name> &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <call><name>apr_ipsubnet_create</name><argument_list>(<argument><expr>&amp;<name>ip</name></expr></argument>, <argument><expr><name>hostname_note</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>SSL_set_tlsext_host_name</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>, <argument><expr><name>hostname_note</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                              <argument><expr>"SNI extension for SSL Proxy request set to '%s'"</expr></argument>,
                              <argument><expr><name>hostname_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02002</expr></argument>)</argument_list></call>
                              "Failed to set SNI extension for SSL Proxy "
                              "request to '%s'"</expr></argument>, <argument><expr><name>hostname_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <if>if <condition>(<expr>(<name>n</name> = <call><name>SSL_connect</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call>) &lt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02003</expr></argument>)</argument_list></call>
                          "SSL Proxy connect failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* ensure that the SSL structures etc are freed, etc: */</comment>
            <expr_stmt><expr><call><name>ssl_filter_io_shutdown</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"SSL_connect_rv"</expr></argument>, <argument><expr>"err"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>MODSSL_ERROR_BAD_GATEWAY</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name>cert</name> = <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>sc</name>-&gt;<name>proxy_ssl_check_peer_expire</name></name> != <name>SSL_ENABLED_FALSE</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<name>cert</name>
                || (<call><name>X509_cmp_current_time</name><argument_list>(
                     <argument><expr><call><name>X509_get_notBefore</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt;= 0)
                || (<call><name>X509_cmp_current_time</name><argument_list>(
                     <argument><expr><call><name>X509_get_notAfter</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt;= 0)</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>proxy_ssl_check_peer_ok</name> = <name>FALSE</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02004</expr></argument>)</argument_list></call>
                              "SSL Proxy: Peer certificate is expired"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr>(<name><name>sc</name>-&gt;<name>proxy_ssl_check_peer_name</name></name> != <name>SSL_ENABLED_FALSE</name>) &amp;&amp;
            ((<name><name>sc</name>-&gt;<name>proxy_ssl_check_peer_cn</name></name> != <name>SSL_ENABLED_FALSE</name>) ||
             (<name><name>sc</name>-&gt;<name>proxy_ssl_check_peer_name</name></name> == <name>SSL_ENABLED_TRUE</name>)) &amp;&amp;
            <name>hostname_note</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"proxy-request-hostname"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>cert</name>
                || <call><name>modssl_X509_match_name</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>cert</name></expr></argument>, <argument><expr><name>hostname_note</name></expr></argument>,
                                          <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call> == <name>FALSE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>proxy_ssl_check_peer_ok</name> = <name>FALSE</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02411</expr></argument>)</argument_list></call>
                              "SSL Proxy: Peer certificate does not match "
                              "for hostname %s"</expr></argument>, <argument><expr><name>hostname_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>(<name><name>sc</name>-&gt;<name>proxy_ssl_check_peer_cn</name></name> == <name>SSL_ENABLED_TRUE</name>) &amp;&amp;
            <name>hostname_note</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hostname</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><name>hostname</name> = <call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>server</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                      <argument><expr>"SSL_CLIENT_S_DN_CN"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"proxy-request-hostname"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Do string match or simplest wildcard match if that
             * fails. */</comment>
            <expr_stmt><expr><name>match</name> = <call><name>strcasecmp</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>hostname_note</name></expr></argument>)</argument_list></call> == 0</expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>match</name> &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr>"*."</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>hostname_note</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                
                <expr_stmt><expr><name>match</name> = <name>p</name> &amp;&amp; <call><name>strcasecmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>hostname</name> + 1</expr></argument>)</argument_list></call> == 0</expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr>!<name>match</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>proxy_ssl_check_peer_ok</name> = <name>FALSE</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02005</expr></argument>)</argument_list></call>
                              "SSL Proxy: Peer certificate CN mismatch:"
                              " Certificate CN: %s Requested hostname: %s"</expr></argument>,
                              <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>hostname_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if></else></if>

        <if>if <condition>(<expr><name>proxy_ssl_check_peer_ok</name> == <name>TRUE</name></expr>)</condition><then> <block>{
            <comment type="block">/* another chance to fail */</comment>
            <expr_stmt><expr><name>post_handshake_rc</name> = <call><name>ssl_run_proxy_post_handshake</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>cert</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>proxy_ssl_check_peer_ok</name> != <name>TRUE</name>
            || (<name>post_handshake_rc</name> != <name>OK</name> &amp;&amp; <name>post_handshake_rc</name> != <name>DECLINED</name>)</expr>)</condition><then> <block>{
            <comment type="block">/* ensure that the SSL structures etc are freed, etc: */</comment>
            <expr_stmt><expr><call><name>ssl_filter_io_shutdown</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"SSL_connect_rv"</expr></argument>, <argument><expr>"err"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_BAD_GATEWAY</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"SSL_connect_rv"</expr></argument>, <argument><expr>"ok"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* We rely on SSL_get_error() after the accept, which requires an empty
     * error queue before the accept in order to work properly.
     */</comment>
    <expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>n</name> = <call><name>SSL_accept</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call>) &lt;= 0</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name> <init>= <expr>(<name>bio_filter_in_ctx_t</name> *)
                                     <call><name>BIO_get_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioRead</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bio_filter_out_ctx_t</name> *</type><name>outctx</name> <init>= <expr>(<name>bio_filter_out_ctx_t</name> *)
                                       <call><name>BIO_get_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rc</name> <init>= <expr><name><name>inctx</name>-&gt;<name>rc</name></name> ? <name><name>inctx</name>-&gt;<name>rc</name></name> : <name><name>outctx</name>-&gt;<name>rc</name></name></expr></init></decl> ;</decl_stmt>
        <expr_stmt><expr><name>ssl_err</name> = <call><name>SSL_get_error</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>ssl_err</name> == <name>SSL_ERROR_ZERO_RETURN</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * The case where the connection was closed before any data
             * was transferred. That's not a real error and can occur
             * sporadically with some clients.
             */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02006</expr></argument>)</argument_list></call>
                         "SSL handshake stopped: connection was closed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>ssl_err</name> == <name>SSL_ERROR_WANT_READ</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * This is in addition to what was present earlier. It is
             * borrowed from openssl_state_machine.c [mod_tls].
             * TBD.
             */</comment>
            <expr_stmt><expr><name><name>outctx</name>-&gt;<name>rc</name></name> = <name>APR_EAGAIN</name></expr>;</expr_stmt>
            <return>return <expr><name>APR_EAGAIN</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><call><name>ERR_GET_LIB</name><argument_list>(<argument><expr><call><name>ERR_peek_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == <name>ERR_LIB_SSL</name> &amp;&amp;
                 <call><name>ERR_GET_REASON</name><argument_list>(<argument><expr><call><name>ERR_peek_error</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> == <name>SSL_R_HTTP_REQUEST</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * The case where OpenSSL has recognized a HTTP request:
             * This means the client speaks plain HTTP on our HTTPS port.
             * ssl_io_filter_error will disable the ssl filters when it
             * sees this status code.
             */</comment>
            <return>return <expr><name>MODSSL_ERROR_HTTP_ON_HTTPS</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>ssl_err</name> == <name>SSL_ERROR_SYSCALL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02007</expr></argument>)</argument_list></call>
                          "SSL handshake interrupted by system "
                          "[Hint: Stop button pressed in browser?!]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <comment type="block">/* if (ssl_err == SSL_ERROR_SSL) */</comment> <block>{
            <comment type="block">/*
             * Log SSL errors and any unexpected conditions.
             */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02008</expr></argument>)</argument_list></call>
                          "SSL library error %d in handshake "
                          "(server %s)"</expr></argument>, <argument><expr><name>ssl_err</name></expr></argument>,
                          <argument><expr><call><name>ssl_util_vhostid</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></else></if></else></if></else></if></else></if>
        <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>rc</name></name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_EGENERAL</name></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>ssl_filter_io_shutdown</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name><name>inctx</name>-&gt;<name>rc</name></name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>sc</name> = <call><name>mySrvConfig</name><argument_list>(<argument><expr><name><name>sslconn</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for failed client authentication
     */</comment>
    <expr_stmt><expr><name>verify_result</name> = <call><name>SSL_get_verify_result</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>verify_result</name> != <name>X509_V_OK</name>) ||
        <name><name>sslconn</name>-&gt;<name>verify_error</name></name></expr>)</condition><then>
    <block>{
        <if>if <condition>(<expr><call><name>ssl_verify_error_is_optional</name><argument_list>(<argument><expr><name>verify_result</name></expr></argument>)</argument_list></call> &amp;&amp;
            (<name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_mode</name></name> == <name>SSL_CVERIFY_OPTIONAL_NO_CA</name>)</expr>)</condition><then>
        <block>{
            <comment type="block">/* leaving this log message as an error for the moment,
             * according to the mod_ssl docs:
             * "level optional_no_ca is actually against the idea
             *  of authentication (but can be used to establish
             * SSL test pages, etc.)"
             * optional_no_ca doesn't appear to work as advertised
             * in 1.x
             */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02009</expr></argument>)</argument_list></call>
                          "SSL client authentication failed, "
                          "accepting certificate based on "
                          "\"SSLVerifyClient optional_no_ca\" "
                          "configuration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error</name> <init>= <expr><name><name>sslconn</name>-&gt;<name>verify_error</name></name> ?
                <name><name>sslconn</name>-&gt;<name>verify_error</name></name> :
                <call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>verify_result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02010</expr></argument>)</argument_list></call>
                         "SSL client authentication failed: %s"</expr></argument>,
                         <argument><expr><name>error</name> ? <name>error</name> : "unknown"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ssl_filter_io_shutdown</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
        }</block></else></if>
    }</block></then></if>

    <comment type="block">/*
     * Remember the peer certificate's DN
     */</comment>
    <if>if <condition>(<expr>(<name>cert</name> = <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name> = <name>cert</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>client_dn</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Make really sure that when a peer certificate
     * is required we really got one... (be paranoid)
     */</comment>
    <if>if <condition>(<expr>(<name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_mode</name></name> == <name>SSL_CVERIFY_REQUIRE</name>) &amp;&amp;
        !<name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr>)</condition><then>
    <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02011</expr></argument>)</argument_list></call>
                      "No acceptable peer certificate available"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ssl_filter_io_shutdown</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_filter_input</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                        <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                        <param><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl></param>,
                                        <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                        <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name> <init>= <expr><name><name>inctx</name>-&gt;<name>buffer</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* start of block to return */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>buffer</name></name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt> <comment type="block">/* length of block to return */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>is_init</name> <init>= <expr>(<name>mode</name> == <name>AP_MODE_INIT</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* XXX: Ok, if we aborted, we ARE at the EOS.  We also have
         * aborted.  This 'double protection' is probably redundant,
         * but also effective against just about anything.
         */</comment>
        <expr_stmt><expr><name>bucket</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>inctx</name>-&gt;<name>ssl</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>non_ssl_request</name></name> == <name>NON_SSL_SEND_REQLINE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>bucket</name> = <call><name>HTTP_ON_HTTPS_PORT_BUCKET</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>mode</name> != <name>AP_MODE_SPECULATIVE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>non_ssl_request</name></name> = <name>NON_SSL_SEND_HDR_SEP</name></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>non_ssl_request</name></name> == <name>NON_SSL_SEND_HDR_SEP</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>bucket</name> = <call><name>apr_bucket_immortal_create</name><argument_list>(<argument><expr><name>CRLF</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>mode</name> != <name>AP_MODE_SPECULATIVE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>non_ssl_request</name></name> = <name>NON_SSL_SET_ERROR_MSG</name></expr>;</expr_stmt>
            }</block></then></if>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* XXX: we don't currently support anything other than these modes. */</comment>
    <if>if <condition>(<expr><name>mode</name> != <name>AP_MODE_READBYTES</name> &amp;&amp; <name>mode</name> != <name>AP_MODE_GETLINE</name> &amp;&amp;
        <name>mode</name> != <name>AP_MODE_SPECULATIVE</name> &amp;&amp; <name>mode</name> != <name>AP_MODE_INIT</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_ENOTIMPL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>mode</name></name> = <name>mode</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>block</name></name> = <name>block</name></expr>;</expr_stmt>

    <comment type="block">/* XXX: we could actually move ssl_io_filter_handshake to an
     * ap_hook_process_connection but would still need to call it for
     * AP_MODE_INIT for protocols that may upgrade the connection
     * rather than have SSLEngine On configured.
     */</comment>
    <if>if <condition>(<expr>(<name>status</name> = <call><name>ssl_io_filter_handshake</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>filter_ctx</name></name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>ssl_io_filter_error</name><argument_list>(<argument><expr><name>inctx</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>is_init</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>is_init</name></expr>)</condition><then> <block>{
        <comment type="block">/* protocol module needs to handshake before sending
         * data to client (e.g. NNTP or FTP)
         */</comment>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>mode</name></name> == <name>AP_MODE_READBYTES</name> ||
        <name><name>inctx</name>-&gt;<name>mode</name></name> == <name>AP_MODE_SPECULATIVE</name></expr>)</condition><then> <block>{
        <comment type="block">/* Protected from truncation, readbytes &lt; MAX_SIZE_T
         * FIXME: No, it's *not* protected.  -- jre */</comment>
        <if>if <condition>(<expr><name>readbytes</name> &lt; <name>len</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>len</name> = (<name>apr_size_t</name>)<name>readbytes</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>status</name> = <call><name>ssl_io_input_read</name><argument_list>(<argument><expr><name>inctx</name></expr></argument>, <argument><expr><name><name>inctx</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>mode</name></name> == <name>AP_MODE_GETLINE</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name></decl>;</decl_stmt>

        <comment type="block">/* Satisfy the read directly out of the buffer if possible;
         * invoking ssl_io_input_getline will mean the entire buffer
         * is copied once (unnecessarily) for each GETLINE call. */</comment>
        <if>if <condition>(<expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>length</name></name>
            &amp;&amp; (<name>pos</name> = <call><name>memchr</name><argument_list>(<argument><expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>value</name></name></expr></argument>, <argument><expr><name>APR_ASCII_LF</name></expr></argument>,
                             <argument><expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>length</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>start</name> = <name><name>inctx</name>-&gt;<name>cbuf</name>.<name>value</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>len</name> = 1 + <name>pos</name> - <name>start</name></expr>;</expr_stmt> <comment type="block">/* +1 to include LF */</comment>
            <comment type="block">/* Buffer contents now consumed. */</comment>
            <expr_stmt><expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>value</name></name> += <name>len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>length</name></name> -= <name>len</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Otherwise fall back to the hard way. */</comment>
            <expr_stmt><expr><name>status</name> = <call><name>ssl_io_input_getline</name><argument_list>(<argument><expr><name>inctx</name></expr></argument>, <argument><expr><name><name>inctx</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* We have no idea what you are talking about, so return an error. */</comment>
        <expr_stmt><expr><name>status</name> = <name>APR_ENOTIMPL</name></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <comment type="block">/* It is possible for mod_ssl's BIO to be used outside of the
     * direct control of mod_ssl's input or output filter -- notably,
     * when mod_ssl initiates a renegotiation.  Switching the BIO mode
     * back to "blocking" here ensures such operations don't fail with
     * SSL_ERROR_WANT_READ. */</comment>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>block</name></name> = <name>APR_BLOCK_READ</name></expr>;</expr_stmt>

    <comment type="block">/* Handle custom errors. */</comment>
    <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>ssl_io_filter_error</name><argument_list>(<argument><expr><name>inctx</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Create a transient bucket out of the decrypted data. */</comment>
    <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>bucket</name> =
            <call><name>apr_bucket_transient_create</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<comment type="block">/* ssl_io_filter_output() produces one SSL/TLS message per bucket
 * passed down the output filter stack.  This results in a high
 * overhead (network packets) for any output comprising many small
 * buckets.  SSI page applied through the HTTP chunk filter, for
 * example, may produce many brigades containing small buckets -
 * [chunk-size CRLF] [chunk-data] [CRLF].
 *
 * The coalescing filter merges many small buckets into larger buckets
 * where possible, allowing the SSL I/O output filter to handle them
 * more efficiently. */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COALESCE_BYTES</name></cpp:macro> <cpp:value>(2048)</cpp:value></cpp:define>

<struct>struct <name>coalesce_ctx</name> <block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>COALESCE_BYTES</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes</name></decl>;</decl_stmt> <comment type="block">/* number of bytes of buffer used. */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_filter_coalesce</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                           <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>, *<decl><type ref="prev"/><name>upto</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>coalesce_ctx</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <comment type="block">/* The brigade consists of zero-or-more small data buckets which
     * can be coalesced (the prefix), followed by the remainder of the
     * brigade.
     *
     * Find the last bucket - if any - of that prefix.  count gives
     * the number of buckets in the prefix.  The "prefix" must contain
     * only data buckets with known length, and must be of a total
     * size which fits into the buffer.
     *
     * N.B.: The process here could be repeated throughout the brigade
     * (coalesce any run of consecutive data buckets) but this would
     * add significant complexity, particularly to memory
     * management. */</comment>
    <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>
             &amp;&amp; !<call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call>
             &amp;&amp; <name><name>e</name>-&gt;<name>length</name></name> != (<name>apr_size_t</name>)-1
             &amp;&amp; <name><name>e</name>-&gt;<name>length</name></name> &lt; <name>COALESCE_BYTES</name>
             &amp;&amp; (<name>bytes</name> + <name><name>e</name>-&gt;<name>length</name></name>) &lt; <name>COALESCE_BYTES</name>
             &amp;&amp; (<name>ctx</name> == <name>NULL</name>
                 || <name>bytes</name> + <name><name>ctx</name>-&gt;<name>bytes</name></name> + <name><name>e</name>-&gt;<name>length</name></name> &lt; <name>COALESCE_BYTES</name>)</expr>;</condition>
         <incr><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
        <if>if <condition>(<expr><name><name>e</name>-&gt;<name>length</name></name></expr>)</condition><then> <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then></if> <comment type="block">/* don't count zero-length buckets */</comment>
        <expr_stmt><expr><name>bytes</name> += <name><name>e</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>upto</name> = <name>e</name></expr>;</expr_stmt>

    <comment type="block">/* Coalesce the prefix, if:
     * a) more than one bucket is found to coalesce, or
     * b) the brigade contains only a single data bucket, or
     * c) the data bucket is not last but we have buffered data already.
     */</comment>
    <if>if <condition>(<expr><name>bytes</name> &gt; 0
        &amp;&amp; (<name>count</name> &gt; 1
            || (<name>upto</name> == <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call>)
            || (<name>ctx</name> &amp;&amp; <name><name>ctx</name>-&gt;<name>bytes</name></name> &gt; 0))</expr>)</condition><then> <block>{
        <comment type="block">/* If coalescing some bytes, ensure a context has been
         * created. */</comment>
        <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>f</name>-&gt;<name>ctx</name></name> = <name>ctx</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>sizeof *<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>bytes</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                      <argument><expr>"coalesce: have %" <name>APR_SIZE_T_FMT</name> " bytes, "
                      "adding %" <name>APR_SIZE_T_FMT</name> " more"</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>bytes</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Iterate through the prefix segment.  For non-fatal errors
         * in this loop it is safe to break out and fall back to the
         * normal path of sending the buffer + remaining buckets in
         * brigade.  */</comment>
        <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <while>while <condition>(<expr><name>e</name> != <name>upto</name></expr>)</condition> <block>{
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>next</name></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call>
                || <name><name>e</name>-&gt;<name>length</name></name> == (<name>apr_size_t</name>)-1</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02012</expr></argument>)</argument_list></call>
                              "unexpected bucket type during coalesce"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break> <comment type="block">/* non-fatal error; break out */</comment>
            }</block></then></if>

            <if>if <condition>(<expr><name><name>e</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

                <comment type="block">/* A blocking read should be fine here for a
                 * known-length data bucket, rather than the usual
                 * non-block/flush/block.  */</comment>
                <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02013</expr></argument>)</argument_list></call>
                                  "coalesce failed to read from data bucket"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>AP_FILTER_ERROR</name></expr>;</return>
                }</block></then></if>

                <comment type="block">/* Be paranoid. */</comment>
                <if>if <condition>(<expr><name>len</name> &gt; sizeof <name><name>ctx</name>-&gt;<name>buffer</name></name>
                    || (<name>len</name> + <name><name>ctx</name>-&gt;<name>bytes</name></name> &gt; sizeof <name><name>ctx</name>-&gt;<name>buffer</name></name>)</expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02014</expr></argument>)</argument_list></call>
                                  "unexpected coalesced bucket data length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break> <comment type="block">/* non-fatal error; break out */</comment>
                }</block></then></if>

                <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>buffer</name></name> + <name><name>ctx</name>-&gt;<name>bytes</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>bytes</name></name> += <name>len</name></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>e</name> = <name>next</name></expr>;</expr_stmt>
        }</block></while>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* If the brigade is now empty, our work here is done. */</comment>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* If anything remains in the brigade, it must now be passed down
     * the filter stack, first prepending anything that has been
     * coalesced. */</comment>
    <if>if <condition>(<expr><name>ctx</name> &amp;&amp; <name><name>ctx</name>-&gt;<name>bytes</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                      <argument><expr>"coalesce: passing on %" <name>APR_SIZE_T_FMT</name> " bytes"</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_transient_create</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>bytes</name></name></expr></argument>, <argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_HEAD</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>bytes</name></name> = 0</expr>;</expr_stmt> <comment type="block">/* buffer now emptied. */</comment>
    }</block></then></if>

    <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_filter_output</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                         <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bio_filter_out_ctx_t</name> *</type><name>outctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_read_type_e</name></type> <name>rblock</name> <init>= <expr><name>APR_NONBLOCK_READ</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>filter_ctx</name>-&gt;<name>pssl</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* ssl_filter_io_shutdown was called */</comment>
        <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>inctx</name> = (<name>bio_filter_in_ctx_t</name> *)<call><name>BIO_get_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioRead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>outctx</name> = (<name>bio_filter_out_ctx_t</name> *)<call><name>BIO_get_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* When we are the writer, we must initialize the inctx
     * mode so that we block for any required ssl input, because
     * output filtering is always nonblocking.
     */</comment>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>mode</name></name> = <name>AP_MODE_READBYTES</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>block</name></name> = <name>APR_BLOCK_READ</name></expr>;</expr_stmt>

    <if>if <condition>(<expr>(<name>status</name> = <call><name>ssl_io_filter_handshake</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>ssl_io_filter_error</name><argument_list>(<argument><expr><name>inctx</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <while>while <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call> &amp;&amp; <name>status</name> == <name>APR_SUCCESS</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name> <init>= <expr><call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Pass through metadata buckets untouched.  EOC is
             * special; terminate the SSL layer first. */</comment>
            <if>if <condition>(<expr><call><name>AP_BUCKET_IS_EOC</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ssl_filter_io_shutdown</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Metadata buckets are passed one per brigade; it might
             * be more efficient (but also more complex) to use
             * outctx-&gt;bb as a true buffer and interleave these with
             * data buckets. */</comment>
            <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_HEAD</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>status</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>status</name> == <name>APR_SUCCESS</name> &amp;&amp; <name><name>f</name>-&gt;<name>c</name>-&gt;<name>aborted</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>status</name> = <name>APR_ECONNRESET</name></expr>;</expr_stmt></then></if>
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>outctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Filter a data bucket. */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>status</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>rblock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* No data available: flush... */</comment>
                <if>if <condition>(<expr><call><name>bio_filter_out_flush</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>status</name> = <name><name>outctx</name>-&gt;<name>rc</name></name></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then></if>
                <expr_stmt><expr><name>rblock</name> = <name>APR_BLOCK_READ</name></expr>;</expr_stmt>
                <comment type="block">/* and try again with a blocking read. */</comment>
                <expr_stmt><expr><name>status</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name>rblock</name> = <name>APR_NONBLOCK_READ</name></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>status</name> != <name>APR_SUCCESS</name>)</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>

            <expr_stmt><expr><name>status</name> = <call><name>ssl_filter_write</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

    }</block></while>

    <return>return <expr><name>status</name></expr>;</return>
}</block></function>

<struct>struct <name>modssl_buffer_ctx</name> <block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><name>int</name></type> <name>ssl_io_buffer_fill</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>maxlen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>modssl_buffer_ctx</name> *</type><name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tempb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>total</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* total length buffered */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>eos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="block">/* non-zero once EOS is seen */</comment>

    <comment type="block">/* Create the context which will be passed to the input filter;
     * containing a setaside pool and a brigade which constrain the
     * lifetime of the buffered data. */</comment>
    <expr_stmt><expr><name>ctx</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>sizeof *<name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* ... and a temporary brigade. */</comment>
    <expr_stmt><expr><name>tempb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr>"filling buffer, max size "
                  "%" <name>APR_SIZE_T_FMT</name> " bytes"</expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>;</decl_stmt>

        <comment type="block">/* The request body is read from the protocol-level input
         * filters; the buffering filter will reinject it from that
         * level, allowing content/resource filters to run later, if
         * necessary. */</comment>

        <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>proto_input_filters</name></name></expr></argument>, <argument><expr><name>tempb</name></expr></argument>, <argument><expr><name>AP_MODE_READBYTES</name></expr></argument>,
                            <argument><expr><name>APR_BLOCK_READ</name></expr></argument>, <argument><expr>8192</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02015</expr></argument>)</argument_list></call>
                          "could not read request body for SSL buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ap_map_http_request_error</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Iterate through the returned brigade: setaside each bucket
         * into the context's pool and move it into the brigade. */</comment>
        <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>tempb</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>tempb</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>eos</name></expr>;</condition> <incr><expr><name>e</name> = <name>next</name></expr></incr>) <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>next</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>eos</name> = 1</expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr>!<call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02016</expr></argument>)</argument_list></call>
                                  "could not read bucket for SSL buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>total</name> += <name>len</name></expr>;</expr_stmt>
            }</block></then></if></else></if>

            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_setaside</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02017</expr></argument>)</argument_list></call>
                              "could not setaside bucket for SSL buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                      <argument><expr>"total of %" <name>APR_OFF_T_FMT</name> " bytes in buffer, eos=%d"</expr></argument>,
                      <argument><expr><name>total</name></expr></argument>, <argument><expr><name>eos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Fail if this exceeds the maximum buffer size. */</comment>
        <if>if <condition>(<expr><name>total</name> &gt; <name>maxlen</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02018</expr></argument>)</argument_list></call>
                          "request body exceeds maximum size (%" <name>APR_SIZE_T_FMT</name>
                          ") for SSL buffer"</expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>;</return>
        }</block></then></if>

    }</block> while <condition>(<expr>!<name>eos</name></expr>)</condition>;</do>

    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>tempb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* After consuming all protocol-level input, remove all protocol-level
     * filters.  It should strictly only be necessary to remove filters
     * at exactly ftype == AP_FTYPE_PROTOCOL, since this filter will
     * precede all &gt; AP_FTYPE_PROTOCOL anyway. */</comment>
    <while>while <condition>(<expr><name><name>r</name>-&gt;<name>proto_input_filters</name>-&gt;<name>frec</name>-&gt;<name>ftype</name></name> &lt; <name>AP_FTYPE_CONNECTION</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>ap_remove_input_filter</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>proto_input_filters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* Insert the filter which will supply the buffered content. */</comment>
    <expr_stmt><expr><call><name>ap_add_input_filter</name><argument_list>(<argument><expr><name>ssl_io_buffer</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/* This input filter supplies the buffered request body to the caller
 * from the brigade stored in f-&gt;ctx.  Note that the placement of this
 * filter in the filter stack is important; it must be the first
 * r-&gt;proto_input_filter; lower-typed filters will not be preserved
 * across internal redirects (see PR 43738).  */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>ssl_io_filter_buffer</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                         <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                         <param><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl></param>,
                                         <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                         <param><decl><type><name>apr_off_t</name></type> <name>bytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>modssl_buffer_ctx</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                  <argument><expr>"read from buffered SSL brigade, mode %d, "
                  "%" <name>APR_OFF_T_FMT</name> " bytes"</expr></argument>,
                  <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>mode</name> != <name>AP_MODE_READBYTES</name> &amp;&amp; <name>mode</name> != <name>AP_MODE_GETLINE</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_ENOTIMPL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* Suprisingly (and perhaps, wrongly), the request body can be
         * pulled from the input filter stack more than once; a
         * handler may read it, and ap_discard_request_body() will
         * attempt to do so again after *every* request.  So input
         * filters must be prepared to give up an EOS if invoked after
         * initially reading the request. The HTTP_IN filter does this
         * with its -&gt;eos_sent flag. */</comment>

        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>mode</name> == <name>AP_MODE_READBYTES</name></expr>)</condition><then> <block>{
        <comment type="block">/* Partition the buffered brigade. */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_brigade_partition</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> &amp;&amp; <name>rv</name> != <name>APR_INCOMPLETE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02019</expr></argument>)</argument_list></call>
                          "could not partition buffered SSL brigade"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_remove_input_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* If the buffered brigade contains less then the requested
         * length, just pass it all back. */</comment>
        <if>if <condition>(<expr><name>rv</name> == <name>APR_INCOMPLETE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>d</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>e</name> = <call><name>APR_BUCKET_PREV</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Unsplice the partitioned segment and move it into the
             * passed-in brigade; no convenient way to do this with
             * the APR_BRIGADE_* macros. */</comment>
            <expr_stmt><expr><call><name>APR_RING_UNSPLICE</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_RING_SPLICE_HEAD</name><argument_list>(<argument><expr>&amp;<name><name>bb</name>-&gt;<name>list</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>apr_bucket</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>APR_BRIGADE_CHECK_CONSISTENCY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_CHECK_CONSISTENCY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* Split a line into the passed-in brigade. */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_brigade_split_line</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02020</expr></argument>)</argument_list></call>
                          "could not split line from buffered SSL brigade"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_remove_input_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>
    }</block></else></if>

    <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_LAST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Ensure that the brigade is terminated by an EOS if the
         * buffered request body has been entirely consumed. */</comment>
        <if>if <condition>(<expr><name>e</name> == <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call> || !<call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name></name></expr></argument>,
                      <argument><expr>"buffered SSL brigade exhausted"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Note that the filter must *not* be removed here; it may be
         * invoked again, see comment above. */</comment>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/* The request_rec pointer is passed in here only to ensure that the
 * filter chain is modified correctly when doing a TLS upgrade.  It
 * must *not* be used otherwise. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>ssl_io_input_add_filter</name><parameter_list>(<param><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name></decl></param>, <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>,
                                    <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>bio_filter_in_ctx_t</name> *</type><name>inctx</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>inctx</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>inctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>pInputFilter</name></name> = <call><name>ap_add_input_filter</name><argument_list>(<argument><expr><name>ssl_io_filter</name></expr></argument>, <argument><expr><name>inctx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MODSSL_USE_OPENSSL_PRE_1_1_API</name></expr></cpp:if>
    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>pbioRead</name></name> = <call><name>BIO_new</name><argument_list>(<argument><expr>&amp;<name>bio_filter_in_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>pbioRead</name></name> = <call><name>BIO_new</name><argument_list>(<argument><expr><name>bio_filter_in_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>BIO_set_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioRead</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<name>inctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>ssl</name></name> = <name>ssl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>bio_out</name></name> = <name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>f</name></name> = <name><name>filter_ctx</name>-&gt;<name>pInputFilter</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>rc</name></name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>mode</name></name> = <name>AP_MODE_READBYTES</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>cbuf</name>.<name>length</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>block</name></name> = <name>APR_BLOCK_READ</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>pool</name></name> = <name><name>c</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>inctx</name>-&gt;<name>filter_ctx</name></name> = <name>filter_ctx</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* The request_rec pointer is passed in here only to ensure that the
 * filter chain is modified correctly when doing a TLS upgrade.  It
 * must *not* be used otherwise. */</comment>
<function><type><name>void</name></type> <name>ssl_io_filter_init</name><parameter_list>(<param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ssl_filter_ctx_t</name> *</type><name>filter_ctx</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>filter_ctx</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ssl_filter_ctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>config</name></name>          = <call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_add_output_filter</name><argument_list>(<argument><expr><name>ssl_io_coalesce</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>pOutputFilter</name></name>   = <call><name>ap_add_output_filter</name><argument_list>(<argument><expr><name>ssl_io_filter</name></expr></argument>,
                                                       <argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MODSSL_USE_OPENSSL_PRE_1_1_API</name></expr></cpp:if>
    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name>       = <call><name>BIO_new</name><argument_list>(<argument><expr>&amp;<name>bio_filter_out_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name>       = <call><name>BIO_new</name><argument_list>(<argument><expr><name>bio_filter_out_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>BIO_set_data</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name></expr></argument>, <argument><expr>(<name>void</name> *)<call><name>bio_filter_out_ctx_new</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* write is non blocking for the benefit of async mpm */</comment>
    <if>if <condition>(<expr><name><name>c</name>-&gt;<name>cs</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>BIO_set_nbio</name><argument_list>(<argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ssl_io_input_add_filter</name><argument_list>(<argument><expr><name>filter_ctx</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SSL_set_bio</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioRead</name></name></expr></argument>, <argument><expr><name><name>filter_ctx</name>-&gt;<name>pbioWrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>filter_ctx</name>-&gt;<name>pssl</name></name>            = <name>ssl</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>(<name>void</name>*)<name>filter_ctx</name></expr></argument>,
                              <argument><expr><name>ssl_io_filter_cleanup</name></expr></argument>, <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><call><name>APLOG_CS_IS_LEVEL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>BIO</name> *</type><name>rbio</name> <init>= <expr><call><name>SSL_get_rbio</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init>,
            *<name>wbio</name> <init>= <expr><call><name>SSL_get_wbio</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>BIO_set_callback</name><argument_list>(<argument><expr><name>rbio</name></expr></argument>, <argument><expr><name>ssl_io_data_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>BIO_set_callback_arg</name><argument_list>(<argument><expr><name>rbio</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>wbio</name> &amp;&amp; <name>wbio</name> != <name>rbio</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>BIO_set_callback</name><argument_list>(<argument><expr><name>wbio</name></expr></argument>, <argument><expr><name>ssl_io_data_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BIO_set_callback_arg</name><argument_list>(<argument><expr><name>wbio</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <return>return;</return>
}</block></function>

<function><type><name>void</name></type> <name>ssl_io_filter_register</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_register_input_filter</name>  <argument_list>(<argument><expr><name>ssl_io_filter</name></expr></argument>, <argument><expr><name>ssl_io_filter_input</name></expr></argument>,  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AP_FTYPE_CONNECTION</name> + 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_register_output_filter</name> <argument_list>(<argument><expr><name>ssl_io_coalesce</name></expr></argument>, <argument><expr><name>ssl_io_filter_coalesce</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AP_FTYPE_CONNECTION</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_register_output_filter</name> <argument_list>(<argument><expr><name>ssl_io_filter</name></expr></argument>, <argument><expr><name>ssl_io_filter_output</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AP_FTYPE_CONNECTION</name> + 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_register_input_filter</name>  <argument_list>(<argument><expr><name>ssl_io_buffer</name></expr></argument>, <argument><expr><name>ssl_io_filter_buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>AP_FTYPE_PROTOCOL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
}</block></function>

<comment type="block">/*  _________________________________________________________________
**
**  I/O Data Debugging
**  _________________________________________________________________
*/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_WIDTH</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ssl_io_data_dump</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>b</name></decl></param>,
                             <param><decl><type><name>long</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>rows</name></decl>, <decl><type ref="prev"/><name>trunc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ch</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>trunc</name> = 0</expr>;</expr_stmt>
    <for>for(<init>;</init> <condition><expr>(<name>len</name> &gt; 0) &amp;&amp; ((<name><name>b</name><index>[<expr><name>len</name>-1</expr>]</index></name> == ' ') || (<name><name>b</name><index>[<expr><name>len</name>-1</expr>]</index></name> == '\0'))</expr>;</condition> <incr><expr><name>len</name>--</expr></incr>)
        <expr_stmt><expr><name>trunc</name>++</expr>;</expr_stmt></for>
    <expr_stmt><expr><name>rows</name> = (<name>len</name> / <name>DUMP_WIDTH</name>)</expr>;</expr_stmt>
    <if>if <condition>(<expr>(<name>rows</name> * <name>DUMP_WIDTH</name>) &lt; <name>len</name></expr>)</condition><then>
        <expr_stmt><expr><name>rows</name>++</expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE7</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>,
            <argument><expr>"+-------------------------------------------------------------------------+"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for(<init><expr><name>i</name> = 0</expr> ;</init> <condition><expr><name>i</name>&lt; <name>rows</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
        <decl_stmt><decl><type><name>char</name></type> <name><name>ebcdic_text</name><index>[<expr><name>DUMP_WIDTH</name></expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name>j</name> = <name>DUMP_WIDTH</name></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>i</name> * <name>DUMP_WIDTH</name> + <name>j</name>) &gt; <name>len</name></expr>)</condition><then>
            <expr_stmt><expr><name>j</name> = <name>len</name> % <name>DUMP_WIDTH</name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>j</name> = <name>DUMP_WIDTH</name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ebcdic_text</name></expr></argument>,<argument><expr><call>(<name>char</name> *)<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> + <name>i</name> * <name>DUMP_WIDTH</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_xlate_proto_from_ascii</name><argument_list>(<argument><expr><name>ebcdic_text</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* APR_CHARSET_EBCDIC */</comment>
        <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"| %04x: "</expr></argument>, <argument><expr><name>i</name> * <name>DUMP_WIDTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>DUMP_WIDTH</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>((<name>i</name> * <name>DUMP_WIDTH</name>) + <name>j</name>) &gt;= <name>len</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>buf</name>+<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"   "</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <block>{
                <expr_stmt><expr><name>ch</name> = ((<name>unsigned</name> <name>char</name>)*(<call>(<name>char</name> *)<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> + <name>i</name> * <name>DUMP_WIDTH</name> + <name>j</name>)) &amp; 0xff</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%02x%c"</expr></argument>, <argument><expr><name>ch</name></expr></argument> , <argument><expr><name>j</name>==7 ? '-' : ' '</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>buf</name>+<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>buf</name>+<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>DUMP_WIDTH</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
            <if>if <condition>(<expr>((<name>i</name> * <name>DUMP_WIDTH</name>) + <name>j</name>) &gt;= <name>len</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>buf</name>+<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
            <else>else <block>{
                <expr_stmt><expr><name>ch</name> = ((<name>unsigned</name> <name>char</name>)*(<call>(<name>char</name> *)<argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> + <name>i</name> * <name>DUMP_WIDTH</name> + <name>j</name>)) &amp; 0xff</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
                <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr>(<name>ch</name> &gt;= 0x20 &amp;&amp; <name>ch</name> &lt;= 0x7F) ? <name><name>ebcdic_text</name><index>[<expr><name>j</name></expr>]</index></name> : '.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* APR_CHARSET_EBCDIC */</comment>
                <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%c"</expr></argument>, <argument><expr>((<name>ch</name> &gt;= ' ') &amp;&amp; (<name>ch</name> &lt;= '~')) ? <name>ch</name> : '.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* APR_CHARSET_EBCDIC */</comment>
                <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>buf</name>+<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>
        <expr_stmt><expr><call><name>apr_cpystrn</name><argument_list>(<argument><expr><name>buf</name>+<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>" |"</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof>-<call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE7</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <if>if <condition>(<expr><name>trunc</name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE7</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>,
                <argument><expr>"| %04ld - &lt;SPACES/NULS&gt;"</expr></argument>, <argument><expr><name>len</name> + <name>trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE7</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>,
            <argument><expr>"+-------------------------------------------------------------------------+"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return;</return>
}</block></function>

<function><type><name>long</name></type> <name>ssl_io_data_cb</name><parameter_list>(<param><decl><type><name>BIO</name> *</type><name>bio</name></decl></param>, <param><decl><type><name>int</name></type> <name>cmd</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>argp</name></decl></param>,
                    <param><decl><type><name>int</name></type> <name>argi</name></decl></param>, <param><decl><type><name>long</name></type> <name>argl</name></decl></param>, <param><decl><type><name>long</name></type> <name>rc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>(<name>ssl</name> = (<name>SSL</name> *)<call><name>BIO_get_callback_arg</name><argument_list>(<argument><expr><name>bio</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>rc</name></expr>;</return></then></if>
    <if>if <condition>(<expr>(<name>c</name> = (<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>rc</name></expr>;</return></then></if>
    <expr_stmt><expr><name>s</name> = <call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(   <expr><name>cmd</name> == (<name>BIO_CB_WRITE</name>|<name>BIO_CB_RETURN</name>)
        || <name>cmd</name> == (<name>BIO_CB_READ</name> |<name>BIO_CB_RETURN</name>)</expr> )</condition><then> <block>{
        <if>if <condition>(<expr><name>rc</name> &gt;= 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cserror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>,
                    <argument><expr>"%s: %s %ld/%d bytes %s BIO#%pp [mem: %pp] %s"</expr></argument>,
                    <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>,
                    <argument><expr>(<name>cmd</name> == (<name>BIO_CB_WRITE</name>|<name>BIO_CB_RETURN</name>) ? "write" : "read")</expr></argument>,
                    <argument><expr><name>rc</name></expr></argument>, <argument><expr><name>argi</name></expr></argument>, <argument><expr>(<name>cmd</name> == (<name>BIO_CB_WRITE</name>|<name>BIO_CB_RETURN</name>) ? "to" : "from")</expr></argument>,
                    <argument><expr><name>bio</name></expr></argument>, <argument><expr><name>argp</name></expr></argument>,
                    <argument><expr>(<name>argp</name> != <name>NULL</name> ? "(BIO dump follows)" : "(Oops, no memory buffer?)")</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>(<name>argp</name> != <name>NULL</name>) &amp;&amp; <call><name>APLOG_CS_IS_LEVEL</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>APLOG_TRACE7</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>ssl_io_data_dump</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>argp</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_cserror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>,
                    <argument><expr>"%s: I/O error, %d bytes expected to %s on BIO#%pp [mem: %pp]"</expr></argument>,
                    <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>, <argument><expr><name>argi</name></expr></argument>,
                    <argument><expr>(<name>cmd</name> == (<name>BIO_CB_WRITE</name>|<name>BIO_CB_RETURN</name>) ? "write" : "read")</expr></argument>,
                    <argument><expr><name>bio</name></expr></argument>, <argument><expr><name>argp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
    <return>return <expr><name>rc</name></expr>;</return>
}</block></function>
</unit>
