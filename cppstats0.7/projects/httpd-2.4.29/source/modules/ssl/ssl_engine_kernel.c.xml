<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/ssl/ssl_engine_kernel.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*                      _             _
 *  _ __ ___   ___   __| |    ___ ___| |  mod_ssl
 * | '_ ` _ \ / _ \ / _` |   / __/ __| |  Apache Interface to OpenSSL
 * | | | | | | (_) | (_| |   \__ \__ \ |
 * |_| |_| |_|\___/ \__,_|___|___/___/_|
 *                      |_____|
 *  ssl_engine_kernel.c
 *  The SSL engine kernel
 */</comment>
                             <comment type="block">/* ``It took me fifteen years to discover
                                  I had no talent for programming, but
                                  I couldn't give it up because by that
                                  time I was too famous.''
                                            -- Unknown                */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ssl_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_ssl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ssl_configure_env</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name></decl></param>)</parameter_list>;</function_decl>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ssl_find_vhost</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>servername</name></decl></param>, <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SWITCH_STATUS_LINE</name></cpp:macro> <cpp:value>"HTTP/1.1 101 Switching Protocols"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UPGRADE_HEADER</name></cpp:macro> <cpp:value>"Upgrade: TLS/1.0, HTTP/1.1"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONNECTION_HEADER</name></cpp:macro> <cpp:value>"Connection: Upgrade"</cpp:value></cpp:define>

<comment type="block">/* Perform an upgrade-to-TLS for the given request, per RFC 2817. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>upgrade_connection</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>conn_rec</name> *</type><name>conn</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02028</expr></argument>)</argument_list></call>
                  "upgrading connection to TLS"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <macro><name>ap_fputs</name><argument_list>(<argument>conn-&gt;output_filters</argument>, <argument>bb</argument>, <argument>SWITCH_STATUS_LINE CRLF
                  UPGRADE_HEADER CRLF CONNECTION_HEADER CRLF CRLF</argument>)</argument_list></macro></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>,
                                <argument><expr><call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02029</expr></argument>)</argument_list></call>
                      "failed to send 101 interim response for connection "
                      "upgrade"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><call><name>ssl_init_ssl_connection</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>sslconn</name> = <call><name>myConnConfig</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ssl</name> = <name><name>sslconn</name>-&gt;<name>ssl</name></name></expr>;</expr_stmt>

    <comment type="block">/* Perform initial SSL handshake. */</comment>
    <expr_stmt><expr><call><name>SSL_set_accept_state</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SSL_do_handshake</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<call><name>SSL_is_init_finished</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02030</expr></argument>)</argument_list></call>
                      "TLS upgrade handshake failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>APR_ECONNABORTED</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<comment type="block">/* Perform a speculative (and non-blocking) read from the connection
 * filters for the given request, to determine whether there is any
 * pending data to read.  Return non-zero if there is, else zero. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>has_buffered_data</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>input_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>AP_MODE_SPECULATIVE</name></expr></argument>,
                        <argument><expr><name>APR_NONBLOCK_READ</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> = <name>rv</name> == <name>APR_SUCCESS</name>
        &amp;&amp; <call><name>apr_brigade_length</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call> == <name>APR_SUCCESS</name>
        &amp;&amp; <name>len</name> &gt; 0</expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>result</name></expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ap_array_same_str_set</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>s1</name></decl></param>, <param><decl><type><name>apr_array_header_t</name> *</type><name>s2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>c</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>s1</name> == <name>s2</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<name>s1</name> || !<name>s2</name> || (<name><name>s1</name>-&gt;<name>nelts</name></name> != <name><name>s2</name>-&gt;<name>nelts</name></name>)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if></else></if>
    
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>s1</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>c</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>c</name> || !<call><name>ap_array_str_contains</name><argument_list>(<argument><expr><name>s2</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
    }</block></for>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ssl_pk_server_compatible</name><parameter_list>(<param><decl><type><name>modssl_pk_server_t</name> *</type><name>pks1</name></decl></param>, 
                                    <param><decl><type><name>modssl_pk_server_t</name> *</type><name>pks2</name></decl></param>)</parameter_list> 
<block>{
    <if>if <condition>(<expr>!<name>pks1</name> || !<name>pks2</name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <comment type="block">/* both have the same certificates? */</comment>
    <if>if <condition>(<expr>(<name><name>pks1</name>-&gt;<name>ca_name_path</name></name> != <name><name>pks2</name>-&gt;<name>ca_name_path</name></name>)
        &amp;&amp; (!<name><name>pks1</name>-&gt;<name>ca_name_path</name></name> || !<name><name>pks2</name>-&gt;<name>ca_name_path</name></name> 
            || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pks1</name>-&gt;<name>ca_name_path</name></name></expr></argument>, <argument><expr><name><name>pks2</name>-&gt;<name>ca_name_path</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name><name>pks1</name>-&gt;<name>ca_name_file</name></name> != <name><name>pks2</name>-&gt;<name>ca_name_file</name></name>)
        &amp;&amp; (!<name><name>pks1</name>-&gt;<name>ca_name_file</name></name> || !<name><name>pks2</name>-&gt;<name>ca_name_file</name></name> 
            || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>pks1</name>-&gt;<name>ca_name_file</name></name></expr></argument>, <argument><expr><name><name>pks2</name>-&gt;<name>ca_name_file</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>!<call><name>ap_array_same_str_set</name><argument_list>(<argument><expr><name><name>pks1</name>-&gt;<name>cert_files</name></name></expr></argument>, <argument><expr><name><name>pks2</name>-&gt;<name>cert_files</name></name></expr></argument>)</argument_list></call>
        || !<call><name>ap_array_same_str_set</name><argument_list>(<argument><expr><name><name>pks1</name>-&gt;<name>key_files</name></name></expr></argument>, <argument><expr><name><name>pks2</name>-&gt;<name>key_files</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ssl_auth_compatible</name><parameter_list>(<param><decl><type><name>modssl_auth_ctx_t</name> *</type><name>a1</name></decl></param>, 
                               <param><decl><type><name>modssl_auth_ctx_t</name> *</type><name>a2</name></decl></param>)</parameter_list> 
<block>{
    <if>if <condition>(<expr>!<name>a1</name> || !<name>a2</name></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <comment type="block">/* both have the same verification */</comment>
    <if>if <condition>(<expr>(<name><name>a1</name>-&gt;<name>verify_depth</name></name> != <name><name>a2</name>-&gt;<name>verify_depth</name></name>)
        || (<name><name>a1</name>-&gt;<name>verify_mode</name></name> != <name><name>a2</name>-&gt;<name>verify_mode</name></name>)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <comment type="block">/* both have the same ca path/file */</comment>
    <if>if <condition>(<expr>(<name><name>a1</name>-&gt;<name>ca_cert_path</name></name> != <name><name>a2</name>-&gt;<name>ca_cert_path</name></name>)
        &amp;&amp; (!<name><name>a1</name>-&gt;<name>ca_cert_path</name></name> || !<name><name>a2</name>-&gt;<name>ca_cert_path</name></name> 
            || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>a1</name>-&gt;<name>ca_cert_path</name></name></expr></argument>, <argument><expr><name><name>a2</name>-&gt;<name>ca_cert_path</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name><name>a1</name>-&gt;<name>ca_cert_file</name></name> != <name><name>a2</name>-&gt;<name>ca_cert_file</name></name>)
        &amp;&amp; (!<name><name>a1</name>-&gt;<name>ca_cert_file</name></name> || !<name><name>a2</name>-&gt;<name>ca_cert_file</name></name> 
            || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>a1</name>-&gt;<name>ca_cert_file</name></name></expr></argument>, <argument><expr><name><name>a2</name>-&gt;<name>ca_cert_file</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <comment type="block">/* both have the same ca cipher suite string */</comment>
    <if>if <condition>(<expr>(<name><name>a1</name>-&gt;<name>cipher_suite</name></name> != <name><name>a2</name>-&gt;<name>cipher_suite</name></name>)
        &amp;&amp; (!<name><name>a1</name>-&gt;<name>cipher_suite</name></name> || !<name><name>a2</name>-&gt;<name>cipher_suite</name></name> 
            || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>a1</name>-&gt;<name>cipher_suite</name></name></expr></argument>, <argument><expr><name><name>a2</name>-&gt;<name>cipher_suite</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ssl_ctx_compatible</name><parameter_list>(<param><decl><type><name>modssl_ctx_t</name> *</type><name>ctx1</name></decl></param>, 
                              <param><decl><type><name>modssl_ctx_t</name> *</type><name>ctx2</name></decl></param>)</parameter_list> 
<block>{
    <if>if <condition>(<expr>!<name>ctx1</name> || !<name>ctx2</name> 
        || (<name><name>ctx1</name>-&gt;<name>protocol</name></name> != <name><name>ctx2</name>-&gt;<name>protocol</name></name>)
        || !<call><name>ssl_auth_compatible</name><argument_list>(<argument><expr>&amp;<name><name>ctx1</name>-&gt;<name>auth</name></name></expr></argument>, <argument><expr>&amp;<name><name>ctx2</name>-&gt;<name>auth</name></name></expr></argument>)</argument_list></call>
        || !<call><name>ssl_pk_server_compatible</name><argument_list>(<argument><expr><name><name>ctx1</name>-&gt;<name>pks</name></name></expr></argument>, <argument><expr><name><name>ctx2</name>-&gt;<name>pks</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>ssl_server_compatible</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s1</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s2</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc1</name> <init>= <expr><name>s1</name>? <call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc2</name> <init>= <expr><name>s2</name>? <call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s2</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* both use the same TLS protocol? */</comment>
    <if>if <condition>(<expr>!<name>sc1</name> || !<name>sc2</name> 
        || !<call><name>ssl_ctx_compatible</name><argument_list>(<argument><expr><name><name>sc1</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name><name>sc2</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>
    
    <return>return <expr>1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 *  Post Read Request Handler
 */</comment>
<function><type><name>int</name></type> <name>ssl_hook_ReadReq</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name> <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>upgrade</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>servername</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name></decl>;</decl_stmt>

    <comment type="block">/* Perform TLS upgrade here if "SSLEngine optional" is configured,
     * SSL is not already set up for this connection, and the client
     * has sent a suitable Upgrade header. */</comment>
    <if>if <condition>(<expr><name><name>sc</name>-&gt;<name>enabled</name></name> == <name>SSL_ENABLED_OPTIONAL</name> &amp;&amp; !<call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call>
        &amp;&amp; (<name>upgrade</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Upgrade"</expr></argument>)</argument_list></call>) != <name>NULL</name>
        &amp;&amp; <call><name>ap_find_token</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>upgrade</name></expr></argument>, <argument><expr>"TLS/1.0"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>upgrade_connection</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>AP_FILTER_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If we are on a slave connection, we do not expect to have an SSLConnRec,
     * but our master connection might. */</comment>
    <expr_stmt><expr><name>sslconn</name> = <call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!(<name>sslconn</name> &amp;&amp; <name><name>sslconn</name>-&gt;<name>ssl</name></name>) &amp;&amp; <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>master</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sslconn</name> = <call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <comment type="block">/* If "SSLEngine optional" is configured, this is not an SSL
     * connection, and this isn't a subrequest, send an Upgrade
     * response header.  Note this must happen before map_to_storage
     * and OPTIONS * request processing is completed.
     */</comment>
    <if>if <condition>(<expr><name><name>sc</name>-&gt;<name>enabled</name></name> == <name>SSL_ENABLED_OPTIONAL</name> &amp;&amp; !(<name>sslconn</name> &amp;&amp; <name><name>sslconn</name>-&gt;<name>ssl</name></name>)
        &amp;&amp; !<name><name>r</name>-&gt;<name/></name>main</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Upgrade"</expr></argument>, <argument><expr>"TLS/1.0, HTTP/1.1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Connection"</expr></argument>, <argument><expr>"upgrade"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>sslconn</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>non_ssl_request</name></name> == <name>NON_SSL_SET_ERROR_MSG</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                       <argument><expr>"Reason: You're speaking plain HTTP to an SSL-enabled "
                       "server port.&lt;br /&gt;\n Instead use the HTTPS scheme to "
                       "access this URL, please.&lt;br /&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Now that we have caught this error, forget it. we are done
         * with using SSL on this request.
         */</comment>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>non_ssl_request</name></name> = <name>NON_SSL_OK</name></expr>;</expr_stmt>

        <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Get the SSL connection structure and perform the
     * delayed interlinking from SSL back to request_rec
     */</comment>
    <expr_stmt><expr><name>ssl</name> = <name><name>sslconn</name>-&gt;<name>ssl</name></name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>ssl</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
    <comment type="block">/*
     * Perform SNI checks only on the initial request.  In particular,
     * if these checks detect a problem, the checks shouldn't return an
     * error again when processing an ErrorDocument redirect for the
     * original problem.
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proxyreq</name></name> != <name>PROXYREQ_PROXY</name> &amp;&amp; <call><name>ap_is_initial_req</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>server_rec</name> *</type><name>handshakeserver</name> <init>= <expr><name><name>sslconn</name>-&gt;<name>server</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>hssc</name> <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name>handshakeserver</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr>(<name>servername</name> = <call><name>SSL_get_servername</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>TLSEXT_NAMETYPE_host_name</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <comment type="block">/*
             * The SNI extension supplied a hostname. So don't accept requests
             * with either no hostname or a hostname that selected a different
             * virtual host than the one used for the handshake, causing
             * different SSL parameters to be applied, such as SSLProtocol,
             * SSLCACertificateFile/Path and SSLCADNRequestFile/Path which
             * cannot be renegotiated (SSLCA* due to current limitations in
             * OpenSSL, see:
             * http://mail-archives.apache.org/mod_mbox/httpd-dev/200806.mbox/%3C48592955.2090303@velox.ch%3E
             * and
             * http://mail-archives.apache.org/mod_mbox/httpd-dev/201312.mbox/%3CCAKQ1sVNpOrdiBm-UPw1hEdSN7YQXRRjeaT-MCWbW_7mN%3DuFiOw%40mail.gmail.com%3E
             * )
             */</comment>
            <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>hostname</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02031</expr></argument>)</argument_list></call>
                            "Hostname %s provided via SNI, but no hostname"
                            " provided in HTTP request"</expr></argument>, <argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>r</name>-&gt;<name>server</name></name> != <name>handshakeserver</name> 
                &amp;&amp; !<call><name>ssl_server_compatible</name><argument_list>(<argument><expr><name><name>sslconn</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* 
                 * The request does not select the virtual host that was
                 * selected by the SNI and its SSL parameters are different
                 */</comment>
                
                <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02032</expr></argument>)</argument_list></call>
                             "Hostname %s provided via SNI and hostname %s provided"
                             " via HTTP have no compatible SSL setup"</expr></argument>,
                             <argument><expr><name>servername</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>hostname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_MISDIRECTED_REQUEST</name></expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr>((<name><name>sc</name>-&gt;<name>strict_sni_vhost_check</name></name> == <name>SSL_ENABLED_TRUE</name>)
                  || <name><name>hssc</name>-&gt;<name>strict_sni_vhost_check</name></name> == <name>SSL_ENABLED_TRUE</name>)
                 &amp;&amp; <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>vhost_lookup_data</name></name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * We are using a name based configuration here, but no hostname was
             * provided via SNI. Don't allow that if are requested to do strict
             * checking. Check whether this strict checking was set up either in the
             * server config we used for handshaking or in our current server.
             * This should avoid insecure configuration by accident.
             */</comment>
            <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02033</expr></argument>)</argument_list></call>
                         "No hostname was provided via SNI for a name based"
                         " virtual host"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                           <argument><expr>"Reason: The client software did not provide a "
                           "hostname using Server Name Indication (SNI), "
                           "which is required to access this server.&lt;br /&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if></else></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>modssl_set_app_data2</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Log information about incoming HTTPS requests
     */</comment>
    <if>if <condition>(<expr><call><name>APLOGrinfo</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>ap_is_initial_req</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02034</expr></argument>)</argument_list></call>
                     "%s HTTPS request received for child %ld (server %s)"</expr></argument>,
                     <argument><expr>(<name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalives</name></name> &lt;= 0 ?
                     "Initial (No.1)" :
                     <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Subsequent (No.%d)"</expr></argument>,
                                  <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalives</name></name>+1</expr></argument>)</argument_list></call>)</expr></argument>,
                     <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>id</name></name></expr></argument>,
                     <argument><expr><call><name>ssl_util_vhostid</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* SetEnvIf ssl-*-shutdown flags can only be per-server,
     * so they won't change across keepalive requests
     */</comment>
    <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>shutdown_type</name></name> == <name>SSL_SHUTDOWN_TYPE_UNSET</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ssl_configure_env</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>sslconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Move SetEnvIf information from request_rec to conn_rec/BUFF
 * to allow the close connection handler to use them.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ssl_configure_env</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>arr</name> <init>= <expr><call><name>apr_table_elts</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_table_entry_t</name> *</type><name>elts</name> <init>= <expr>(const <name>apr_table_entry_t</name> *)<name><name>arr</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>shutdown_type</name></name> = <name>SSL_SHUTDOWN_TYPE_STANDARD</name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>arr</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name> <init>= <expr><name><name>elts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>key</name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr>*<name>key</name></expr>)</condition> <block>{
          <case>case <expr>'s'</expr>:
            <comment type="block">/* being case-sensitive here.
             * and not checking for the -shutdown since these are the only
             * SetEnvIf "flags" we support
             */</comment>
            <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>key</name>+1</expr></argument>, <argument><expr>"sl-"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>key</name> += 4</expr>;</expr_stmt>
                <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"unclean"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>shutdown_type</name></name> = <name>SSL_SHUTDOWN_TYPE_UNCLEAN</name></expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr>"accurate"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>shutdown_type</name></name> = <name>SSL_SHUTDOWN_TYPE_ACCURATE</name></expr>;</expr_stmt>
                }</block></then></if></else></if>
                <return>return;</return> <comment type="block">/* should only ever be one ssl-*-shutdown */</comment>
            }</block></then></if>
            <break>break;</break>
        </case>}</block></switch>
    }</block></for>
}</block></function>

<comment type="block">/*
 *  Access Handler
 */</comment>
<function><type><name>int</name></type> <name>ssl_hook_Access</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLDirConfigRec</name> *</type><name>dc</name>         <init>= <expr><call><name>myDirConfig</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name>         <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name>         <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name>                    <init>= <expr><name>sslconn</name> ? <name><name>sslconn</name>-&gt;<name>ssl</name></name> : <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>handshakeserver</name> <init>= <expr><name>sslconn</name> ? <name><name>sslconn</name>-&gt;<name>server</name></name> : <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>hssc</name>       <init>= <expr><name>handshakeserver</name>? <call><name>mySrvConfig</name><argument_list>(<argument><expr><name>handshakeserver</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL_CTX</name> *</type><name>ctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>requires</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssl_require_t</name> *</type><name>ssl_requires</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>ok</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>renegotiate</name> <init>= <expr><name>FALSE</name></expr></init>, <name>renegotiate_quick</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name> *</type><name>cert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name> *</type><name>peercert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509_STORE</name> *</type><name>cert_store</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509_STORE_CTX</name> *</type><name>cert_store_ctx</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>SSL_CIPHER</name></expr></argument>)</argument_list></call> *<name>cipher_list_old</name> = <name>NULL</name></expr>, <expr>*<name>cipher_list</name> = <name>NULL</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>SSL_CIPHER</name> *</type><name>cipher</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>verify_old</name></decl>, <decl><type ref="prev"/><name>verify</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>is_slave</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ncipher_suite</name></decl>;</decl_stmt>

    <comment type="block">/* On a slave connection, we do not expect to have an SSLConnRec, but
     * our master connection might have one. */</comment>
    <if>if <condition>(<expr>!(<name>sslconn</name> &amp;&amp; <name>ssl</name>) &amp;&amp; <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>master</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sslconn</name>         = <call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>ssl</name>             = <name>sslconn</name> ? <name><name>sslconn</name>-&gt;<name>ssl</name></name> : <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>handshakeserver</name> = <name>sslconn</name> ? <name><name>sslconn</name>-&gt;<name>server</name></name> : <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>hssc</name>            = <name>handshakeserver</name>? <call><name>mySrvConfig</name><argument_list>(<argument><expr><name>handshakeserver</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>is_slave</name>        = 1</expr>;</expr_stmt>
    }</block></then></if>
    
    <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * We should have handshaken here (on handshakeserver),
         * otherwise we are being redirected (ErrorDocument) from
         * a renegotiation failure below. The access is still 
         * forbidden in the latter case, let ap_die() handle
         * this recursive (same) error.
         */</comment>
        <if>if <condition>(<expr>!<call><name>SSL_is_init_finished</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>ctx</name> = <call><name>SSL_get_SSL_CTX</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Support for SSLRequireSSL directive
     */</comment>
    <if>if <condition>(<expr><name><name>dc</name>-&gt;<name>bSSLRequired</name></name> &amp;&amp; !<name>ssl</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name><name>sc</name>-&gt;<name>enabled</name></name> == <name>SSL_ENABLED_OPTIONAL</name>) &amp;&amp; !<name>is_slave</name></expr>)</condition><then> <block>{
            <comment type="block">/* This vhost was configured for optional SSL, just tell the
             * client that we need to upgrade.
             */</comment>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"Upgrade"</expr></argument>, <argument><expr>"TLS/1.0, HTTP/1.1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>"Connection"</expr></argument>, <argument><expr>"Upgrade"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>HTTP_UPGRADE_REQUIRED</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02219</expr></argument>)</argument_list></call>
                      "access to %s failed, reason: %s"</expr></argument>,
                      <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"SSL connection required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remember forbidden access for strict require option */</comment>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-access-forbidden"</expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Check to see whether SSL is in use; if it's not, then no
     * further access control checks are relevant.  (the test for
     * sc-&gt;enabled is probably strictly unnecessary)
     */</comment>
    <if>if <condition>(<expr><name><name>sc</name>-&gt;<name>enabled</name></name> == <name>SSL_ENABLED_FALSE</name> || !<name>ssl</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SRP</name></cpp:ifdef>
    <comment type="block">/*
     * Support for per-directory reconfigured SSL connection parameters
     *
     * We do not force any renegotiation if the user is already authenticated
     * via SRP.
     *
     */</comment>
    <if>if <condition>(<expr><call><name>SSL_get_srp_username</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * Support for per-directory reconfigured SSL connection parameters.
     *
     * This is implemented by forcing an SSL renegotiation with the
     * reconfigured parameter suite. But Apache's internal API processing
     * makes our life very hard here, because when internal sub-requests occur
     * we nevertheless should avoid multiple unnecessary SSL handshakes (they
     * require extra network I/O and especially time to perform).
     *
     * But the optimization for filtering out the unnecessary handshakes isn't
     * obvious and trivial.  Especially because while Apache is in its
     * sub-request processing the client could force additional handshakes,
     * too. And these take place perhaps without our notice. So the only
     * possibility is to explicitly _ask_ OpenSSL whether the renegotiation
     * has to be performed or not. It has to performed when some parameters
     * which were previously known (by us) are not those we've now
     * reconfigured (as known by OpenSSL) or (in optimized way) at least when
     * the reconfigured parameter suite is stronger (more restrictions) than
     * the currently active one.
     */</comment>

    <comment type="block">/*
     * Override of SSLCipherSuite
     *
     * We provide two options here:
     *
     * o The paranoid and default approach where we force a renegotiation when
     *   the cipher suite changed in _any_ way (which is straight-forward but
     *   often forces renegotiations too often and is perhaps not what the
     *   user actually wanted).
     *
     * o The optimized and still secure way where we force a renegotiation
     *   only if the currently active cipher is no longer contained in the
     *   reconfigured/new cipher suite. Any other changes are not important
     *   because it's the servers choice to select a cipher from the ones the
     *   client supports. So as long as the current cipher is still in the new
     *   cipher suite we're happy. Because we can assume we would have
     *   selected it again even when other (better) ciphers exists now in the
     *   new cipher suite. This approach is fine because the user explicitly
     *   has to enable this via ``SSLOptions +OptRenegotiate''. So we do no
     *   implicit optimizations.
     */</comment>     
    <expr_stmt><expr><name>ncipher_suite</name> = (<name><name>dc</name>-&gt;<name>szCipherSuite</name></name>? 
                     <name><name>dc</name>-&gt;<name>szCipherSuite</name></name> : (<name><name>r</name>-&gt;<name>server</name></name> != <name>handshakeserver</name>)?
                     <name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>cipher_suite</name></name> : <name>NULL</name>)</expr>;</expr_stmt>
    
    <if>if <condition>(<expr><name>ncipher_suite</name> &amp;&amp; (!<name><name>sslconn</name>-&gt;<name>cipher_suite</name></name> 
                          || <call><name>strcmp</name><argument_list>(<argument><expr><name>ncipher_suite</name></expr></argument>, <argument><expr><name><name>sslconn</name>-&gt;<name>cipher_suite</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <comment type="block">/* remember old state */</comment>

        <if>if <condition>(<expr><name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_OPTRENEGOTIATE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cipher</name> = <call><name>SSL_get_current_cipher</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>cipher_list_old</name> = (<call><name>STACK_OF</name><argument_list>(<argument><expr><name>SSL_CIPHER</name></expr></argument>)</argument_list></call> *)<call><name>SSL_get_ciphers</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>cipher_list_old</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cipher_list_old</name> = <call><name>sk_SSL_CIPHER_dup</name><argument_list>(<argument><expr><name>cipher_list_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>

        <comment type="block">/* configure new state */</comment>
        <if>if <condition>(<expr><name>is_slave</name></expr>)</condition><then> <block>{
            <comment type="block">/* TODO: this categorically fails changed cipher suite settings
             * on slave connections. We could do better by
             * - create a new SSL* from our SSL_CTX and set cipher suite there,
             *   and retrieve ciphers, free afterwards
             * Modifying the SSL on a slave connection is no good.
             */</comment>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-renegotiate-forbidden"</expr></argument>, <argument><expr>"cipher-suite"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr>!<call><name>SSL_set_cipher_list</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>ncipher_suite</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02253</expr></argument>)</argument_list></call>
                          "Unable to reconfigure (per-directory) "
                          "permitted SSL ciphers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>cipher_list_old</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>sk_SSL_CIPHER_free</name><argument_list>(<argument><expr><name>cipher_list_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* determine whether a renegotiation has to be forced */</comment>
        <expr_stmt><expr><name>cipher_list</name> = (<call><name>STACK_OF</name><argument_list>(<argument><expr><name>SSL_CIPHER</name></expr></argument>)</argument_list></call> *)<call><name>SSL_get_ciphers</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_OPTRENEGOTIATE</name></expr>)</condition><then> <block>{
            <comment type="block">/* optimized way */</comment>
            <if>if <condition>(<expr>(!<name>cipher</name> &amp;&amp; <name>cipher_list</name>) ||
                (<name>cipher</name> &amp;&amp; !<name>cipher_list</name>)</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>renegotiate</name> = <name>TRUE</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>cipher</name> &amp;&amp; <name>cipher_list</name> &amp;&amp;
                     (<call><name>sk_SSL_CIPHER_find</name><argument_list>(<argument><expr><name>cipher_list</name></expr></argument>, <argument><expr><name>cipher</name></expr></argument>)</argument_list></call> &lt; 0)</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>renegotiate</name> = <name>TRUE</name></expr>;</expr_stmt>
            }</block></then></if></else></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* paranoid way */</comment>
            <if>if <condition>(<expr>(!<name>cipher_list_old</name> &amp;&amp; <name>cipher_list</name>) ||
                (<name>cipher_list_old</name> &amp;&amp; !<name>cipher_list</name>)</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>renegotiate</name> = <name>TRUE</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>cipher_list_old</name> &amp;&amp; <name>cipher_list</name></expr>)</condition><then> <block>{
                <for>for (<init><expr><name>n</name> = 0</expr>;</init>
                     <condition><expr>!<name>renegotiate</name> &amp;&amp; (<name>n</name> &lt; <call><name>sk_SSL_CIPHER_num</name><argument_list>(<argument><expr><name>cipher_list</name></expr></argument>)</argument_list></call>)</expr>;</condition>
                     <incr><expr><name>n</name>++</expr></incr>)
                <block>{
                    <decl_stmt><decl><type><specifier>const</specifier> <name>SSL_CIPHER</name> *</type><name>value</name> <init>= <expr><call><name>sk_SSL_CIPHER_value</name><argument_list>(<argument><expr><name>cipher_list</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><call><name>sk_SSL_CIPHER_find</name><argument_list>(<argument><expr><name>cipher_list_old</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>renegotiate</name> = <name>TRUE</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>

                <for>for (<init><expr><name>n</name> = 0</expr>;</init>
                     <condition><expr>!<name>renegotiate</name> &amp;&amp; (<name>n</name> &lt; <call><name>sk_SSL_CIPHER_num</name><argument_list>(<argument><expr><name>cipher_list_old</name></expr></argument>)</argument_list></call>)</expr>;</condition>
                     <incr><expr><name>n</name>++</expr></incr>)
                <block>{
                    <decl_stmt><decl><type><specifier>const</specifier> <name>SSL_CIPHER</name> *</type><name>value</name> <init>= <expr><call><name>sk_SSL_CIPHER_value</name><argument_list>(<argument><expr><name>cipher_list_old</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                    <if>if <condition>(<expr><call><name>sk_SSL_CIPHER_find</name><argument_list>(<argument><expr><name>cipher_list</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>renegotiate</name> = <name>TRUE</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></for>
            }</block></then></if></else></if>
        }</block></else></if>

        <comment type="block">/* cleanup */</comment>
        <if>if <condition>(<expr><name>cipher_list_old</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>sk_SSL_CIPHER_free</name><argument_list>(<argument><expr><name>cipher_list_old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>renegotiate</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>is_slave</name></expr>)</condition><then> <block>{
                <comment type="block">/* The request causes renegotiation on a slave connection.
                 * This is not allowed since we might have concurrent requests
                 * on this connection.
                 */</comment>
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-renegotiate-forbidden"</expr></argument>, <argument><expr>"cipher-suite"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
            }</block></then></if>
            
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SSL_OP_CIPHER_SERVER_PREFERENCE</name></cpp:ifdef>
            <if>if <condition>(<expr><name><name>sc</name>-&gt;<name>cipher_server_pref</name></name> == <name>TRUE</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>SSL_set_options</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>SSL_OP_CIPHER_SERVER_PREFERENCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* tracing */</comment>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02220</expr></argument>)</argument_list></call>
                         "Reconfigured cipher suite will force renegotiation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/*
     * override of SSLVerifyClient
     *
     * We force a renegotiation if the reconfigured/new verify type is
     * stronger than the currently active verify type.
     *
     * The order is: none &lt;&lt; optional_no_ca &lt;&lt; optional &lt;&lt; require
     *
     * Additionally the following optimization is possible here: When the
     * currently active verify type is "none" but a client certificate is
     * already known/present, it's enough to manually force a client
     * verification but at least skip the I/O-intensive renegotiation
     * handshake.
     */</comment>
    <if>if <condition>(<expr>(<name><name>dc</name>-&gt;<name>nVerifyClient</name></name> != <name>SSL_CVERIFY_UNSET</name>) ||
        (<name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_mode</name></name> != <name>SSL_CVERIFY_UNSET</name>)</expr>)</condition><then> <block>{

        <comment type="block">/* remember old state */</comment>
        <expr_stmt><expr><name>verify_old</name> = <call><name>SSL_get_verify_mode</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* configure new state */</comment>
        <expr_stmt><expr><name>verify</name> = <name>SSL_VERIFY_NONE</name></expr>;</expr_stmt>

        <if>if <condition>(<expr>(<name><name>dc</name>-&gt;<name>nVerifyClient</name></name> == <name>SSL_CVERIFY_REQUIRE</name>) ||
            (<name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_mode</name></name> == <name>SSL_CVERIFY_REQUIRE</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>verify</name> |= <name>SSL_VERIFY_PEER_STRICT</name></expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr>(<name><name>dc</name>-&gt;<name>nVerifyClient</name></name> == <name>SSL_CVERIFY_OPTIONAL</name>) ||
            (<name><name>dc</name>-&gt;<name>nVerifyClient</name></name> == <name>SSL_CVERIFY_OPTIONAL_NO_CA</name>) ||
            (<name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_mode</name></name> == <name>SSL_CVERIFY_OPTIONAL</name>) ||
            (<name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_mode</name></name> == <name>SSL_CVERIFY_OPTIONAL_NO_CA</name>)</expr>)</condition><then>
        <block>{
            <expr_stmt><expr><name>verify</name> |= <name>SSL_VERIFY_PEER</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* TODO: this seems premature since we do not know if there
         *       are any changes required.
         */</comment>
        <expr_stmt><expr><call><name>SSL_set_verify</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>verify</name></expr></argument>, <argument><expr><name>ssl_callback_SSLVerify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SSL_set_verify_result</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>X509_V_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* determine whether we've to force a renegotiation */</comment>
        <if>if <condition>(<expr>!<name>renegotiate</name> &amp;&amp; <name>verify</name> != <name>verify_old</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>((<name>verify_old</name> == <name>SSL_VERIFY_NONE</name>) &amp;&amp;
                 (<name>verify</name>     != <name>SSL_VERIFY_NONE</name>)) ||

                (!(<name>verify_old</name> &amp; <name>SSL_VERIFY_PEER</name>) &amp;&amp;
                  (<name>verify</name>     &amp; <name>SSL_VERIFY_PEER</name>)) ||

                (!(<name>verify_old</name> &amp; <name>SSL_VERIFY_FAIL_IF_NO_PEER_CERT</name>) &amp;&amp;
                  (<name>verify</name>     &amp; <name>SSL_VERIFY_FAIL_IF_NO_PEER_CERT</name>))</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><name>renegotiate</name> = <name>TRUE</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>is_slave</name></expr>)</condition><then> <block>{
                    <comment type="block">/* The request causes renegotiation on a slave connection.
                     * This is not allowed since we might have concurrent requests
                     * on this connection.
                     */</comment>
                    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-renegotiate-forbidden"</expr></argument>, <argument><expr>"verify-client"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>SSL_set_verify</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>verify_old</name></expr></argument>, <argument><expr><name>ssl_callback_SSLVerify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
                }</block></then></if>
                <comment type="block">/* optimization */</comment>

                <if>if <condition>(<expr>(<name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_OPTRENEGOTIATE</name>) &amp;&amp;
                    (<name>verify_old</name> == <name>SSL_VERIFY_NONE</name>) &amp;&amp;
                    ((<name>peercert</name> = <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call>) != <name>NULL</name>)</expr>)</condition><then>
                <block>{
                    <expr_stmt><expr><name>renegotiate_quick</name> = <name>TRUE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name>peercert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>

                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02255</expr></argument>)</argument_list></call>
                              "Changed client verification type will force "
                              "%srenegotiation"</expr></argument>,
                              <argument><expr><name>renegotiate_quick</name> ? "quick " : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>verify</name> != <name>SSL_VERIFY_NONE</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * override of SSLVerifyDepth
                 *
                 * The depth checks are handled by us manually inside the
                 * verify callback function and not by OpenSSL internally
                 * (and our function is aware of both the per-server and
                 * per-directory contexts). So we cannot ask OpenSSL about
                 * the currently verify depth. Instead we remember it in our
                 * SSLConnRec attached to the SSL* of OpenSSL.  We've to force
                 * the renegotiation if the reconfigured/new verify depth is
                 * less than the currently active/remembered verify depth
                 * (because this means more restriction on the certificate
                 * chain).
                 */</comment>
                <expr_stmt><expr><name>n</name> = (<name><name>sslconn</name>-&gt;<name>verify_depth</name></name> != <name>UNSET</name>)
                    ? <name><name>sslconn</name>-&gt;<name>verify_depth</name></name>
                    : <name><name>hssc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_depth</name></name></expr>;</expr_stmt>
                <comment type="block">/* determine the new depth */</comment>
                <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>verify_depth</name></name> = (<name><name>dc</name>-&gt;<name>nVerifyDepth</name></name> != <name>UNSET</name>)
                                        ? <name><name>dc</name>-&gt;<name>nVerifyDepth</name></name>
                                        : <name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_depth</name></name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>verify_depth</name></name> &lt; <name>n</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>renegotiate</name> = <name>TRUE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02254</expr></argument>)</argument_list></call>
                                  "Reduced client verification depth will "
                                  "force renegotiation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if></else></if>
        }</block></then></if>
        <comment type="block">/* If we're handling a request for a vhost other than the default one,
         * then we need to make sure that client authentication is properly
         * enforced. For clients supplying an SNI extension, the peer
         * certificate verification has happened in the handshake already
         * (and r-&gt;server == handshakeserver). For non-SNI requests,
         * an additional check is needed here. If client authentication
         * is configured as mandatory, then we can only proceed if the
         * CA list doesn't have to be changed (OpenSSL doesn't provide
         * an option to change the list for an existing session).
         */</comment>
        <if>if <condition>(<expr>(<name><name>r</name>-&gt;<name>server</name></name> != <name>handshakeserver</name>)
            &amp;&amp; <name>renegotiate</name>
            &amp;&amp; ((<name>verify</name> &amp; <name>SSL_VERIFY_PEER</name>) ||
                (<name>verify</name> &amp; <name>SSL_VERIFY_FAIL_IF_NO_PEER_CERT</name>))</expr>)</condition><then> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MODSSL_CFG_CA_NE</name><parameter_list>(<param><type><name>f</name></type></param>, <param><type><name>sc1</name></type></param>, <param><type><name>sc2</name></type></param>)</parameter_list></cpp:macro> \
            <cpp:value>(sc1-&gt;server-&gt;auth.f &amp;&amp; \
             (!sc2-&gt;server-&gt;auth.f || \
              strNE(sc1-&gt;server-&gt;auth.f, sc2-&gt;server-&gt;auth.f)))</cpp:value></cpp:define>

            <if>if <condition>(<expr><call><name>MODSSL_CFG_CA_NE</name><argument_list>(<argument><expr><name>ca_cert_file</name></expr></argument>, <argument><expr><name>sc</name></expr></argument>, <argument><expr><name>hssc</name></expr></argument>)</argument_list></call> ||
                <call><name>MODSSL_CFG_CA_NE</name><argument_list>(<argument><expr><name>ca_cert_path</name></expr></argument>, <argument><expr><name>sc</name></expr></argument>, <argument><expr><name>hssc</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>verify</name> &amp; <name>SSL_VERIFY_FAIL_IF_NO_PEER_CERT</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02256</expr></argument>)</argument_list></call>
                         "Non-default virtual host with SSLVerify set to "
                         "'require' and VirtualHost-specific CA certificate "
                         "list is only available to clients with TLS server "
                         "name indication (SNI) support"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>SSL_set_verify</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>verify_old</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
                }</block></then> <else>else
                    <comment type="block">/* let it pass, possibly with an "incorrect" peer cert,
                     * so make sure the SSL_CLIENT_VERIFY environment variable
                     * will indicate partial success only, later on.
                     */</comment>
                    <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>verify_info</name></name> = "GENEROUS"</expr>;</expr_stmt></else></if>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If a renegotiation is now required for this location, and the
     * request includes a message body (and the client has not
     * requested a "100 Continue" response), then the client will be
     * streaming the request body over the wire already.  In that
     * case, it is not possible to stop and perform a new SSL
     * handshake immediately; once the SSL library moves to the
     * "accept" state, it will reject the SSL packets which the client
     * is sending for the request body.
     *
     * To allow authentication to complete in this auth hook, the
     * solution used here is to fill a (bounded) buffer with the
     * request body, and then to reinject that request body later.
     */</comment>
    <if>if <condition>(<expr><name>renegotiate</name> &amp;&amp; !<name>renegotiate_quick</name>
        &amp;&amp; (<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"transfer-encoding"</expr></argument>)</argument_list></call>
            || (<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"content-length"</expr></argument>)</argument_list></call>
                &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"content-length"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call>))
        &amp;&amp; !<name><name>r</name>-&gt;<name>expecting_100</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>rsize</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rsize</name> = <name><name>dc</name>-&gt;<name>nRenegBufferSize</name></name> == <name>UNSET</name> ? <name>DEFAULT_RENEG_BUFFER_SIZE</name> :
                                                <name><name>dc</name>-&gt;<name>nRenegBufferSize</name></name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rsize</name> &gt; 0</expr>)</condition><then> <block>{
            <comment type="block">/* Fill the I/O buffer with the request body if possible. */</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>ssl_io_buffer_fill</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>rsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* If the reneg buffer size is set to zero, just fail. */</comment>
            <expr_stmt><expr><name>rv</name> = <name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name>rv</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02257</expr></argument>)</argument_list></call>
                          "could not buffer message body to allow "
                          "SSL renegotiation to proceed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/*
     * now do the renegotiation if anything was actually reconfigured
     */</comment>
    <if>if <condition>(<expr><name>renegotiate</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * Now we force the SSL renegotiation by sending the Hello Request
         * message to the client. Here we have to do a workaround: Actually
         * OpenSSL returns immediately after sending the Hello Request (the
         * intent AFAIK is because the SSL/TLS protocol says it's not a must
         * that the client replies to a Hello Request). But because we insist
         * on a reply (anything else is an error for us) we have to go to the
         * ACCEPT state manually. Using SSL_set_accept_state() doesn't work
         * here because it resets too much of the connection.  So we set the
         * state explicitly and continue the handshake manually.
         */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02221</expr></argument>)</argument_list></call>
                      "Requesting connection re-negotiation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>renegotiate_quick</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> *<name>cert_stack</name></expr>;</expr_stmt>

            <comment type="block">/* perform just a manual re-verification of the peer */</comment>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02258</expr></argument>)</argument_list></call>
                         "Performing quick renegotiation: "
                         "just re-verifying the peer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>cert_stack</name> = (<call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> *)<call><name>SSL_get_peer_cert_chain</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>cert</name> = <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<name>cert_stack</name> || (<call><name>sk_X509_num</name><argument_list>(<argument><expr><name>cert_stack</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
                <if>if <condition>(<expr>!<name>cert</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02222</expr></argument>)</argument_list></call>
                                  "Cannot find peer certificate chain"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
                }</block></then></if>

                <comment type="block">/* client cert is in the session cache, but there is
                 * no chain, since ssl3_get_client_certificate()
                 * sk_X509_shift-ed the peer cert out of the chain.
                 * we put it back here for the purpose of quick_renegotiation.
                 */</comment>
                <expr_stmt><expr><name>cert_stack</name> = <call><name>sk_X509_new_null</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>sk_X509_push</name><argument_list>(<argument><expr><name>cert_stack</name></expr></argument>, <argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <if>if <condition>(<expr>!(<name>cert_store</name> ||
                  (<name>cert_store</name> = <call><name>SSL_CTX_get_cert_store</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call>))</expr>)</condition><then>
            <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02223</expr></argument>)</argument_list></call>
                              "Cannot find certificate storage"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr>!<name>cert</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cert</name> = <call><name>sk_X509_value</name><argument_list>(<argument><expr><name>cert_stack</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><name>cert_store_ctx</name> = <call><name>X509_STORE_CTX_new</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>X509_STORE_CTX_init</name><argument_list>(<argument><expr><name>cert_store_ctx</name></expr></argument>, <argument><expr><name>cert_store</name></expr></argument>, <argument><expr><name>cert</name></expr></argument>, <argument><expr><name>cert_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>depth</name> = <call><name>SSL_get_verify_depth</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>depth</name> &gt;= 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>X509_STORE_CTX_set_depth</name><argument_list>(<argument><expr><name>cert_store_ctx</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name>X509_STORE_CTX_set_ex_data</name><argument_list>(<argument><expr><name>cert_store_ctx</name></expr></argument>,
                                       <argument><expr><call><name>SSL_get_ex_data_X509_STORE_CTX_idx</name><argument_list>()</argument_list></call></expr></argument>,
                                       <argument><expr>(<name>char</name> *)<name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<call><name>X509_verify_cert</name><argument_list>(<argument><expr><name>cert_store_ctx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02224</expr></argument>)</argument_list></call>
                              "Re-negotiation verification step failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

            <expr_stmt><expr><call><name>SSL_set_verify_result</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><call><name>X509_STORE_CTX_get_error</name><argument_list>(<argument><expr><name>cert_store_ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>X509_STORE_CTX_cleanup</name><argument_list>(<argument><expr><name>cert_store_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>X509_STORE_CTX_free</name><argument_list>(<argument><expr><name>cert_store_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr><name>cert_stack</name> != <call><name>SSL_get_peer_cert_chain</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* we created this ourselves, so free it */</comment>
                <expr_stmt><expr><call><name>sk_X509_pop_free</name><argument_list>(<argument><expr><name>cert_stack</name></expr></argument>, <argument><expr><name>X509_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>char</name></type> <name><name>peekbuf</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reneg_support</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>request_rec</name> *</type><name>id</name> <init>= <expr><name><name>r</name>-&gt;<name/></name>main ? <name><name>r</name>-&gt;<name/></name>main : <name>r</name></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Additional mitigation for CVE-2009-3555: At this point,
             * before renegotiating, an (entire) request has been read
             * from the connection.  An attacker may have sent further
             * data to "prefix" any subsequent request by the victim's
             * client after the renegotiation; this data may already
             * have been read and buffered.  Forcing a connection
             * closure after the response ensures such data will be
             * discarded.  Legimately pipelined HTTP requests will be
             * retried anyway with this approach. */</comment>
            <if>if <condition>(<expr><call><name>has_buffered_data</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02259</expr></argument>)</argument_list></call>
                              "insecure SSL re-negotiation required, but "
                              "a pipelined request is present; keepalive "
                              "disabled"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
            }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SSL_get_secure_renegotiation_support</name></expr></argument>)</argument_list></call></expr></cpp:if>
            <expr_stmt><expr><name>reneg_support</name> = <call><name>SSL_get_secure_renegotiation_support</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> ?
                            "client does" : "client does not"</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><name>reneg_support</name> = "server does not"</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <comment type="block">/* Perform a full renegotiation. */</comment>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02260</expr></argument>)</argument_list></call>
                          "Performing full renegotiation: complete handshake "
                          "protocol (%s support secure renegotiation)"</expr></argument>,
                          <argument><expr><name>reneg_support</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SSL_set_session_id_context</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>,
                                       <argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>id</name></expr></argument>,
                                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Toggle the renegotiation state to allow the new
             * handshake to proceed. */</comment>
            <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>reneg_state</name></name> = <name>RENEG_ALLOW</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SSL_renegotiate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SSL_do_handshake</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<call><name>SSL_is_init_finished</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02225</expr></argument>)</argument_list></call>
                              "Re-negotiation request failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02226</expr></argument>)</argument_list></call>
                          "Awaiting re-negotiation handshake"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* XXX: Should replace setting state with SSL_renegotiate(ssl);
             * However, this causes failures in perl-framework currently,
             * perhaps pre-test if we have already negotiated?
             */</comment>
            <comment type="block">/* Need to trigger renegotiation handshake by reading.
             * Peeking 0 bytes actually works.
             * See: http://marc.info/?t=145493359200002&amp;r=1&amp;w=2
             */</comment>
            <expr_stmt><expr><call><name>SSL_peek</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>peekbuf</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>reneg_state</name></name> = <name>RENEG_REJECT</name></expr>;</expr_stmt>

            <if>if <condition>(<expr>!<call><name>SSL_is_init_finished</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02261</expr></argument>)</argument_list></call>
                              "Re-negotiation handshake failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ssl_log_ssl_error</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
            }</block></then></if>

            <comment type="block">/* Full renegotiation successful, we now have handshaken with
             * this server's parameters.
             */</comment>
            <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>server</name></name> = <name><name>r</name>-&gt;<name>server</name></name></expr>;</expr_stmt>
        }</block></else></if>

        <comment type="block">/*
         * Remember the peer certificate's DN
         */</comment>
        <if>if <condition>(<expr>(<name>cert</name> = <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name> = <name>cert</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>client_dn</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/*
         * Finally check for acceptable renegotiation results
         */</comment>
        <if>if <condition>(<expr>(<name><name>dc</name>-&gt;<name>nVerifyClient</name></name> != <name>SSL_CVERIFY_NONE</name>) ||
            (<name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_mode</name></name> != <name>SSL_CVERIFY_NONE</name>)</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>BOOL</name></type> <name>do_verify</name> <init>= <expr>((<name><name>dc</name>-&gt;<name>nVerifyClient</name></name> == <name>SSL_CVERIFY_REQUIRE</name>) ||
                              (<name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>verify_mode</name></name> == <name>SSL_CVERIFY_REQUIRE</name>))</expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>do_verify</name> &amp;&amp; (<call><name>SSL_get_verify_result</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> != <name>X509_V_OK</name>)</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02262</expr></argument>)</argument_list></call>
                              "Re-negotiation handshake failed: "
                              "Client verification failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>do_verify</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr>(<name>peercert</name> = <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02263</expr></argument>)</argument_list></call>
                                  "Re-negotiation handshake failed: "
                                  "Client certificate missing"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
                }</block></then></if>

                <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name>peercert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/*
         * Also check that SSLCipherSuite has been enforced as expected.
         */</comment>
        <if>if <condition>(<expr><name>cipher_list</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>cipher</name> = <call><name>SSL_get_current_cipher</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><call><name>sk_SSL_CIPHER_find</name><argument_list>(<argument><expr><name>cipher_list</name></expr></argument>, <argument><expr><name>cipher</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02264</expr></argument>)</argument_list></call>
                             "SSL cipher suite not renegotiated: "
                             "access to %s denied using cipher %s"</expr></argument>,
                              <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                              <argument><expr><call><name>SSL_CIPHER_get_name</name><argument_list>(<argument><expr><name>cipher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
        <comment type="block">/* remember any new cipher suite used in renegotiation */</comment>
        <if>if <condition>(<expr><name>ncipher_suite</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>cipher_suite</name></name> = <name>ncipher_suite</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* If we're trying to have the user name set from a client
     * certificate then we need to set it here. This should be safe as
     * the user name probably isn't important from an auth checking point
     * of view as the certificate supplied acts in that capacity.
     * However, if FakeAuth is being used then this isn't the case so
     * we need to postpone setting the username until later.
     */</comment>
    <if>if <condition>(<expr>(<name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_FAKEBASICAUTH</name>) == 0 &amp;&amp; <name><name>dc</name>-&gt;<name>szUserName</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>val</name> <init>= <expr><call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>,
                                   <argument><expr><name>r</name></expr></argument>, <argument><expr>(<name>char</name> *)<name><name>dc</name>-&gt;<name>szUserName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>val</name> &amp;&amp; <name><name>val</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>r</name>-&gt;<name>user</name></name> = <name>val</name></expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02227</expr></argument>)</argument_list></call>
                          "Failed to set r-&gt;user to '%s'"</expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>szUserName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>

    <comment type="block">/*
     * Check SSLRequire boolean expressions
     */</comment>
    <expr_stmt><expr><name>requires</name> = <name><name>dc</name>-&gt;<name>aRequirement</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>ssl_requires</name> = (<name>ssl_require_t</name> *)<name><name>requires</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>requires</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type><name>ssl_require_t</name> *</type><name>req</name> <init>= <expr>&amp;<name><name>ssl_requires</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errstring</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>ok</name> = <call><name>ap_expr_exec</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>mpExpr</name></name></expr></argument>, <argument><expr>&amp;<name>errstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>ok</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02265</expr></argument>)</argument_list></call>
                          "access to %s failed, reason: Failed to execute "
                          "SSL requirement expression: %s"</expr></argument>,
                          <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name>errstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* remember forbidden access for strict require option */</comment>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-access-forbidden"</expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>ok</name> != 1</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02266</expr></argument>)</argument_list></call>
                          "Access to %s denied for %s "
                          "(requirement expression not fulfilled)"</expr></argument>,
                          <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>useragent_ip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02228</expr></argument>)</argument_list></call>
                          "Failed expression: %s"</expr></argument>, <argument><expr><name><name>req</name>-&gt;<name>cpExpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02229</expr></argument>)</argument_list></call>
                          "access to %s failed, reason: %s"</expr></argument>,
                          <argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                          <argument><expr>"SSL requirement expression not fulfilled"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* remember forbidden access for strict require option */</comment>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-access-forbidden"</expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <comment type="block">/*
     * Else access is granted from our point of view (except vendor
     * handlers override). But we have to return DECLINED here instead
     * of OK, because mod_auth and other modules still might want to
     * deny access.
     */</comment>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<comment type="block">/*
 *  Authentication Handler:
 *  Fake a Basic authentication from the X509 client certificate.
 *
 *  This must be run fairly early on to prevent a real authentication from
 *  occurring, in particular it must be run before anything else that
 *  authenticates a user.  This means that the Module statement for this
 *  module should be LAST in the Configuration file.
 */</comment>
<function><type><name>int</name></type> <name>ssl_hook_UserCheck</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name> <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLDirConfigRec</name> *</type><name>dc</name> <init>= <expr><call><name>myDirConfig</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>clientdn</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>auth_line</name></decl>, *<decl><type ref="prev"/><name>username</name></decl>, *<decl><type ref="prev"/><name>password</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Additionally forbid access (again)
     * when strict require option is used.
     */</comment>
    <if>if <condition>(<expr>(<name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_STRICTREQUIRE</name>) &amp;&amp;
        (<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-access-forbidden"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
        <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * We decline when we are in a subrequest.  The Authorization header
     * would already be present if it was added in the main request.
     */</comment>
    <if>if <condition>(<expr>!<call><name>ap_is_initial_req</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Make sure the user is not able to fake the client certificate
     * based authentication by just entering an X.509 Subject DN
     * ("/XX=YYY/XX=YYY/..") as the username and "password" as the
     * password.
     */</comment>
    <if>if <condition>(<expr>(<name>auth_line</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Authorization"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>strcEQ</name><argument_list>(<argument><expr><call><name>ap_getword</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>auth_line</name></expr></argument>, <argument><expr>' '</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"Basic"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <while>while <condition>(<expr>(*<name>auth_line</name> == ' ') || (*<name>auth_line</name> == '\t')</expr>)</condition> <block>{
                <expr_stmt><expr><name>auth_line</name>++</expr>;</expr_stmt>
            }</block></while>

            <expr_stmt><expr><name>auth_line</name> = <call><name>ap_pbase64decode</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>auth_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>username</name> = <call><name>ap_getword_nulls</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>auth_line</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>password</name> = <name>auth_line</name></expr>;</expr_stmt>

            <if>if <condition>(<expr>(<name><name>username</name><index>[<expr>0</expr>]</index></name> == '/') &amp;&amp; <call><name>strEQ</name><argument_list>(<argument><expr><name>password</name></expr></argument>, <argument><expr>"password"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02035</expr></argument>)</argument_list></call>
                    "Encountered FakeBasicAuth spoof: %s"</expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/*
     * We decline operation in various situations...
     * - SSLOptions +FakeBasicAuth not configured
     * - r-&gt;user already authenticated
     * - ssl not enabled
     * - client did not present a certificate
     */</comment>
    <if>if <condition>(<expr>!((<name><name>sc</name>-&gt;<name>enabled</name></name> == <name>SSL_ENABLED_TRUE</name> || <name><name>sc</name>-&gt;<name>enabled</name></name> == <name>SSL_ENABLED_OPTIONAL</name>)
          &amp;&amp; <name>sslconn</name> &amp;&amp; <name><name>sslconn</name>-&gt;<name>ssl</name></name> &amp;&amp; <name><name>sslconn</name>-&gt;<name>client_cert</name></name>) ||
        !(<name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_FAKEBASICAUTH</name>) || <name><name>r</name>-&gt;<name>user</name></name></expr>)</condition><then>
    <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name><name>sslconn</name>-&gt;<name>client_dn</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>X509_NAME</name> *</type><name>name</name> <init>= <expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>cp</name> <init>= <expr><call><name>X509_NAME_oneline</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>client_dn</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>OPENSSL_free</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>clientdn</name> = (<name>char</name> *)<name><name>sslconn</name>-&gt;<name>client_dn</name></name></expr>;</expr_stmt>

    <comment type="block">/*
     * Fake a password - which one would be immaterial, as, it seems, an empty
     * password in the users file would match ALL incoming passwords, if only
     * we were using the standard crypt library routine. Unfortunately, OpenSSL
     * "fixes" a "bug" in crypt and thus prevents blank passwords from
     * working.  (IMHO what they really fix is a bug in the users of the code
     * - failing to program correctly for shadow passwords).  We need,
     * therefore, to provide a password. This password can be matched by
     * adding the string "xxj31ZMTZzkVA" as the password in the user file.
     * This is just the crypted variant of the word "password" ;-)
     */</comment>
    <expr_stmt><expr><name>auth_line</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"Basic "</expr></argument>,
                            <argument><expr><call><name>ap_pbase64encode</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                             <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>clientdn</name></expr></argument>,
                                                         <argument><expr>":password"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Authorization"</expr></argument>, <argument><expr><name>auth_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02036</expr></argument>)</argument_list></call>
                  "Faking HTTP Basic Auth header: \"Authorization: %s\""</expr></argument>,
                  <argument><expr><name>auth_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<comment type="block">/* authorization phase */</comment>
<function><type><name>int</name></type> <name>ssl_hook_Auth</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLDirConfigRec</name> *</type><name>dc</name> <init>= <expr><call><name>myDirConfig</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Additionally forbid access (again)
     * when strict require option is used.
     */</comment>
    <if>if <condition>(<expr>(<name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_STRICTREQUIRE</name>) &amp;&amp;
        (<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-access-forbidden"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
        <return>return <expr><name>HTTP_FORBIDDEN</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<comment type="block">/*
 *   Fixup Handler
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name><name>ssl_hook_Fixup_vars</name><index>[]</index></name> <init>= <expr><block>{
    <expr>"SSL_VERSION_INTERFACE"</expr>,
    <expr>"SSL_VERSION_LIBRARY"</expr>,
    <expr>"SSL_PROTOCOL"</expr>,
    <expr>"SSL_SECURE_RENEG"</expr>,
    <expr>"SSL_COMPRESS_METHOD"</expr>,
    <expr>"SSL_CIPHER"</expr>,
    <expr>"SSL_CIPHER_EXPORT"</expr>,
    <expr>"SSL_CIPHER_USEKEYSIZE"</expr>,
    <expr>"SSL_CIPHER_ALGKEYSIZE"</expr>,
    <expr>"SSL_CLIENT_VERIFY"</expr>,
    <expr>"SSL_CLIENT_M_VERSION"</expr>,
    <expr>"SSL_CLIENT_M_SERIAL"</expr>,
    <expr>"SSL_CLIENT_V_START"</expr>,
    <expr>"SSL_CLIENT_V_END"</expr>,
    <expr>"SSL_CLIENT_V_REMAIN"</expr>,
    <expr>"SSL_CLIENT_S_DN"</expr>,
    <expr>"SSL_CLIENT_I_DN"</expr>,
    <expr>"SSL_CLIENT_A_KEY"</expr>,
    <expr>"SSL_CLIENT_A_SIG"</expr>,
    <expr>"SSL_CLIENT_CERT_RFC4523_CEA"</expr>,
    <expr>"SSL_SERVER_M_VERSION"</expr>,
    <expr>"SSL_SERVER_M_SERIAL"</expr>,
    <expr>"SSL_SERVER_V_START"</expr>,
    <expr>"SSL_SERVER_V_END"</expr>,
    <expr>"SSL_SERVER_S_DN"</expr>,
    <expr>"SSL_SERVER_I_DN"</expr>,
    <expr>"SSL_SERVER_A_KEY"</expr>,
    <expr>"SSL_SERVER_A_SIG"</expr>,
    <expr>"SSL_SESSION_ID"</expr>,
    <expr>"SSL_SESSION_RESUMED"</expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SRP</name></cpp:ifdef>
    <expr>"SSL_SRP_USER"</expr>,
    <expr>"SSL_SRP_USERINFO"</expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>ssl_hook_Fixup</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name> <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLDirConfigRec</name> *</type><name>dc</name> <init>= <expr><call><name>myDirConfig</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>env</name> <init>= <expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>var</name></decl>, *<decl><type ref="prev"/><name>val</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>servername</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> *<name>peer_certs</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!(<name>sslconn</name> &amp;&amp; <name><name>sslconn</name>-&gt;<name>ssl</name></name>) &amp;&amp; <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>master</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>sslconn</name> = <call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>master</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Check to see if SSL is on
     */</comment>
    <if>if <condition>(<expr>!(((<name><name>sc</name>-&gt;<name>enabled</name></name> == <name>SSL_ENABLED_TRUE</name>) || (<name><name>sc</name>-&gt;<name>enabled</name></name> == <name>SSL_ENABLED_OPTIONAL</name>)) &amp;&amp; <name>sslconn</name> &amp;&amp; (<name>ssl</name> = <name><name>sslconn</name>-&gt;<name>ssl</name></name>))</expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/*
     * Annotate the SSI/CGI environment with standard SSL information
     */</comment>
    <comment type="block">/* the always present HTTPS (=HTTP over SSL) flag! */</comment>
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr>"HTTPS"</expr></argument>, <argument><expr>"on"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
    <comment type="block">/* add content of SNI TLS extension (if supplied with ClientHello) */</comment>
    <if>if <condition>(<expr>(<name>servername</name> = <call><name>SSL_get_servername</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>TLSEXT_NAMETYPE_host_name</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_set</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr>"SSL_TLS_SNI"</expr></argument>, <argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* standard SSL environment variables */</comment>
    <if>if <condition>(<expr><name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_STDENVVARS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>modssl_var_extract_dns</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>modssl_var_extract_san_entries</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>ssl_hook_Fixup_vars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>var</name> = (<name>char</name> *)<name><name>ssl_hook_Fixup_vars</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>val</name> = <call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<call><name>strIsEmpty</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <comment type="block">/*
     * On-demand bloat up the SSI/CGI environment with certificate data
     */</comment>
    <if>if <condition>(<expr><name><name>dc</name>-&gt;<name>nOptions</name></name> &amp; <name>SSL_OPT_EXPORTCERTDATA</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>val</name> = <call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>,
                             <argument><expr><name>r</name></expr></argument>, <argument><expr>"SSL_SERVER_CERT"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr>"SSL_SERVER_CERT"</expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>val</name> = <call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>,
                             <argument><expr><name>r</name></expr></argument>, <argument><expr>"SSL_CLIENT_CERT"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr>"SSL_CLIENT_CERT"</expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr>(<name>peer_certs</name> = (<call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> *)<call><name>SSL_get_peer_cert_chain</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>sk_X509_num</name><argument_list>(<argument><expr><name>peer_certs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
                <expr_stmt><expr><name>var</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"SSL_CLIENT_CERT_CHAIN_%d"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>val</name> = <call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>,
                                     <argument><expr><name>r</name></expr></argument>, <argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>val</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>env</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
    }</block></then></if>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SSL_get_secure_renegotiation_support</name></cpp:ifdef>
    <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"ssl-secure-reneg"</expr></argument>,
                   <argument><expr><call><name>SSL_get_secure_renegotiation_support</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> ? "1" : "0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<comment type="block">/*  _________________________________________________________________
**
**  Authz providers for use with mod_authz_core
**  _________________________________________________________________
*/</comment>

<function><type><specifier>static</specifier> <name>authz_status</name></type> <name>ssl_authz_require_ssl_check</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>require_line</name></decl></param>,
                                                <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>parsed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name> <init>= <expr><name>sslconn</name> ? <name><name>sslconn</name>-&gt;<name>ssl</name></name> : <name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>ssl</name></expr>)</condition><then>
        <return>return <expr><name>AUTHZ_GRANTED</name></expr>;</return></then>
    <else>else
        <return>return <expr><name>AUTHZ_DENIED</name></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ssl_authz_require_ssl_parse</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>require_line</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>parsed</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>require_line</name> &amp;&amp; <name><name>require_line</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
        <return>return <expr>"'Require ssl' does not take arguments"</expr>;</return></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>authz_provider</name></type> <name>ssl_authz_provider_require_ssl</name> <init>=
<expr><block>{
    <expr>&amp;<name>ssl_authz_require_ssl_check</name></expr>,
    <expr>&amp;<name>ssl_authz_require_ssl_parse</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>authz_status</name></type> <name>ssl_authz_verify_client_check</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>require_line</name></decl></param>,
                                                  <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>parsed</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name> <init>= <expr><name>sslconn</name> ? <name><name>sslconn</name>-&gt;<name>ssl</name></name> : <name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>ssl</name></expr>)</condition><then>
        <return>return <expr><name>AUTHZ_DENIED</name></expr>;</return></then></if>

    <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>verify_error</name></name> == <name>NULL</name> &amp;&amp;
        <name><name>sslconn</name>-&gt;<name>verify_info</name></name> == <name>NULL</name> &amp;&amp;
        <call><name>SSL_get_verify_result</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> == <name>X509_V_OK</name></expr>)</condition><then>
    <block>{
        <decl_stmt><decl><type><name>X509</name> *</type><name>xs</name> <init>= <expr><call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>xs</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name>xs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>AUTHZ_GRANTED</name></expr>;</return>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name>xs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <return>return <expr><name>AUTHZ_DENIED</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ssl_authz_verify_client_parse</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>,
                                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>require_line</name></decl></param>,
                                                 <param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>parsed</name></decl></param>)</parameter_list>
<block>{
    <if>if <condition>(<expr><name>require_line</name> &amp;&amp; <name><name>require_line</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
        <return>return <expr>"'Require ssl-verify-client' does not take arguments"</expr>;</return></then></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>const</specifier> <name>authz_provider</name></type> <name>ssl_authz_provider_verify_client</name> <init>=
<expr><block>{
    <expr>&amp;<name>ssl_authz_verify_client_check</name></expr>,
    <expr>&amp;<name>ssl_authz_verify_client_parse</name></expr>,
}</block></expr></init></decl>;</decl_stmt>



<comment type="block">/*  _________________________________________________________________
**
**  OpenSSL Callback Functions
**  _________________________________________________________________
*/</comment>

<comment type="block">/*
 * Hand out standard DH parameters, based on the authentication strength
 */</comment>
<function><type><name>DH</name> *</type><name>ssl_callback_TmpDH</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>, <param><decl><type><name>int</name></type> <name>export</name></decl></param>, <param><decl><type><name>int</name></type> <name>keylen</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>EVP_PKEY</name> *</type><name>pkey</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SSL_CERT_SET_SERVER</name></cpp:ifdef>
    <comment type="block">/*
     * When multiple certs/keys are configured for the SSL_CTX: make sure
     * that we get the private key which is indeed used for the current
     * SSL connection (available in OpenSSL 1.0.2 or later only)
     */</comment>
    <expr_stmt><expr><call><name>SSL_set_current_cert</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>SSL_CERT_SET_SERVER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name>pkey</name> = <call><name>SSL_get_privatekey</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPENSSL_VERSION_NUMBER</name> &lt; 0x10100000L</expr></cpp:if>
    <expr_stmt><expr><name>type</name> = <name>pkey</name> ? <call><name>EVP_PKEY_type</name><argument_list>(<argument><expr><name><name>pkey</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call> : <name>EVP_PKEY_NONE</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>type</name> = <name>pkey</name> ? <call><name>EVP_PKEY_base_id</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>)</argument_list></call> : <name>EVP_PKEY_NONE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * OpenSSL will call us with either keylen == 512 or keylen == 1024
     * (see the definition of SSL_EXPORT_PKEYLENGTH in ssl_locl.h).
     * Adjust the DH parameter length according to the size of the
     * RSA/DSA private key used for the current connection, and always
     * use at least 1024-bit parameters.
     * Note: This may cause interoperability issues with implementations
     * which limit their DH support to 1024 bit - e.g. Java 7 and earlier.
     * In this case, SSLCertificateFile can be used to specify fixed
     * 1024-bit DH parameters (with the effect that OpenSSL skips this
     * callback).
     */</comment>
    <if>if <condition>(<expr>(<name>type</name> == <name>EVP_PKEY_RSA</name>) || (<name>type</name> == <name>EVP_PKEY_DSA</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>keylen</name> = <call><name>EVP_PKEY_bits</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                  <argument><expr>"handing out built-in DH parameters for %d-bit authenticated connection"</expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><call><name>modssl_get_dh_params</name><argument_list>(<argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/*
 * This OpenSSL callback function is called when OpenSSL
 * does client authentication and verifies the certificate chain.
 */</comment>
<function><type><name>int</name></type> <name>ssl_callback_SSLVerify</name><parameter_list>(<param><decl><type><name>int</name></type> <name>ok</name></decl></param>, <param><decl><type><name>X509_STORE_CTX</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Get Apache context back through OpenSSL context */</comment>
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name> <init>= <expr><call><name>X509_STORE_CTX_get_ex_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
                                          <argument><expr><call><name>SSL_get_ex_data_X509_STORE_CTX_idx</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>conn</name>      <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name>      <init>= <expr>(<name>request_rec</name> *)<call><name>modssl_get_app_data2</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name>       <init>= <expr><name>r</name> ? <name><name>r</name>-&gt;<name>server</name></name> : <call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name> <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLDirConfigRec</name> *</type><name>dc</name> <init>= <expr><name>r</name> ? <call><name>myDirConfig</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>modssl_ctx_t</name> *</type><name>mctx</name>  <init>= <expr><call><name>myCtxConfig</name><argument_list>(<argument><expr><name>sslconn</name></expr></argument>, <argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>crl_check_mode</name>  <init>= <expr><name><name>mctx</name>-&gt;<name>crl_check_mask</name></name> &amp; ~<name>SSL_CRLCHECK_FLAGS</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Get verify ingredients */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>errnum</name>   <init>= <expr><call><name>X509_STORE_CTX_get_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>errdepth</name> <init>= <expr><call><name>X509_STORE_CTX_get_error_depth</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>, <decl><type ref="prev"/><name>verify</name></decl>;</decl_stmt>


    <comment type="block">/*
     * Log verification information
     */</comment>
    <expr_stmt><expr><call><name>ssl_log_cxerror</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>conn</name></expr></argument>,
                    <argument><expr><call><name>X509_STORE_CTX_get_current_cert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02275</expr></argument>)</argument_list></call>
                    "Certificate Verification, depth %d, "
                    "CRL checking mode: %s (%x)"</expr></argument>, <argument><expr><name>errdepth</name></expr></argument>,
                    <argument><expr><name>crl_check_mode</name> == <name>SSL_CRLCHECK_CHAIN</name> ? "chain" :
                    <name>crl_check_mode</name> == <name>SSL_CRLCHECK_LEAF</name>  ? "leaf"  : "none"</expr></argument>,
                    <argument><expr><name><name>mctx</name>-&gt;<name>crl_check_mask</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Check for optionally acceptable non-verifiable issuer situation
     */</comment>
    <if>if <condition>(<expr><name>dc</name> &amp;&amp; (<name><name>dc</name>-&gt;<name>nVerifyClient</name></name> != <name>SSL_CVERIFY_UNSET</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>verify</name> = <name><name>dc</name>-&gt;<name>nVerifyClient</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>verify</name> = <name><name>mctx</name>-&gt;<name>auth</name>.<name>verify_mode</name></name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>verify</name> == <name>SSL_CVERIFY_NONE</name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * SSLProxyVerify is either not configured or set to "none".
         * (this callback doesn't happen in the server context if SSLVerify
         *  is not configured or set to "none")
         */</comment>
        <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ssl_verify_error_is_optional</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call> &amp;&amp;
        (<name>verify</name> == <name>SSL_CVERIFY_OPTIONAL_NO_CA</name>)</expr>)</condition><then>
    <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02037</expr></argument>)</argument_list></call>
                      "Certificate Verification: Verifiable Issuer is "
                      "configured as optional, therefore we're accepting "
                      "the certificate"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>verify_info</name></name> = "GENEROUS"</expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Expired certificates vs. "expired" CRLs: by default, OpenSSL
     * turns X509_V_ERR_CRL_HAS_EXPIRED into a "certificate_expired(45)"
     * SSL alert, but that's not really the message we should convey to the
     * peer (at the very least, it's confusing, and in many cases, it's also
     * inaccurate, as the certificate itself may very well not have expired
     * yet). We set the X509_STORE_CTX error to something which OpenSSL's
     * s3_both.c:ssl_verify_alarm_type() maps to SSL_AD_CERTIFICATE_UNKNOWN,
     * i.e. the peer will receive a "certificate_unknown(46)" alert.
     * We do not touch errnum, though, so that later on we will still log
     * the "real" error, as returned by OpenSSL.
     */</comment>
    <if>if <condition>(<expr>!<name>ok</name> &amp;&amp; <name>errnum</name> == <name>X509_V_ERR_CRL_HAS_EXPIRED</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>X509_STORE_CTX_set_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>ok</name> &amp;&amp; <name>errnum</name> == <name>X509_V_ERR_UNABLE_TO_GET_CRL</name>
            &amp;&amp; (<name><name>mctx</name>-&gt;<name>crl_check_mask</name></name> &amp; <name>SSL_CRLCHECK_NO_CRL_FOR_CERT_OK</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>conn</name></expr></argument>,
                      <argument><expr>"Certificate Verification: Temporary error (%d): %s: "
                      "optional therefore we're accepting the certificate"</expr></argument>,
                      <argument><expr><name>errnum</name></expr></argument>, <argument><expr><call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>X509_STORE_CTX_set_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>X509_V_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errnum</name> = <name>X509_V_OK</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ok</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>OPENSSL_NO_OCSP</name></cpp:ifndef>
    <comment type="block">/*
     * Perform OCSP-based revocation checks
     */</comment>
    <if>if <condition>(<expr><name>ok</name> &amp;&amp; <name><name>sc</name>-&gt;<name>server</name>-&gt;<name>ocsp_enabled</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* If there was an optional verification error, it's not
         * possible to perform OCSP validation since the issuer may be
         * missing/untrusted.  Fail in that case. */</comment>
        <if>if <condition>(<expr><call><name>ssl_verify_error_is_optional</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>X509_STORE_CTX_set_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>X509_V_ERR_APPLICATION_VERIFICATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>errnum</name> = <name>X509_V_ERR_APPLICATION_VERIFICATION</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02038</expr></argument>)</argument_list></call>
                          "cannot perform OCSP validation for cert "
                          "if issuer has not been verified "
                          "(optional_no_ca configured)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>ok</name> = <name>FALSE</name></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><name>ok</name> = <call><name>modssl_verify_ocsp</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>sc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>errnum</name> = <call><name>X509_STORE_CTX_get_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/*
     * If we already know it's not ok, log the real reason
     */</comment>
    <if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>APLOGcinfo</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ssl_log_cxerror</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>conn</name></expr></argument>,
                            <argument><expr><call><name>X509_STORE_CTX_get_current_cert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02276</expr></argument>)</argument_list></call>
                            "Certificate Verification: Error (%d): %s"</expr></argument>,
                            <argument><expr><name>errnum</name></expr></argument>, <argument><expr><call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02039</expr></argument>)</argument_list></call>
                          "Certificate Verification: Error (%d): %s"</expr></argument>,
                          <argument><expr><name>errnum</name></expr></argument>, <argument><expr><call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

        <if>if <condition>(<expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>client_cert</name></name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>client_dn</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>verify_error</name></name> = <call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Finally check the depth of the certificate verification
     */</comment>
    <if>if <condition>(<expr><name>dc</name> &amp;&amp; (<name><name>dc</name>-&gt;<name>nVerifyDepth</name></name> != <name>UNSET</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>depth</name> = <name><name>dc</name>-&gt;<name>nVerifyDepth</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>depth</name> = <name><name>mctx</name>-&gt;<name>auth</name>.<name>verify_depth</name></name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if <condition>(<expr><name>errdepth</name> &gt; <name>depth</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02040</expr></argument>)</argument_list></call>
                      "Certificate Verification: Certificate Chain too long "
                      "(chain has %d certificates, but maximum allowed are "
                      "only %d)"</expr></argument>,
                      <argument><expr><name>errdepth</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>errnum</name> = <name>X509_V_ERR_CERT_CHAIN_TOO_LONG</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sslconn</name>-&gt;<name>verify_error</name></name> = <call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>errnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>ok</name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * And finally signal OpenSSL the (perhaps changed) state
     */</comment>
    <return>return <expr><name>ok</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SSLPROXY_CERT_CB_LOG_FMT</name></cpp:macro> \
   <cpp:value>"Proxy client certificate callback: (%s) "</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>modssl_proxy_info_log</name><parameter_list>(<param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>,
                                  <param><decl><type><name>X509_INFO</name> *</type><name>info</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ssl_log_cxerror</name><argument_list>(<argument><expr><name>SSLLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>info</name>-&gt;<name>x509</name></name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>02277</argument>)</argument_list></macro>
                    <name>SSLPROXY_CERT_CB_LOG_FMT</name> "%s, sending"</expr></argument>,
                    <argument><expr>(<call><name>mySrvConfigFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>)-&gt;<name>vhost_id</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 * caller will decrement the cert and key reference
 * so we need to increment here to prevent them from
 * being freed.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MODSSL_USE_OPENSSL_PRE_1_1_API</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>modssl_set_cert_info</name><parameter_list>(<param><type><name>info</name></type></param>, <param><type><name>cert</name></type></param>, <param><type><name>pkey</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>*cert = info-&gt;x509; \
    CRYPTO_add(&amp;(*cert)-&gt;references, +1, CRYPTO_LOCK_X509); \
    *pkey = info-&gt;x_pkey-&gt;dec_pkey; \
    CRYPTO_add(&amp;(*pkey)-&gt;references, +1, CRYPTO_LOCK_X509_PKEY)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>modssl_set_cert_info</name><parameter_list>(<param><type><name>info</name></type></param>, <param><type><name>cert</name></type></param>, <param><type><name>pkey</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>*cert = info-&gt;x509; \
    X509_up_ref(*cert); \
    *pkey = info-&gt;x_pkey-&gt;dec_pkey; \
    EVP_PKEY_up_ref(*pkey);</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type> <name>ssl_callback_proxy_cert</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>, <param><decl><type><name>X509</name> **</type><name>x509</name></decl></param>, <param><decl><type><name>EVP_PKEY</name> **</type><name>pkey</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name> <init>= <expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name> <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509_NAME</name> *</type><name>ca_name</name></decl>, *<decl><type ref="prev"/><name>issuer</name></decl>, *<decl><type ref="prev"/><name>ca_issuer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509_INFO</name> *</type><name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name> *</type><name>ca_cert</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509_NAME</name></expr></argument>)</argument_list></call> *<name>ca_list</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509_INFO</name></expr></argument>)</argument_list></call> *<name>certs</name> = <name><name>sc</name>-&gt;<name>proxy</name>-&gt;<name>pkp</name>-&gt;<name>certs</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> *<name>ca_certs</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>X509</name></expr></argument>)</argument_list></call> **<name>ca_cert_chains</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>02267</argument>)</argument_list></macro>
                 <name>SSLPROXY_CERT_CB_LOG_FMT</name> "entered"</expr></argument>,
                 <argument><expr><name><name>sc</name>-&gt;<name>vhost_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>certs</name> || (<call><name>sk_X509_INFO_num</name><argument_list>(<argument><expr><name>certs</name></expr></argument>)</argument_list></call> &lt;= 0)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_WARNING</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>02268</argument>)</argument_list></macro>
                     <name>SSLPROXY_CERT_CB_LOG_FMT</name>
                     "downstream server wanted client certificate "
                     "but none are configured"</expr></argument>, <argument><expr><name><name>sc</name>-&gt;<name>vhost_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>FALSE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ca_list</name> = <call><name>SSL_get_client_CA_list</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>ca_list</name> || (<call><name>sk_X509_NAME_num</name><argument_list>(<argument><expr><name>ca_list</name></expr></argument>)</argument_list></call> &lt;= 0)</expr>)</condition><then> <block>{
        <comment type="block">/*
         * downstream server didn't send us a list of acceptable CA certs,
         * so we send the first client cert in the list.
         */</comment>
        <expr_stmt><expr><name>info</name> = <call><name>sk_X509_INFO_value</name><argument_list>(<argument><expr><name>certs</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>modssl_proxy_info_log</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02278</expr></argument>)</argument_list></call> "no acceptable CA list"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>modssl_set_cert_info</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>x509</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>ca_cert_chains</name> = <name><name>sc</name>-&gt;<name>proxy</name>-&gt;<name>pkp</name>-&gt;<name>ca_certs</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>sk_X509_NAME_num</name><argument_list>(<argument><expr><name>ca_list</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>ca_name</name> = <call><name>sk_X509_NAME_value</name><argument_list>(<argument><expr><name>ca_list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <call><name>sk_X509_INFO_num</name><argument_list>(<argument><expr><name>certs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
            <expr_stmt><expr><name>info</name> = <call><name>sk_X509_INFO_value</name><argument_list>(<argument><expr><name>certs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>issuer</name> = <call><name>X509_get_issuer_name</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>x509</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Search certs (by issuer name) one by one*/</comment>
            <if>if <condition>(<expr><call><name>X509_NAME_cmp</name><argument_list>(<argument><expr><name>issuer</name></expr></argument>, <argument><expr><name>ca_name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>modssl_proxy_info_log</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02279</expr></argument>)</argument_list></call>
                                      "found acceptable cert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>modssl_set_cert_info</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>x509</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><name>TRUE</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>ca_cert_chains</name></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Failed to find direct issuer - search intermediates
                 * (by issuer name), if provided.
                 */</comment>
                <expr_stmt><expr><name>ca_certs</name> = <name><name>ca_cert_chains</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
                <for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <call><name>sk_X509_num</name><argument_list>(<argument><expr><name>ca_certs</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
                    <expr_stmt><expr><name>ca_cert</name> = <call><name>sk_X509_value</name><argument_list>(<argument><expr><name>ca_certs</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>ca_issuer</name> = <call><name>X509_get_issuer_name</name><argument_list>(<argument><expr><name>ca_cert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if>if<condition>(<expr><call><name>X509_NAME_cmp</name><argument_list>(<argument><expr><name>ca_issuer</name></expr></argument>, <argument><expr><name>ca_name</name></expr></argument>)</argument_list></call> == 0</expr> )</condition><then> <block>{
                        <expr_stmt><expr><call><name>modssl_proxy_info_log</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02280</expr></argument>)</argument_list></call>
                                              "found acceptable cert by intermediate CA"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <expr_stmt><expr><call><name>modssl_set_cert_info</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>x509</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                        <return>return <expr><name>TRUE</name></expr>;</return>
                    }</block></then></if>
                }</block></for> <comment type="block">/* end loop through chained certs */</comment>
            }</block></then></if>
        }</block></for> <comment type="block">/* end loop through available certs */</comment>
    }</block></for>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><macro><name>APLOGNO</name><argument_list>(<argument>02269</argument>)</argument_list></macro>
                 <name>SSLPROXY_CERT_CB_LOG_FMT</name>
                 "no client certificate found!?"</expr></argument>, <argument><expr><name><name>sc</name>-&gt;<name>vhost_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>ssl_session_log</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>request</name></decl></param>,
                            <param><decl><type><name>IDCONST</name> <name>unsigned</name> <name>char</name> *</type><name>id</name></decl></param>,
                            <param><decl><type><name>unsigned</name> <name>int</name></type> <name>idlen</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>status</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl></param>,
                            <param><decl><type><name>long</name></type> <name>timeout</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MODSSL_SESSION_ID_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>timeout_str</name><index>[<expr>56</expr>]</index></name> <init>= <expr><block>{<expr>'\0'</expr>}</block></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>APLOGdebug</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>timeout</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_snprintf</name><argument_list>(<argument><expr><name>timeout_str</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>timeout_str</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                     <argument><expr>"timeout=%lds "</expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_log_error</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE2</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>,
                 <argument><expr>"Inter-Process Session Cache: "
                 "request=%s status=%s id=%s %s(session %s)"</expr></argument>,
                 <argument><expr><name>request</name></expr></argument>, <argument><expr><name>status</name></expr></argument>,
                 <argument><expr><call><name>modssl_SSL_SESSION_id2sz</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>timeout_str</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/*
 *  This callback function is executed by OpenSSL whenever a new SSL_SESSION is
 *  added to the internal OpenSSL session cache. We use this hook to spread the
 *  SSL_SESSION also to the inter-process disk-cache to make share it with our
 *  other Apache pre-forked server processes.
 */</comment>
<function><type><name>int</name></type> <name>ssl_callback_NewSessionCacheEntry</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>, <param><decl><type><name>SSL_SESSION</name> *</type><name>session</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Get Apache context back through OpenSSL context */</comment>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>conn</name>      <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name>       <init>= <expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name> <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>timeout</name>        <init>= <expr><name><name>sc</name>-&gt;<name>session_cache_timeout</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>rc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IDCONST</name> <name>unsigned</name> <name>char</name> *</type><name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>idlen</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Set the timeout also for the internal OpenSSL cache, because this way
     * our inter-process cache is consulted only when it's really necessary.
     */</comment>
    <expr_stmt><expr><call><name>SSL_set_timeout</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Store the SSL_SESSION in the inter-process cache with the
     * same expire time, so it expires automatically there, too.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPENSSL_NO_SSL_INTERN</name></cpp:ifdef>
    <expr_stmt><expr><name>id</name> = (<name>unsigned</name> <name>char</name> *)<call><name>SSL_SESSION_get_id</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>idlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>id</name> = <name><name>session</name>-&gt;<name>session_id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>idlen</name> = <name><name>session</name>-&gt;<name>session_id_length</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>rc</name> = <call><name>ssl_scache_store</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>,
                          <argument><expr><call><name>apr_time_from_sec</name><argument_list>(<argument><expr><call><name>SSL_SESSION_get_time</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call>
                                          + <name>timeout</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>session</name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ssl_session_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"SET"</expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>,
                    <argument><expr><name>rc</name> == <name>TRUE</name> ? "OK" : "BAD"</expr></argument>,
                    <argument><expr>"caching"</expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * return 0 which means to OpenSSL that the session is still
     * valid and was not freed by us with SSL_SESSION_free().
     */</comment>
    <return>return <expr>0</expr>;</return>
}</block></function>

<comment type="block">/*
 *  This callback function is executed by OpenSSL whenever a
 *  SSL_SESSION is looked up in the internal OpenSSL cache and it
 *  was not found. We use this to lookup the SSL_SESSION in the
 *  inter-process disk-cache where it was perhaps stored by one
 *  of our other Apache pre-forked server processes.
 */</comment>
<function><type><name>SSL_SESSION</name> *</type><name>ssl_callback_GetSessionCacheEntry</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>,
                                               <param><decl><type><name>IDCONST</name> <name>unsigned</name> <name>char</name> *</type><name>id</name></decl></param>,
                                               <param><decl><type><name>int</name></type> <name>idlen</name></decl></param>, <param><decl><type><name>int</name> *</type><name>do_copy</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Get Apache context back through OpenSSL context */</comment>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>conn</name> <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name>  <init>= <expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL_SESSION</name> *</type><name>session</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Try to retrieve the SSL_SESSION from the inter-process cache
     */</comment>
    <expr_stmt><expr><name>session</name> = <call><name>ssl_scache_retrieve</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ssl_session_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"GET"</expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>,
                    <argument><expr><name>session</name> ? "FOUND" : "MISSED"</expr></argument>,
                    <argument><expr><name>session</name> ? "reuse" : "renewal"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Return NULL or the retrieved SSL_SESSION. But indicate (by
     * setting do_copy to 0) that the reference count on the
     * SSL_SESSION should not be incremented by the SSL library,
     * because we will no longer hold a reference to it ourself.
     */</comment>
    <expr_stmt><expr>*<name>do_copy</name> = 0</expr>;</expr_stmt>

    <return>return <expr><name>session</name></expr>;</return>
}</block></function>

<comment type="block">/*
 *  This callback function is executed by OpenSSL whenever a
 *  SSL_SESSION is removed from the internal OpenSSL cache.
 *  We use this to remove the SSL_SESSION in the inter-process
 *  disk-cache, too.
 */</comment>
<function><type><name>void</name></type> <name>ssl_callback_DelSessionCacheEntry</name><parameter_list>(<param><decl><type><name>SSL_CTX</name> *</type><name>ctx</name></decl></param>,
                                       <param><decl><type><name>SSL_SESSION</name> *</type><name>session</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>IDCONST</name> <name>unsigned</name> <name>char</name> *</type><name>id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>idlen</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Get Apache context back through OpenSSL context
     */</comment>
    <if>if <condition>(<expr>!(<name>s</name> = (<name>server_rec</name> *)<call><name>SSL_CTX_get_app_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return;</return> <comment type="block">/* on server shutdown Apache is already gone */</comment>
    }</block></then></if>

    <expr_stmt><expr><name>sc</name> = <call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Remove the SSL_SESSION from the inter-process cache
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>OPENSSL_NO_SSL_INTERN</name></cpp:ifdef>
    <expr_stmt><expr><name>id</name> = (<name>unsigned</name> <name>char</name> *)<call><name>SSL_SESSION_get_id</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>idlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>id</name> = <name><name>session</name>-&gt;<name>session_id</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>idlen</name> = <name><name>session</name>-&gt;<name>session_id_length</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* TODO: Do we need a temp pool here, or are we always shutting down? */</comment>
    <expr_stmt><expr><call><name>ssl_scache_remove</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>, <argument><expr><name><name>sc</name>-&gt;<name>mc</name>-&gt;<name>pPool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ssl_session_log</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>"REM"</expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>idlen</name></expr></argument>,
                    <argument><expr>"OK"</expr></argument>, <argument><expr>"dead"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return;</return>
}</block></function>

<comment type="block">/* Dump debugginfo trace to the log file. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>log_tracing_state</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>SSL</name> *</type><name>ssl</name></decl></param>, <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>,
                              <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>where</name></decl></param>, <param><decl><type><name>int</name></type> <name>rc</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/*
     * create the various trace messages
     */</comment>
    <if>if <condition>(<expr><name>where</name> &amp; <name>SSL_CB_HANDSHAKE_START</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                      <argument><expr>"%s: Handshake: start"</expr></argument>, <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>where</name> &amp; <name>SSL_CB_HANDSHAKE_DONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                      <argument><expr>"%s: Handshake: done"</expr></argument>, <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>where</name> &amp; <name>SSL_CB_LOOP</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                      <argument><expr>"%s: Loop: %s"</expr></argument>,
                      <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>, <argument><expr><call><name>SSL_state_string_long</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>where</name> &amp; <name>SSL_CB_READ</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                      <argument><expr>"%s: Read: %s"</expr></argument>,
                      <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>, <argument><expr><call><name>SSL_state_string_long</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>where</name> &amp; <name>SSL_CB_WRITE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                      <argument><expr>"%s: Write: %s"</expr></argument>,
                      <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>, <argument><expr><call><name>SSL_state_string_long</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>where</name> &amp; <name>SSL_CB_ALERT</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>str</name> <init>= <expr>(<name>where</name> &amp; <name>SSL_CB_READ</name>) ? "read" : "write"</expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                      <argument><expr>"%s: Alert: %s:%s:%s"</expr></argument>,
                      <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>, <argument><expr><name>str</name></expr></argument>,
                      <argument><expr><call><name>SSL_alert_type_string_long</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>SSL_alert_desc_string_long</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>where</name> &amp; <name>SSL_CB_EXIT</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>rc</name> == 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                          <argument><expr>"%s: Exit: failed in %s"</expr></argument>,
                          <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>, <argument><expr><call><name>SSL_state_string_long</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>rc</name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>,
                          <argument><expr>"%s: Exit: error in %s"</expr></argument>,
                          <argument><expr><name>MODSSL_LIBRARY_NAME</name></expr></argument>, <argument><expr><call><name>SSL_state_string_long</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then></if></else></if></else></if></else></if></else></if></else></if></else></if>

    <comment type="block">/*
     * Because SSL renegotiations can happen at any time (not only after
     * SSL_accept()), the best way to log the current connection details is
     * right after a finished handshake.
     */</comment>
    <if>if <condition>(<expr><name>where</name> &amp; <name>SSL_CB_HANDSHAKE_DONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02041</expr></argument>)</argument_list></call>
                      "Protocol: %s, Cipher: %s (%s/%s bits)"</expr></argument>,
                      <argument><expr><call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"SSL_PROTOCOL"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"SSL_CIPHER"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"SSL_CIPHER_USEKEYSIZE"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><call><name>ssl_var_lookup</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"SSL_CIPHER_ALGKEYSIZE"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/*
 * This callback function is executed while OpenSSL processes the SSL
 * handshake and does SSL record layer stuff.  It's used to trap
 * client-initiated renegotiations, and for dumping everything to the
 * log.
 */</comment>
<function><type><name>void</name></type> <name>ssl_callback_Info</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>SSL</name> *</type><name>ssl</name></decl></param>, <param><decl><type><name>int</name></type> <name>where</name></decl></param>, <param><decl><type><name>int</name></type> <name>rc</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>scr</name></decl>;</decl_stmt>

    <comment type="block">/* Retrieve the conn_rec and the associated SSLConnRec. */</comment>
    <if>if <condition>(<expr>(<name>c</name> = (<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr>(<name>SSL</name> *)<name>ssl</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>scr</name> = <call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* If the reneg state is to reject renegotiations, check the SSL
     * state machine and move to ABORT if a Client Hello is being
     * read. */</comment>
    <if>if <condition>(<expr>!<name><name>scr</name>-&gt;<name>is_proxy</name></name> &amp;&amp;
        (<name>where</name> &amp; <name>SSL_CB_HANDSHAKE_START</name>) &amp;&amp;
        <name><name>scr</name>-&gt;<name>reneg_state</name></name> == <name>RENEG_REJECT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>scr</name>-&gt;<name>reneg_state</name></name> = <name>RENEG_ABORT</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02042</expr></argument>)</argument_list></call>
                          "rejecting client initiated renegotiation"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <comment type="block">/* If the first handshake is complete, change state to reject any
     * subsequent client-initiated renegotiation. */</comment>
    <else>else <if>if <condition>(<expr>(<name>where</name> &amp; <name>SSL_CB_HANDSHAKE_DONE</name>) &amp;&amp; <name><name>scr</name>-&gt;<name>reneg_state</name></name> == <name>RENEG_INIT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>scr</name>-&gt;<name>reneg_state</name></name> = <name>RENEG_REJECT</name></expr>;</expr_stmt>
    }</block></then></if></else></if>

    <expr_stmt><expr><name>s</name> = <call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>s</name> &amp;&amp; <call><name>APLOGdebug</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>log_tracing_state</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLSEXT</name></cpp:ifdef>
<comment type="block">/*
 * This function sets the virtual host from an extended
 * client hello with a server name indication extension ("SNI", cf. RFC 6066).
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>init_vhost</name><parameter_list>(<param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>servername</name></decl>;</decl_stmt>
    
    <if>if <condition>(<expr><name>c</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslcon</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        
        <if>if <condition>(<expr><name><name>sslcon</name>-&gt;<name>server</name></name> != <name><name>c</name>-&gt;<name>base_server</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* already found the vhost */</comment>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>
        
        <expr_stmt><expr><name>servername</name> = <call><name>SSL_get_servername</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>TLSEXT_NAMETYPE_host_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>servername</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>ap_vhost_iterate_given_conn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ssl_find_vhost</name></expr></argument>,
                                            <argument><expr>(<name>void</name> *)<name>servername</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02043</expr></argument>)</argument_list></call>
                              "SSL virtual host for servername %s found"</expr></argument>,
                              <argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02044</expr></argument>)</argument_list></call>
                              "No matching SSL virtual host for servername "
                              "%s found (using default/first virtual host)"</expr></argument>,
                              <argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <comment type="block">/*
                 * RFC 6066 section 3 says "It is NOT RECOMMENDED to send
                 * a warning-level unrecognized_name(112) alert, because
                 * the client's behavior in response to warning-level alerts
                 * is unpredictable."
                 *
                 * To maintain backwards compatibility in mod_ssl, we
                 * no longer send any alert (neither warning- nor fatal-level),
                 * i.e. we take the second action suggested in RFC 6066:
                 * "If the server understood the ClientHello extension but
                 * does not recognize the server name, the server SHOULD take
                 * one of two actions: either abort the handshake by sending
                 * a fatal-level unrecognized_name(112) alert or continue
                 * the handshake."
                 */</comment>
            }</block></else></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02645</expr></argument>)</argument_list></call>
                          "Server name not provided via TLS extension "
                          "(using default/first virtual host)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
    
    <return>return <expr><name>APR_NOTFOUND</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * This callback function is executed when OpenSSL encounters an extended
 * client hello with a server name indication extension ("SNI", cf. RFC 6066).
 */</comment>
<function><type><name>int</name></type> <name>ssl_callback_ServerNameIndication</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>, <param><decl><type><name>int</name> *</type><name>al</name></decl></param>, <param><decl><type><name>modssl_ctx_t</name> *</type><name>mctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name> <init>= <expr><call><name>init_vhost</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <return>return <expr>(<name>status</name> == <name>APR_SUCCESS</name>)? <name>SSL_TLSEXT_ERR_OK</name> : <name>SSL_TLSEXT_ERR_NOACK</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Find a (name-based) SSL virtual host where either the ServerName
 * or one of the ServerAliases matches the supplied name (to be used
 * with ap_vhost_iterate_given_conn())
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>ssl_find_vhost</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>servername</name></decl></param>, <param><decl><type><name>conn_rec</name> *</type><name>c</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name> *</type><name>ssl</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>BOOL</name></type> <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslcon</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>found</name> = <call><name>ssl_util_vhost_matches</name><argument_list>(<argument><expr><name>servername</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set SSL_CTX (if matched) */</comment>
    <expr_stmt><expr><name>sslcon</name> = <call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>found</name> &amp;&amp; (<name>ssl</name> = <name><name>sslcon</name>-&gt;<name>ssl</name></name>) &amp;&amp;
        (<name>sc</name> = <call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>SSL_CTX</name> *</type><name>ctx</name> <init>= <expr><call><name>SSL_set_SSL_CTX</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name><name>sc</name>-&gt;<name>server</name>-&gt;<name>ssl_ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <comment type="block">/*
         * SSL_set_SSL_CTX() only deals with the server cert,
         * so we need to duplicate a few additional settings
         * from the ctx by hand
         */</comment>
        <expr_stmt><expr><call><name>SSL_set_options</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><call><name>SSL_CTX_get_options</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<call><name>SSL_get_verify_mode</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> == <name>SSL_VERIFY_NONE</name>) ||
            (<call><name>SSL_num_renegotiations</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
           <comment type="block">/*
            * Only initialize the verification settings from the ctx
            * if they are not yet set, or if we're called when a new
            * SSL connection is set up (num_renegotiations == 0).
            * Otherwise, we would possibly reset a per-directory
            * configuration which was put into effect by ssl_hook_Access.
            */</comment>
            <expr_stmt><expr><call><name>SSL_set_verify</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><call><name>SSL_CTX_get_verify_mode</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>SSL_CTX_get_verify_callback</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/*
         * Adjust the session id context. ssl_init_ssl_connection()
         * always picks the configuration of the first vhost when
         * calling SSL_new(), but we want to tie the session to the
         * vhost we have just switched to. Again, we have to make sure
         * that we're not overwriting a session id context which was
         * possibly set in ssl_hook_Access(), before triggering
         * a renegotiation.
         */</comment>
        <if>if <condition>(<expr><call><name>SSL_num_renegotiations</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>sid_ctx</name> <init>=
                <expr>(<name>unsigned</name> <name>char</name> *)<call><name>ap_md5_binary</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>,
                                               <argument><expr>(<name>unsigned</name> <name>char</name> *)<name><name>sc</name>-&gt;<name>vhost_id</name></name></expr></argument>,
                                               <argument><expr><name><name>sc</name>-&gt;<name>vhost_id_len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>SSL_set_session_id_context</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>sid_ctx</name></expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name>*2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/*
         * Save the found server into our SSLConnRec for later
         * retrieval
         */</comment>
        <expr_stmt><expr><name><name>sslcon</name>-&gt;<name>server</name></name> = <name>s</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>sslcon</name>-&gt;<name>cipher_suite</name></name> = <name><name>sc</name>-&gt;<name>server</name>-&gt;<name>auth</name>.<name>cipher_suite</name></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>ap_update_child_status_from_server</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>sbh</name></name></expr></argument>, <argument><expr><name>SERVER_BUSY_READ</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/*
         * There is one special filter callback, which is set
         * very early depending on the base_server's log level.
         * If this is not the first vhost we're now selecting
         * (and the first vhost doesn't use APLOG_TRACE4), then
         * we need to set that callback here.
         */</comment>
        <if>if <condition>(<expr><call><name>APLOGtrace4</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>BIO</name> *</type><name>rbio</name> <init>= <expr><call><name>SSL_get_rbio</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init>,
                *<name>wbio</name> <init>= <expr><call><name>SSL_get_wbio</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>BIO_set_callback</name><argument_list>(<argument><expr><name>rbio</name></expr></argument>, <argument><expr><name>ssl_io_data_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>BIO_set_callback_arg</name><argument_list>(<argument><expr><name>rbio</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>wbio</name> &amp;&amp; <name>wbio</name> != <name>rbio</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>BIO_set_callback</name><argument_list>(<argument><expr><name>wbio</name></expr></argument>, <argument><expr><name>ssl_io_data_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>BIO_set_callback_arg</name><argument_list>(<argument><expr><name>wbio</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TLSEXT */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLS_SESSION_TICKETS</name></cpp:ifdef>
<comment type="block">/*
 * This callback function is executed when OpenSSL needs a key for encrypting/
 * decrypting a TLS session ticket (RFC 5077) and a ticket key file has been
 * configured through SSLSessionTicketKeyFile.
 */</comment>
<function><type><name>int</name></type> <name>ssl_callback_SessionTicket</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>,
                               <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>keyname</name></decl></param>,
                               <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>iv</name></decl></param>,
                               <param><decl><type><name>EVP_CIPHER_CTX</name> *</type><name>cipher_ctx</name></decl></param>,
                               <param><decl><type><name>HMAC_CTX</name> *</type><name>hctx</name></decl></param>,
                               <param><decl><type><name>int</name></type> <name>mode</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr>(<name>conn_rec</name> *)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>s</name> <init>= <expr><call><name>mySrvFromConn</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLSrvConfigRec</name> *</type><name>sc</name> <init>= <expr><call><name>mySrvConfig</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>modssl_ctx_t</name> *</type><name>mctx</name> <init>= <expr><call><name>myCtxConfig</name><argument_list>(<argument><expr><name>sslconn</name></expr></argument>, <argument><expr><name>sc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>modssl_ticket_key_t</name> *</type><name>ticket_key</name> <init>= <expr><name><name>mctx</name>-&gt;<name>ticket_key</name></name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>mode</name> == 1</expr>)</condition><then> <block>{
        <comment type="block">/* 
         * OpenSSL is asking for a key for encrypting a ticket,
         * see s3_srvr.c:ssl3_send_newsession_ticket()
         */</comment>

        <if>if <condition>(<expr><name>ticket_key</name> == <name>NULL</name></expr>)</condition><then> <block>{
            <comment type="block">/* should never happen, but better safe than sorry */</comment>
            <return>return <expr>-1</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>, <argument><expr><name><name>ticket_key</name>-&gt;<name>key_name</name></name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>RAND_bytes</name><argument_list>(<argument><expr><name>iv</name></expr></argument>, <argument><expr><name>EVP_MAX_IV_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>EVP_EncryptInit_ex</name><argument_list>(<argument><expr><name>cipher_ctx</name></expr></argument>, <argument><expr><call><name>EVP_aes_128_cbc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><name><name>ticket_key</name>-&gt;<name>aes_key</name></name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HMAC_Init_ex</name><argument_list>(<argument><expr><name>hctx</name></expr></argument>, <argument><expr><name><name>ticket_key</name>-&gt;<name>hmac_secret</name></name></expr></argument>, <argument><expr>16</expr></argument>, <argument><expr><call><name>tlsext_tick_md</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02289</expr></argument>)</argument_list></call>
                      "TLS session ticket key for %s successfully set, "
                      "creating new session ticket"</expr></argument>, <argument><expr><name><name>sc</name>-&gt;<name>vhost_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr>1</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>mode</name> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* 
         * OpenSSL is asking for the decryption key,
         * see t1_lib.c:tls_decrypt_ticket()
         */</comment>

        <comment type="block">/* check key name */</comment>
        <if>if <condition>(<expr><name>ticket_key</name> == <name>NULL</name> || <call><name>memcmp</name><argument_list>(<argument><expr><name>keyname</name></expr></argument>, <argument><expr><name><name>ticket_key</name>-&gt;<name>key_name</name></name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>EVP_DecryptInit_ex</name><argument_list>(<argument><expr><name>cipher_ctx</name></expr></argument>, <argument><expr><call><name>EVP_aes_128_cbc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><name><name>ticket_key</name>-&gt;<name>aes_key</name></name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HMAC_Init_ex</name><argument_list>(<argument><expr><name>hctx</name></expr></argument>, <argument><expr><name><name>ticket_key</name>-&gt;<name>hmac_secret</name></name></expr></argument>, <argument><expr>16</expr></argument>, <argument><expr><call><name>tlsext_tick_md</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02290</expr></argument>)</argument_list></call>
                      "TLS session ticket key for %s successfully set, "
                      "decrypting existing session ticket"</expr></argument>, <argument><expr><name><name>sc</name>-&gt;<name>vhost_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <return>return <expr>1</expr>;</return>
    }</block></then></if></else></if>

    <comment type="block">/* OpenSSL is not expected to call us with modes other than 1 or 0 */</comment>
    <return>return <expr>-1</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TLS_SESSION_TICKETS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_TLS_ALPN</name></cpp:ifdef>

<comment type="block">/*
 * This callback function is executed when the TLS Application-Layer
 * Protocol Negotiation Extension (ALPN, RFC 7301) is triggered by the Client
 * Hello, giving a list of desired protocol names (in descending preference) 
 * to the server.
 * The callback has to select a protocol name or return an error if none of
 * the clients preferences is supported.
 * The selected protocol does not have to be on the client list, according
 * to RFC 7301, so no checks are performed.
 * The client protocol list is serialized as length byte followed by ASCII
 * characters (not null-terminated), followed by the next protocol name.
 */</comment>
<function><type><name>int</name></type> <name>ssl_callback_alpn_select</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> **</type><name>out</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name> *</type><name>outlen</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>in</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>inlen</name></decl></param>,
                             <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr>(<name>conn_rec</name>*)<call><name>SSL_get_app_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSLConnRec</name> *</type><name>sslconn</name> <init>= <expr><call><name>myConnConfig</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>client_protos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proposed</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* If the connection object is not available,
     * then there's nothing for us to do. */</comment>
    <if>if <condition>(<expr><name>c</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><name>SSL_TLSEXT_ERR_OK</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>inlen</name> == 0</expr>)</condition><then> <block>{
        <comment type="block">/* someone tries to trick us? */</comment>
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02837</expr></argument>)</argument_list></call>
                      "ALPN client protocol list empty"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SSL_TLSEXT_ERR_ALERT_FATAL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>client_protos</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>inlen</name></expr>;</condition> <comment type="block">/**/</comment><incr/>) <block>{
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>plen</name> <init>= <expr><name><name>in</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>plen</name> + <name>i</name> &gt; <name>inlen</name></expr>)</condition><then> <block>{
            <comment type="block">/* someone tries to trick us? */</comment>
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02838</expr></argument>)</argument_list></call>
                          "ALPN protocol identifier too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SSL_TLSEXT_ERR_ALERT_FATAL</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>client_protos</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call> =
            <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>(const <name>char</name> *)<name>in</name>+<name>i</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> += <name>plen</name></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* The order the callbacks are invoked from TLS extensions is, unfortunately
     * not defined and older openssl versions do call ALPN selection before
     * they callback the SNI. We need to make sure that we know which vhost
     * we are dealing with so we respect the correct protocols.
     */</comment>
    <expr_stmt><expr><call><name>init_vhost</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name>proposed</name> = <call><name>ap_select_protocol</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>sslconn</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>client_protos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>proposed</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>proposed</name> = <call><name>ap_get_protocol</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    
    <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>proposed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len</name> &gt; 255</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02840</expr></argument>)</argument_list></call>
                      "ALPN negotiated protocol name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>SSL_TLSEXT_ERR_ALERT_FATAL</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr>*<name>out</name> = (const <name>unsigned</name> <name>char</name> *)<name>proposed</name></expr>;</expr_stmt>
    <expr_stmt><expr>*<name>outlen</name> = (<name>unsigned</name> <name>char</name>)<name>len</name></expr>;</expr_stmt>
        
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>proposed</name></expr></argument>, <argument><expr><call><name>ap_get_protocol</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
        
        <expr_stmt><expr><name>status</name> = <call><name>ap_switch_protocol</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>sslconn</name>-&gt;<name>server</name></name></expr></argument>, <argument><expr><name>proposed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>status</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_cerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>c</name></expr></argument>,
                          <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02908</expr></argument>)</argument_list></call> "protocol switch to '%s' failed"</expr></argument>,
                          <argument><expr><name>proposed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>SSL_TLSEXT_ERR_ALERT_FATAL</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>SSL_TLSEXT_ERR_OK</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_TLS_ALPN */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SRP</name></cpp:ifdef>

<function><type><name>int</name></type> <name>ssl_callback_SRPServerParams</name><parameter_list>(<param><decl><type><name>SSL</name> *</type><name>ssl</name></decl></param>, <param><decl><type><name>int</name> *</type><name>ad</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>modssl_ctx_t</name> *</type><name>mctx</name> <init>= <expr>(<name>modssl_ctx_t</name> *)<name>arg</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>username</name> <init>= <expr><call><name>SSL_get_srp_username</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SRP_user_pwd</name> *</type><name>u</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>username</name> == <name>NULL</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPENSSL_VERSION_NUMBER</name> &lt; 0x10100000L</expr></cpp:if>
        || (<name>u</name> = <call><name>SRP_VBASE_get_by_user</name><argument_list>(<argument><expr><name><name>mctx</name>-&gt;<name>srp_vbase</name></name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr>|| (<name>u</name> = <call><name>SRP_VBASE_get1_by_user</name><argument_list>(<argument><expr><name><name>mctx</name>-&gt;<name>srp_vbase</name></name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr></expr_stmt>)</block> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr>*<name>ad</name> = <name>SSL_AD_UNKNOWN_PSK_IDENTITY</name></expr>;</expr_stmt>
        <return>return <expr><name>SSL3_AL_FATAL</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>SSL_set_srp_server_param</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>N</name></name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>g</name></name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>s</name></name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>v</name></name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPENSSL_VERSION_NUMBER</name> &gt;= 0x10100000L</expr></cpp:if>
        <expr_stmt><expr><call><name>SRP_user_pwd_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr>*<name>ad</name> = <name>SSL_AD_INTERNAL_ERROR</name></expr>;</expr_stmt>
        <return>return <expr><name>SSL3_AL_FATAL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* reset all other options */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPENSSL_VERSION_NUMBER</name> &gt;= 0x10100000L</expr></cpp:if>
    <expr_stmt><expr><call><name>SRP_user_pwd_free</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>SSL_set_verify</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>SSL_VERIFY_NONE</name></expr></argument>,  <argument><expr><name>ssl_callback_SSLVerify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SSL_ERROR_NONE</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* HAVE_SRP */</comment>
</unit>
