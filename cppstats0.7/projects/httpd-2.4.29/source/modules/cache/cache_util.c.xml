<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/cache/cache_util.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cache_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ap_provider.h&gt;</cpp:file></cpp:include>

<expr_stmt><expr><call><name>APLOG_USE_MODULE</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* -------------------------------------------------------------- */</comment>

<extern>extern APR_OPTIONAL_FN_TYPE(ap_cache_generate_key</extern>) <expr_stmt><expr>*<name>cache_generate_key</name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>cache_module</name></decl>;</decl_stmt>

<comment type="block">/* Determine if "url" matches the hostname, scheme and port and path
 * in "filter". All but the path comparisons are case-insensitive.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>uri_meets_conditions</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>apr_uri_t</name> *</type><name>filter</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>int</name></type> <name>pathlen</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>apr_uri_t</name> *</type><name>url</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Scheme, hostname port and local part. The filter URI and the
     * URI we test may have the following shapes:
     *   /&lt;path&gt;
     *   &lt;scheme&gt;[:://&lt;hostname&gt;[:&lt;port&gt;][/&lt;path&gt;]]
     * That is, if there is no scheme then there must be only the path,
     * and we check only the path; if there is a scheme, we check the
     * scheme for equality, and then if present we match the hostname,
     * and then if present match the port, and finally the path if any.
     *
     * Note that this means that "/&lt;path&gt;" only matches local paths,
     * and to match proxied paths one *must* specify the scheme.
     */</comment>

    <comment type="block">/* Is the filter is just for a local path or a proxy URI? */</comment>
    <if>if <condition>(<expr>!<name><name>filter</name>-&gt;<name>scheme</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>url</name>-&gt;<name>scheme</name></name> || <name><name>url</name>-&gt;<name>hostname</name></name></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* The URI scheme must be present and identical except for case. */</comment>
        <if>if <condition>(<expr>!<name><name>url</name>-&gt;<name>scheme</name></name> || <call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><name><name>filter</name>-&gt;<name>scheme</name></name></expr></argument>, <argument><expr><name><name>url</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>

        <comment type="block">/* If the filter hostname is null or empty it matches any hostname,
         * if it begins with a "*" it matches the _end_ of the URI hostname
         * excluding the "*", if it begins with a "." it matches the _end_
         * of the URI * hostname including the ".", otherwise it must match
         * the URI hostname exactly. */</comment>

        <if>if <condition>(<expr><name><name>filter</name>-&gt;<name>hostname</name></name> &amp;&amp; <name><name>filter</name>-&gt;<name>hostname</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>filter</name>-&gt;<name>hostname</name><index>[<expr>0</expr>]</index></name> == '.'</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>fhostlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>filter</name>-&gt;<name>hostname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>uhostlen</name> <init>= <expr><name><name>url</name>-&gt;<name>hostname</name></name> ? <call><name>strlen</name><argument_list>(<argument><expr><name><name>url</name>-&gt;<name>hostname</name></name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>fhostlen</name> &gt; <name>uhostlen</name>
                    || (<name><name>url</name>-&gt;<name>hostname</name></name>
                        &amp;&amp; <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>filter</name>-&gt;<name>hostname</name></name></expr></argument>,
                                      <argument><expr><name><name>url</name>-&gt;<name>hostname</name></name> + <name>uhostlen</name> - <name>fhostlen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                    <return>return <expr>0</expr>;</return>
                }</block></then></if>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>filter</name>-&gt;<name>hostname</name><index>[<expr>0</expr>]</index></name> == '*'</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>fhostlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>filter</name>-&gt;<name>hostname</name></name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>uhostlen</name> <init>= <expr><name><name>url</name>-&gt;<name>hostname</name></name> ? <call><name>strlen</name><argument_list>(<argument><expr><name><name>url</name>-&gt;<name>hostname</name></name></expr></argument>)</argument_list></call> : 0</expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>fhostlen</name> &gt; <name>uhostlen</name>
                    || (<name><name>url</name>-&gt;<name>hostname</name></name>
                        &amp;&amp; <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>filter</name>-&gt;<name>hostname</name></name> + 1</expr></argument>,
                                      <argument><expr><name><name>url</name>-&gt;<name>hostname</name></name> + <name>uhostlen</name> - <name>fhostlen</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
                    <return>return <expr>0</expr>;</return>
                }</block></then></if>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<name><name>url</name>-&gt;<name>hostname</name></name> || <call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>filter</name>-&gt;<name>hostname</name></name></expr></argument>, <argument><expr><name><name>url</name>-&gt;<name>hostname</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr>0</expr>;</return>
            }</block></then></if></else></if></else></if>
        }</block></then></if>

        <comment type="block">/* If the filter port is empty it matches any URL port.
         * If the filter or URL port are missing, or the URL port is
         * empty, they default to the port for their scheme. */</comment>

        <if>if <condition>(<expr>!(<name><name>filter</name>-&gt;<name>port_str</name></name> &amp;&amp; !<name><name>filter</name>-&gt;<name>port_str</name><index>[<expr>0</expr>]</index></name>)</expr>)</condition><then> <block>{
            <comment type="block">/* NOTE:  ap_port_of_scheme will return 0 if given NULL input */</comment>
            <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>fport</name> <init>= <expr><name><name>filter</name>-&gt;<name>port_str</name></name> ? <name><name>filter</name>-&gt;<name>port</name></name>
                    : <call><name>apr_uri_port_of_scheme</name><argument_list>(<argument><expr><name><name>filter</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>uport</name> <init>= <expr>(<name><name>url</name>-&gt;<name>port_str</name></name> &amp;&amp; <name><name>url</name>-&gt;<name>port_str</name><index>[<expr>0</expr>]</index></name>)
                    ? <name><name>url</name>-&gt;<name>port</name></name> : <call><name>apr_uri_port_of_scheme</name><argument_list>(<argument><expr><name><name>url</name>-&gt;<name>scheme</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><name>fport</name> != <name>uport</name></expr>)</condition><then> <block>{
                <return>return <expr>0</expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></else></if>

    <comment type="block">/* For HTTP caching purposes, an empty (NULL) path is equivalent to
     * a single "/" path. RFCs 3986/2396
     */</comment>
    <if>if <condition>(<expr>!<name>path</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>*<name><name>filter</name>-&gt;<name>path</name></name> == '/' &amp;&amp; <name>pathlen</name> == 1</expr>)</condition><then> <block>{
            <return>return <expr>1</expr>;</return>
        }</block></then>
        <else>else <block>{
            <return>return <expr>0</expr>;</return>
        }</block></else></if>
    }</block></then></if>

    <comment type="block">/* Url has met all of the filter conditions so far, determine
     * if the paths match.
     */</comment>
    <return>return <expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name><name>filter</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathlen</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>cache_use_early_url</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cache_server_conf</name> *</type><name>conf</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proxyreq</name></name> == <name>PROXYREQ_PROXY</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>, <argument><expr>&amp;<name>cache_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>quick</name></name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>

    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>cache_provider_list</name> *</type><name>get_provider</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type>struct <name>cache_enable</name> *</type><name>ent</name></decl></param>,
        <param><decl><type><name>cache_provider_list</name> *</type><name>providers</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Fetch from global config and add to the list. */</comment>
    <decl_stmt><decl><type><name>cache_provider</name> *</type><name>provider</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>provider</name> = <call><name>ap_lookup_provider</name><argument_list>(<argument><expr><name>CACHE_PROVIDER_GROUP</name></expr></argument>, <argument><expr><name><name>ent</name>-&gt;<name>type</name></name></expr></argument>,
                                  <argument><expr>"0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>provider</name></expr>)</condition><then> <block>{
        <comment type="block">/* Log an error! */</comment>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><name>cache_provider_list</name> *</type><name>newp</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>newp</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cache_provider_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newp</name>-&gt;<name>provider_name</name></name> = <name><name>ent</name>-&gt;<name>type</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>newp</name>-&gt;<name>provider</name></name> = <name>provider</name></expr>;</expr_stmt>

        <if>if <condition>(<expr>!<name>providers</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>providers</name> = <name>newp</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <decl_stmt><decl><type><name>cache_provider_list</name> *</type><name>last</name> <init>= <expr><name>providers</name></expr></init></decl>;</decl_stmt>

            <while>while <condition>(<expr><name><name>last</name>-&gt;<name>next</name></name></expr>)</condition> <block>{
                <if>if <condition>(<expr><name><name>last</name>-&gt;<name>provider</name></name> == <name>provider</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>providers</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name>last</name> = <name><name>last</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
            }</block></while>
            <if>if <condition>(<expr><name><name>last</name>-&gt;<name>provider</name></name> == <name>provider</name></expr>)</condition><then> <block>{
                <return>return <expr><name>providers</name></expr>;</return>
            }</block></then></if>
            <expr_stmt><expr><name><name>last</name>-&gt;<name>next</name></name> = <name>newp</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>

    <return>return <expr><name>providers</name></expr>;</return>
}</block></function>

<function><type><name>cache_provider_list</name> *</type><name>cache_get_providers</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                         <param><decl><type><name>cache_server_conf</name> *</type><name>conf</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cache_dir_conf</name> *</type><name>dconf</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>, <argument><expr>&amp;<name>cache_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cache_provider_list</name> *</type><name>providers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* per directory cache disable */</comment>
    <if>if <condition>(<expr><name><name>dconf</name>-&gt;<name>disable</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>path</name> = <call><name>cache_use_early_url</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> ? <name><name>r</name>-&gt;<name>parsed_uri</name>.<name>path</name></name> : <name><name>r</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>

    <comment type="block">/* global cache disable */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>conf</name>-&gt;<name>cachedisable</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type>struct <name>cache_disable</name> *</type><name>ent</name> <init>=
                               <expr>(struct <name>cache_disable</name> *)<name><name>conf</name>-&gt;<name>cachedisable</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>uri_meets_conditions</name><argument_list>(<argument><expr>&amp;<name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name>.<name>url</name></expr></argument>, <argument><expr><name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pathlen</name></expr></argument>,
                                 <argument><expr>&amp;<name><name>r</name>-&gt;<name>parsed_uri</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Stop searching now. */</comment>
            <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></for>

    <comment type="block">/* loop through all the per directory cacheenable entries */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>dconf</name>-&gt;<name>cacheenable</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type>struct <name>cache_enable</name> *</type><name>ent</name> <init>=
                                <expr>(struct <name>cache_enable</name> *)<name><name>dconf</name>-&gt;<name>cacheenable</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>providers</name> = <call><name>get_provider</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>providers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* loop through all the global cacheenable entries */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>conf</name>-&gt;<name>cacheenable</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <decl_stmt><decl><type>struct <name>cache_enable</name> *</type><name>ent</name> <init>=
                                <expr>(struct <name>cache_enable</name> *)<name><name>conf</name>-&gt;<name>cacheenable</name>-&gt;<name>elts</name></name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>uri_meets_conditions</name><argument_list>(<argument><expr>&amp;<name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name>.<name>url</name></expr></argument>, <argument><expr><name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pathlen</name></expr></argument>,
                                 <argument><expr>&amp;<name><name>r</name>-&gt;<name>parsed_uri</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>providers</name> = <call><name>get_provider</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name><name>ent</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>providers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

    <return>return <expr><name>providers</name></expr>;</return>
}</block></function>


<comment type="block">/* do a HTTP/1.1 age calculation */</comment>
<macro><name>CACHE_DECLARE</name><argument_list>(<argument>apr_int64_t</argument>)</argument_list></macro> <macro><name>ap_cache_current_age</name><argument_list>(<argument>cache_info *info</argument>,
                                                <argument>const apr_time_t age_value</argument>,
                                                <argument>apr_time_t now</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>apparent_age</name></decl>, <decl><type ref="prev"/><name>corrected_received_age</name></decl>, <decl><type ref="prev"/><name>response_delay</name></decl>,
               <decl><type ref="prev"/><name>corrected_initial_age</name></decl>, <decl><type ref="prev"/><name>resident_time</name></decl>, <decl><type ref="prev"/><name>current_age</name></decl>,
               <decl><type ref="prev"/><name>age_value_usec</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>age_value_usec</name> = <call><name>apr_time_from_sec</name><argument_list>(<argument><expr><name>age_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Perform an HTTP/1.1 age calculation. (RFC2616 13.2.3) */</comment>

    <expr_stmt><expr><name>apparent_age</name> = <call><name>MAX</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>info</name>-&gt;<name>response_time</name></name> - <name><name>info</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>corrected_received_age</name> = <call><name>MAX</name><argument_list>(<argument><expr><name>apparent_age</name></expr></argument>, <argument><expr><name>age_value_usec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>response_delay</name> = <name><name>info</name>-&gt;<name>response_time</name></name> - <name><name>info</name>-&gt;<name>request_time</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>corrected_initial_age</name> = <name>corrected_received_age</name> + <name>response_delay</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>resident_time</name> = <name>now</name> - <name><name>info</name>-&gt;<name>response_time</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>current_age</name> = <name>corrected_initial_age</name> + <name>resident_time</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>current_age</name> &lt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>current_age</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><call><name>apr_time_sec</name><argument_list>(<argument><expr><name>current_age</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/**
 * Try obtain a cache wide lock on the given cache key.
 *
 * If we return APR_SUCCESS, we obtained the lock, and we are clear to
 * proceed to the backend. If we return APR_EEXIST, then the lock is
 * already locked, someone else has gone to refresh the backend data
 * already, so we must return stale data with a warning in the mean
 * time. If we return anything else, then something has gone pear
 * shaped, and we allow the request through to the backend regardless.
 *
 * This lock is created from the request pool, meaning that should
 * something go wrong and the lock isn't deleted on return of the
 * request headers from the backend for whatever reason, at worst the
 * lock will be cleaned up when the request dies or finishes.
 *
 * If something goes truly bananas and the lock isn't deleted when the
 * request dies, the lock will be trashed when its max-age is reached,
 * or when a request arrives containing a Cache-Control: no-cache. At
 * no point is it possible for this lock to permanently deny access to
 * the backend.
 */</comment>
<function><type><name>apr_status_t</name></type> <name>cache_try_lock</name><parameter_list>(<param><decl><type><name>cache_server_conf</name> *</type><name>conf</name></decl></param>, <param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>,
        <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lockname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>dir</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>now</name> <init>= <expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>lockfile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>void</name> *</type><name>dummy</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>finfo</name>.<name>mtime</name></name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>conf</name> || !<name><name>conf</name>-&gt;<name>lock</name></name> || !<name><name>conf</name>-&gt;<name>lockpath</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* no locks configured, leave */</comment>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* lock already obtained earlier? if so, success */</comment>
    <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>dummy</name></expr></argument>, <argument><expr><name>CACHE_LOCKFILE_KEY</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>dummy</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* create the key if it doesn't exist */</comment>
    <if>if <condition>(<expr>!<name><name>cache</name>-&gt;<name>key</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>cache_handle_t</name> *</type><name>h</name></decl>;</decl_stmt>
        <comment type="block">/*
         * Try to use the key of a possible open but stale cache
         * entry if we have one.
         */</comment>
        <if>if <condition>(<expr><name><name>cache</name>-&gt;<name>handle</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>h</name> = <name><name>cache</name>-&gt;<name>handle</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name>h</name> = <name><name>cache</name>-&gt;<name>stale_handle</name></name></expr>;</expr_stmt>
        }</block></else></if>
        <if>if <condition>(<expr>(<name>h</name> != <name>NULL</name>) &amp;&amp;
            (<name><name>h</name>-&gt;<name>cache_obj</name></name> != <name>NULL</name>) &amp;&amp;
            (<name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>key</name></name> != <name>NULL</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>cache</name>-&gt;<name>key</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>cache_generate_key</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name><name>cache</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <comment type="block">/* create a hashed filename from the key, and save it for later */</comment>
    <expr_stmt><expr><name>lockname</name> = <call><name>ap_cache_generate_name</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cache</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* lock files represent discrete just-went-stale URLs "in flight", so
     * we support a simple two level directory structure, more is overkill.
     */</comment>
    <expr_stmt><expr><name><name>dir</name><index>[<expr>0</expr>]</index></name> = '/'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dir</name><index>[<expr>1</expr>]</index></name> = <name><name>lockname</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dir</name><index>[<expr>2</expr>]</index></name> = '/'</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dir</name><index>[<expr>3</expr>]</index></name> = <name><name>lockname</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>dir</name><index>[<expr>4</expr>]</index></name> = 0</expr>;</expr_stmt>

    <comment type="block">/* make the directories */</comment>
    <expr_stmt><expr><name>path</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>lockpath</name></name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>APR_SUCCESS</name> != (<name>status</name> = <call><name>apr_dir_make_recursive</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
            <argument><expr><name>APR_UREAD</name>|<name>APR_UWRITE</name>|<name>APR_UEXECUTE</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00778</expr></argument>)</argument_list></call>
                "Could not create a cache lock directory: %s"</expr></argument>,
                <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>lockname</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr><name>lockname</name></expr></argument>, <argument><expr><name>CACHE_LOCKNAME_KEY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* is an existing lock file too old? */</comment>
    <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>,
                <argument><expr><name>APR_FINFO_MTIME</name> | <name>APR_FINFO_NLINK</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr>!(<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call>) &amp;&amp; <name>APR_SUCCESS</name> != <name>status</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00779</expr></argument>)</argument_list></call>
                "Could not stat a cache lock file: %s"</expr></argument>,
                <argument><expr><name>lockname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>status</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr>(<name>status</name> == <name>APR_SUCCESS</name>) &amp;&amp; (((<name>now</name> - <name><name>finfo</name>.<name>mtime</name></name>) &gt; <name><name>conf</name>-&gt;<name>lockmaxage</name></name>)
                                  || (<name>now</name> &lt; <name><name>finfo</name>.<name>mtime</name></name>))</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00780</expr></argument>)</argument_list></call>
                "Cache lock file for '%s' too old, removing: %s"</expr></argument>,
                <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_file_remove</name><argument_list>(<argument><expr><name>lockname</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* try obtain a lock on the file */</comment>
    <if>if <condition>(<expr><name>APR_SUCCESS</name> == (<name>status</name> = <call><name>apr_file_open</name><argument_list>(<argument><expr>&amp;<name>lockfile</name></expr></argument>, <argument><expr><name>lockname</name></expr></argument>,
            <argument><expr><name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_EXCL</name> | <name>APR_DELONCLOSE</name></expr></argument>,
            <argument><expr><name>APR_UREAD</name> | <name>APR_UWRITE</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>, <argument><expr><name>CACHE_LOCKFILE_KEY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>status</name></expr>;</return>

}</block></function>

<comment type="block">/**
 * Remove the cache lock, if present.
 *
 * First, try to close the file handle, whose delete-on-close should
 * kill the file. Otherwise, just delete the file by name.
 *
 * If no lock name has yet been calculated, do the calculation of the
 * lock name first before trying to delete the file.
 *
 * If an optional bucket brigade is passed, the lock will only be
 * removed if the bucket brigade contains an EOS bucket.
 */</comment>
<function><type><name>apr_status_t</name></type> <name>cache_remove_lock</name><parameter_list>(<param><decl><type><name>cache_server_conf</name> *</type><name>conf</name></decl></param>,
        <param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>dummy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lockname</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>conf</name> || !<name><name>conf</name>-&gt;<name>lock</name></name> || !<name><name>conf</name>-&gt;<name>lockpath</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* no locks configured, leave */</comment>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>bb</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>eos_found</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>eos_found</name> = 1</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr>!<name>eos_found</name></expr>)</condition><then> <block>{
            <comment type="block">/* no eos found in brigade, don't delete anything just yet,
             * we are not done.
             */</comment>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>dummy</name></expr></argument>, <argument><expr><name>CACHE_LOCKFILE_KEY</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>dummy</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_file_close</name><argument_list>(<argument><expr>(<name>apr_file_t</name> *)<name>dummy</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>dummy</name></expr></argument>, <argument><expr><name>CACHE_LOCKNAME_KEY</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>lockname</name> = (const <name>char</name> *)<name>dummy</name></expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name>lockname</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name><name>dir</name><index>[<expr>5</expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/* create the key if it doesn't exist */</comment>
        <if>if <condition>(<expr>!<name><name>cache</name>-&gt;<name>key</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>cache_generate_key</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name><name>cache</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* create a hashed filename from the key, and save it for later */</comment>
        <expr_stmt><expr><name>lockname</name> = <call><name>ap_cache_generate_name</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>cache</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* lock files represent discrete just-went-stale URLs "in flight", so
         * we support a simple two level directory structure, more is overkill.
         */</comment>
        <expr_stmt><expr><name><name>dir</name><index>[<expr>0</expr>]</index></name> = '/'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dir</name><index>[<expr>1</expr>]</index></name> = <name><name>lockname</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dir</name><index>[<expr>2</expr>]</index></name> = '/'</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dir</name><index>[<expr>3</expr>]</index></name> = <name><name>lockname</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>dir</name><index>[<expr>4</expr>]</index></name> = 0</expr>;</expr_stmt>

        <expr_stmt><expr><name>lockname</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>conf</name>-&gt;<name>lockpath</name></name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>lockname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><call><name>apr_file_remove</name><argument_list>(<argument><expr><name>lockname</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>ap_cache_check_no_cache</name><parameter_list>(<param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{

    <decl_stmt><decl><type><name>cache_server_conf</name> *</type><name>conf</name> <init>=
      <expr>(<name>cache_server_conf</name> *)<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                                <argument><expr>&amp;<name>cache_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * At this point, we may have data cached, but the request may have
     * specified that cached data may not be used in a response.
     *
     * This is covered under RFC2616 section 14.9.4 (Cache Revalidation and
     * Reload Controls).
     *
     * - RFC2616 14.9.4 End to end reload, Cache-Control: no-cache, or Pragma:
     * no-cache. The server MUST NOT use a cached copy when responding to such
     * a request.
     */</comment>

    <comment type="block">/* This value comes from the client's initial request. */</comment>
    <if>if <condition>(<expr>!<name><name>cache</name>-&gt;<name>control_in</name>.<name>parsed</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cc_req</name> <init>= <expr><call><name>cache_table_getm</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>,
                <argument><expr>"Cache-Control"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pragma</name> <init>= <expr><call><name>cache_table_getm</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Pragma"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_cache_control</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name><name>cache</name>-&gt;<name>control_in</name></name></expr></argument>, <argument><expr><name>cc_req</name></expr></argument>, <argument><expr><name>pragma</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>cache</name>-&gt;<name>control_in</name>.<name>no_cache</name></name></expr>)</condition><then> <block>{

        <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>ignorecachecontrol</name></name></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02657</expr></argument>)</argument_list></call>
                    "Incoming request is asking for an uncached version of "
                    "%s, but we have been configured to ignore it and serve "
                    "cached content anyway"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>unparsed_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>ap_cache_check_no_store</name><parameter_list>(<param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{

    <decl_stmt><decl><type><name>cache_server_conf</name> *</type><name>conf</name> <init>=
      <expr>(<name>cache_server_conf</name> *)<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                                <argument><expr>&amp;<name>cache_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * At this point, we may have data cached, but the request may have
     * specified that cached data may not be used in a response.
     *
     * - RFC2616 14.9.2 What May be Stored by Caches. If Cache-Control:
     * no-store arrives, do not serve from or store to the cache.
     */</comment>

    <comment type="block">/* This value comes from the client's initial request. */</comment>
    <if>if <condition>(<expr>!<name><name>cache</name>-&gt;<name>control_in</name>.<name>parsed</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cc_req</name> <init>= <expr><call><name>cache_table_getm</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>,
                <argument><expr>"Cache-Control"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pragma</name> <init>= <expr><call><name>cache_table_getm</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Pragma"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_cache_control</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name><name>cache</name>-&gt;<name>control_in</name></name></expr></argument>, <argument><expr><name>cc_req</name></expr></argument>, <argument><expr><name>pragma</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>cache</name>-&gt;<name>control_in</name>.<name>no_store</name></name></expr>)</condition><then> <block>{

        <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>ignorecachecontrol</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* We're not allowed to serve a cached copy */</comment>
            <return>return <expr>0</expr>;</return>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02658</expr></argument>)</argument_list></call>
                    "Incoming request is asking for a no-store version of "
                    "%s, but we have been configured to ignore it and serve "
                    "cached content anyway"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>unparsed_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><name>int</name></type> <name>cache_check_freshness</name><parameter_list>(<param><decl><type><name>cache_handle_t</name> *</type><name>h</name></decl></param>, <param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>,
        <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>age</name></decl>, <decl><type ref="prev"/><name>maxage_req</name></decl>, <decl><type ref="prev"/><name>maxage_cresp</name></decl>, <decl><type ref="prev"/><name>maxage</name></decl>, <decl><type ref="prev"/><name>smaxage</name></decl>, <decl><type ref="prev"/><name>maxstale</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>minfresh</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cc_req</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pragma</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>agestr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>age_c</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cache_info</name> *</type><name>info</name> <init>= <expr>&amp;(<name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>info</name></name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>warn_head</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cache_server_conf</name> *</type><name>conf</name> <init>=
      <expr>(<name>cache_server_conf</name> *)<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                                <argument><expr>&amp;<name>cache_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * We now want to check if our cached data is still fresh. This depends
     * on a few things, in this order:
     *
     * - RFC2616 14.9.4 End to end reload, Cache-Control: no-cache. no-cache
     * in either the request or the cached response means that we must
     * perform the request unconditionally, and ignore cached content. We
     * should never reach here, but if we do, mark the content as stale,
     * as this is the best we can do.
     *
     * - RFC2616 14.32 Pragma: no-cache This is treated the same as
     * Cache-Control: no-cache.
     *
     * - RFC2616 14.9.3 Cache-Control: max-stale, must-revalidate,
     * proxy-revalidate if the max-stale request header exists, modify the
     * stale calculations below so that an object can be at most &lt;max-stale&gt;
     * seconds stale before we request a revalidation, _UNLESS_ a
     * must-revalidate or proxy-revalidate cached response header exists to
     * stop us doing this.
     *
     * - RFC2616 14.9.3 Cache-Control: s-maxage the origin server specifies the
     * maximum age an object can be before it is considered stale. This
     * directive has the effect of proxy|must revalidate, which in turn means
     * simple ignore any max-stale setting.
     *
     * - RFC2616 14.9.4 Cache-Control: max-age this header can appear in both
     * requests and responses. If both are specified, the smaller of the two
     * takes priority.
     *
     * - RFC2616 14.21 Expires: if this request header exists in the cached
     * entity, and it's value is in the past, it has expired.
     *
     */</comment>

    <comment type="block">/* This value comes from the client's initial request. */</comment>
    <expr_stmt><expr><name>cc_req</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Cache-Control"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pragma</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Pragma"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_cache_control</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name><name>cache</name>-&gt;<name>control_in</name></name></expr></argument>, <argument><expr><name>cc_req</name></expr></argument>, <argument><expr><name>pragma</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>cache</name>-&gt;<name>control_in</name>.<name>no_cache</name></name></expr>)</condition><then> <block>{

        <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>ignorecachecontrol</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* Treat as stale, causing revalidation */</comment>
            <return>return <expr>0</expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00781</expr></argument>)</argument_list></call>
                "Incoming request is asking for a uncached version of "
                "%s, but we have been configured to ignore it and "
                "serve a cached response anyway"</expr></argument>,
                <argument><expr><name><name>r</name>-&gt;<name>unparsed_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* These come from the cached entity. */</comment>
    <if>if <condition>(<expr><name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>info</name>.<name>control</name>.<name>no_cache</name></name>
            || <name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>info</name>.<name>control</name>.<name>invalidated</name></name></expr>)</condition><then> <block>{
        <comment type="block">/*
         * The cached entity contained Cache-Control: no-cache, or a
         * no-cache with a header present, or a private with a header
         * present, or the cached entity has been invalidated in the
         * past, so treat as stale causing revalidation.
         */</comment>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>(<name>agestr</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>resp_hdrs</name></name></expr></argument>, <argument><expr>"Age"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>endp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offt</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>offt</name></expr></argument>, <argument><expr><name>agestr</name></expr></argument>, <argument><expr>&amp;<name>endp</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>
                &amp;&amp; <name>endp</name> &gt; <name>agestr</name> &amp;&amp; !*<name>endp</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>age_c</name> = <name>offt</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* calculate age of object */</comment>
    <expr_stmt><expr><name>age</name> = <call><name>ap_cache_current_age</name><argument_list>(<argument><expr><name>info</name></expr></argument>, <argument><expr><name>age_c</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* extract s-maxage */</comment>
    <expr_stmt><expr><name>smaxage</name> = <name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>info</name>.<name>control</name>.<name>s_maxage_value</name></name></expr>;</expr_stmt>

    <comment type="block">/* extract max-age from request */</comment>
    <expr_stmt><expr><name>maxage_req</name> = -1</expr>;</expr_stmt>
    <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>ignorecachecontrol</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>maxage_req</name> = <name><name>cache</name>-&gt;<name>control_in</name>.<name>max_age_value</name></name></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * extract max-age from response, if both s-maxage and max-age, s-maxage
     * takes priority
     */</comment>
    <if>if <condition>(<expr><name>smaxage</name> != -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>maxage_cresp</name> = <name>smaxage</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>maxage_cresp</name> = <name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>info</name>.<name>control</name>.<name>max_age_value</name></name></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     * if both maxage request and response, the smaller one takes priority
     */</comment>
    <if>if <condition>(<expr><name>maxage_req</name> == -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>maxage</name> = <name>maxage_cresp</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>maxage_cresp</name> == -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>maxage</name> = <name>maxage_req</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>maxage</name> = <call><name>MIN</name><argument_list>(<argument><expr><name>maxage_req</name></expr></argument>, <argument><expr><name>maxage_cresp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

    <comment type="block">/* extract max-stale */</comment>
    <if>if <condition>(<expr><name><name>cache</name>-&gt;<name>control_in</name>.<name>max_stale</name></name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>cache</name>-&gt;<name>control_in</name>.<name>max_stale_value</name></name> != -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>maxstale</name> = <name><name>cache</name>-&gt;<name>control_in</name>.<name>max_stale_value</name></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/*
             * If no value is assigned to max-stale, then the client is willing
             * to accept a stale response of any age (RFC2616 14.9.3). We will
             * set it to one year in this case as this situation is somewhat
             * similar to a "never expires" Expires header (RFC2616 14.21)
             * which is set to a date one year from the time the response is
             * sent in this case.
             */</comment>
            <expr_stmt><expr><name>maxstale</name> = <call><name>APR_INT64_C</name><argument_list>(<argument><expr>86400*365</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>maxstale</name> = 0</expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* extract min-fresh */</comment>
    <if>if <condition>(<expr>!<name><name>conf</name>-&gt;<name>ignorecachecontrol</name></name> &amp;&amp; <name><name>cache</name>-&gt;<name>control_in</name>.<name>min_fresh</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>minfresh</name> = <name><name>cache</name>-&gt;<name>control_in</name>.<name>min_fresh_value</name></name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>minfresh</name> = 0</expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/* override maxstale if must-revalidate, proxy-revalidate or s-maxage */</comment>
    <if>if <condition>(<expr><name>maxstale</name> &amp;&amp; (<name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>info</name>.<name>control</name>.<name>must_revalidate</name></name>
            || <name><name>h</name>-&gt;<name>cache_obj</name>-&gt;<name>info</name>.<name>control</name>.<name>proxy_revalidate</name></name> || <name>smaxage</name> != -1)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name>maxstale</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* handle expiration */</comment>
    <if>if <condition>(<expr>((<name>maxage</name> != -1) &amp;&amp; (<name>age</name> &lt; (<name>maxage</name> + <name>maxstale</name> - <name>minfresh</name>))) ||
        ((<name>smaxage</name> == -1) &amp;&amp; (<name>maxage</name> == -1) &amp;&amp;
         (<name><name>info</name>-&gt;<name>expire</name></name> != <name>APR_DATE_BAD</name>) &amp;&amp;
         (<name>age</name> &lt; (<call><name>apr_time_sec</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>expire</name></name> - <name><name>info</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call> + <name>maxstale</name> - <name>minfresh</name>)))</expr>)</condition><then> <block>{

        <expr_stmt><expr><name>warn_head</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>resp_hdrs</name></name></expr></argument>, <argument><expr>"Warning"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* it's fresh darlings... */</comment>
        <comment type="block">/* set age header on response */</comment>
        <expr_stmt><expr><call><name>apr_table_set</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>resp_hdrs</name></name></expr></argument>, <argument><expr>"Age"</expr></argument>,
                      <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%lu"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>long</name>)<name>age</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* add warning if maxstale overrode freshness calculation */</comment>
        <if>if <condition>(<expr>!(((<name>maxage</name> != -1) &amp;&amp; <name>age</name> &lt; <name>maxage</name>) ||
              (<name><name>info</name>-&gt;<name>expire</name></name> != <name>APR_DATE_BAD</name> &amp;&amp;
               (<call><name>apr_time_sec</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>expire</name></name> - <name><name>info</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call>) &gt; <name>age</name>))</expr>)</condition><then> <block>{
            <comment type="block">/* make sure we don't stomp on a previous warning */</comment>
            <if>if <condition>(<expr>(<name>warn_head</name> == <name>NULL</name>) ||
                ((<name>warn_head</name> != <name>NULL</name>) &amp;&amp; (<call><name>ap_strstr_c</name><argument_list>(<argument><expr><name>warn_head</name></expr></argument>, <argument><expr>"110"</expr></argument>)</argument_list></call> == <name>NULL</name>))</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>resp_hdrs</name></name></expr></argument>, <argument><expr>"Warning"</expr></argument>,
                                 <argument><expr>"110 Response is stale"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/*
         * If none of Expires, Cache-Control: max-age, or Cache-Control:
         * s-maxage appears in the response, and the response header age
         * calculated is more than 24 hours add the warning 113
         */</comment>
        <if>if <condition>(<expr>(<name>maxage_cresp</name> == -1) &amp;&amp; (<name>smaxage</name> == -1) &amp;&amp; (<call><name>apr_table_get</name><argument_list>(
                <argument><expr><name><name>h</name>-&gt;<name>resp_hdrs</name></name></expr></argument>, <argument><expr>"Expires"</expr></argument>)</argument_list></call> == <name>NULL</name>) &amp;&amp; (<name>age</name> &gt; 86400)</expr>)</condition><then> <block>{

            <comment type="block">/* Make sure we don't stomp on a previous warning, and don't dup
             * a 113 marning that is already present. Also, make sure to add
             * the new warning to the correct *headers_out location.
             */</comment>
            <if>if <condition>(<expr>(<name>warn_head</name> == <name>NULL</name>) ||
                ((<name>warn_head</name> != <name>NULL</name>) &amp;&amp; (<call><name>ap_strstr_c</name><argument_list>(<argument><expr><name>warn_head</name></expr></argument>, <argument><expr>"113"</expr></argument>)</argument_list></call> == <name>NULL</name>))</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>resp_hdrs</name></name></expr></argument>, <argument><expr>"Warning"</expr></argument>,
                                 <argument><expr>"113 Heuristic expiration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <return>return <expr>1</expr>;</return>    <comment type="block">/* Cache object is fresh (enough) */</comment>
    }</block></then></if>

    <comment type="block">/*
     * At this point we are stale, but: if we are under load, we may let
     * a significant number of stale requests through before the first
     * stale request successfully revalidates itself, causing a sudden
     * unexpected thundering herd which in turn brings angst and drama.
     *
     * So.
     *
     * We want the first stale request to go through as normal. But the
     * second and subsequent request, we must pretend to be fresh until
     * the first request comes back with either new content or confirmation
     * that the stale content is still fresh.
     *
     * To achieve this, we create a very simple file based lock based on
     * the key of the cached object. We attempt to open the lock file with
     * exclusive write access. If we succeed, woohoo! we're first, and we
     * follow the stale path to the backend server. If we fail, oh well,
     * we follow the fresh path, and avoid being a thundering herd.
     *
     * The lock lives only as long as the stale request that went on ahead.
     * If the request succeeds, the lock is deleted. If the request fails,
     * the lock is deleted, and another request gets to make a new lock
     * and try again.
     *
     * At any time, a request marked "no-cache" will force a refresh,
     * ignoring the lock, ensuring an extended lockout is impossible.
     *
     * A lock that exceeds a maximum age will be deleted, and another
     * request gets to make a new lock and try again.
     */</comment>
    <expr_stmt><expr><name>status</name> = <call><name>cache_try_lock</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>APR_SUCCESS</name> == <name>status</name></expr>)</condition><then> <block>{
        <comment type="block">/* we obtained a lock, follow the stale path */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00782</expr></argument>)</argument_list></call>
                "Cache lock obtained for stale cached URL, "
                "revalidating entry: %s"</expr></argument>,
                <argument><expr><name><name>r</name>-&gt;<name>unparsed_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* lock already exists, return stale data anyway, with a warning */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00783</expr></argument>)</argument_list></call>
                "Cache already locked for stale cached URL, "
                "pretend it is fresh: %s"</expr></argument>,
                <argument><expr><name><name>r</name>-&gt;<name>unparsed_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* make sure we don't stomp on a previous warning */</comment>
        <expr_stmt><expr><name>warn_head</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>resp_hdrs</name></name></expr></argument>, <argument><expr>"Warning"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>warn_head</name> == <name>NULL</name>) ||
            ((<name>warn_head</name> != <name>NULL</name>) &amp;&amp; (<call><name>ap_strstr_c</name><argument_list>(<argument><expr><name>warn_head</name></expr></argument>, <argument><expr>"110"</expr></argument>)</argument_list></call> == <name>NULL</name>))</expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>resp_hdrs</name></name></expr></argument>, <argument><expr>"Warning"</expr></argument>,
                             <argument><expr>"110 Response is stale"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <return>return <expr>1</expr>;</return>
    }</block></then>
    <else>else <block>{
        <comment type="block">/* some other error occurred, just treat the object as stale */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>00784</expr></argument>)</argument_list></call>
                "Attempt to obtain a cache lock for stale "
                "cached URL failed, revalidating entry anyway: %s"</expr></argument>,
                <argument><expr><name><name>r</name>-&gt;<name>unparsed_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></else></if></else></if>

}</block></function>

<comment type="block">/* return each comma separated token, one at a time */</comment>
<macro><name>CACHE_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro><macro><name>ap_cache_tokstr</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>const char *list</argument>,
                                           <argument>const char **str</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>s</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>s</name> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>i</name> = <name>s</name> - <name>list</name></expr>;</expr_stmt>
        <do>do
            <expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
        while <condition>(<expr><call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
            ;</do> <comment type="block">/* noop */</comment>
    }</block></then>
    <else>else
        <expr_stmt><expr><name>i</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    <while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>list</name><index>[<expr><name>i</name> - 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
        <expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>

    <expr_stmt><expr>*<name>str</name> = <name>s</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>i</name></expr>)</condition><then>
        <return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return></then>
    <else>else
        <return>return <expr><name>NULL</name></expr>;</return></else></if>
}</block>

<comment type="block">/*
 * Converts apr_time_t expressed as hex digits to
 * a true apr_time_t.
 */</comment>
<macro><name>CACHE_DECLARE</name><argument_list>(<argument>apr_time_t</argument>)</argument_list></macro> <macro><name>ap_cache_hex2usec</name><argument_list>(<argument>const char *x</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>j</name></decl>;</decl_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></sizeof> * 2</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name>ch</name> = <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> &lt;&lt;= 4</expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>apr_isdigit</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>j</name> |= <name>ch</name> - '0'</expr>;</expr_stmt></then>
        <else>else <if>if <condition>(<expr><call><name>apr_isupper</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>j</name> |= <name>ch</name> - ('A' - 10)</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name>j</name> |= <name>ch</name> - ('a' - 10)</expr>;</expr_stmt></else></if></else></if>
    }</block></for>
    <return>return <expr><name>j</name></expr>;</return>
}</block>

<comment type="block">/*
 * Converts apr_time_t to apr_time_t expressed as hex digits.
 */</comment>
<macro><name>CACHE_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_cache_usec2hex</name><argument_list>(<argument>apr_time_t j</argument>, <argument>char *y</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ch</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = (<sizeof>sizeof<argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></sizeof> * 2)-1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
        <expr_stmt><expr><name>ch</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>j</name> &amp; 0xF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>j</name> &gt;&gt;= 4</expr>;</expr_stmt>
        <if>if <condition>(<expr><name>ch</name> &gt;= 10</expr>)</condition><then>
            <expr_stmt><expr><name><name>y</name><index>[<expr><name>i</name></expr>]</index></name> = <name>ch</name> + ('A' - 10)</expr>;</expr_stmt></then>
        <else>else
            <expr_stmt><expr><name><name>y</name><index>[<expr><name>i</name></expr>]</index></name> = <name>ch</name> + '0'</expr>;</expr_stmt></else></if>
    }</block></for>
    <expr_stmt><expr><name><name>y</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></sizeof> * 2</expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cache_hash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>it</name></decl></param>, <param><decl><type><name>char</name> *</type><name>val</name></decl></param>, <param><decl><type><name>int</name></type> <name>ndepth</name></decl></param>, <param><decl><type><name>int</name></type> <name>nlength</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_md5_ctx_t</name></type> <name>context</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr>16</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr>22</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>enc_table</name><index>[<expr>64</expr>]</index></name> <init>=
    <expr>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_@"</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>apr_md5_init</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_md5_update</name><argument_list>(<argument><expr>&amp;<name>context</name></expr></argument>, <argument><expr>(const <name>unsigned</name> <name>char</name> *) <name>it</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_md5_final</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr>&amp;<name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* encode 128 bits as 22 characters, using a modified uuencoding
     * the encoding is 3 bytes -&gt; 4 characters* i.e. 128 bits is
     * 5 x 3 bytes + 1 byte -&gt; 5 * 4 characters + 2 characters
     */</comment>
    <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>k</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 15</expr>;</condition> <incr><expr><name>i</name> += 3</expr></incr>) <block>{
        <expr_stmt><expr><name>x</name> = (<name><name>digest</name><index>[<expr><name>i</name></expr>]</index></name> &lt;&lt; 16) | (<name><name>digest</name><index>[<expr><name>i</name> + 1</expr>]</index></name> &lt;&lt; 8) | <name><name>digest</name><index>[<expr><name>i</name> + 2</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr><name>x</name> &gt;&gt; 18</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr>(<name>x</name> &gt;&gt; 12) &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr>(<name>x</name> &gt;&gt; 6) &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr><name>x</name> &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>
    }</block></for>

    <comment type="block">/* one byte left */</comment>
    <expr_stmt><expr><name>x</name> = <name><name>digest</name><index>[<expr>15</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr><name>x</name> &gt;&gt; 2</expr>]</index></name></expr>;</expr_stmt>    <comment type="block">/* use up 6 bits */</comment>
    <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>k</name>++</expr>]</index></name> = <name><name>enc_table</name><index>[<expr>(<name>x</name> &lt;&lt; 4) &amp; 0x3f</expr>]</index></name></expr>;</expr_stmt>

    <comment type="block">/* now split into directory levels */</comment>
    <for>for (<init><expr><name>i</name> = <name>k</name> = <name>d</name> = 0</expr>;</init> <condition><expr><name>d</name> &lt; <name>ndepth</name></expr>;</condition> <incr><expr>++<name>d</name></expr></incr>) <block>{
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>tmp</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>nlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> += <name>nlength</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>val</name><index>[<expr><name>i</name> + <name>nlength</name></expr>]</index></name> = '/'</expr>;</expr_stmt>
        <expr_stmt><expr><name>i</name> += <name>nlength</name> + 1</expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>&amp;<name><name>val</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>tmp</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr>22 - <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>val</name><index>[<expr><name>i</name> + 22 - <name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>

<macro><name>CACHE_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro><macro><name>ap_cache_generate_name</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>int dirlevels</argument>,
                                            <argument>int dirlength</argument>, <argument>const char *name</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>hashfile</name><index>[<expr>66</expr>]</index></name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>cache_hash</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>hashfile</name></expr></argument>, <argument><expr><name>dirlevels</name></expr></argument>, <argument><expr><name>dirlength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>hashfile</name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/**
 * String tokenizer that ignores separator characters within quoted strings
 * and escaped characters, as per RFC2616 section 2.2.
 */</comment>
<function><type><name>char</name> *</type><name>cache_strqtok</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl></param>, <param><decl><type><name>char</name> **</type><name>last</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>quoted</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{         <comment type="block">/* subsequent call */</comment>
        <expr_stmt><expr><name>str</name> = *<name>last</name></expr>;</expr_stmt>    <comment type="block">/* start where we left off */</comment>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{         <comment type="block">/* no more tokens */</comment>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* skip characters in sep (will terminate at '\0') */</comment>
    <while>while <condition>(<expr>*<name>str</name> &amp;&amp; <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
        <expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
    }</block></while>

    <if>if <condition>(<expr>!*<name>str</name></expr>)</condition><then> <block>{        <comment type="block">/* no more tokens */</comment>
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>token</name> = <name>str</name></expr>;</expr_stmt>

    <comment type="block">/* skip valid token characters to terminate token and
     * prepare for the next call (will terminate at '\0)
     * on the way, ignore all quoted strings, and within
     * quoted strings, escaped characters.
     */</comment>
    <expr_stmt><expr>*<name>last</name> = <name>token</name></expr>;</expr_stmt>
    <while>while <condition>(<expr>**<name>last</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<name>quoted</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>**<name>last</name> == '\"' &amp;&amp; !<call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr>'\"'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>quoted</name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr>++*<name>last</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>!<call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr>**<name>last</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr>++*<name>last</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <break>break;</break>
            }</block></else></if></else></if>
        }</block></then>
        <else>else <block>{
            <if>if <condition>(<expr>**<name>last</name> == '\"'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>quoted</name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr>++*<name>last</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr>**<name>last</name> == '\\'</expr>)</condition><then> <block>{
                <expr_stmt><expr>++*<name>last</name></expr>;</expr_stmt>
                <if>if <condition>(<expr>**<name>last</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr>++*<name>last</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr>++*<name>last</name></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></else></if>
    }</block></while>

    <if>if <condition>(<expr>**<name>last</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>**<name>last</name> = '\0'</expr>;</expr_stmt>
        <expr_stmt><expr>++*<name>last</name></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>token</name></expr>;</return>
}</block></function>

<comment type="block">/**
 * Parse the Cache-Control and Pragma headers in one go, marking
 * which tokens appear within the header. Populate the structure
 * passed in.
 */</comment>
<function><type><name>int</name></type> <name>ap_cache_control</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>cache_control_t</name> *</type><name>cc</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cc_header</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pragma_header</name></decl></param>, <param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>last</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>cc</name>-&gt;<name>parsed</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name><name>cc</name>-&gt;<name>cache_control</name></name> || <name><name>cc</name>-&gt;<name>pragma</name></name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name><name>cc</name>-&gt;<name>parsed</name></name> = 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cc</name>-&gt;<name>max_age_value</name></name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cc</name>-&gt;<name>max_stale_value</name></name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cc</name>-&gt;<name>min_fresh_value</name></name> = -1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cc</name>-&gt;<name>s_maxage_value</name></name> = -1</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>pragma_header</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>header</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>pragma_header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name> <init>= <expr><call><name>cache_strqtok</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>CACHE_SEPARATOR</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
            <if>if <condition>(<expr>!<call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"no-cache"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>cc</name>-&gt;<name>no_cache</name></name> = 1</expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>token</name> = <call><name>cache_strqtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CACHE_SEPARATOR</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name><name>cc</name>-&gt;<name>pragma</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name>cc_header</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>endp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offt</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>header</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>cc_header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name> <init>= <expr><call><name>cache_strqtok</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>CACHE_SEPARATOR</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
            <switch>switch <condition>(<expr><name><name>token</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr>'n'</expr>:
            </case><case>case <expr>'N'</expr>: <block>{
                <if>if <condition>(<expr>!<call><name>ap_cstr_casecmpn</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"no-cache"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>token</name><index>[<expr>8</expr>]</index></name> == '='</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>no_cache_header</name></name> = 1</expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr>!<name><name>token</name><index>[<expr>8</expr>]</index></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>no_cache</name></name> = 1</expr>;</expr_stmt>
                    }</block></then></if></else></if>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"no-store"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>cc</name>-&gt;<name>no_store</name></name> = 1</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"no-transform"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>cc</name>-&gt;<name>no_transform</name></name> = 1</expr>;</expr_stmt>
                }</block></then></if></else></if></else></if>
                <break>break;</break>
            }</block>
            </case><case>case <expr>'m'</expr>:
            </case><case>case <expr>'M'</expr>: <block>{
                <if>if <condition>(<expr>!<call><name>ap_cstr_casecmpn</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"max-age"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>token</name><index>[<expr>7</expr>]</index></name> == '='
                            &amp;&amp; !<call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>offt</name></expr></argument>, <argument><expr><name>token</name> + 8</expr></argument>, <argument><expr>&amp;<name>endp</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>
                            &amp;&amp; <name>endp</name> &gt; <name>token</name> + 8 &amp;&amp; !*<name>endp</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>max_age</name></name> = 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>max_age_value</name></name> = <name>offt</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"must-revalidate"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>cc</name>-&gt;<name>must_revalidate</name></name> = 1</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>ap_cstr_casecmpn</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"max-stale"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>token</name><index>[<expr>9</expr>]</index></name> == '='
                            &amp;&amp; !<call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>offt</name></expr></argument>, <argument><expr><name>token</name> + 10</expr></argument>, <argument><expr>&amp;<name>endp</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>
                            &amp;&amp; <name>endp</name> &gt; <name>token</name> + 10 &amp;&amp; !*<name>endp</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>max_stale</name></name> = 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>max_stale_value</name></name> = <name>offt</name></expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr>!<name><name>token</name><index>[<expr>9</expr>]</index></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>max_stale</name></name> = 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>max_stale_value</name></name> = -1</expr>;</expr_stmt>
                    }</block></then></if></else></if>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>ap_cstr_casecmpn</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"min-fresh"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>token</name><index>[<expr>9</expr>]</index></name> == '='
                            &amp;&amp; !<call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>offt</name></expr></argument>, <argument><expr><name>token</name> + 10</expr></argument>, <argument><expr>&amp;<name>endp</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>
                            &amp;&amp; <name>endp</name> &gt; <name>token</name> + 10 &amp;&amp; !*<name>endp</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>min_fresh</name></name> = 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>min_fresh_value</name></name> = <name>offt</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if></else></if></else></if></else></if>
                <break>break;</break>
            }</block>
            </case><case>case <expr>'o'</expr>:
            </case><case>case <expr>'O'</expr>: <block>{
                <if>if <condition>(<expr>!<call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"only-if-cached"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>cc</name>-&gt;<name>only_if_cached</name></name> = 1</expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
            }</block>
            </case><case>case <expr>'p'</expr>:
            </case><case>case <expr>'P'</expr>: <block>{
                <if>if <condition>(<expr>!<call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"public"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>cc</name>-&gt;<name>public</name></name> = 1</expr>;</expr_stmt>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>ap_cstr_casecmpn</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"private"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>token</name><index>[<expr>7</expr>]</index></name> == '='</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>private_header</name></name> = 1</expr>;</expr_stmt>
                    }</block></then>
                    <else>else <if>if <condition>(<expr>!<name><name>token</name><index>[<expr>7</expr>]</index></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>private</name></name> = 1</expr>;</expr_stmt>
                    }</block></then></if></else></if>
                }</block></then>
                <else>else <if>if <condition>(<expr>!<call><name>ap_cstr_casecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"proxy-revalidate"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>cc</name>-&gt;<name>proxy_revalidate</name></name> = 1</expr>;</expr_stmt>
                }</block></then></if></else></if></else></if>
                <break>break;</break>
            }</block>
            </case><case>case <expr>'s'</expr>:
            </case><case>case <expr>'S'</expr>: <block>{
                <if>if <condition>(<expr>!<call><name>ap_cstr_casecmpn</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"s-maxage"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>token</name><index>[<expr>8</expr>]</index></name> == '='
                            &amp;&amp; !<call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name>offt</name></expr></argument>, <argument><expr><name>token</name> + 9</expr></argument>, <argument><expr>&amp;<name>endp</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>
                            &amp;&amp; <name>endp</name> &gt; <name>token</name> + 9 &amp;&amp; !*<name>endp</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>s_maxage</name></name> = 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>cc</name>-&gt;<name>s_maxage_value</name></name> = <name>offt</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <break>break;</break>
            }</block>
            </case>}</block></switch>
            <expr_stmt><expr><name>token</name> = <call><name>cache_strqtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CACHE_SEPARATOR</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><name><name>cc</name>-&gt;<name>cache_control</name></name> = 1</expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr>(<name>cc_header</name> != <name>NULL</name> || <name>pragma_header</name> != <name>NULL</name>)</expr>;</return>
}</block></function>

<comment type="block">/**
 * Parse the Cache-Control, identifying and removing headers that
 * exist as tokens after the no-cache and private tokens.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>cache_control_remove</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cc_header</name></decl></param>,
        <param><decl><type><name>apr_table_t</name> *</type><name>headers</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>last</name></decl>, *<decl><type ref="prev"/><name>slast</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>cc_header</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>header</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>cc_header</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>token</name> <init>= <expr><call><name>cache_strqtok</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>CACHE_SEPARATOR</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>token</name></expr>)</condition> <block>{
            <switch>switch <condition>(<expr><name><name>token</name><index>[<expr>0</expr>]</index></name></expr>)</condition> <block>{
            <case>case <expr>'n'</expr>:
            </case><case>case <expr>'N'</expr>: <block>{
                <if>if <condition>(<expr>!<call><name>ap_cstr_casecmpn</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"no-cache"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>token</name><index>[<expr>8</expr>]</index></name> == '='</expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name> <init>= <expr><call><name>cache_strqtok</name><argument_list>(<argument><expr><name>token</name> + 9</expr></argument>,
                                <argument><expr><name>CACHE_SEPARATOR</name> "\""</expr></argument>, <argument><expr>&amp;<name>slast</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <while>while <condition>(<expr><name>header</name></expr>)</condition> <block>{
                            <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>header</name> = <call><name>cache_strqtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CACHE_SEPARATOR</name> "\""</expr></argument>,
                                    <argument><expr>&amp;<name>slast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></while>
                        <expr_stmt><expr><name>found</name> = 1</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <break>break;</break>
            }</block>
            </case><case>case <expr>'p'</expr>:
            </case><case>case <expr>'P'</expr>: <block>{
                <if>if <condition>(<expr>!<call><name>ap_cstr_casecmpn</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr>"private"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <if>if <condition>(<expr><name><name>token</name><index>[<expr>7</expr>]</index></name> == '='</expr>)</condition><then> <block>{
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name> <init>= <expr><call><name>cache_strqtok</name><argument_list>(<argument><expr><name>token</name> + 8</expr></argument>,
                                <argument><expr><name>CACHE_SEPARATOR</name> "\""</expr></argument>, <argument><expr>&amp;<name>slast</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                        <while>while <condition>(<expr><name>header</name></expr>)</condition> <block>{
                            <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <expr_stmt><expr><name>header</name> = <call><name>cache_strqtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CACHE_SEPARATOR</name> "\""</expr></argument>,
                                    <argument><expr>&amp;<name>slast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></while>
                        <expr_stmt><expr><name>found</name> = 1</expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
                <break>break;</break>
            }</block>
            </case>}</block></switch>
            <expr_stmt><expr><name>token</name> = <call><name>cache_strqtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CACHE_SEPARATOR</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>
    }</block></then></if>

    <return>return <expr><name>found</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Create a new table consisting of those elements from an
 * headers table that are allowed to be stored in a cache.
 */</comment>
<macro><name>CACHE_DECLARE</name><argument_list>(<argument>apr_table_t *</argument>)</argument_list></macro><macro><name>ap_cache_cacheable_headers</name><argument_list>(<argument>apr_pool_t *pool</argument>,
                                                        <argument>apr_table_t *t</argument>,
                                                        <argument>server_rec *s</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>cache_server_conf</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers_out</name></decl>;</decl_stmt>

    <comment type="block">/* Short circuit the common case that there are not
     * (yet) any headers populated.
     */</comment>
    <if>if <condition>(<expr><name>t</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>apr_table_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if><empty_stmt>;</empty_stmt>

    <comment type="block">/* Make a copy of the headers, and remove from
     * the copy any hop-by-hop headers, as defined in Section
     * 13.5.1 of RFC 2616
     */</comment>
    <expr_stmt><expr><name>headers_out</name> = <call><name>apr_table_copy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Connection"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Keep-Alive"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Proxy-Authenticate"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Proxy-Authorization"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"TE"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Trailers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Upgrade"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>conf</name> = (<name>cache_server_conf</name> *)<call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>module_config</name></name></expr></argument>,
                                                     <argument><expr>&amp;<name>cache_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Remove the user defined headers set with CacheIgnoreHeaders.
     * This may break RFC 2616 compliance on behalf of the administrator.
     */</comment>
    <expr_stmt><expr><name>header</name> = (<name>char</name> **)<name><name>conf</name>-&gt;<name>ignore_headers</name>-&gt;<name>elts</name></name></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>conf</name>-&gt;<name>ignore_headers</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr><name><name>header</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>headers_out</name></expr>;</return>
}</block>

<comment type="block">/*
 * Create a new table consisting of those elements from an input
 * headers table that are allowed to be stored in a cache.
 */</comment>
<macro><name>CACHE_DECLARE</name><argument_list>(<argument>apr_table_t *</argument>)</argument_list></macro><macro><name>ap_cache_cacheable_headers_in</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <return>return <expr><call><name>ap_cache_cacheable_headers</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block>

<comment type="block">/*
 * Create a new table consisting of those elements from an output
 * headers table that are allowed to be stored in a cache;
 * ensure there is a content type and capture any errors.
 */</comment>
<macro><name>CACHE_DECLARE</name><argument_list>(<argument>apr_table_t *</argument>)</argument_list></macro><macro><name>ap_cache_cacheable_headers_out</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers_out</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>headers_out</name> = <call><name>ap_cache_cacheable_headers</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                             <argument><expr><call><name>cache_merge_headers_out</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>,
                                             <argument><expr><name><name>r</name>-&gt;<name>server</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>cache_control_remove</name><argument_list>(<argument><expr><name>r</name></expr></argument>,
            <argument><expr><call><name>cache_table_getm</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Cache-Control"</expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><name>headers_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>headers_out</name></expr>;</return>
}</block>

<function><type><name>apr_table_t</name> *</type><name>cache_merge_headers_out</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>headers_out</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>headers_out</name> = <call><name>apr_table_overlay</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>,
                                    <argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>content_type</name></name>
            &amp;&amp; !<call><name>apr_table_get</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Content-Type"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ctype</name> <init>= <expr><call><name>ap_make_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>content_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>ctype</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Content-Type"</expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>content_encoding</name></name>
            &amp;&amp; !<call><name>apr_table_get</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Content-Encoding"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name>headers_out</name></expr></argument>, <argument><expr>"Content-Encoding"</expr></argument>,
                       <argument><expr><name><name>r</name>-&gt;<name>content_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <return>return <expr><name>headers_out</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct
<block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>first</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>merged</name></decl>;</decl_stmt>
}</block></struct></type> <name>cache_table_getm_t</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cache_table_getm_do</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cache_table_getm_t</name> *</type><name>state</name> <init>= <expr>(<name>cache_table_getm_t</name> *) <name>v</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>first</name></name></expr>)</condition><then> <block>{
        <comment type="block">/**
         * The most common case is a single header, and this is covered by
         * a fast path that doesn't allocate any memory. On the second and
         * subsequent header, an array is created and the array concatenated
         * together to form the final value.
         */</comment>
        <expr_stmt><expr><name><name>state</name>-&gt;<name>first</name></name> = <name>val</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>elt</name></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<name><name>state</name>-&gt;<name>merged</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>state</name>-&gt;<name>merged</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>p</name></name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>elt</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>merged</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr>*<name>elt</name> = <name><name>state</name>-&gt;<name>first</name></name></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>elt</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>state</name>-&gt;<name>merged</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr>*<name>elt</name> = <name>val</name></expr>;</expr_stmt>
    }</block></else></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type><name>cache_table_getm</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>apr_table_t</name> *</type><name>t</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>cache_table_getm_t</name></type> <name>state</name></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>state</name>.<name>p</name></name> = <name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>first</name></name> = <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>state</name>.<name>merged</name></name> = <name>NULL</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>cache_table_getm_do</name></expr></argument>, <argument><expr>&amp;<name>state</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>state</name>.<name>first</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<name><name>state</name>.<name>merged</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name><name>state</name>.<name>first</name></name></expr>;</return>
    }</block></then>
    <else>else <block>{
        <return>return <expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>state</name>.<name>merged</name></name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if>
}</block></function>
</unit>
