<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/cache/cache_util.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file cache_util.h
 * @brief Cache Storage Functions
 *
 * @defgroup Cache_util  Cache Utility Functions
 * @ingroup  MOD_CACHE
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>CACHE_UTIL_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_UTIL_H</name></cpp:macro></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_cache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_hooks.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_optional.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_uri.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETDB_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netdb.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SOCKET_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_NETINET_IN_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_ARPA_INET_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_atomic.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MAX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<param><type><name>a</name></type></param>,<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>                <cpp:value>((a) &gt; (b) ? (a) : (b))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MIN</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<param><type><name>a</name></type></param>,<param><type><name>b</name></type></param>)</parameter_list></cpp:macro>                <cpp:value>((a) &lt; (b) ? (a) : (b))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSEC_ONE_DAY</name></cpp:macro>    <cpp:value>((apr_time_t)(86400*APR_USEC_PER_SEC))</cpp:value></cpp:define> <comment type="block">/* one day, in microseconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSEC_ONE_HR</name></cpp:macro>     <cpp:value>((apr_time_t)(3600*APR_USEC_PER_SEC))</cpp:value></cpp:define>  <comment type="block">/* one hour, in microseconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSEC_ONE_MIN</name></cpp:macro>    <cpp:value>((apr_time_t)(60*APR_USEC_PER_SEC))</cpp:value></cpp:define>    <comment type="block">/* one minute, in microseconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSEC_ONE_SEC</name></cpp:macro>    <cpp:value>((apr_time_t)(APR_USEC_PER_SEC))</cpp:value></cpp:define>       <comment type="block">/* one second, in microseconds */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CACHE_MAXEXPIRE</name></cpp:macro> <cpp:value>MSEC_ONE_DAY</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CACHE_MINEXPIRE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CACHE_EXPIRE</name></cpp:macro>    <cpp:value>MSEC_ONE_HR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CACHE_LMFACTOR</name></cpp:macro>  <cpp:value>(0.1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CACHE_MAXAGE</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_X_CACHE</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_X_CACHE_DETAIL</name></cpp:macro>  <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CACHE_STALE_ON_ERROR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_CACHE_LOCKPATH</name></cpp:macro> <cpp:value>"/mod_cache-lock"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_LOCKNAME_KEY</name></cpp:macro> <cpp:value>"mod_cache-lockname"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_LOCKFILE_KEY</name></cpp:macro> <cpp:value>"mod_cache-lockfile"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_CTX_KEY</name></cpp:macro> <cpp:value>"mod_cache-ctx"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_SEPARATOR</name></cpp:macro> <cpp:value>", \t"</cpp:value></cpp:define>

<comment type="block">/**
 * cache_util.c
 */</comment>

<struct>struct <name>cache_enable</name> <block>{
    <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>url</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>pathlen</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>cache_disable</name> <block>{
    <decl_stmt><decl><type><name>apr_uri_t</name></type> <name>url</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>pathlen</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* static information about the local cache */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>cacheenable</name></decl>;</decl_stmt>    <comment type="block">/* URLs to cache */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>cachedisable</name></decl>;</decl_stmt>   <comment type="block">/* URLs not to cache */</comment>
    <comment type="block">/** store the headers that should not be stored in the cache */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ignore_headers</name></decl>;</decl_stmt>
    <comment type="block">/** store the identifiers that should not be used for key calculation */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ignore_session_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lockpath</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>lockmaxage</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uri_t</name> *</type><name>base_uri</name></decl>;</decl_stmt>
    <comment type="block">/** ignore client's requests for uncached responses */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>ignorecachecontrol</name>:1</expr>;</expr_stmt>
    <comment type="block">/** ignore query-string when caching */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>ignorequerystring</name>:1</expr>;</expr_stmt>
    <comment type="block">/** run within the quick handler */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>quick</name>:1</expr>;</expr_stmt>
    <comment type="block">/* thundering herd lock */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>lock</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>x_cache</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>x_cache_detail</name>:1</expr>;</expr_stmt>
    <comment type="block">/* flag if CacheIgnoreHeader has been set */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_IGNORE_HEADERS_SET</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_IGNORE_HEADERS_UNSET</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>ignore_headers_set</name>:1</expr>;</expr_stmt>
    <comment type="block">/* flag if CacheIgnoreURLSessionIdentifiers has been set */</comment>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_IGNORE_SESSION_ID_SET</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
    <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CACHE_IGNORE_SESSION_ID_UNSET</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>ignore_session_id_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>base_uri_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>ignorecachecontrol_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>ignorequerystring_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>quick_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>lock_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>lockpath_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>lockmaxage_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>x_cache_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>x_cache_detail_set</name>:1</expr>;</expr_stmt>
}</block></struct></type> <name>cache_server_conf</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
    <comment type="block">/* Minimum time to keep cached files in msecs */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>minex</name></decl>;</decl_stmt>
    <comment type="block">/* Maximum time to keep cached files in msecs */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>maxex</name></decl>;</decl_stmt>
    <comment type="block">/* default time to keep cached file in msecs */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>defex</name></decl>;</decl_stmt>
    <comment type="block">/* factor for estimating expires date */</comment>
    <decl_stmt><decl><type><name>double</name></type> <name>factor</name></decl>;</decl_stmt>
    <comment type="block">/* cache enabled for this location */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>cacheenable</name></decl>;</decl_stmt>
    <comment type="block">/* cache disabled for this location */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>disable</name>:1</expr>;</expr_stmt>
    <comment type="block">/* set X-Cache headers */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>x_cache</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>x_cache_detail</name>:1</expr>;</expr_stmt>
    <comment type="block">/* serve stale on error */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>stale_on_error</name>:1</expr>;</expr_stmt>
    <comment type="block">/** ignore the last-modified header when deciding to cache this request */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>no_last_mod_ignore</name>:1</expr>;</expr_stmt>
    <comment type="block">/** ignore expiration date from server */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>store_expired</name>:1</expr>;</expr_stmt>
    <comment type="block">/** ignore Cache-Control: private header from server */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>store_private</name>:1</expr>;</expr_stmt>
    <comment type="block">/** ignore Cache-Control: no-store header from client or server */</comment>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>store_nostore</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>minex_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>maxex_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>defex_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>factor_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>x_cache_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>x_cache_detail_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>stale_on_error_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>no_last_mod_ignore_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>store_expired_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>store_private_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>store_nostore_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>enable_set</name>:1</expr>;</expr_stmt>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>disable_set</name>:1</expr>;</expr_stmt>
}</block></struct></type> <name>cache_dir_conf</name>;</typedef>

<comment type="block">/* A linked-list of authn providers. */</comment>
<typedef>typedef <type>struct <name>cache_provider_list</name></type> <name>cache_provider_list</name>;</typedef>

<struct>struct <name>cache_provider_list</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>provider_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>cache_provider</name> *</type><name>provider</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>cache_provider_list</name> *</type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* per request cache information */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>cache_provider_list</name> *</type><name>providers</name></decl>;</decl_stmt>     <comment type="block">/* possible cache providers */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>cache_provider</name> *</type><name>provider</name></decl>;</decl_stmt>     <comment type="block">/* current cache provider */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>provider_name</name></decl>;</decl_stmt>          <comment type="block">/* current cache provider name */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>fresh</name></decl>;</decl_stmt>                          <comment type="block">/* is the entity fresh? */</comment>
    <decl_stmt><decl><type><name>cache_handle_t</name> *</type><name>handle</name></decl>;</decl_stmt>             <comment type="block">/* current cache handle */</comment>
    <decl_stmt><decl><type><name>cache_handle_t</name> *</type><name>stale_handle</name></decl>;</decl_stmt>       <comment type="block">/* stale cache handle */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>stale_headers</name></decl>;</decl_stmt>         <comment type="block">/* original request headers. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>in_checked</name></decl>;</decl_stmt>                     <comment type="block">/* CACHE_SAVE must cache the entity */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>block_response</name></decl>;</decl_stmt>                 <comment type="block">/* CACHE_SAVE must block response. */</comment>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>saved_brigade</name></decl>;</decl_stmt>  <comment type="block">/* copy of partial response */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>saved_size</name></decl>;</decl_stmt>               <comment type="block">/* length of saved_brigade */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>exp</name></decl>;</decl_stmt>                     <comment type="block">/* expiration */</comment>
    <decl_stmt><decl><type><name>apr_time_t</name></type> <name>lastmod</name></decl>;</decl_stmt>                 <comment type="block">/* last-modified time */</comment>
    <decl_stmt><decl><type><name>cache_info</name> *</type><name>info</name></decl>;</decl_stmt>                   <comment type="block">/* current cache info */</comment>
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>save_filter</name></decl>;</decl_stmt>           <comment type="block">/* Enable us to restore the filter on error */</comment>
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>remove_url_filter</name></decl>;</decl_stmt>     <comment type="block">/* Enable us to remove the filter */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>                    <comment type="block">/* The cache key created for this
                                         * request
                                         */</comment>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>size</name></decl>;</decl_stmt>                     <comment type="block">/* the content length from the headers, or -1 */</comment>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>out</name></decl>;</decl_stmt>            <comment type="block">/* brigade to reuse for upstream responses */</comment>
    <decl_stmt><decl><type><name>cache_control_t</name></type> <name>control_in</name></decl>;</decl_stmt>         <comment type="block">/* cache control incoming */</comment>
}</block></struct></type> <name>cache_request_rec</name>;</typedef>

<comment type="block">/**
 * Check the whether the request allows a cached object to be served as per RFC2616
 * section 14.9.4 (Cache Revalidation and Reload Controls)
 * @param cache cache_request_rec
 * @param r request_rec
 * @return 0 ==&gt; cache object may not be served, 1 ==&gt; cache object may be served
 */</comment>
<function_decl><type><name>int</name></type> <name>ap_cache_check_no_cache</name><parameter_list>(<param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Check the whether the request allows a cached object to be stored as per RFC2616
 * section 14.9.2 (What May be Stored by Caches)
 * @param cache cache_request_rec
 * @param r request_rec
 * @return 0 ==&gt; cache object may not be served, 1 ==&gt; cache object may be served
 */</comment>
<function_decl><type><name>int</name></type> <name>ap_cache_check_no_store</name><parameter_list>(<param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Check the freshness of the cache object per RFC2616 section 13.2 (Expiration Model)
 * @param h cache_handle_t
 * @param cache cache_request_rec
 * @param r request_rec
 * @return 0 ==&gt; cache object is stale, 1 ==&gt; cache object is fresh
 */</comment>
<function_decl><type><name>int</name></type> <name>cache_check_freshness</name><parameter_list>(<param><decl><type><name>cache_handle_t</name> *</type><name>h</name></decl></param>, <param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>,
        <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Try obtain a cache wide lock on the given cache key.
 *
 * If we return APR_SUCCESS, we obtained the lock, and we are clear to
 * proceed to the backend. If we return APR_EEXISTS, then the lock is
 * already locked, someone else has gone to refresh the backend data
 * already, so we must return stale data with a warning in the mean
 * time. If we return anything else, then something has gone pear
 * shaped, and we allow the request through to the backend regardless.
 *
 * This lock is created from the request pool, meaning that should
 * something go wrong and the lock isn't deleted on return of the
 * request headers from the backend for whatever reason, at worst the
 * lock will be cleaned up when the request is dies or finishes.
 *
 * If something goes truly bananas and the lock isn't deleted when the
 * request dies, the lock will be trashed when its max-age is reached,
 * or when a request arrives containing a Cache-Control: no-cache. At
 * no point is it possible for this lock to permanently deny access to
 * the backend.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>cache_try_lock</name><parameter_list>(<param><decl><type><name>cache_server_conf</name> *</type><name>conf</name></decl></param>, <param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>,
        <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Remove the cache lock, if present.
 *
 * First, try to close the file handle, whose delete-on-close should
 * kill the file. Otherwise, just delete the file by name.
 *
 * If no lock name has yet been calculated, do the calculation of the
 * lock name first before trying to delete the file.
 *
 * If an optional bucket brigade is passed, the lock will only be
 * removed if the bucket brigade contains an EOS bucket.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>cache_remove_lock</name><parameter_list>(<param><decl><type><name>cache_server_conf</name> *</type><name>conf</name></decl></param>,
        <param><decl><type><name>cache_request_rec</name> *</type><name>cache</name></decl></param>, <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>cache_provider_list</name> *</type><name>cache_get_providers</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                         <param><decl><type><name>cache_server_conf</name> *</type><name>conf</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get a value from a table, where the table may contain multiple
 * values for a given key.
 *
 * When the table contains a single value, that value is returned
 * unchanged.
 *
 * When the table contains two or more values for a key, all values
 * for the key are returned, separated by commas.
 */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>cache_table_getm</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>apr_table_t</name> *</type><name>t</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * String tokenizer that ignores separator characters within quoted strings
 * and escaped characters, as per RFC2616 section 2.2.
 */</comment>
<function_decl><type><name>char</name> *</type><name>cache_strqtok</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep</name></decl></param>, <param><decl><type><name>char</name> **</type><name>last</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Merge err_headers_out into headers_out and add request's Content-Type and
 * Content-Encoding if available.
 */</comment>
<function_decl><type><name>apr_table_t</name> *</type><name>cache_merge_headers_out</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return whether to use request's path/query from early stage (r-&gt;parsed_uri)
 * or the current/rewritable ones (r-&gt;uri/r-&gt;args).
 */</comment>
<function_decl><type><name>int</name></type> <name>cache_use_early_url</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !CACHE_UTIL_H */</comment>
<comment type="block">/** @} */</comment>
</unit>
