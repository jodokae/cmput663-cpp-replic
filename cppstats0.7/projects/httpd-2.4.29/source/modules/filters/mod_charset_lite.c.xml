<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/filters/mod_charset_lite.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * simple hokey charset recoding configuration module
 *
 * See mod_ebcdic and mod_charset for more thought-out examples.  This
 * one is just so Jeff can learn how a module works and experiment with
 * basic character set recoding configuration.
 *
 * !!!This is an extremely cheap ripoff of mod_charset.c from Russian Apache!!!
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_charset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_xlate.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_XLATE_BUF_SIZE</name></cpp:macro> <cpp:value>(16*1024)</cpp:value></cpp:define> <comment type="block">/* size of translation buffer used on output */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INPUT_XLATE_BUF_SIZE</name></cpp:macro>  <cpp:value>(8*1024)</cpp:value></cpp:define>  <comment type="block">/* size of translation buffer used on input */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XLATE_MIN_BUFF_LEFT</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>  <comment type="block">/* flush once there is no more than this much
                                  * space left in the translation buffer
                                  */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FATTEST_CHAR</name></cpp:macro>  <cpp:value>8</cpp:value></cpp:define>          <comment type="block">/* we don't handle chars wider than this that straddle
                                  * two buckets
                                  */</comment>

<comment type="block">/* extended error status codes; this is used in addition to an apr_status_t to
 * track errors in the translation filter
 */</comment>
<typedef>typedef <type><enum>enum <block>{
    <decl><name>EES_INIT</name> <init>= <expr>0</expr></init></decl>,   <comment type="block">/* no error info yet; value must be 0 for easy init */</comment>
    <decl><name>EES_LIMIT</name></decl>,      <comment type="block">/* built-in restriction encountered */</comment>
    <decl><name>EES_INCOMPLETE_CHAR</name></decl>, <comment type="block">/* incomplete multi-byte char at end of content */</comment>
    <decl><name>EES_BUCKET_READ</name></decl>,
    <decl><name>EES_DOWNSTREAM</name></decl>, <comment type="block">/* something bad happened in a filter below xlate */</comment>
    <decl><name>EES_BAD_INPUT</name></decl>   <comment type="block">/* input data invalid */</comment>
}</block></enum></type> <name>ees_t</name>;</typedef>

<comment type="block">/* registered name of the output translation filter */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XLATEOUT_FILTER_NAME</name></cpp:macro> <cpp:value>"XLATEOUT"</cpp:value></cpp:define>
<comment type="block">/* registered name of input translation filter */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XLATEIN_FILTER_NAME</name></cpp:macro>  <cpp:value>"XLATEIN"</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>charset_dir_t</name> <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>charset_source</name></decl>;</decl_stmt> <comment type="block">/* source encoding */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>charset_default</name></decl>;</decl_stmt> <comment type="block">/* how to ship on wire */</comment>
    <comment type="block">/** module does ap_add_*_filter()? */</comment>
    <enum>enum <block>{<decl><name>IA_INIT</name></decl>, <decl><name>IA_IMPADD</name></decl>, <decl><name>IA_NOIMPADD</name></decl>}</block> <decl><name>implicit_add</name></decl>;</enum>
    <comment type="block">/** treat all mimetypes as text? */</comment>
    <enum>enum <block>{<decl><name>FX_INIT</name></decl>, <decl><name>FX_FORCE</name></decl>, <decl><name>FX_NOFORCE</name></decl>}</block> <decl><name>force_xlate</name></decl>;</enum>
}</block></struct></type> <name>charset_dir_t</name>;</typedef>

<comment type="block">/* charset_filter_ctx_t is created for each filter instance; because the same
 * filter code is used for translating in both directions, we need this context
 * data to tell the filter which translation handle to use; it also can hold a
 * character which was split between buckets
 */</comment>
<typedef>typedef <type><struct>struct <name>charset_filter_ctx_t</name> <block>{
    <decl_stmt><decl><type><name>apr_xlate_t</name> *</type><name>xlate</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>is_sb</name></decl>;</decl_stmt>              <comment type="block">/* single-byte translation? */</comment>
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ees_t</name></type> <name>ees</name></decl>;</decl_stmt>              <comment type="block">/* extended error status */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>saved</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>FATTEST_CHAR</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* we want to be able to build a complete char here */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>ran</name></decl>;</decl_stmt>                <comment type="block">/* has filter instance run before? */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>noop</name></decl>;</decl_stmt>               <comment type="block">/* should we pass brigades through unchanged? */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>              <comment type="block">/* buffer for input filtering */</comment>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt> <comment type="block">/* input buckets we couldn't finish translating */</comment>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>tmpbb</name></decl>;</decl_stmt> <comment type="block">/* used for passing downstream */</comment>
}</block></struct></type> <name>charset_filter_ctx_t</name>;</typedef>

<comment type="block">/* charset_req_t is available via r-&gt;request_config if any translation is
 * being performed
 */</comment>
<typedef>typedef <type><struct>struct <name>charset_req_t</name> <block>{
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_filter_ctx_t</name> *</type><name>output_ctx</name></decl>, *<name>input_ctx</name>;</decl_stmt>
}</block></struct></type> <name>charset_req_t</name>;</typedef>

<decl_stmt><decl><type><name>module</name> <name>AP_MODULE_DECLARE_DATA</name></type> <name>charset_lite_module</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>create_charset_dir_conf</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,<param><decl><type><name>char</name> *</type><name>dummy</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name> <init>= <expr>(<name>charset_dir_t</name> *)<call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>charset_dir_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <return>return <expr><name>dc</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name> *</type><name>merge_charset_dir_conf</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>basev</name></decl></param>, <param><decl><type><name>void</name> *</type><name>overridesv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>a</name> <init>= <expr>(<name>charset_dir_t</name> *)<call><name>apr_pcalloc</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>charset_dir_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>base</name> <init>= <expr>(<name>charset_dir_t</name> *)<name>basev</name></expr></init>,
        *<name>over</name> <init>= <expr>(<name>charset_dir_t</name> *)<name>overridesv</name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* If it is defined in the current container, use it.  Otherwise, use the one
     * from the enclosing container.
     */</comment>

    <expr_stmt><expr><name><name>a</name>-&gt;<name>charset_default</name></name> =
        <name><name>over</name>-&gt;<name>charset_default</name></name> ? <name><name>over</name>-&gt;<name>charset_default</name></name> : <name><name>base</name>-&gt;<name>charset_default</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>charset_source</name></name> =
        <name><name>over</name>-&gt;<name>charset_source</name></name> ? <name><name>over</name>-&gt;<name>charset_source</name></name> : <name><name>base</name>-&gt;<name>charset_source</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>implicit_add</name></name> =
        <name><name>over</name>-&gt;<name>implicit_add</name></name> != <name>IA_INIT</name> ? <name><name>over</name>-&gt;<name>implicit_add</name></name> : <name><name>base</name>-&gt;<name>implicit_add</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>a</name>-&gt;<name>force_xlate</name></name>=
        <name><name>over</name>-&gt;<name>force_xlate</name></name> != <name>FX_INIT</name> ? <name><name>over</name>-&gt;<name>force_xlate</name></name> : <name><name>base</name>-&gt;<name>force_xlate</name></name></expr>;</expr_stmt>
    <return>return <expr><name>a</name></expr>;</return>
}</block></function>

<comment type="block">/* CharsetSourceEnc charset
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_charset_source</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>in_dc</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name> <init>= <expr><name>in_dc</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>dc</name>-&gt;<name>charset_source</name></name> = <name>name</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* CharsetDefault charset
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_charset_default</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>in_dc</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name> <init>= <expr><name>in_dc</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>dc</name>-&gt;<name>charset_default</name></name> = <name>name</name></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* CharsetOptions optionflag...
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>add_charset_options</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>in_dc</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>flag</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name> <init>= <expr><name>in_dc</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr>"ImplicitAdd"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>dc</name>-&gt;<name>implicit_add</name></name> = <name>IA_IMPADD</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr>"NoImplicitAdd"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>dc</name>-&gt;<name>implicit_add</name></name> = <name>IA_NOIMPADD</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr>"TranslateAllMimeTypes"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>dc</name>-&gt;<name>force_xlate</name></name> = <name>FX_FORCE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr>"NoTranslateAllMimeTypes"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>dc</name>-&gt;<name>force_xlate</name></name> = <name>FX_NOFORCE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>cmd</name>-&gt;<name>temp_pool</name></name></expr></argument>,
                           <argument><expr>"Invalid CharsetOptions option: "</expr></argument>,
                           <argument><expr><name>flag</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if></else></if></else></if>

    <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* find_code_page() is a fixup hook that checks if the module is
 * configured and the input or output potentially need to be translated.
 * If so, context is initialized for the filters.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>find_code_page</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                             <argument><expr>&amp;<name>charset_lite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_req_t</name> *</type><name>reqinfo</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_filter_ctx_t</name> *</type><name>input_ctx</name></decl>, *<decl><type ref="prev"/><name>output_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                  <argument><expr>"uri: %s file: %s method: %d "
                  "imt: %s flags: %s%s%s %s-&gt;%s"</expr></argument>,
                  <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>,
                  <argument><expr><name><name>r</name>-&gt;<name>filename</name></name> ? <name><name>r</name>-&gt;<name>filename</name></name> : "(none)"</expr></argument>,
                  <argument><expr><name><name>r</name>-&gt;<name>method_number</name></name></expr></argument>,
                  <argument><expr><name><name>r</name>-&gt;<name>content_type</name></name> ? <name><name>r</name>-&gt;<name>content_type</name></name> : "(unknown)"</expr></argument>,
                  <argument><expr><name><name>r</name>-&gt;<name/></name>main     ? "S" : ""</expr></argument>,    <comment type="block">/* S if subrequest */</comment>
                  <argument><expr><name><name>r</name>-&gt;<name>prev</name></name>     ? "R" : ""</expr></argument>,    <comment type="block">/* R if redirect */</comment>
                  <argument><expr><name><name>r</name>-&gt;<name>proxyreq</name></name> ? "P" : ""</expr></argument>,    <comment type="block">/* P if proxy */</comment>
                  <argument><expr><name><name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we don't have a full directory configuration, bail out.
     */</comment>
    <if>if <condition>(<expr>!<name><name>dc</name>-&gt;<name>charset_source</name></name> || !<name><name>dc</name>-&gt;<name>charset_default</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01448</expr></argument>)</argument_list></call>
                      "incomplete configuration: src %s, dst %s"</expr></argument>,
                      <argument><expr><name><name>dc</name>-&gt;<name>charset_source</name></name> ? <name><name>dc</name>-&gt;<name>charset_source</name></name> : "unspecified"</expr></argument>,
                      <argument><expr><name><name>dc</name>-&gt;<name>charset_default</name></name> ? <name><name>dc</name>-&gt;<name>charset_default</name></name> : "unspecified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* catch proxy requests */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proxyreq</name></name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* mod_rewrite indicators */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>filename</name></name>
        &amp;&amp; (!<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"redirect:"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call>
            || !<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"gone:"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call>
            || !<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"passthrough:"</expr></argument>, <argument><expr>12</expr></argument>)</argument_list></call>
            || !<call><name>strncmp</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>filename</name></name></expr></argument>, <argument><expr>"forbidden:"</expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* no translation when server and network charsets are set to the same value */</comment>
    <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Get storage for the request data and the output filter context.
     * We rarely need the input filter context, so allocate that separately.
     */</comment>
    <expr_stmt><expr><name>reqinfo</name> = (<name>charset_req_t</name> *)<call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                           <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>charset_req_t</name></expr></argument>)</argument_list></sizeof> +
                                           <sizeof>sizeof<argument_list>(<argument><expr><name>charset_filter_ctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>output_ctx</name> = <call>(<name>charset_filter_ctx_t</name> *)<argument_list>(<argument><expr><name>reqinfo</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>reqinfo</name>-&gt;<name>dc</name></name> = <name>dc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>output_ctx</name>-&gt;<name>dc</name></name> = <name>dc</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>output_ctx</name>-&gt;<name>tmpbb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                           <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_set_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>, <argument><expr>&amp;<name>charset_lite_module</name></expr></argument>, <argument><expr><name>reqinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>reqinfo</name>-&gt;<name>output_ctx</name></name> = <name>output_ctx</name></expr>;</expr_stmt>

    <switch>switch <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name></expr>)</condition> <block>{
    <case>case <expr><name>M_PUT</name></expr>:
    </case><case>case <expr><name>M_POST</name></expr>:
        <comment type="block">/* Set up input translation.  Note: A request body can be included
         * with the OPTIONS method, but for now we don't set up translation
         * of it.
         */</comment>
        <expr_stmt><expr><name>input_ctx</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>charset_filter_ctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>input_ctx</name>-&gt;<name>bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                           <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>input_ctx</name>-&gt;<name>tmp</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>INPUT_XLATE_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>input_ctx</name>-&gt;<name>dc</name></name> = <name>dc</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>reqinfo</name>-&gt;<name>input_ctx</name></name> = <name>input_ctx</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_xlate_open</name><argument_list>(<argument><expr>&amp;<name><name>input_ctx</name>-&gt;<name>xlate</name></name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>,
                            <argument><expr><name><name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01449</expr></argument>)</argument_list></call>
                          "can't open translation %s-&gt;%s"</expr></argument>,
                          <argument><expr><name><name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><call><name>apr_xlate_sb_get</name><argument_list>(<argument><expr><name><name>input_ctx</name>-&gt;<name>xlate</name></name></expr></argument>, <argument><expr>&amp;<name><name>input_ctx</name>-&gt;<name>is_sb</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>input_ctx</name>-&gt;<name>is_sb</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>
    </case>}</block></switch>

    <return>return <expr><name>DECLINED</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>configured_in_list</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filter_name</name></decl></param>,
                              <param><decl><type>struct <name>ap_filter_t</name> *</type><name>filter_list</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>ap_filter_t</name> *</type><name>filter</name> <init>= <expr><name>filter_list</name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>filter</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>filter_name</name></expr></argument>, <argument><expr><name><name>filter</name>-&gt;<name>frec</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>1</expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>filter</name> = <name><name>filter</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>
    <return>return <expr>0</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>configured_on_input</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filter_name</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>configured_in_list</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>filter_name</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>input_filters</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>configured_on_output</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filter_name</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><call><name>configured_in_list</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>filter_name</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* xlate_insert_filter() is a filter hook which decides whether or not
 * to insert a translation filter for the current request.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>xlate_insert_filter</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <comment type="block">/* Hey... don't be so quick to use reqinfo-&gt;dc here; reqinfo may be NULL */</comment>
    <decl_stmt><decl><type><name>charset_req_t</name> *</type><name>reqinfo</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>,
                                                  <argument><expr>&amp;<name>charset_lite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                             <argument><expr>&amp;<name>charset_lite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>dc</name> &amp;&amp; (<name><name>dc</name>-&gt;<name>implicit_add</name></name> == <name>IA_NOIMPADD</name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE6</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                      <argument><expr>"xlate output filter not added implicitly because "
                      "CharsetOptions included 'NoImplicitAdd'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name>reqinfo</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>reqinfo</name>-&gt;<name>output_ctx</name></name> &amp;&amp; !<call><name>configured_on_output</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>XLATEOUT_FILTER_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_add_output_filter</name><argument_list>(<argument><expr><name>XLATEOUT_FILTER_NAME</name></expr></argument>, <argument><expr><name><name>reqinfo</name>-&gt;<name>output_ctx</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>,
                                 <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                      <argument><expr>"xlate output filter not added implicitly because %s"</expr></argument>,
                      <argument><expr>!<name><name>reqinfo</name>-&gt;<name>output_ctx</name></name> ?
                      "no output configuration available" :
                      "another module added the filter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>reqinfo</name>-&gt;<name>input_ctx</name></name> &amp;&amp; !<call><name>configured_on_input</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>XLATEIN_FILTER_NAME</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_add_input_filter</name><argument_list>(<argument><expr><name>XLATEIN_FILTER_NAME</name></expr></argument>, <argument><expr><name><name>reqinfo</name>-&gt;<name>input_ctx</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>,
                                <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                      <argument><expr>"xlate input filter not added implicitly because %s"</expr></argument>,
                      <argument><expr>!<name><name>reqinfo</name>-&gt;<name>input_ctx</name></name> ?
                      "no input configuration available" :
                      "another module added the filter"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* stuff that sucks that I know of:
 *
 * bucket handling:
 *  why create an eos bucket when we see it come down the stream?  just send the one
 *  passed as input...  news flash: this will be fixed when xlate_out_filter() starts
 *  using the more generic xlate_brigade()
 *
 * translation mechanics:
 *   we don't handle characters that straddle more than two buckets; an error
 *   will be generated
 */</comment>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_bucket_downstream</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_filter_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ees</name></name> = <name>EES_DOWNSTREAM</name></expr>;</expr_stmt>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>tmpbb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block">/* send_downstream() is passed the translated data; it puts it in a single-
 * bucket brigade and passes the brigade to the next filter
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_downstream</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_transient_create</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><call><name>send_bucket_downstream</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_eos</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_filter_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ees</name></name> = <name>EES_DOWNSTREAM</name></expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>set_aside_partial_char</name><parameter_list>(<param><decl><type><name>charset_filter_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>partial</name></decl></param>,
                                           <param><decl><type><name>apr_size_t</name></type> <name>partial_len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></sizeof> &gt; <name>partial_len</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>saved</name></name> = <name>partial_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>partial</name></expr></argument>, <argument><expr><name>partial_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>rv</name> = <name>APR_INCOMPLETE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ees</name></name> = <name>EES_LIMIT</name></expr>;</expr_stmt> <comment type="block">/* we don't handle chars this wide which straddle
                               * buckets
                               */</comment>
    }</block></else></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>finish_partial_char</name><parameter_list>(<param><decl><type><name>charset_filter_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                        <comment type="block">/* input buffer: */</comment>
                                        <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>cur_str</name></decl></param>,
                                        <param><decl><type><name>apr_size_t</name> *</type><name>cur_len</name></decl></param>,
                                        <comment type="block">/* output buffer: */</comment>
                                        <param><decl><type><name>char</name> **</type><name>out_str</name></decl></param>,
                                        <param><decl><type><name>apr_size_t</name> *</type><name>out_len</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>tmp_input_len</name></decl>;</decl_stmt>

    <comment type="block">/* Keep adding bytes from the input string to the saved string until we
     *    1) finish the input char
     *    2) get an error
     * or 3) run out of bytes to add
     */</comment>

    <do>do <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>buf</name><index>[<expr><name><name>ctx</name>-&gt;<name>saved</name></name></expr>]</index></name> = **<name>cur_str</name></expr>;</expr_stmt>
        <expr_stmt><expr>++<name><name>ctx</name>-&gt;<name>saved</name></name></expr>;</expr_stmt>
        <expr_stmt><expr>++*<name>cur_str</name></expr>;</expr_stmt>
        <expr_stmt><expr>--*<name>cur_len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp_input_len</name> = <name><name>ctx</name>-&gt;<name>saved</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>apr_xlate_conv_buffer</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>xlate</name></name></expr></argument>,
                                   <argument><expr><name><name>ctx</name>-&gt;<name>buf</name></name></expr></argument>,
                                   <argument><expr>&amp;<name>tmp_input_len</name></expr></argument>,
                                   <argument><expr>*<name>out_str</name></expr></argument>,
                                   <argument><expr><name>out_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>rv</name> == <name>APR_INCOMPLETE</name> &amp;&amp; *<name>cur_len</name></expr>)</condition>;</do>

    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>saved</name></name> = 0</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ees</name></name> = <name>EES_LIMIT</name></expr>;</expr_stmt> <comment type="block">/* code isn't smart enough to handle chars
                               * straddling more than two buckets
                               */</comment>
    }</block></else></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>log_xlate_error</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_status_t</name></type> <name>rv</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_filter_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>msgbuf</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <switch>switch<condition>(<expr><name><name>ctx</name>-&gt;<name>ees</name></name></expr>)</condition> <block>{
    <case>case <expr><name>EES_LIMIT</name></expr>:
        <expr_stmt><expr><name>rv</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>msg</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02193</expr></argument>)</argument_list></call> "xlate filter - a built-in restriction was encountered"</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>EES_BAD_INPUT</name></expr>:
        <expr_stmt><expr><name>rv</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>msg</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02194</expr></argument>)</argument_list></call> "xlate filter - an input character was invalid"</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>EES_BUCKET_READ</name></expr>:
        <expr_stmt><expr><name>rv</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>msg</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02195</expr></argument>)</argument_list></call> "xlate filter - bucket read routine failed"</expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>EES_INCOMPLETE_CHAR</name></expr>:
        <expr_stmt><expr><name>rv</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02196</expr></argument>)</argument_list></call> "xlate filter - incomplete char at end of input - "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> = <name><name>ctx</name>-&gt;<name>saved</name></name></expr>;</expr_stmt>

        <comment type="block">/* We must ensure not to process more than what would fit in the
         * remaining of the destination buffer, including terminating NULL */</comment>
        <if>if <condition>(<expr><name>len</name> &gt; (<sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof> - <call><name>strlen</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call> - 1) / 2</expr>)</condition><then>
            <expr_stmt><expr><name>len</name> = (<sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof> - <call><name>strlen</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call> - 1) / 2</expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>ap_bin2hex</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>msgbuf</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>msg</name> = <name>msgbuf</name></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr><name>EES_DOWNSTREAM</name></expr>:
        <expr_stmt><expr><name>msg</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02197</expr></argument>)</argument_list></call> "xlate filter - an error occurred in a lower filter"</expr>;</expr_stmt>
        <break>break;</break>
    </case><default>default:
        <expr_stmt><expr><name>msg</name> = <call><name>APLOGNO</name><argument_list>(<argument><expr>02198</expr></argument>)</argument_list></call> "xlate filter - returning error"</expr>;</expr_stmt>
    </default>}</block></switch>
    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02997</expr></argument>)</argument_list></call> "%s"</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* chk_filter_chain() is called once per filter instance; it tries to
 * determine if the current filter instance should be disabled because
 * its translation is incompatible with the translation of an existing
 * instance of the translate filter
 *
 * Example bad scenario:
 *
 *   configured filter chain for the request:
 *     INCLUDES XLATEOUT(8859-1-&gt;UTS-16)
 *   configured filter chain for the subrequest:
 *     XLATEOUT(8859-1-&gt;UTS-16)
 *
 *   When the subrequest is processed, the filter chain will be
 *     XLATEOUT(8859-1-&gt;UTS-16) XLATEOUT(8859-1-&gt;UTS-16)
 *   This makes no sense, so the instance of XLATEOUT added for the
 *   subrequest will be noop-ed.
 *
 * Example good scenario:
 *
 *   configured filter chain for the request:
 *     INCLUDES XLATEOUT(8859-1-&gt;UTS-16)
 *   configured filter chain for the subrequest:
 *     XLATEOUT(IBM-1047-&gt;8859-1)
 *
 *   When the subrequest is processed, the filter chain will be
 *     XLATEOUT(IBM-1047-&gt;8859-1) XLATEOUT(8859-1-&gt;UTS-16)
 *   This makes sense, so the instance of XLATEOUT added for the
 *   subrequest will be left alone and it will translate from
 *   IBM-1047-&gt;8859-1.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>chk_filter_chain</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>curf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_filter_ctx_t</name> *</type><name>curctx</name></decl>, *<decl><type ref="prev"/><name>last_xlate_ctx</name> <init>= <expr><name>NULL</name></expr></init>,
        *<name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>output</name> <init>= <expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>frec</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>XLATEOUT_FILTER_NAME</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>noop</name></name></expr>)</condition><then> <block>{
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* walk the filter chain; see if it makes sense for our filter to
     * do any translation
     */</comment>
    <expr_stmt><expr><name>curf</name> = <name>output</name> ? <name><name>f</name>-&gt;<name>r</name>-&gt;<name>output_filters</name></name> : <name><name>f</name>-&gt;<name>r</name>-&gt;<name>input_filters</name></name></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>curf</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name><name>curf</name>-&gt;<name>frec</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>frec</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call> &amp;&amp;
            <name><name>curf</name>-&gt;<name>ctx</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>curctx</name> = (<name>charset_filter_ctx_t</name> *)<name><name>curf</name>-&gt;<name>ctx</name></name></expr>;</expr_stmt>
            <if>if <condition>(<expr>!<name>last_xlate_ctx</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>last_xlate_ctx</name> = <name>curctx</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>last_xlate_ctx</name>-&gt;<name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>,
                           <argument><expr><name><name>curctx</name>-&gt;<name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <comment type="block">/* incompatible translation
                     * if our filter instance is incompatible with an instance
                     * already in place, noop our instance
                     * Notes:
                     * . We are only willing to noop our own instance.
                     * . It is possible to noop another instance which has not
                     *   yet run, but this is not currently implemented.
                     *   Hopefully it will not be needed.
                     * . It is not possible to noop an instance which has
                     *   already run.
                     */</comment>
                    <if>if <condition>(<expr><name>last_xlate_ctx</name> == <name><name>f</name>-&gt;<name>ctx</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name><name>last_xlate_ctx</name>-&gt;<name>noop</name></name> = 1</expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name>APLOGrtrace1</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>symbol</name> <init>= <expr><name>output</name> ? "-&gt;" : "&lt;-"</expr></init></decl>;</decl_stmt>

                            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_DEBUG</name></expr></argument>,
                                          <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01451</expr></argument>)</argument_list></call>
                                          "%s %s - disabling "
                                          "translation %s%s%s; existing "
                                          "translation %s%s%s"</expr></argument>,
                                          <argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>uri</name></name> ? "uri" : "file"</expr></argument>,
                                          <argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>uri</name></name> ? <name><name>f</name>-&gt;<name>r</name>-&gt;<name>uri</name></name> : <name><name>f</name>-&gt;<name>r</name>-&gt;<name>filename</name></name></expr></argument>,
                                          <argument><expr><name><name>last_xlate_ctx</name>-&gt;<name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>,
                                          <argument><expr><name>symbol</name></expr></argument>,
                                          <argument><expr><name><name>last_xlate_ctx</name>-&gt;<name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>,
                                          <argument><expr><name><name>curctx</name>-&gt;<name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>,
                                          <argument><expr><name>symbol</name></expr></argument>,
                                          <argument><expr><name><name>curctx</name>-&gt;<name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then>
                    <else>else <block>{
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>symbol</name> <init>= <expr><name>output</name> ? "-&gt;" : "&lt;-"</expr></init></decl>;</decl_stmt>

                        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>,
                                      <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01452</expr></argument>)</argument_list></call>
                                      "chk_filter_chain() - can't disable "
                                      "translation %s%s%s; existing "
                                      "translation %s%s%s"</expr></argument>,
                                      <argument><expr><name><name>last_xlate_ctx</name>-&gt;<name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>,
                                      <argument><expr><name>symbol</name></expr></argument>,
                                      <argument><expr><name><name>last_xlate_ctx</name>-&gt;<name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>,
                                      <argument><expr><name><name>curctx</name>-&gt;<name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>,
                                      <argument><expr><name>symbol</name></expr></argument>,
                                      <argument><expr><name><name>curctx</name>-&gt;<name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></else></if>
                    <break>break;</break>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>
        <expr_stmt><expr><name>curf</name> = <name><name>curf</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>
}</block></function>

<comment type="block">/* xlate_brigade() is used to filter request and response bodies
 *
 * we'll stop when one of the following occurs:
 * . we run out of buckets
 * . we run out of space in the output buffer
 * . we hit an error or metadata
 *
 * inputs:
 *   bb:               brigade to process
 *   buffer:           storage to hold the translated characters
 *   buffer_avail:     size of buffer
 *   (and a few more uninteresting parms)
 *
 * outputs:
 *   return value:     APR_SUCCESS or some error code
 *   bb:               we've removed any buckets representing the
 *                     translated characters; the eos bucket, if
 *                     present, will be left in the brigade
 *   buffer:           filled in with translated characters
 *   buffer_avail:     updated with the bytes remaining
 *   hit_eos:          did we hit an EOS bucket?
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>xlate_brigade</name><parameter_list>(<param><decl><type><name>charset_filter_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                  <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                  <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>,
                                  <param><decl><type><name>apr_size_t</name> *</type><name>buffer_avail</name></decl></param>,
                                  <param><decl><type><name>int</name> *</type><name>hit_eos</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* set to NULL only to quiet some gcc */</comment>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>consumed_bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_in_bucket</name></decl>;</decl_stmt> <comment type="block">/* total bytes read from current bucket */</comment>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bucket_avail</name></decl>;</decl_stmt>    <comment type="block">/* bytes left in current bucket */</comment>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr>*<name>hit_eos</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>bucket_avail</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>consumed_bucket</name> = <name>NULL</name></expr>;</expr_stmt>
    <while>while <condition>(<expr>1</expr>)</condition> <block>{
        <if>if <condition>(<expr>!<name>bucket_avail</name></expr>)</condition><then> <block>{ <comment type="block">/* no bytes left to process in the current bucket... */</comment>
            <if>if <condition>(<expr><name>consumed_bucket</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>consumed_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>consumed_bucket</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>b</name> == <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call> ||
                <call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>bucket</name></expr></argument>, <argument><expr>&amp;<name>bytes_in_bucket</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ees</name></name> = <name>EES_BUCKET_READ</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>bucket_avail</name> = <name>bytes_in_bucket</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>consumed_bucket</name> = <name>b</name></expr>;</expr_stmt>   <comment type="block">/* for axing when we're done reading it */</comment>
        }</block></then></if>
        <if>if <condition>(<expr><name>bucket_avail</name></expr>)</condition><then> <block>{
            <comment type="block">/* We've got data, so translate it. */</comment>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>saved</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* Rats... we need to finish a partial character from the previous
                 * bucket.
                 *
                 * Strangely, finish_partial_char() increments the input buffer
                 * pointer but does not increment the output buffer pointer.
                 */</comment>
                <decl_stmt><decl><type><name>apr_size_t</name></type> <name>old_buffer_avail</name> <init>= <expr>*<name>buffer_avail</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name>finish_partial_char</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
                                         <argument><expr>&amp;<name>bucket</name></expr></argument>, <argument><expr>&amp;<name>bucket_avail</name></expr></argument>,
                                         <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr><name>buffer_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buffer</name> += <name>old_buffer_avail</name> - *<name>buffer_avail</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <decl_stmt><decl><type><name>apr_size_t</name></type> <name>old_buffer_avail</name> <init>= <expr>*<name>buffer_avail</name></expr></init></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_size_t</name></type> <name>old_bucket_avail</name> <init>= <expr><name>bucket_avail</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name>apr_xlate_conv_buffer</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>xlate</name></name></expr></argument>,
                                           <argument><expr><name>bucket</name></expr></argument>, <argument><expr>&amp;<name>bucket_avail</name></expr></argument>,
                                           <argument><expr><name>buffer</name></expr></argument>,
                                           <argument><expr><name>buffer_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buffer</name>  += <name>old_buffer_avail</name> - *<name>buffer_avail</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>bucket</name>  += <name>old_bucket_avail</name> - <name>bucket_avail</name></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>rv</name> == <name>APR_INCOMPLETE</name></expr>)</condition><then> <block>{ <comment type="block">/* partial character at end of input */</comment>
                    <comment type="block">/* We need to save the final byte(s) for next time; we can't
                     * convert it until we look at the next bucket.
                     */</comment>
                    <expr_stmt><expr><name>rv</name> = <call><name>set_aside_partial_char</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>bucket</name></expr></argument>, <argument><expr><name>bucket_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>bucket_avail</name> = 0</expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <comment type="block">/* bad input byte or partial char too big to store */</comment>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr>*<name>buffer_avail</name> &lt; <name>XLATE_MIN_BUFF_LEFT</name></expr>)</condition><then> <block>{
                <comment type="block">/* if any data remains in the current bucket, split there */</comment>
                <if>if <condition>(<expr><name>bucket_avail</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><call><name>apr_bucket_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>bytes_in_bucket</name> - <name>bucket_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
        }</block></then></if>
    }</block></while>

    <if>if <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* Leave the eos bucket in the brigade for reporting to
             * subsequent filters.
             */</comment>
            <expr_stmt><expr>*<name>hit_eos</name> = 1</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>saved</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* Oops... we have a partial char from the previous bucket
                 * that won't be completed because there's no more data.
                 */</comment>
                <expr_stmt><expr><name>rv</name> = <name>APR_INCOMPLETE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ees</name></name> = <name>EES_INCOMPLETE_CHAR</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block">/* xlate_out_filter() handles (almost) arbitrary conversions from one charset
 * to another...
 * translation is determined in the fixup hook (find_code_page), which is
 * where the filter's context data is set up... the context data gives us
 * the translation handle
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>xlate_out_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>charset_req_t</name> *</type><name>reqinfo</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>request_config</name></name></expr></argument>,
                                                  <argument><expr>&amp;<name>charset_lite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                             <argument><expr>&amp;<name>charset_lite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_filter_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>dptr</name></decl>, *<decl><type ref="prev"/><name>consumed_bucket</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cur_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>cur_len</name></decl>, <decl><type ref="prev"/><name>cur_avail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><name>OUTPUT_XLATE_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>space_avail</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{
        <comment type="block">/* this is SetOutputFilter path; grab the preallocated context,
         * if any; note that if we decided not to do anything in an earlier
         * handler, we won't even have a reqinfo
         */</comment>
        <if>if <condition>(<expr><name>reqinfo</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ctx</name> = <name><name>f</name>-&gt;<name>ctx</name></name> = <name><name>reqinfo</name>-&gt;<name>output_ctx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reqinfo</name>-&gt;<name>output_ctx</name></name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* prevent SNAFU if user coded us twice
                                         * in the filter chain; we can't have two
                                         * instances using the same context
                                         */</comment>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{                   <comment type="block">/* no idea how to translate; don't do anything */</comment>
            <expr_stmt><expr><name>ctx</name> = <name><name>f</name>-&gt;<name>ctx</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>charset_filter_ctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>dc</name></name> = <name>dc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>noop</name></name> = 1</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* Check the mime type to see if translation should be performed.
     */</comment>
    <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>noop</name></name> &amp;&amp; <name><name>ctx</name>-&gt;<name>xlate</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mime_type</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>content_type</name></name></expr></init></decl>;</decl_stmt>

        <if>if <condition>(<expr><name>mime_type</name> &amp;&amp; (<call><name>strncasecmp</name><argument_list>(<argument><expr><name>mime_type</name></expr></argument>, <argument><expr>"text/"</expr></argument>, <argument><expr>5</expr></argument>)</argument_list></call> == 0 ||
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
        <comment type="block">/* On an EBCDIC machine, be willing to translate mod_autoindex-
         * generated output.  Otherwise, it doesn't look too cool.
         *
         * XXX This isn't a perfect fix because this doesn't trigger us
         * to convert from the charset of the source code to ASCII.  The
         * general solution seems to be to allow a generator to set an
         * indicator in the r specifying that the body is coded in the
         * implementation character set (i.e., the charset of the source
         * code).  This would get several different types of documents
         * translated properly: mod_autoindex output, mod_status output,
         * mod_info output, hard-coded error documents, etc.
         */</comment>
            <call><name>strcmp</name><argument_list>(<argument><expr><name>mime_type</name></expr></argument>, <argument><expr><name>DIR_MAGIC_TYPE</name></expr></argument>)</argument_list></call> == 0 ||
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <call><name>strncasecmp</name><argument_list>(<argument><expr><name>mime_type</name></expr></argument>, <argument><expr>"message/"</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0 ||
            <name><name>dc</name>-&gt;<name>force_xlate</name></name> == <name>FX_FORCE</name>)</expr>)</condition><then> <block>{

            <expr_stmt><expr><name>rv</name> = <call><name>apr_xlate_open</name><argument_list>(<argument><expr>&amp;<name><name>ctx</name>-&gt;<name>xlate</name></name></expr></argument>,
                                <argument><expr><name><name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01453</expr></argument>)</argument_list></call>
                              "can't open translation %s-&gt;%s"</expr></argument>,
                              <argument><expr><name><name>dc</name>-&gt;<name>charset_source</name></name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>charset_default</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>noop</name></name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <if>if <condition>(<expr><call><name>apr_xlate_sb_get</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>xlate</name></name></expr></argument>, <argument><expr>&amp;<name><name>ctx</name>-&gt;<name>is_sb</name></name></expr></argument>)</argument_list></call> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>is_sb</name></name> = 0</expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>noop</name></name> = 1</expr>;</expr_stmt>
            <if>if <condition>(<expr><name>mime_type</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE6</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>,
                              <argument><expr>"mime type is %s; no translation selected"</expr></argument>,
                              <argument><expr><name>mime_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE6</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>,
                  <argument><expr>"xlate_out_filter() - "
                  "charset_source: %s charset_default: %s"</expr></argument>,
                  <argument><expr><name>dc</name> &amp;&amp; <name><name>dc</name>-&gt;<name>charset_source</name></name> ? <name><name>dc</name>-&gt;<name>charset_source</name></name> : "(none)"</expr></argument>,
                  <argument><expr><name>dc</name> &amp;&amp; <name><name>dc</name>-&gt;<name>charset_default</name></name> ? <name><name>dc</name>-&gt;<name>charset_default</name></name> : "(none)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>ran</name></name></expr>)</condition><then> <block>{  <comment type="block">/* filter never ran before */</comment>
        <expr_stmt><expr><call><name>chk_filter_chain</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ran</name></name> = 1</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>noop</name></name> &amp;&amp; !<name><name>ctx</name>-&gt;<name>is_sb</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* We're not converting between two single-byte charsets, so unset
             * Content-Length since it is unlikely to remain the same.
             */</comment>
            <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>noop</name></name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>dptr</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>done</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>cur_len</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>space_avail</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name>consumed_bucket</name> = <name>NULL</name></expr>;</expr_stmt>
    <while>while <condition>(<expr>!<name>done</name></expr>)</condition> <block>{
        <if>if <condition>(<expr>!<name>cur_len</name></expr>)</condition><then> <block>{ <comment type="block">/* no bytes left to process in the current bucket... */</comment>
            <if>if <condition>(<expr><name>consumed_bucket</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>consumed_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>consumed_bucket</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>dptr</name> == <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>dptr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>cur_len</name> = -1</expr>;</expr_stmt> <comment type="block">/* XXX yuck, but that tells us to send
                                 * eos down; when we minimize our bb construction
                                 * we'll fix this crap */</comment>
                <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>saved</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/* Oops... we have a partial char from the previous bucket
                     * that won't be completed because there's no more data.
                     */</comment>
                    <expr_stmt><expr><name>rv</name> = <name>APR_INCOMPLETE</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ees</name></name> = <name>EES_INCOMPLETE_CHAR</name></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>dptr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>metadata_bucket</name></decl>;</decl_stmt>
                <expr_stmt><expr><name>metadata_bucket</name> = <name>dptr</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>dptr</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>dptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>metadata_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name>send_bucket_downstream</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>metadata_bucket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>done</name> = 1</expr>;</expr_stmt>
                }</block></then></if>
                <continue>continue;</continue>
            }</block></then></if>
            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>dptr</name></expr></argument>, <argument><expr>&amp;<name>cur_str</name></expr></argument>, <argument><expr>&amp;<name>cur_len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ees</name></name> = <name>EES_BUCKET_READ</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <expr_stmt><expr><name>consumed_bucket</name> = <name>dptr</name></expr>;</expr_stmt> <comment type="block">/* for axing when we're done reading it */</comment>
            <expr_stmt><expr><name>dptr</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>dptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* get ready for when we access the
                                          * next bucket */</comment>
        }</block></then></if>
        <comment type="block">/* Try to fill up our tmp buffer with translated data. */</comment>
        <expr_stmt><expr><name>cur_avail</name> = <name>cur_len</name></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>cur_len</name></expr>)</condition><then> <block>{ <comment type="block">/* maybe we just hit the end of a pipe (len = 0) ? */</comment>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>saved</name></name></expr>)</condition><then> <block>{
                <comment type="block">/* Rats... we need to finish a partial character from the previous
                 * bucket.
                 */</comment>
                <decl_stmt><decl><type><name>char</name> *</type><name>tmp_tmp</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>tmp_tmp</name> = <name>tmp</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof> - <name>space_avail</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>rv</name> = <call><name>finish_partial_char</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>,
                                         <argument><expr>&amp;<name>cur_str</name></expr></argument>, <argument><expr>&amp;<name>cur_len</name></expr></argument>,
                                         <argument><expr>&amp;<name>tmp_tmp</name></expr></argument>, <argument><expr>&amp;<name>space_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>rv</name> = <call><name>apr_xlate_conv_buffer</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>xlate</name></name></expr></argument>,
                                           <argument><expr><name>cur_str</name></expr></argument>, <argument><expr>&amp;<name>cur_avail</name></expr></argument>,
                                           <argument><expr><name>tmp</name> + <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof> - <name>space_avail</name></expr></argument>, <argument><expr>&amp;<name>space_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* Update input ptr and len after consuming some bytes */</comment>
                <expr_stmt><expr><name>cur_str</name> += <name>cur_len</name> - <name>cur_avail</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>cur_len</name> = <name>cur_avail</name></expr>;</expr_stmt>

                <if>if <condition>(<expr><name>rv</name> == <name>APR_INCOMPLETE</name></expr>)</condition><then> <block>{ <comment type="block">/* partial character at end of input */</comment>
                    <comment type="block">/* We need to save the final byte(s) for next time; we can't
                     * convert it until we look at the next bucket.
                     */</comment>
                    <expr_stmt><expr><name>rv</name> = <call><name>set_aside_partial_char</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>cur_str</name></expr></argument>, <argument><expr><name>cur_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><name>cur_len</name> = 0</expr>;</expr_stmt>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>

        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <comment type="block">/* bad input byte or partial char too big to store */</comment>
            <expr_stmt><expr><name>done</name> = 1</expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>space_avail</name> &lt; <name>XLATE_MIN_BUFF_LEFT</name></expr>)</condition><then> <block>{
            <comment type="block">/* It is time to flush, as there is not enough space left in the
             * current output buffer to bother with converting more data.
             */</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>send_downstream</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof> - <name>space_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>done</name> = 1</expr>;</expr_stmt>
            }</block></then></if>

            <comment type="block">/* tmp is now empty */</comment>
            <expr_stmt><expr><name>space_avail</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
        }</block></then></if>
    }</block></while>

    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>space_avail</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then> <block>{ <comment type="block">/* gotta write out what we converted */</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>send_downstream</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof> - <name>space_avail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>cur_len</name> == -1</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>rv</name> = <call><name>send_eos</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>log_xlate_error</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>xlate_in_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                    <param><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                    <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_req_t</name> *</type><name>reqinfo</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>request_config</name></name></expr></argument>,
                                                  <argument><expr>&amp;<name>charset_lite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_dir_t</name> *</type><name>dc</name> <init>= <expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>per_dir_config</name></name></expr></argument>,
                                             <argument><expr>&amp;<name>charset_lite_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>charset_filter_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buffer_size</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>hit_eos</name></decl>;</decl_stmt>

    <comment type="block">/* just get out of the way of things we don't want. */</comment>
    <if>if <condition>(<expr><name>mode</name> != <name>AP_MODE_READBYTES</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{
        <comment type="block">/* this is SetInputFilter path; grab the preallocated context,
         * if any; note that if we decided not to do anything in an earlier
         * handler, we won't even have a reqinfo
         */</comment>
        <if>if <condition>(<expr><name>reqinfo</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>ctx</name> = <name><name>f</name>-&gt;<name>ctx</name></name> = <name><name>reqinfo</name>-&gt;<name>input_ctx</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>reqinfo</name>-&gt;<name>input_ctx</name></name> = <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* prevent SNAFU if user coded us twice
                                        * in the filter chain; we can't have two
                                        * instances using the same context
                                        */</comment>
        }</block></then></if>
        <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{                   <comment type="block">/* no idea how to translate; don't do anything */</comment>
            <expr_stmt><expr><name>ctx</name> = <name><name>f</name>-&gt;<name>ctx</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>charset_filter_ctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>dc</name></name> = <name>dc</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>noop</name></name> = 1</expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE6</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>,
                 <argument><expr>"xlate_in_filter() - "
                 "charset_source: %s charset_default: %s"</expr></argument>,
                 <argument><expr><name>dc</name> &amp;&amp; <name><name>dc</name>-&gt;<name>charset_source</name></name> ? <name><name>dc</name>-&gt;<name>charset_source</name></name> : "(none)"</expr></argument>,
                 <argument><expr><name>dc</name> &amp;&amp; <name><name>dc</name>-&gt;<name>charset_default</name></name> ? <name><name>dc</name>-&gt;<name>charset_default</name></name> : "(none)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>ran</name></name></expr>)</condition><then> <block>{  <comment type="block">/* filter never ran before */</comment>
        <expr_stmt><expr><call><name>chk_filter_chain</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>ran</name></name> = 1</expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>noop</name></name> &amp;&amp; !<name><name>ctx</name>-&gt;<name>is_sb</name></name>
            &amp;&amp; <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/* A Content-Length header is present, but it won't be valid after
             * conversion because we're not converting between two single-byte
             * charsets.  This will affect most CGI scripts and may affect
             * some modules.
             * Content-Length can't be unset here because that would break
             * being able to read the request body.
             * Processing of chunked request bodies is not impacted by this
             * filter since the length was not declared anyway.
             */</comment>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE1</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>,
                          <argument><expr>"Request body length may change, resulting in "
                          "misprocessing by some modules or scripts"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>noop</name></name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>(<name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>block</name></expr></argument>,
                                 <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>APR_BRIGADE_PREPEND</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* first use the leftovers */</comment>
    }</block></else></if>

    <expr_stmt><expr><name>buffer_size</name> = <name>INPUT_XLATE_BUF_SIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>xlate_brigade</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>tmp</name></name></expr></argument>, <argument><expr>&amp;<name>buffer_size</name></expr></argument>, <argument><expr>&amp;<name>hit_eos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr>!<name>hit_eos</name></expr>)</condition><then> <block>{
            <comment type="block">/* move anything leftover into our context for next time;
             * we don't currently "set aside" since the data came from
             * down below, but I suspect that for long-term we need to
             * do that
             */</comment>
            <expr_stmt><expr><call><name>APR_BRIGADE_CONCAT</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>buffer_size</name> &lt; <name>INPUT_XLATE_BUF_SIZE</name></expr>)</condition><then> <block>{ <comment type="block">/* do we have output? */</comment>
            <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>

            <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_heap_create</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>tmp</name></name></expr></argument>,
                                       <argument><expr><name>INPUT_XLATE_BUF_SIZE</name> - <name>buffer_size</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* make sure we insert at the head, because there may be
             * an eos bucket already there, and the eos bucket should
             * come after the data
             */</comment>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_HEAD</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* XXX need to get some more data... what if the last brigade
             * we got had only the first byte of a multibyte char?  we need
             * to grab more data from the network instead of returning an
             * empty brigade
             */</comment>
        }</block></else></if>
        <comment type="block">/* If we have any metadata at the head of ctx-&gt;bb, go ahead and move it
         * onto the end of bb to be returned to our caller.
         */</comment>
        <if>if <condition>(<expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name> <init>= <expr><call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <while>while <condition>(<expr><name>b</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call>
                   &amp;&amp; <call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>b</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>log_xlate_error</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>command_rec</name></type> <name><name>cmds</name><index>[]</index></name> <init>=
<expr><block>{
    <expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"CharsetSourceEnc"</expr></argument>,
                  <argument><expr><name>add_charset_source</name></expr></argument>,
                  <argument><expr><name>NULL</name></expr></argument>,
                  <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                  <argument><expr>"source (html,cgi,ssi) file charset"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_TAKE1</name><argument_list>(<argument><expr>"CharsetDefault"</expr></argument>,
                  <argument><expr><name>add_charset_default</name></expr></argument>,
                  <argument><expr><name>NULL</name></expr></argument>,
                  <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                  <argument><expr>"name of default charset"</expr></argument>)</argument_list></call></expr>,
    <expr><call><name>AP_INIT_ITERATE</name><argument_list>(<argument><expr>"CharsetOptions"</expr></argument>,
                    <argument><expr><name>add_charset_options</name></expr></argument>,
                    <argument><expr><name>NULL</name></expr></argument>,
                    <argument><expr><name>OR_FILEINFO</name></expr></argument>,
                    <argument><expr>"valid options: ImplicitAdd, NoImplicitAdd, TranslateAllMimeTypes, "
                    "NoTranslateAllMimeTypes"</expr></argument>)</argument_list></call></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>charset_register_hooks</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><call><name>ap_hook_fixups</name><argument_list>(<argument><expr><name>find_code_page</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_MIDDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_hook_insert_filter</name><argument_list>(<argument><expr><name>xlate_insert_filter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>APR_HOOK_REALLY_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_register_output_filter</name><argument_list>(<argument><expr><name>XLATEOUT_FILTER_NAME</name></expr></argument>, <argument><expr><name>xlate_out_filter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><name>AP_FTYPE_RESOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_register_input_filter</name><argument_list>(<argument><expr><name>XLATEIN_FILTER_NAME</name></expr></argument>, <argument><expr><name>xlate_in_filter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>AP_FTYPE_RESOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<expr_stmt><expr><call><name>AP_DECLARE_MODULE</name><argument_list>(<argument><expr><name>charset_lite</name></expr></argument>)</argument_list></call> =
<block>{
    <expr><name>STANDARD20_MODULE_STUFF</name></expr>,
    <expr><name>create_charset_dir_conf</name></expr>,
    <expr><name>merge_charset_dir_conf</name></expr>,
    <expr><name>NULL</name></expr>,
    <expr><name>NULL</name></expr>,
    <expr><name>cmds</name></expr>,
    <expr><name>charset_register_hooks</name></expr>
}</block></expr>;</expr_stmt>

</unit>
