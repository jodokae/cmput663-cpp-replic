<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/http/chunk_filter.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * chunk_filter.c --- HTTP/1.1 chunked transfer encoding filter.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_thread_proc.h"</cpp:file></cpp:include>    <comment type="block">/* for RLIMIT stuff */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>  <comment type="block">/* For index_of_response().  Grump. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ebcdic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_core.h"</cpp:file></cpp:include>

<comment type="block">/*
 * A pointer to this is used to memorize in the filter context that a bad
 * gateway error bucket had been seen. It is used as an invented unique pointer.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name>bad_gateway_seen</name></decl>;</decl_stmt>

<function><type><name>apr_status_t</name></type> <name>ap_http_chunk_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASCII_CRLF</name></cpp:macro>  <cpp:value>"\015\012"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASCII_ZERO</name></cpp:macro>  <cpp:value>"\060"</cpp:value></cpp:define>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>more</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>more</name> = <name>tmp</name> = <name>NULL</name></expr>;</init> <condition><expr><name>b</name></expr>;</condition> <incr><expr><name>b</name> = <name>more</name></expr>, <expr><name>more</name> = <name>NULL</name></expr></incr>) <block>{
        <decl_stmt><decl><type><name>apr_off_t</name></type> <name>bytes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>eos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>flush</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
        <comment type="block">/* XXX: chunk_hdr must remain at this scope since it is used in a
         *      transient bucket.
         */</comment>
        <decl_stmt><decl><type><name>char</name></type> <name><name>chunk_hdr</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* enough space for the snprintf below */</comment>


        <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/* there shouldn't be anything after the eos */</comment>
                <expr_stmt><expr><name>eos</name> = <name>e</name></expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>AP_BUCKET_IS_ERROR</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call>
                &amp;&amp; ((<call>(<name>ap_bucket_error</name> *)<argument_list>(<argument><expr><name><name>e</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call>)-&gt;<name>status</name>
                    == <name>HTTP_BAD_GATEWAY</name>)</expr>)</condition><then> <block>{
                <comment type="block">/*
                 * We had a broken backend. Memorize this in the filter
                 * context.
                 */</comment>
                <expr_stmt><expr><name><name>f</name>-&gt;<name>ctx</name></name> = &amp;<name>bad_gateway_seen</name></expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>
            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_FLUSH</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>flush</name> = <name>e</name></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>e</name> != <call><name>APR_BRIGADE_LAST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name>more</name> = <call><name>apr_brigade_split_ex</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
                <break>break;</break>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>e</name>-&gt;<name>length</name></name> == (<name>apr_size_t</name>)-1</expr>)</condition><then> <block>{
                <comment type="block">/* unknown amount of data (e.g. a pipe) */</comment>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>rv</name></expr>;</return>
                }</block></then></if>
                <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * There may be a new next bucket representing the
                     * rest of the data stream on which a read() may
                     * block so we pass down what we have so far.
                     */</comment>
                    <expr_stmt><expr><name>bytes</name> += <name>len</name></expr>;</expr_stmt>
                    <expr_stmt><expr><name>more</name> = <call><name>apr_brigade_split_ex</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <break>break;</break>
                }</block></then>
                <else>else <block>{
                    <comment type="block">/* If there was nothing in this bucket then we can
                     * safely move on to the next one without pausing
                     * to pass down what we have counted up so far.
                     */</comment>
                    <continue>continue;</continue>
                }</block></else></if>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name>bytes</name> += <name><name>e</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></for>

        <comment type="block">/*
         * XXX: if there aren't very many bytes at this point it may
         * be a good idea to set them aside and return for more,
         * unless we haven't finished counting this brigade yet.
         */</comment>
        <comment type="block">/* if there are content bytes, then wrap them in a chunk */</comment>
        <if>if <condition>(<expr><name>bytes</name> &gt; 0</expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>hdr_len</name></decl>;</decl_stmt>
            <comment type="block">/*
             * Insert the chunk header, specifying the number of bytes in
             * the chunk.
             */</comment>
            <expr_stmt><expr><name>hdr_len</name> = <macro><name>apr_snprintf</name><argument_list>(<argument>chunk_hdr</argument>, <argument>sizeof(chunk_hdr)</argument>,
                                   <argument>"%" APR_UINT64_T_HEX_FMT CRLF</argument>, <argument>(apr_uint64_t)bytes</argument>)</argument_list></macro></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>chunk_hdr</name></expr></argument>, <argument><expr><name>hdr_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_transient_create</name><argument_list>(<argument><expr><name>chunk_hdr</name></expr></argument>, <argument><expr><name>hdr_len</name></expr></argument>,
                                            <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_HEAD</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/*
             * Insert the end-of-chunk CRLF before an EOS or
             * FLUSH bucket, or appended to the brigade
             */</comment>
            <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_immortal_create</name><argument_list>(<argument><expr><name>ASCII_CRLF</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>eos</name> != <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>eos</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>flush</name> != <name>NULL</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>flush</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
        }</block></then></if>

        <comment type="block">/* RFC 2616, Section 3.6.1
         *
         * If there is an EOS bucket, then prefix it with:
         *   1) the last-chunk marker ("0" CRLF)
         *   2) the trailer
         *   3) the end-of-chunked body CRLF
         *
         * We only do this if we have not seen an error bucket with
         * status HTTP_BAD_GATEWAY. We have memorized an
         * error bucket that we had seen in the filter context.
         * The error bucket with status HTTP_BAD_GATEWAY indicates that the
         * connection to the backend (mod_proxy) broke in the middle of the
         * response. In order to signal the client that something went wrong
         * we do not create the last-chunk marker and set c-&gt;keepalive to
         * AP_CONN_CLOSE in the core output filter.
         *
         * XXX: it would be nice to combine this with the end-of-chunk
         * marker above, but this is a bit more straight-forward for
         * now.
         */</comment>
        <if>if <condition>(<expr><name>eos</name> &amp;&amp; !<name><name>f</name>-&gt;<name>ctx</name></name></expr>)</condition><then> <block>{
            <comment type="block">/* XXX: (2) trailers ... does not yet exist */</comment>
            <expr_stmt><expr><name>e</name> = <macro><name>apr_bucket_immortal_create</name><argument_list>(<argument>ASCII_ZERO ASCII_CRLF
                                           <comment type="block">/* &lt;trailers&gt; */</comment>
                                           ASCII_CRLF</argument>, <argument>5</argument>, <argument>c-&gt;bucket_alloc</argument>)</argument_list></macro></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BUCKET_INSERT_BEFORE</name><argument_list>(<argument><expr><name>eos</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* pass the brigade to the next filter. */</comment>
        <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name> || <name>eos</name> != <name>NULL</name></expr>)</condition><then> <block>{
            <return>return <expr><name>rv</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name>tmp</name> = <name>b</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>
</unit>
