<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/modules/http/http_filters.c"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/*
 * http_filter.c --- HTTP routines which either filters or deal with filters.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_strings.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_buckets.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_lib.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_signal.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STDIO</name></cpp:macro></cpp:define>          <comment type="block">/* for sscanf */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_MEMFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_want.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_filter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"httpd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_core.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_request.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_vhost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_log.h"</cpp:file></cpp:include>           <comment type="block">/* For errors detected in basic auth common
                                 * support code... */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_date.h"</cpp:file></cpp:include>           <comment type="block">/* For apr_date_parse_http and APR_DATE_BAD */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_charset.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_ebcdic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_core.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_STDARG_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_UNISTD_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>APLOG_USE_MODULE</name><argument_list>(<argument><expr><name>http</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<typedef>typedef <type><struct>struct <name>http_filter_ctx</name>
<block>{
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>remaining</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>limit</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_off_t</name></type> <name>limit_used</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>chunk_used</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>chunk_bws</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>chunkbits</name></decl>;</decl_stmt>
    <enum>enum
    <block>{
        <decl><name>BODY_NONE</name></decl>, <comment type="block">/* streamed data */</comment>
        <decl><name>BODY_LENGTH</name></decl>, <comment type="block">/* data constrained by content length */</comment>
        <decl><name>BODY_CHUNK</name></decl>, <comment type="block">/* chunk expected */</comment>
        <decl><name>BODY_CHUNK_PART</name></decl>, <comment type="block">/* chunk digits */</comment>
        <decl><name>BODY_CHUNK_EXT</name></decl>, <comment type="block">/* chunk extension */</comment>
        <decl><name>BODY_CHUNK_CR</name></decl>, <comment type="block">/* got space(s) after digits, expect [CR]LF or ext */</comment>
        <decl><name>BODY_CHUNK_LF</name></decl>, <comment type="block">/* got CR after digits or ext, expect LF */</comment>
        <decl><name>BODY_CHUNK_DATA</name></decl>, <comment type="block">/* data constrained by chunked encoding */</comment>
        <decl><name>BODY_CHUNK_END</name></decl>, <comment type="block">/* chunked data terminating CRLF */</comment>
        <decl><name>BODY_CHUNK_END_LF</name></decl>, <comment type="block">/* got CR after data, expect LF */</comment>
        <decl><name>BODY_CHUNK_TRAILER</name></decl> <comment type="block">/* trailers */</comment>
    }</block> <decl><name>state</name></decl>;</enum>
    <expr_stmt><expr><name>unsigned</name> <name>int</name> <name>eos_sent</name> :1</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
}</block></struct></type> <name>http_ctx_t</name>;</typedef>

<comment type="block">/* bail out if some error in the HTTP input filter happens */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>bail_out_on_error</name><parameter_list>(<param><decl><type><name>http_ctx_t</name> *</type><name>ctx</name></decl></param>,
                                      <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                      <param><decl><type><name>int</name></type> <name>http_error</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name> <init>= <expr><name><name>ctx</name>-&gt;<name>bb</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>proxyreq</name></name> == <name>PROXYREQ_RESPONSE</name></expr>)</condition><then> <block>{
        <switch>switch <condition>(<expr><name>http_error</name></expr>)</condition> <block>{
        <case>case <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>:
            <return>return <expr><name>APR_ENOSPC</name></expr>;</return>

        </case><case>case <expr><name>HTTP_REQUEST_TIME_OUT</name></expr>:
            <return>return <expr><name>APR_INCOMPLETE</name></expr>;</return>

        </case><case>case <expr><name>HTTP_NOT_IMPLEMENTED</name></expr>:
            <return>return <expr><name>APR_ENOTIMPL</name></expr>;</return>

        </case><default>default:
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
        </default>}</block></switch>
    }</block></then></if>

    <expr_stmt><expr><name>e</name> = <call><name>ap_bucket_error_create</name><argument_list>(<argument><expr><name>http_error</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                               <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>eos_sent</name></name> = 1</expr>;</expr_stmt>
    <comment type="block">/* If chunked encoding / content-length are corrupt, we may treat parts
     * of this request's body as the next one's headers.
     * To be safe, disable keep-alive.
     */</comment>
    <expr_stmt><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
    <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/**
 * Parse a chunk line with optional extension, detect overflow.
 * There are several error cases:
 *  1) If the chunk link is misformatted, APR_EINVAL is returned.
 *  2) If the conversion would require too many bits, APR_EGENERAL is returned.
 *  3) If the conversion used the correct number of bits, but an overflow
 *     caused only the sign bit to flip, then APR_ENOSPC is returned.
 * A negative chunk length always indicates an overflow error.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>parse_chunk_size</name><parameter_list>(<param><decl><type><name>http_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>,
                                     <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>linelimit</name></decl></param>, <param><decl><type><name>int</name></type> <name>strict</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition> <block>{
        <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>ap_xlate_proto_from_ascii</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* handle CRLF after the chunk */</comment>
        <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_END</name>
                || <name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_END_LF</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>c</name> == <name>LF</name></expr>)</condition><then> <block>{
                <if>if <condition>(<expr><name>strict</name> &amp;&amp; (<name><name>ctx</name>-&gt;<name>state</name></name> != <name>BODY_CHUNK_END_LF</name>)</expr>)</condition><then> <block>{
                    <comment type="block">/*
                     * CR missing before LF.
                     */</comment>
                    <return>return <expr><name>APR_EINVAL</name></expr>;</return>
                }</block></then></if>
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>c</name> == <name>CR</name> &amp;&amp; <name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_END</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK_END_LF</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/*
                 * CRLF expected.
                 */</comment>
                <return>return <expr><name>APR_EINVAL</name></expr>;</return>
            }</block></else></if></else></if>
            <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>

        <comment type="block">/* handle start of the chunk */</comment>
        <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>apr_isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <comment type="block">/*
                 * Detect invalid character at beginning. This also works for
                 * empty chunk size lines.
                 */</comment>
                <return>return <expr><name>APR_EINVAL</name></expr>;</return>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK_PART</name></expr>;</expr_stmt>
            }</block></else></if>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>remaining</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>chunkbits</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>apr_off_t</name></expr></argument>)</argument_list></sizeof> * 8</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>chunk_used</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>chunk_bws</name></name> = 0</expr>;</expr_stmt>
        }</block></then></if>

        <if>if <condition>(<expr><name>c</name> == <name>LF</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name>strict</name> &amp;&amp; (<name><name>ctx</name>-&gt;<name>state</name></name> != <name>BODY_CHUNK_LF</name>)</expr>)</condition><then> <block>{
                <comment type="block">/*
                 * CR missing before LF.
                 */</comment>
                <return>return <expr><name>APR_EINVAL</name></expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>remaining</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK_DATA</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK_TRAILER</name></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_LF</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * LF expected.
             */</comment>
            <return>return <expr><name>APR_EINVAL</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>c</name> == <name>CR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK_LF</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>c</name> == ';'</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK_EXT</name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_EXT</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Control chars (excluding tabs) are invalid.
             * TODO: more precisely limit input
             */</comment>
            <if>if <condition>(<expr><name>c</name> != '\t' &amp;&amp; <call><name>apr_iscntrl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <return>return <expr><name>APR_EINVAL</name></expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>c</name> == ' ' || <name>c</name> == '\t'</expr>)</condition><then> <block>{
            <comment type="block">/* Be lenient up to 10 implied *LWS, a legacy of RFC 2616,
             * and noted as errata to RFC7230;
             * https://www.rfc-editor.org/errata_search.php?rfc=7230&amp;eid=4667
             */</comment>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK_CR</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>++<name><name>ctx</name>-&gt;<name>chunk_bws</name></name> &gt; 10</expr>)</condition><then> <block>{
                <return>return <expr><name>APR_EINVAL</name></expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_CR</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * ';', CR or LF expected.
             */</comment>
            <return>return <expr><name>APR_EINVAL</name></expr>;</return>
        }</block></then>
        <else>else <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_PART</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>xvalue</name></decl>;</decl_stmt>

            <comment type="block">/* ignore leading zeros */</comment>
            <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>remaining</name></name> &amp;&amp; <name>c</name> == '0'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
                <continue>continue;</continue>
            }</block></then></if>

            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>chunkbits</name></name> -= 4</expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>chunkbits</name></name> &lt; 0</expr>)</condition><then> <block>{
                <comment type="block">/* overflow */</comment>
                <return>return <expr><name>APR_ENOSPC</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>xvalue</name> = <name>c</name> - '0'</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>c</name> &gt;= 'A' &amp;&amp; <name>c</name> &lt;= 'F'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>xvalue</name> = <name>c</name> - 'A' + 0xa</expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name>c</name> &gt;= 'a' &amp;&amp; <name>c</name> &lt;= 'f'</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>xvalue</name> = <name>c</name> - 'a' + 0xa</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* bogus character */</comment>
                <return>return <expr><name>APR_EINVAL</name></expr>;</return>
            }</block></else></if></else></if></else></if>

            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>remaining</name></name> = (<name><name>ctx</name>-&gt;<name>remaining</name></name> &lt;&lt; 4) | <name>xvalue</name></expr>;</expr_stmt>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>remaining</name></name> &lt; 0</expr>)</condition><then> <block>{
                <comment type="block">/* overflow */</comment>
                <return>return <expr><name>APR_ENOSPC</name></expr>;</return>
            }</block></then></if>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Should not happen */</comment>
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
        }</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>

        <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></while>

    <comment type="block">/* sanity check */</comment>
    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>chunk_used</name></name> += <name>len</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>chunk_used</name></name> &lt; 0 || <name><name>ctx</name>-&gt;<name>chunk_used</name></name> &gt; <name>linelimit</name></expr>)</condition><then> <block>{
        <return>return <expr><name>APR_ENOSPC</name></expr>;</return>
    }</block></then></if>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>read_chunked_trailers</name><parameter_list>(<param><decl><type><name>http_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                          <param><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl></param>, <param><decl><type><name>int</name></type> <name>merge</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>saved_headers_in</name> <init>= <expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>saved_status</name> <init>= <expr><name><name>r</name>-&gt;<name>status</name></name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_OK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>headers_in</name></name> = <name><name>r</name>-&gt;<name>trailers_in</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_clear</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_get_mime_headers</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>(<expr><name><name>r</name>-&gt;<name>status</name></name> == <name>HTTP_OK</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>saved_status</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>eos_sent</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error_notes</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>,
                                                <argument><expr>"error-notes"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02656</expr></argument>)</argument_list></call>
                      "Error while reading HTTP trailer: %i%s%s"</expr></argument>,
                      <argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>, <argument><expr><name>error_notes</name> ? ": " : ""</expr></argument>,
                      <argument><expr><name>error_notes</name> ? <name>error_notes</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <name>APR_EINVAL</name></expr>;</expr_stmt>
    }</block></else></if>

    <if>if<condition>(<expr>!<name>merge</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>headers_in</name></name> = <name>saved_headers_in</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>headers_in</name></name> = <call><name>apr_table_overlay</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>saved_headers_in</name></expr></argument>,
                <argument><expr><name><name>r</name>-&gt;<name>trailers_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <return>return <expr><name>rv</name></expr>;</return>
}</block></function>

<comment type="block">/* This is the HTTP_INPUT filter for HTTP requests and responses from
 * proxied servers (mod_proxy).  It handles chunked and content-length
 * bodies.  This can only be inserted/used after the headers
 * are successfully parsed.
 */</comment>
<function><type><name>apr_status_t</name></type> <name>ap_http_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl></param>,
                            <param><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl></param>, <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                            <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name> <init>=
        <expr>(<name>core_server_config</name> *) <call><name>ap_get_module_config</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>,
                                                    <argument><expr>&amp;<name>core_module</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>strict</name> <init>= <expr>(<name><name>conf</name>-&gt;<name>http_conformance</name></name> != <name>AP_HTTP_CONFORMANCE_UNSAFE</name>)</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>http_ctx_t</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>http_error</name> <init>= <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>again</name></decl>;</decl_stmt>

    <comment type="block">/* just get out of the way of things we don't want. */</comment>
    <if>if <condition>(<expr><name>mode</name> != <name>AP_MODE_READBYTES</name> &amp;&amp; <name>mode</name> != <name>AP_MODE_GETLINE</name></expr>)</condition><then> <block>{
        <return>return <expr><call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tenc</name></decl>, *<decl><type ref="prev"/><name>lenp</name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>f</name>-&gt;<name>ctx</name></name> = <name>ctx</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_NONE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>bb</name></name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bb</name> = <name><name>ctx</name>-&gt;<name>bb</name></name></expr>;</expr_stmt>

        <comment type="block">/* LimitRequestBody does not apply to proxied responses.
         * Consider implementing this check in its own filter.
         * Would adding a directive to limit the size of proxied
         * responses be useful?
         */</comment>
        <if>if <condition>(<expr>!<name><name>f</name>-&gt;<name>r</name>-&gt;<name>proxyreq</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>limit</name></name> = <call><name>ap_get_limit_req_body</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>limit</name></name> = 0</expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>tenc</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lenp</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>tenc</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>tenc</name></expr></argument>, <argument><expr>"chunked"</expr></argument>)</argument_list></call> == 0 <comment type="block">/* fast path */</comment>
                    || <call><name>ap_find_last_token</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>tenc</name></expr></argument>, <argument><expr>"chunked"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <if>if <condition>(<expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>proxyreq</name></name> == <name>PROXYREQ_RESPONSE</name></expr>)</condition><then> <block>{
                <comment type="block">/* http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-23
                 * Section 3.3.3.3: "If a Transfer-Encoding header field is
                 * present in a response and the chunked transfer coding is not
                 * the final encoding, the message body length is determined by
                 * reading the connection until it is closed by the server."
                 */</comment>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02555</expr></argument>)</argument_list></call>
                              "Unknown Transfer-Encoding: %s; "
                              "using read-until-close"</expr></argument>, <argument><expr><name>tenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tenc</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <comment type="block">/* Something that isn't a HTTP request, unless some future
                 * edition defines new transfer encodings, is unsupported.
                 */</comment>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01585</expr></argument>)</argument_list></call>
                              "Unknown Transfer-Encoding: %s"</expr></argument>, <argument><expr><name>tenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>bail_out_on_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if></else></if>
            <expr_stmt><expr><name>lenp</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
        <if>if <condition>(<expr><name>lenp</name></expr>)</condition><then> <block>{
            <decl_stmt><decl><type><name>char</name> *</type><name>endstr</name></decl>;</decl_stmt>

            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_LENGTH</name></expr>;</expr_stmt>

            <comment type="block">/* Protects against over/underflow, non-digit chars in the
             * string (excluding leading space) (the endstr checks)
             * and a negative number. */</comment>
            <if>if <condition>(<expr><call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name><name>ctx</name>-&gt;<name>remaining</name></name></expr></argument>, <argument><expr><name>lenp</name></expr></argument>, <argument><expr>&amp;<name>endstr</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>
                || <name>endstr</name> == <name>lenp</name> || *<name>endstr</name> || <name><name>ctx</name>-&gt;<name>remaining</name></name> &lt; 0</expr>)</condition><then> <block>{

                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>remaining</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01587</expr></argument>)</argument_list></call>
                              "Invalid Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <return>return <expr><call><name>bail_out_on_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <comment type="block">/* If we have a limit in effect and we know the C-L ahead of
             * time, stop it here if it is invalid.
             */</comment>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>limit</name></name> &amp;&amp; <name><name>ctx</name>-&gt;<name>limit</name></name> &lt; <name><name>ctx</name>-&gt;<name>remaining</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01588</expr></argument>)</argument_list></call>
                          "Requested content-length of %" <name>APR_OFF_T_FMT</name>
                          " is larger than the configured limit"
                          " of %" <name>APR_OFF_T_FMT</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>remaining</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><call><name>bail_out_on_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then></if>

        <comment type="block">/* If we don't have a request entity indicated by the headers, EOS.
         * (BODY_NONE is a valid intermediate state due to trailers,
         *  but it isn't a valid starting state.)
         *
         * RFC 2616 Section 4.4 note 5 states that connection-close
         * is invalid for a request entity - request bodies must be
         * denoted by C-L or T-E: chunked.
         *
         * Note that since the proxy uses this filter to handle the
         * proxied *response*, proxy responses MUST be exempt.
         */</comment>
        <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_NONE</name> &amp;&amp; <name><name>f</name>-&gt;<name>r</name>-&gt;<name>proxyreq</name></name> != <name>PROXYREQ_RESPONSE</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>eos_sent</name></name> = 1</expr>;</expr_stmt>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>

        <comment type="block">/* Since we're about to read data, send 100-Continue if needed.
         * Only valid on chunked and C-L bodies where the C-L is &gt; 0. */</comment>
        <if>if <condition>(<expr>(<name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK</name> ||
            (<name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_LENGTH</name> &amp;&amp; <name><name>ctx</name>-&gt;<name>remaining</name></name> &gt; 0)) &amp;&amp;
            <name><name>f</name>-&gt;<name>r</name>-&gt;<name>expecting_100</name></name> &amp;&amp; <name><name>f</name>-&gt;<name>r</name>-&gt;<name>proto_num</name></name> &gt;= <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call> &amp;&amp;
            !(<name><name>f</name>-&gt;<name>r</name>-&gt;<name>eos_sent</name></name> || <name><name>f</name>-&gt;<name>r</name>-&gt;<name>bytes_sent</name></name>)</expr>)</condition><then> <block>{
            <if>if <condition>(<expr>!<call><name>ap_is_HTTP_SUCCESS</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_NONE</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>eos_sent</name></name> = 1</expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
                <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

                <comment type="block">/* if we send an interim response, we're no longer
                 * in a state of expecting one.
                 */</comment>
                <expr_stmt><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>expecting_100</name></name> = 0</expr>;</expr_stmt>
                <expr_stmt><expr><name>tmp</name> = <macro><name>apr_pstrcat</name><argument_list>(<argument>f-&gt;r-&gt;pool</argument>, <argument>AP_SERVER_PROTOCOL " "</argument>,
                                  <argument>ap_get_status_line(HTTP_CONTINUE)</argument>, <argument>CRLF CRLF</argument>,
                                  <argument>NULL</argument>)</argument_list></macro></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                           <argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_HEAD</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_flush_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>output_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>AP_FILTER_ERROR</name></expr>;</return>
                }</block></then></if>
            }</block></else></if>
        }</block></then></if>
    }</block></then></if>

    <comment type="block">/* sanity check in case we're read twice */</comment>
    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>eos_sent</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>

    <do>do <block>{
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>again</name> = 0</expr>;</expr_stmt> <comment type="block">/* until further notice */</comment>

        <comment type="block">/* read and handle the brigade */</comment>
        <switch>switch <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name></expr>)</condition> <block>{
        <case>case <expr><name>BODY_CHUNK</name></expr>:
        </case><case>case <expr><name>BODY_CHUNK_PART</name></expr>:
        </case><case>case <expr><name>BODY_CHUNK_EXT</name></expr>:
        </case><case>case <expr><name>BODY_CHUNK_CR</name></expr>:
        </case><case>case <expr><name>BODY_CHUNK_LF</name></expr>:
        </case><case>case <expr><name>BODY_CHUNK_END</name></expr>:
        </case><case>case <expr><name>BODY_CHUNK_END_LF</name></expr>: <block>{

            <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>AP_MODE_GETLINE</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* for timeout */</comment>
            <if>if <condition>(<expr><name>block</name> == <name>APR_NONBLOCK_READ</name>
                    &amp;&amp; ((<name>rv</name> == <name>APR_SUCCESS</name> &amp;&amp; <call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>)
                            || (<call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
                <return>return <expr><name>APR_EAGAIN</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>rv</name> == <name>APR_EOF</name></expr>)</condition><then> <block>{
                <return>return <expr><name>APR_INCOMPLETE</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <while>while <condition>(<expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

                <if>if <condition>(<expr>!<call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                    <decl_stmt><decl><type><name>int</name></type> <name>parsing</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

                    <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                    <if>if <condition>(<expr><name>rv</name> == <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>parsing</name> = 1</expr>;</expr_stmt>
                        <expr_stmt><expr><name>rv</name> = <call><name>parse_chunk_size</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
                                <argument><expr><name><name>f</name>-&gt;<name>r</name>-&gt;<name>server</name>-&gt;<name>limit_req_fieldsize</name></name></expr></argument>, <argument><expr><name>strict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01590</expr></argument>)</argument_list></call>
                                      "Error reading/parsing chunk %s "</expr></argument>,
                                      <argument><expr>(<name>APR_ENOSPC</name> == <name>rv</name>) ? "(overflow)" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><name>parsing</name></expr>)</condition><then> <block>{
                            <if>if <condition>(<expr><name>rv</name> != <name>APR_ENOSPC</name></expr>)</condition><then> <block>{
                                <expr_stmt><expr><name>http_error</name> = <name>HTTP_BAD_REQUEST</name></expr>;</expr_stmt>
                            }</block></then></if>
                            <return>return <expr><call><name>bail_out_on_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>http_error</name></expr></argument>)</argument_list></call></expr>;</return>
                        }</block></then></if>
                        <return>return <expr><name>rv</name></expr>;</return>
                    }</block></then></if>
                }</block></then></if>

                <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
            <expr_stmt><expr><name>again</name> = 1</expr>;</expr_stmt> <comment type="block">/* come around again */</comment>

            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_TRAILER</name></expr>)</condition><then> <block>{
                <comment type="block">/* Treat UNSET as DISABLE - trailers aren't merged by default */</comment>
                <return>return <expr><call><name>read_chunked_trailers</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                            <argument><expr><name><name>conf</name>-&gt;<name>merge_trailers</name></name> == <name>AP_MERGE_TRAILERS_ENABLE</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

            <break>break;</break>
        }</block>
        </case><case>case <expr><name>BODY_NONE</name></expr>:
        </case><case>case <expr><name>BODY_LENGTH</name></expr>:
        </case><case>case <expr><name>BODY_CHUNK_DATA</name></expr>: <block>{

            <comment type="block">/* Ensure that the caller can not go over our boundary point. */</comment>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> != <name>BODY_NONE</name> &amp;&amp; <name><name>ctx</name>-&gt;<name>remaining</name></name> &lt; <name>readbytes</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>readbytes</name> = <name><name>ctx</name>-&gt;<name>remaining</name></name></expr>;</expr_stmt>
            }</block></then></if>
            <if>if <condition>(<expr><name>readbytes</name> &gt; 0</expr>)</condition><then> <block>{
                <decl_stmt><decl><type><name>apr_off_t</name></type> <name>totalread</name></decl>;</decl_stmt>

                <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* for timeout */</comment>
                <if>if <condition>(<expr><name>block</name> == <name>APR_NONBLOCK_READ</name>
                        &amp;&amp; ((<name>rv</name> == <name>APR_SUCCESS</name> &amp;&amp; <call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>)
                                || (<call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
                    <return>return <expr><name>APR_EAGAIN</name></expr>;</return>
                }</block></then></if>

                <if>if <condition>(<expr><name>rv</name> == <name>APR_EOF</name> &amp;&amp; <name><name>ctx</name>-&gt;<name>state</name></name> != <name>BODY_NONE</name>
                        &amp;&amp; <name><name>ctx</name>-&gt;<name>remaining</name></name> &gt; 0</expr>)</condition><then> <block>{
                    <return>return <expr><name>APR_INCOMPLETE</name></expr>;</return>
                }</block></then></if>

                <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                    <return>return <expr><name>rv</name></expr>;</return>
                }</block></then></if>

                <comment type="block">/* How many bytes did we just read? */</comment>
                <expr_stmt><expr><call><name>apr_brigade_length</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>totalread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <comment type="block">/* If this happens, we have a bucket of unknown length.  Die because
                 * it means our assumptions have changed. */</comment>
                <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><name>totalread</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> != <name>BODY_NONE</name></expr>)</condition><then> <block>{
                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>remaining</name></name> -= <name>totalread</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>remaining</name></name> &gt; 0</expr>)</condition><then> <block>{
                        <expr_stmt><expr><name>e</name> = <call><name>APR_BRIGADE_LAST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                            <expr_stmt><expr><call><name>apr_bucket_delete</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <return>return <expr><name>APR_INCOMPLETE</name></expr>;</return>
                        }</block></then></if>
                    }</block></then>
                    <else>else <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_CHUNK_DATA</name></expr>)</condition><then> <block>{
                        <comment type="block">/* next chunk please */</comment>
                        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>state</name></name> = <name>BODY_CHUNK_END</name></expr>;</expr_stmt>
                        <expr_stmt><expr><name><name>ctx</name>-&gt;<name>chunk_used</name></name> = 0</expr>;</expr_stmt>
                    }</block></then></if></else></if>
                }</block></then></if>

                <comment type="block">/* We have a limit in effect. */</comment>
                <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>limit</name></name></expr>)</condition><then> <block>{
                    <comment type="block">/* FIXME: Note that we might get slightly confused on
                     * chunked inputs as we'd need to compensate for the chunk
                     * lengths which may not really count.  This seems to be up
                     * for interpretation.
                     */</comment>
                    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>limit_used</name></name> += <name>totalread</name></expr>;</expr_stmt>
                    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>limit</name></name> &lt; <name><name>ctx</name>-&gt;<name>limit_used</name></name></expr>)</condition><then> <block>{
                        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>,
                                      <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01591</expr></argument>)</argument_list></call> "Read content length of "
                                      "%" <name>APR_OFF_T_FMT</name> " is larger than the "
                                      "configured limit of %" <name>APR_OFF_T_FMT</name></expr></argument>,
                                      <argument><expr><name><name>ctx</name>-&gt;<name>limit_used</name></name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <return>return <expr><call><name>bail_out_on_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>f</name></expr></argument>,
                                                 <argument><expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr></argument>)</argument_list></call></expr>;</return>
                    }</block></then></if>
                }</block></then></if>
            }</block></then></if>

            <comment type="block">/* If we have no more bytes remaining on a C-L request,
             * save the caller a round trip to discover EOS.
             */</comment>
            <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>state</name></name> == <name>BODY_LENGTH</name> &amp;&amp; <name><name>ctx</name>-&gt;<name>remaining</name></name> == 0</expr>)</condition><then> <block>{
                <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>ctx</name>-&gt;<name>eos_sent</name></name> = 1</expr>;</expr_stmt>
            }</block></then></if>

            <break>break;</break>
        }</block>
        </case><case>case <expr><name>BODY_CHUNK_TRAILER</name></expr>: <block>{

            <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>readbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* for timeout */</comment>
            <if>if <condition>(<expr><name>block</name> == <name>APR_NONBLOCK_READ</name>
                    &amp;&amp; ((<name>rv</name> == <name>APR_SUCCESS</name> &amp;&amp; <call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call>)
                            || (<call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
                <return>return <expr><name>APR_EAGAIN</name></expr>;</return>
            }</block></then></if>

            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <return>return <expr><name>rv</name></expr>;</return>
            }</block></then></if>

            <break>break;</break>
        }</block>
        </case><default>default: <block>{
            <comment type="block">/* Should not happen */</comment>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02901</expr></argument>)</argument_list></call>
                          "Unexpected body state (%i)"</expr></argument>, <argument><expr>(<name>int</name>)<name><name>ctx</name>-&gt;<name>state</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
        }</block>
        </default>}</block></switch>

    }</block> while <condition>(<expr><name>again</name></expr>)</condition>;</do>

    <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>

<struct>struct <name>check_header_ctx</name> <block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>strict</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* check a single header, to be used with apr_table_do() */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>check_header</name><parameter_list>(<param><decl><type>struct <name>check_header_ctx</name> *</type><name>ctx</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pos</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>dst</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02428</expr></argument>)</argument_list></call>
                      "Empty response header name, aborting request"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>strict</name></name></expr>)</condition><then> <block>{ 
        <expr_stmt><expr><name>end</name> = <call><name>ap_scan_http_token</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>end</name> = <call><name>ap_scan_vchar_obstext</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
    <if>if <condition>(<expr>*<name>end</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02429</expr></argument>)</argument_list></call>
                      "Response header name '%s' contains invalid "
                      "characters, aborting request"</expr></argument>,
                      <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <for>for (<init><expr><name>pos</name> = *<name>val</name></expr>;</init> <condition><expr>*<name>pos</name></expr>;</condition> <incr><expr><name>pos</name> = <name>end</name></expr></incr>) <block>{
        <expr_stmt><expr><name>end</name> = <call><name>ap_scan_http_field_content</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>*<name>end</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>end</name><index>[<expr>0</expr>]</index></name> != <name>CR</name> || <name><name>end</name><index>[<expr>1</expr>]</index></name> != <name>LF</name> || (<name><name>end</name><index>[<expr>2</expr>]</index></name> != ' ' &amp;&amp;
                                                 <name><name>end</name><index>[<expr>2</expr>]</index></name> != '\t')</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>02430</expr></argument>)</argument_list></call>
                              "Response header '%s' value of '%s' contains "
                              "invalid characters, aborting request"</expr></argument>,
                              <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr>0</expr>;</return>
            }</block></then></if>
            <if>if <condition>(<expr>!<name>dst</name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*<name>val</name> = <name>dst</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr>*<name>val</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
        <if>if <condition>(<expr><name>dst</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>end</name> - <name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>dst</name> += <name>end</name> - <name>pos</name></expr>;</expr_stmt>
            <if>if <condition>(<expr>*<name>end</name></expr>)</condition><then> <block>{
                <comment type="block">/* skip folding and replace with a single space */</comment>
                <expr_stmt><expr><name>end</name> += 3 + <call><name>strspn</name><argument_list>(<argument><expr><name>end</name> + 3</expr></argument>, <argument><expr>"\t "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr>*<name>dst</name>++ = ' '</expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>
    }</block></for>
    <if>if <condition>(<expr><name>dst</name></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>dst</name> = '\0'</expr>;</expr_stmt>
    }</block></then></if>
    <return>return <expr>1</expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_headers_table</name><parameter_list>(<param><decl><type><name>apr_table_t</name> *</type><name>t</name></decl></param>, <param><decl><type>struct <name>check_header_ctx</name> *</type><name>ctx</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>headers</name> <init>= <expr><call><name>apr_table_elts</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_table_entry_t</name> *</type><name>header</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>headers</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
        <expr_stmt><expr><name>header</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>apr_table_entry_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name><name>header</name>-&gt;<name>key</name></name></expr>)</condition><then> <block>{
            <continue>continue;</continue>
        }</block></then></if>
        <if>if <condition>(<expr>!<call><name>check_header</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name><name>header</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr>(const <name>char</name> **)&amp;<name><name>header</name>-&gt;<name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <return>return <expr>0</expr>;</return>
        }</block></then></if>
    }</block></for>
    <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/**
 * Check headers for HTTP conformance
 * @return 1 if ok, 0 if bad
 */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>int</name></type> <name>check_headers</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type>struct <name>check_header_ctx</name></type> <name>ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name> <init>=
            <expr><call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>ctx</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>ctx</name>.<name>strict</name></name> = (<name><name>conf</name>-&gt;<name>http_conformance</name></name> != <name>AP_HTTP_CONFORMANCE_UNSAFE</name>)</expr>;</expr_stmt>
    <return>return <expr><call><name>check_headers_table</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call> &amp;&amp;
           <call><name>check_headers_table</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>, <argument><expr>&amp;<name>ctx</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>check_headers_recursion</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>void</name> *</type><name>check</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>check</name></expr></argument>, <argument><expr>"check_headers_recursion"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>check</name></expr>)</condition><then> <block>{
        <return>return <expr>1</expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>apr_pool_userdata_setn</name><argument_list>(<argument><expr>"true"</expr></argument>, <argument><expr>"check_headers_recursion"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr>0</expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <name>header_struct</name> <block>{
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
}</block></struct></type> <name>header_struct</name>;</typedef>

<comment type="block">/* Send a single HTTP header field to the client.  Note that this function
 * is used in calls to apr_table_do(), so don't change its interface.
 * It returns true unless there was a write error of some kind.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>form_header_field</name><parameter_list>(<param><decl><type><name>header_struct</name> *</type><name>h</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fieldname</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fieldval</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
    <decl_stmt><decl><type><name>char</name> *</type><name>headfield</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>headfield</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>fieldname</name></expr></argument>, <argument><expr>": "</expr></argument>, <argument><expr><name>fieldval</name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>headfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>headfield</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_write</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>headfield</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <decl_stmt><decl><type>struct <name>iovec</name></type> <name><name>vec</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>iovec</name> *</type><name>v</name> <init>= <expr><name>vec</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>v</name>-&gt;<name>iov_base</name></name> = (<name>void</name> *)<name>fieldname</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name>-&gt;<name>iov_len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>fieldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name>-&gt;<name>iov_base</name></name> = ": "</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name>-&gt;<name>iov_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr>": "</expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name>-&gt;<name>iov_base</name></name> = (<name>void</name> *)<name>fieldval</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name>-&gt;<name>iov_len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name>fieldval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>v</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name>-&gt;<name>iov_base</name></name> = <name>CRLF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>v</name>-&gt;<name>iov_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>CRLF</name></expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_writev</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !APR_CHARSET_EBCDIC */</comment>
    <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/* This routine is called by apr_table_do and merges all instances of
 * the passed field values into a single array that will be further
 * processed by some later routine.  Originally intended to help split
 * and recombine multiple Vary fields, though it is generic to any field
 * consisting of comma/space-separated tokens.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>uniq_field_values</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>d</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>values</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> **</type><name>strpp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>  <name>i</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>values</name> = (<name>apr_array_header_t</name> *)<name>d</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>e</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>values</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <do>do <block>{
        <comment type="block">/* Find a non-empty fieldname */</comment>

        <while>while <condition>(<expr>*<name>e</name> == ',' || <call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>e</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>*<name>e</name> == '\0'</expr>)</condition><then> <block>{
            <break>break;</break>
        }</block></then></if>
        <expr_stmt><expr><name>start</name> = <name>e</name></expr>;</expr_stmt>
        <while>while <condition>(<expr>*<name>e</name> != '\0' &amp;&amp; *<name>e</name> != ',' &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>e</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
            <expr_stmt><expr>++<name>e</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr>*<name>e</name> != '\0'</expr>)</condition><then> <block>{
            <expr_stmt><expr>*<name>e</name>++ = '\0'</expr>;</expr_stmt>
        }</block></then></if>

        <comment type="block">/* Now add it to values if it isn't already represented.
         * Could be replaced by a ap_array_strcasecmp() if we had one.
         */</comment>
        <for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>strpp</name> = (<name>char</name> **) <name><name>values</name>-&gt;<name>elts</name></name></expr>;</init> <condition><expr><name>i</name> &lt; <name><name>values</name>-&gt;<name>nelts</name></name></expr>;</condition>
             <incr><expr>++<name>i</name></expr>, <expr>++<name>strpp</name></expr></incr>) <block>{
            <if>if <condition>(<expr>*<name>strpp</name> &amp;&amp; <call><name>strcasecmp</name><argument_list>(<argument><expr>*<name>strpp</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
                <break>break;</break>
            }</block></then></if>
        }</block></for>
        <if>if <condition>(<expr><name>i</name> == <name><name>values</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{  <comment type="block">/* if not found */</comment>
            <expr_stmt><expr>*(<name>char</name> **)<call><name>apr_array_push</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call> = <name>start</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block> while <condition>(<expr>*<name>e</name> != '\0'</expr>)</condition>;</do>

    <return>return <expr>1</expr>;</return>
}</block></function>

<comment type="block">/*
 * Since some clients choke violently on multiple Vary fields, or
 * Vary fields with duplicate tokens, combine any multiples and remove
 * any duplicates.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>fixup_vary</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>varies</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>varies</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>5</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Extract all Vary fields from the headers_out, separate each into
     * its comma-separated fieldname values, and then add them to varies
     * if not already present in the array.
     */</comment>
    <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr><name>uniq_field_values</name></expr></argument>, <argument><expr><name>varies</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If we found any, replace old Vary fields with unique-ified value */</comment>

    <if>if <condition>(<expr><name><name>varies</name>-&gt;<name>nelts</name></name> &gt; 0</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>,
                       <argument><expr><call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>varies</name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<comment type="block">/* Send a request's HTTP response headers to the client.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>send_all_header_fields</name><parameter_list>(<param><decl><type><name>header_struct</name> *</type><name>h</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>elts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_table_entry_t</name> *</type><name>t_elt</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>apr_table_entry_t</name> *</type><name>t_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>iovec</name> *</type><name>vec</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>iovec</name> *</type><name>vec_next</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>elts</name> = <call><name>apr_table_elts</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name><name>elts</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then> <block>{
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>
    <expr_stmt><expr><name>t_elt</name> = (const <name>apr_table_entry_t</name> *)(<name><name>elts</name>-&gt;<name>elts</name></name>)</expr>;</expr_stmt>
    <expr_stmt><expr><name>t_end</name> = <name>t_elt</name> + <name><name>elts</name>-&gt;<name>nelts</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>vec</name> = (struct <name>iovec</name> *)<call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>4 * <name><name>elts</name>-&gt;<name>nelts</name></name> *
                                     <sizeof>sizeof<argument_list>(<argument>struct <expr><name>iovec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>vec_next</name> = <name>vec</name></expr>;</expr_stmt>

    <comment type="block">/* For each field, generate
     *    name ": " value CRLF
     */</comment>
    <do>do <block>{
        <expr_stmt><expr><name><name>vec_next</name>-&gt;<name>iov_base</name></name> = <call>(<name>void</name>*)<argument_list>(<argument><expr><name><name>t_elt</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec_next</name>-&gt;<name>iov_len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>t_elt</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vec_next</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec_next</name>-&gt;<name>iov_base</name></name> = ": "</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec_next</name>-&gt;<name>iov_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr>": "</expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>vec_next</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec_next</name>-&gt;<name>iov_base</name></name> = <call>(<name>void</name>*)<argument_list>(<argument><expr><name><name>t_elt</name>-&gt;<name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec_next</name>-&gt;<name>iov_len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>t_elt</name>-&gt;<name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>vec_next</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec_next</name>-&gt;<name>iov_base</name></name> = <name>CRLF</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>vec_next</name>-&gt;<name>iov_len</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name>CRLF</name></expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>vec_next</name>++</expr>;</expr_stmt>
        <expr_stmt><expr><name>t_elt</name>++</expr>;</expr_stmt>
    }</block> while <condition>(<expr><name>t_elt</name> &lt; <name>t_end</name></expr>)</condition>;</do>

    <if>if <condition>(<expr><call><name>APLOGrtrace4</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>t_elt</name> = (const <name>apr_table_entry_t</name> *)(<name><name>elts</name>-&gt;<name>elts</name></name>)</expr>;</expr_stmt>
        <do>do <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE4</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>"  %s: %s"</expr></argument>,
                          <argument><expr><call><name>ap_escape_logitem</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>t_elt</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>ap_escape_logitem</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>t_elt</name>-&gt;<name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>t_elt</name>++</expr>;</expr_stmt>
        }</block> while <condition>(<expr><name>t_elt</name> &lt; <name>t_end</name></expr>)</condition>;</do>
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
    <block>{
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>apr_pstrcatv</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>vec_next</name> - <name>vec</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><call><name>apr_brigade_write</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>apr_brigade_writev</name><argument_list>(<argument><expr><name><name>h</name>-&gt;<name>bb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr><name>vec_next</name> - <name>vec</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* Confirm that the status line is well-formed and matches r-&gt;status.
 * If they don't match, a filter may have negated the status line set by a
 * handler.
 * Zap r-&gt;status_line if bad.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>validate_status_line</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>status_line</name></name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status_line</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><name>len</name> &lt; 3
            || <call><name>apr_strtoi64</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status_line</name></name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call> != <name><name>r</name>-&gt;<name>status</name></name>
            || (<name>end</name> - 3) != <name><name>r</name>-&gt;<name>status_line</name></name>
            || (<name>len</name> &gt;= 4 &amp;&amp; ! <call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status_line</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>status_line</name></name> = <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
        }</block></then></if>
        <comment type="block">/* Since we passed the above check, we know that length three
         * is equivalent to only a 3 digit numeric http status.
         * RFC2616 mandates a trailing space, let's add it.
         */</comment>
        <if>if <condition>(<expr><name>len</name> == 3</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>status_line</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>status_line</name></name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
        }</block></then></if>
        <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>APR_EGENERAL</name></expr>;</return>
}</block></function>

<comment type="block">/*
 * Determine the protocol to use for the response. Potentially downgrade
 * to HTTP/1.0 in some situations and/or turn off keepalives.
 *
 * also prepare r-&gt;status_line.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>basic_http_header_check</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>protocol</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>assbackwards</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* no such thing as a response protocol */</comment>
        <return>return;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>validate_status_line</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name><name>r</name>-&gt;<name>status_line</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>status_line</name></name> = <call><name>ap_get_status_line</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then> <else>else <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <comment type="block">/* Status line is OK but our own reason phrase
         * would be preferred if defined
         */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>ap_get_status_line</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr>!<call><name>strncmp</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>status_line</name></name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>status_line</name></name> = <name>tmp</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if></else></if>

    <comment type="block">/* Note that we must downgrade before checking for force responses. */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proto_num</name></name> &gt; <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>
        &amp;&amp; <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"downgrade-1.0"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* kludge around broken browsers when indicated by force-response-1.0
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proto_num</name></name> == <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call>
        &amp;&amp; <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"force-response-1.0"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr>*<name>protocol</name> = "HTTP/1.0"</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr>*<name>protocol</name> = <name>AP_SERVER_PROTOCOL</name></expr>;</expr_stmt>
    }</block></else></if>

}</block></function>

<comment type="block">/* fill "bb" with a barebones/initial HTTP response header */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>basic_http_header</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>protocol</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name> *</type><name>date</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proxy_date</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>server</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>us</name> <init>= <expr><call><name>ap_get_server_banner</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>header_struct</name></type> <name>h</name></decl>;</decl_stmt>
    <decl_stmt><decl><type>struct <name>iovec</name></type> <name><name>vec</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>assbackwards</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* there are no headers to send */</comment>
        <return>return;</return>
    }</block></then></if>

    <comment type="block">/* Output the HTTP/1.x Status-Line and the Date and Server fields */</comment>

    <expr_stmt><expr><name><name>vec</name><index>[<expr>0</expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name>protocol</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vec</name><index>[<expr>0</expr>]</index></name>.<name>iov_len</name>  = <call><name>strlen</name><argument_list>(<argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vec</name><index>[<expr>1</expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)" "</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vec</name><index>[<expr>1</expr>]</index></name>.<name>iov_len</name>  = <sizeof>sizeof<argument_list>(<argument><expr>" "</expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vec</name><index>[<expr>2</expr>]</index></name>.<name>iov_base</name> = <call>(<name>void</name> *)<argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status_line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vec</name><index>[<expr>2</expr>]</index></name>.<name>iov_len</name>  = <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status_line</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vec</name><index>[<expr>3</expr>]</index></name>.<name>iov_base</name> = (<name>void</name> *)<name>CRLF</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>vec</name><index>[<expr>3</expr>]</index></name>.<name>iov_len</name>  = <sizeof>sizeof<argument_list>(<argument><expr><name>CRLF</name></expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
    <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>tmp</name> = <call><name>apr_pstrcatv</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_brigade_write</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>apr_brigade_writev</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>vec</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>h</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>h</name>.<name>bb</name></name> = <name>bb</name></expr>;</expr_stmt>

    <comment type="block">/*
     * keep the set-by-proxy server and date headers, otherwise
     * generate a new server header / date header
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>proxyreq</name></name> != <name>PROXYREQ_NONE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>proxy_date</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Date"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>!<name>proxy_date</name></expr>)</condition><then> <block>{
            <comment type="block">/*
             * proxy_date needs to be const. So use date for the creation of
             * our own Date header and pass it over to proxy_date later to
             * avoid a compiler warning.
             */</comment>
            <expr_stmt><expr><name>date</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>APR_RFC822_DATE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_recent_rfc822_date</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><name>server</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Server"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><name>date</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>APR_RFC822_DATE_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_recent_rfc822_date</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>form_header_field</name><argument_list>(<argument><expr>&amp;<name>h</name></expr></argument>, <argument><expr>"Date"</expr></argument>, <argument><expr><name>proxy_date</name> ? <name>proxy_date</name> : <name>date</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>server</name> &amp;&amp; *<name>us</name></expr>)</condition><then>
        <expr_stmt><expr><name>server</name> = <name>us</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>server</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>form_header_field</name><argument_list>(<argument><expr>&amp;<name>h</name></expr></argument>, <argument><expr>"Server"</expr></argument>, <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <if>if <condition>(<expr><call><name>APLOGrtrace3</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>,
                      <argument><expr>"Response sent with status %d%s"</expr></argument>,
                      <argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>,
                      <argument><expr><call><name>APLOGrtrace4</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call> ? ", headers:" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * Date and Server are less interesting, use TRACE5 for them while
         * using TRACE4 for the other headers.
         */</comment>
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE5</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>"  Date: %s"</expr></argument>,
                      <argument><expr><name>proxy_date</name> ? <name>proxy_date</name> : <name>date</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>server</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_TRACE5</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>"  Server: %s"</expr></argument>,
                          <argument><expr><name>server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>


    <comment type="block">/* unset so we don't send them again */</comment>
    <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Date"</expr></argument>)</argument_list></call></expr>;</expr_stmt>        <comment type="block">/* Avoid bogosity */</comment>
    <if>if <condition>(<expr><name>server</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Server"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_basic_http_header</name><argument_list>(<argument>request_rec *r</argument>, <argument>apr_bucket_brigade *bb</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>protocol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>basic_http_header_check</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>basic_http_header</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>

<function><type><specifier>static</specifier> <name>void</name></type> <name>terminate_header</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>char</name></type> <name><name>crlf</name><index>[]</index></name> <init>= <expr><name>CRLF</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buflen</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>buflen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>crlf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>crlf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_write</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>crlf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_send_http_trace</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>core_server_config</name> *</type><name>conf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>header_struct</name></type> <name>h</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>body</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> *</type><name>bodyread</name> <init>= <expr><name>NULL</name></expr></init>, *<name>bodyoff</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bodylen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bodybuf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type> <name>res</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt> <comment type="block">/* init to avoid gcc -Wall warning */</comment>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>method_number</name></name> != <name>M_TRACE</name></expr>)</condition><then> <block>{
        <return>return <expr><name>DECLINED</name></expr>;</return>
    }</block></then></if>

    <comment type="block">/* Get the original request */</comment>
    <while>while <condition>(<expr><name><name>r</name>-&gt;<name>prev</name></name></expr>)</condition> <block>{
        <expr_stmt><expr><name>r</name> = <name><name>r</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
    }</block></while>
    <expr_stmt><expr><name>conf</name> = <call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>server</name>-&gt;<name>module_config</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>trace_enable</name></name> == <name>AP_TRACE_DISABLE</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                      <argument><expr>"TRACE denied by server configuration"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>conf</name>-&gt;<name>trace_enable</name></name> == <name>AP_TRACE_EXTENDED</name></expr>)</condition><then>
        <comment type="block">/* XXX: should be = REQUEST_CHUNKED_PASS */</comment>
        <expr_stmt><expr><name>body</name> = <name>REQUEST_CHUNKED_DECHUNK</name></expr>;</expr_stmt></then>
    <else>else
        <expr_stmt><expr><name>body</name> = <name>REQUEST_NO_BODY</name></expr>;</expr_stmt></else></if>

    <if>if <condition>(<expr>(<name>rv</name> = <call><name>ap_setup_client_block</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name>rv</name> == <name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                          <argument><expr>"TRACE with a request body is not allowed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <return>return <expr><name>rv</name></expr>;</return>
    }</block></then></if>

    <if>if <condition>(<expr><call><name>ap_should_client_block</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{

        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>remaining</name></name> &gt; 0</expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>r</name>-&gt;<name>remaining</name></name> &gt; 65536</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                       <argument><expr>"Extended TRACE request bodies cannot exceed 64k\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>;</return>
            }</block></then></if>
            <comment type="block">/* always 32 extra bytes to catch chunk header exceptions */</comment>
            <expr_stmt><expr><name>bodybuf</name> = (<name>apr_size_t</name>)<name><name>r</name>-&gt;<name>remaining</name></name> + 32</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <comment type="block">/* Add an extra 8192 for chunk headers */</comment>
            <expr_stmt><expr><name>bodybuf</name> = 73730</expr>;</expr_stmt>
        }</block></else></if>

        <expr_stmt><expr><name>bodyoff</name> = <name>bodyread</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>bodybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* only while we have enough for a chunked header */</comment>
        <while>while <condition>(<expr>(!<name>bodylen</name> || <name>bodybuf</name> &gt;= 32) &amp;&amp;
               (<name>res</name> = <call><name>ap_get_client_block</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>bodyoff</name></expr></argument>, <argument><expr><name>bodybuf</name></expr></argument>)</argument_list></call>) &gt; 0</expr>)</condition> <block>{
            <expr_stmt><expr><name>bodylen</name> += <name>res</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>bodybuf</name> -= <name>res</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>bodyoff</name> += <name>res</name></expr>;</expr_stmt>
        }</block></while>
        <if>if <condition>(<expr><name>res</name> &gt; 0 &amp;&amp; <name>bodybuf</name> &lt; 32</expr>)</condition><then> <block>{
            <comment type="block">/* discard_rest_of_request_body into our buffer */</comment>
            <while>while <condition>(<expr><call><name>ap_get_client_block</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>bodyread</name></expr></argument>, <argument><expr><name>bodylen</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition>
                <empty_stmt>;</empty_stmt></while>
            <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"error-notes"</expr></argument>,
                   <argument><expr>"Extended TRACE request bodies cannot exceed 64k\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>;</return>
        }</block></then></if>

        <if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then> <block>{
            <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>"message/http"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now we recreate the request, and echo it back */</comment>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_CHARSET_EBCDIC</name></expr></cpp:if>
    <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>the_request</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>tmp</name> = <call><name>apr_pmemdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>the_request</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_xlate_proto_to_ascii</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_brigade_putstrs</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>CRLF_ASCII</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><call><name>apr_brigade_putstrs</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>the_request</name></name></expr></argument>, <argument><expr><name>CRLF</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>h</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>h</name>.<name>bb</name></name> = <name>bb</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr>(<call><call><name>int</name> <argument_list>(<argument><expr>*</expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>void</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>)
                 <name>form_header_field</name></expr></argument>, <argument><expr>(<name>void</name> *) &amp;<name>h</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>apr_brigade_puts</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>CRLF_ASCII</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* If configured to accept a body, echo the body */</comment>
    <if>if <condition>(<expr><name>bodylen</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>b</name> = <call><name>apr_bucket_pool_create</name><argument_list>(<argument><expr><name>bodyread</name></expr></argument>, <argument><expr><name>bodylen</name></expr></argument>,
                                   <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>bb</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>,  <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>DONE</name></expr>;</return>
}</block>

<typedef>typedef <type><struct>struct <name>header_filter_ctx</name> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>headers_sent</name></decl>;</decl_stmt>
}</block></struct></type> <name>header_filter_ctx</name>;</typedef>

<macro><name>AP_CORE_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_http_header_filter</name><argument_list>(<argument>ap_filter_t *f</argument>,
                                                           <argument>apr_bucket_brigade *b</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>conn_rec</name> *</type><name>c</name> <init>= <expr><name><name>r</name>-&gt;<name>connection</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>clheader</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>protocol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>b2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>header_struct</name></type> <name>h</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>header_filter_ctx</name> *</type><name>ctx</name> <init>= <expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ctype</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ap_bucket_error</name> *</type><name>eb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name> <init>= <expr><name>APR_SUCCESS</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>recursive_error</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr>!<name><name>r</name>-&gt;<name/></name>main</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ctx</name> = <name><name>f</name>-&gt;<name>ctx</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>header_filter_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>headers_sent</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* Eat body if response must not have one. */</comment>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>header_only</name></name> || <name><name>r</name>-&gt;<name>status</name></name> == <name>HTTP_NO_CONTENT</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
        }</block></then></if>
    }</block></then></if></else></if>

    <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
        <if>if <condition>(<expr><call><name>AP_BUCKET_IS_ERROR</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> &amp;&amp; !<name>eb</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>eb</name> = <name><name>e</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
            <continue>continue;</continue>
        }</block></then></if>
        <comment type="block">/*
         * If we see an EOC bucket it is a signal that we should get out
         * of the way doing nothing.
         */</comment>
        <if>if <condition>(<expr><call><name>AP_BUCKET_IS_EOC</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_remove_output_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></for>

    <if>if <condition>(<expr>!<name><name>ctx</name>-&gt;<name>headers_sent</name></name> &amp;&amp; !<call><name>check_headers</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <comment type="block">/* We may come back here from ap_die() below,
         * so clear anything from this response.
         */</comment>
        <expr_stmt><expr><call><name>apr_table_clear</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_clear</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Don't recall ap_die() if we come back here (from its own internal
         * redirect or error response), otherwise we can end up in infinite
         * recursion; better fall through with 500, minimal headers and an
         * empty body (EOS only).
         */</comment>
        <if>if <condition>(<expr>!<call><name>check_headers_recursion</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_die</name><argument_list>(<argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>AP_FILTER_ERROR</name></expr>;</return>
        }</block></then></if>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>status</name></name> = <name>HTTP_INTERNAL_SERVER_ERROR</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name> = <call><name>ap_bucket_eoc_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>e</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>content_type</name></name> = <name><name>r</name>-&gt;<name>content_encoding</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>content_languages</name></name> = <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_set_content_length</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>recursive_error</name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>eb</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>status</name> = <name><name>eb</name>-&gt;<name>status</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_die</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>AP_FILTER_ERROR</name></expr>;</return>
    }</block></then></if></else></if>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>assbackwards</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>sent_bodyct</name></name> = 1</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ap_remove_output_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <comment type="block">/*
     * Now that we are ready to send a response, we need to combine the two
     * header field tables into a single table.  If we don't do this, our
     * later attempts to set or unset a given fieldname might be bypassed.
     */</comment>
    <if>if <condition>(<expr>!<call><name>apr_is_empty_table</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>headers_out</name></name> = <call><name>apr_table_overlay</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>err_headers_out</name></name></expr></argument>,
                                           <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Remove the 'Vary' header field if the client can't handle it.
     * Since this will have nasty effects on HTTP/1.1 caches, force
     * the response into HTTP/1.0 mode.
     *
     * Note: the force-response-1.0 should come before the call to
     *       basic_http_header_check()
     */</comment>
    <if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"force-no-vary"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Vary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>proto_num</name></name> = <call><name>HTTP_VERSION</name><argument_list>(<argument><expr>1</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>subprocess_env</name></name></expr></argument>, <argument><expr>"force-response-1.0"</expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>fixup_vary</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <comment type="block">/*
     * Now remove any ETag response header field if earlier processing
     * says so (such as a 'FileETag None' directive).
     */</comment>
    <if>if <condition>(<expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>notes</name></name></expr></argument>, <argument><expr>"no-etag"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"ETag"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* determine the protocol and whether we should use keepalives. */</comment>
    <expr_stmt><expr><call><name>basic_http_header_check</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_set_keepalive</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>chunked</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_mergen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>, <argument><expr>"chunked"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>status</name></name> == <name>HTTP_NO_CONTENT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>ctype</name> = <call><name>ap_make_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>content_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>ctype</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Type"</expr></argument>, <argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>content_encoding</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Encoding"</expr></argument>,
                       <argument><expr><name><name>r</name>-&gt;<name>content_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <if>if <condition>(<expr>!<call><name>apr_is_empty_array</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>content_languages</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>token</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> **</type><name>languages</name> <init>= <expr><call>(<name>char</name> **)<argument_list>(<argument><expr><name><name>r</name>-&gt;<name>content_languages</name>-&gt;<name>elts</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>field</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Language"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>field</name> &amp;&amp; (<name>token</name> = <call><name>ap_get_list_item</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>field</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>r</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
                <if>if <condition>(<expr>!<call><name>strcasecmp</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>languages</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                    <break>break;</break></then></if>
            }</block></for>
            <if>if <condition>(<expr><name>i</name> == <name><name>r</name>-&gt;<name>content_languages</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
                <expr_stmt><expr>*((<name>char</name> **) <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>content_languages</name></name></expr></argument>)</argument_list></call>) = <name>token</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></while>

        <expr_stmt><expr><name>field</name> = <call><name>apr_array_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>content_languages</name></name></expr></argument>, <argument><expr>','</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Language"</expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/*
     * Control cachability for non-cacheable responses if not already set by
     * some other part of the server configuration.
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>no_cache</name></name> &amp;&amp; !<call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Expires"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>date</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>APR_RFC822_DATE_LEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>ap_recent_rfc822_date</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>request_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_table_addn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Expires"</expr></argument>, <argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* This is a hack, but I can't find anyway around it.  The idea is that
     * we don't want to send out 0 Content-Lengths if it is a head request.
     * This happens when modules try to outsmart the server, and return
     * if they see a HEAD request.  Apache 1.3 handlers were supposed to
     * just return in that situation, and the core handled the HEAD.  In
     * 2.0, if a handler returns, then the core sends an EOS bucket down
     * the filter stack, and the content-length filter computes a C-L of
     * zero and that gets put in the headers, and we end up sending a
     * zero C-L to the client.  We can't just remove the C-L filter,
     * because well behaved 2.0 handlers will send their data down the stack,
     * and we will compute a real C-L for the head request. RBB
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>header_only</name></name>
        &amp;&amp; (<name>clheader</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call>)
        &amp;&amp; !<call><name>strcmp</name><argument_list>(<argument><expr><name>clheader</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_unset</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <expr_stmt><expr><name>b2</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>basic_http_header</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>b2</name></expr></argument>, <argument><expr><name>protocol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>h</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>h</name>.<name>bb</name></name> = <name>b2</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>status</name></name> == <name>HTTP_NOT_MODIFIED</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_table_do</name><argument_list>(<argument><expr>(<call><call><name>int</name> <argument_list>(<argument><expr>*</expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>) <name>form_header_field</name></expr></argument>,
                     <argument><expr>(<name>void</name> *) &amp;<name>h</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>,
                     <argument><expr>"Connection"</expr></argument>,
                     <argument><expr>"Keep-Alive"</expr></argument>,
                     <argument><expr>"ETag"</expr></argument>,
                     <argument><expr>"Content-Location"</expr></argument>,
                     <argument><expr>"Expires"</expr></argument>,
                     <argument><expr>"Cache-Control"</expr></argument>,
                     <argument><expr>"Vary"</expr></argument>,
                     <argument><expr>"Warning"</expr></argument>,
                     <argument><expr>"WWW-Authenticate"</expr></argument>,
                     <argument><expr>"Proxy-Authenticate"</expr></argument>,
                     <argument><expr>"Set-Cookie"</expr></argument>,
                     <argument><expr>"Set-Cookie2"</expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
        <expr_stmt><expr><call><name>send_all_header_fields</name><argument_list>(<argument><expr>&amp;<name>h</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

    <expr_stmt><expr><call><name>terminate_header</name><argument_list>(<argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>
    <expr_stmt><expr><name><name>ctx</name>-&gt;<name>headers_sent</name></name> = 1</expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>header_only</name></name> || <name><name>r</name>-&gt;<name>status</name></name> == <name>HTTP_NO_CONTENT</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>out</name>;</goto>
    }</block></then></if>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>sent_bodyct</name></name> = 1</expr>;</expr_stmt>         <comment type="block">/* Whatever follows is real body stuff... */</comment>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>chunked</name></name></expr>)</condition><then> <block>{
        <comment type="block">/* We can't add this filter until we have already sent the headers.
         * If we add it before this point, then the headers will be chunked
         * as well, and that is just wrong.
         */</comment>
        <expr_stmt><expr><call><name>ap_add_output_filter</name><argument_list>(<argument><expr>"CHUNK"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

    <comment type="block">/* Don't remove this filter until after we have added the CHUNK filter.
     * Otherwise, f-&gt;next won't be the CHUNK filter and thus the first
     * brigade won't be chunked properly.
     */</comment>
    <expr_stmt><expr><call><name>ap_remove_output_filter</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>rv</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>out</name>:</label>
    <if>if <condition>(<expr><name>recursive_error</name></expr>)</condition><then> <block>{
        <return>return <expr><name>AP_FILTER_ERROR</name></expr>;</return>
    }</block></then></if>
    <return>return <expr><name>rv</name></expr>;</return>
}</block>

<comment type="block">/*
 * Map specific APR codes returned by the filter stack to HTTP error
 * codes, or the default status code provided. Use it as follows:
 *
 * return ap_map_http_request_error(rv, HTTP_BAD_REQUEST);
 *
 * If the filter has already handled the error, AP_FILTER_ERROR will
 * be returned, which is cleanly passed through.
 *
 * These mappings imply that the filter stack is reading from the
 * downstream client, the proxy will map these codes differently.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_map_http_request_error</name><argument_list>(<argument>apr_status_t rv</argument>, <argument>int status</argument>)</argument_list></macro>
<block>{
    <switch>switch <condition>(<expr><name>rv</name></expr>)</condition> <block>{
    <case>case <expr><name>AP_FILTER_ERROR</name></expr>:
        <return>return <expr><name>AP_FILTER_ERROR</name></expr>;</return>

    </case><case>case <expr><name>APR_ENOSPC</name></expr>:
        <return>return <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>;</return>

    </case><case>case <expr><name>APR_ENOTIMPL</name></expr>:
        <return>return <expr><name>HTTP_NOT_IMPLEMENTED</name></expr>;</return>

    </case><case>case <expr><name>APR_TIMEUP</name></expr>:
    </case><case>case <expr><name>APR_ETIMEDOUT</name></expr>:
        <return>return <expr><name>HTTP_REQUEST_TIME_OUT</name></expr>;</return>

    </case><default>default:
        <return>return <expr><name>status</name></expr>;</return>
    </default>}</block></switch>
}</block>

<comment type="block">/* In HTTP/1.1, any method can have a body.  However, most GET handlers
 * wouldn't know what to do with a request body if they received one.
 * This helper routine tests for and reads any message body in the request,
 * simply discarding whatever it receives.  We need to do this because
 * failing to read the request body would cause it to be interpreted
 * as the next request on a persistent connection.
 *
 * Since we return an error status if the request is malformed, this
 * routine should be called at the beginning of a no-body handler, e.g.,
 *
 *    if ((retval = ap_discard_request_body(r)) != OK) {
 *        return retval;
 *    }
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_discard_request_body</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>seen_eos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

    <comment type="block">/* Sometimes we'll get in a state where the input handling has
     * detected an error where we want to drop the connection, so if
     * that's the case, don't read the data as that is what we're trying
     * to avoid.
     *
     * This function is also a no-op on a subrequest.
     */</comment>
    <if>if <condition>(<expr><name><name>r</name>-&gt;<name/></name>main || <name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> == <name>AP_CONN_CLOSE</name> ||
        <call><name>ap_status_drops_connection</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>status</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <return>return <expr><name>OK</name></expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>seen_eos</name> = 0</expr>;</expr_stmt>
    <do>do <block>{
        <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bucket</name></decl>;</decl_stmt>

        <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>input_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>AP_MODE_READBYTES</name></expr></argument>,
                            <argument><expr><name>APR_BLOCK_READ</name></expr></argument>, <argument><expr><name>HUGE_STRING_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><call><name>ap_map_http_request_error</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

        <for>for (<init><expr><name>bucket</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>bucket</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>bucket</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
            <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><name>seen_eos</name> = 1</expr>;</expr_stmt>
                <break>break;</break>
            }</block></then></if>

            <comment type="block">/* These are metadata buckets. */</comment>
            <if>if <condition>(<expr><name><name>bucket</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
                <continue>continue;</continue>
            }</block></then></if>

            <comment type="block">/* We MUST read because in case we have an unknown-length
             * bucket or one that morphs, we want to exhaust it.
             */</comment>
            <expr_stmt><expr><name>rv</name> = <call><name>apr_bucket_read</name><argument_list>(<argument><expr><name>bucket</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>APR_BLOCK_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
            }</block></then></if>
        }</block></for>
        <expr_stmt><expr><call><name>apr_brigade_cleanup</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block> while <condition>(<expr>!<name>seen_eos</name></expr>)</condition>;</do>

    <return>return <expr><name>OK</name></expr>;</return>
}</block>

<comment type="block">/* Here we deal with getting the request message body from the client.
 * Whether or not the request contains a body is signaled by the presence
 * of a non-zero Content-Length or by a Transfer-Encoding: chunked.
 *
 * Note that this is more complicated than it was in Apache 1.1 and prior
 * versions, because chunked support means that the module does less.
 *
 * The proper procedure is this:
 *
 * 1. Call ap_setup_client_block() near the beginning of the request
 *    handler. This will set up all the necessary properties, and will
 *    return either OK, or an error code. If the latter, the module should
 *    return that error code. The second parameter selects the policy to
 *    apply if the request message indicates a body, and how a chunked
 *    transfer-coding should be interpreted. Choose one of
 *
 *    REQUEST_NO_BODY          Send 413 error if message has any body
 *    REQUEST_CHUNKED_ERROR    Send 411 error if body without Content-Length
 *    REQUEST_CHUNKED_DECHUNK  If chunked, remove the chunks for me.
 *    REQUEST_CHUNKED_PASS     If chunked, pass the chunk headers with body.
 *
 *    In order to use the last two options, the caller MUST provide a buffer
 *    large enough to hold a chunk-size line, including any extensions.
 *
 * 2. When you are ready to read a body (if any), call ap_should_client_block().
 *    This will tell the module whether or not to read input. If it is 0,
 *    the module should assume that there is no message body to read.
 *
 * 3. Finally, call ap_get_client_block in a loop. Pass it a buffer and its size.
 *    It will put data into the buffer (not necessarily a full buffer), and
 *    return the length of the input block. When it is done reading, it will
 *    return 0 if EOF, or -1 if there was an error.
 *    If an error occurs on input, we force an end to keepalive.
 *
 *    This step also sends a 100 Continue response to HTTP/1.1 clients if appropriate.
 */</comment>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_setup_client_block</name><argument_list>(<argument>request_rec *r</argument>, <argument>int read_policy</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tenc</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Transfer-Encoding"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lenp</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"Content-Length"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>r</name>-&gt;<name>read_body</name></name> = <name>read_policy</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>read_chunked</name></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>remaining</name></name> = 0</expr>;</expr_stmt>

    <if>if <condition>(<expr><name>tenc</name></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>tenc</name></expr></argument>, <argument><expr>"chunked"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01592</expr></argument>)</argument_list></call>
                          "Unknown Transfer-Encoding %s"</expr></argument>, <argument><expr><name>tenc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_NOT_IMPLEMENTED</name></expr>;</return>
        }</block></then></if>
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>read_body</name></name> == <name>REQUEST_CHUNKED_ERROR</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01593</expr></argument>)</argument_list></call>
                          "chunked Transfer-Encoding forbidden: %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr>(<name>lenp</name>) ? <name>HTTP_BAD_REQUEST</name> : <name>HTTP_LENGTH_REQUIRED</name></expr>;</return>
        }</block></then></if>

        <expr_stmt><expr><name><name>r</name>-&gt;<name>read_chunked</name></name> = 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>lenp</name></expr>)</condition><then> <block>{
        <decl_stmt><decl><type><name>char</name> *</type><name>endstr</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><call><name>apr_strtoff</name><argument_list>(<argument><expr>&amp;<name><name>r</name>-&gt;<name>remaining</name></name></expr></argument>, <argument><expr><name>lenp</name></expr></argument>, <argument><expr>&amp;<name>endstr</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>
            || *<name>endstr</name> || <name><name>r</name>-&gt;<name>remaining</name></name> &lt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>remaining</name></name> = 0</expr>;</expr_stmt>
            <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01594</expr></argument>)</argument_list></call>
                          "Invalid Content-Length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>HTTP_BAD_REQUEST</name></expr>;</return>
        }</block></then></if>
    }</block></then></if></else></if>

    <if>if <condition>(<expr>(<name><name>r</name>-&gt;<name>read_body</name></name> == <name>REQUEST_NO_BODY</name>)
        &amp;&amp; (<name><name>r</name>-&gt;<name>read_chunked</name></name> || (<name><name>r</name>-&gt;<name>remaining</name></name> &gt; 0))</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_INFO</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><call><name>APLOGNO</name><argument_list>(<argument><expr>01595</expr></argument>)</argument_list></call>
                      "%s with body is not allowed for %s"</expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>method</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>HTTP_REQUEST_ENTITY_TOO_LARGE</name></expr>;</return>
    }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_DEBUG</name></cpp:ifdef>
    <block>{
        <comment type="block">/* Make sure ap_getline() didn't leave any droppings. */</comment>
        <decl_stmt><decl><type><name>core_request_config</name> *</type><name>req_cfg</name> <init>=
            <expr>(<name>core_request_config</name> *)<call><name>ap_get_core_module_config</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>request_config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr><call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name><name>req_cfg</name>-&gt;<name>bb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <return>return <expr><name>OK</name></expr>;</return>
}</block>

<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_should_client_block</name><argument_list>(<argument>request_rec *r</argument>)</argument_list></macro>
<block>{
    <comment type="block">/* First check if we have already read the request body */</comment>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>read_length</name></name> || (!<name><name>r</name>-&gt;<name>read_chunked</name></name> &amp;&amp; (<name><name>r</name>-&gt;<name>remaining</name></name> &lt;= 0))</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <return>return <expr>1</expr>;</return>
}</block>

<comment type="block">/* get_client_block is called in a loop to get the request message body.
 * This is quite simple if the client includes a content-length
 * (the normal case), but gets messy if the body is chunked. Note that
 * r-&gt;remaining is used to maintain state across calls and that
 * r-&gt;read_length is the total number of bytes given to the caller
 * across all invocations.  It is messy because we have to be careful not
 * to read past the data provided by the client, since these reads block.
 * Returns 0 on End-of-body, -1 on error or premature chunk end.
 *
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>long</argument>)</argument_list></macro> <macro><name>ap_get_client_block</name><argument_list>(<argument>request_rec *r</argument>, <argument>char *buffer</argument>,
                                     <argument>apr_size_t bufsiz</argument>)</argument_list></macro>
<block>{
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>

    <if>if <condition>(<expr><name><name>r</name>-&gt;<name>remaining</name></name> &lt; 0 || (!<name><name>r</name>-&gt;<name>read_chunked</name></name> &amp;&amp; <name><name>r</name>-&gt;<name>remaining</name></name> == 0)</expr>)</condition><then> <block>{
        <return>return <expr>0</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>bb</name> == <name>NULL</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>ap_get_brigade</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>input_filters</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>AP_MODE_READBYTES</name></expr></argument>,
                        <argument><expr><name>APR_BLOCK_READ</name></expr></argument>, <argument><expr><name>bufsiz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* We lose the failure code here.  This is why ap_get_client_block should
     * not be used.
     */</comment>
    <if>if <condition>(<expr><name>rv</name> == <name>AP_FILTER_ERROR</name></expr>)</condition><then> <block>{
        <comment type="block">/* AP_FILTER_ERROR means a filter has responded already,
         * we are DONE.
         */</comment>
        <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <comment type="block">/* if we actually fail here, we want to just return and
         * stop trying to read data from the client.
         */</comment>
        <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* If this fails, it means that a filter is written incorrectly and that
     * it needs to learn how to properly handle APR_BLOCK_READ requests by
     * returning data when requested.
     */</comment>
    <expr_stmt><expr><call><name>AP_DEBUG_ASSERT</name><argument_list>(<argument><expr>!<call><name>APR_BRIGADE_EMPTY</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Check to see if EOS in the brigade.
     *
     * If so, we have to leave a nugget for the *next* ap_get_client_block
     * call to return 0.
     */</comment>
    <if>if <condition>(<expr><call><name>APR_BUCKET_IS_EOS</name><argument_list>(<argument><expr><call><name>APR_BRIGADE_LAST</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if <condition>(<expr><name><name>r</name>-&gt;<name>read_chunked</name></name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>remaining</name></name> = -1</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
            <expr_stmt><expr><name><name>r</name>-&gt;<name>remaining</name></name> = 0</expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

    <expr_stmt><expr><name>rv</name> = <call><name>apr_brigade_flatten</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>bufsiz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>rv</name> != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr>-1</expr>;</return>
    }</block></then></if>

    <comment type="block">/* XXX yank me? */</comment>
    <expr_stmt><expr><name><name>r</name>-&gt;<name>read_length</name></name> += <name>bufsiz</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>apr_brigade_destroy</name><argument_list>(<argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>bufsiz</name></expr>;</return>
}</block>

<comment type="block">/* Context struct for ap_http_outerror_filter */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>seen_eoc</name></decl>;</decl_stmt>
}</block></struct></type> <name>outerror_filter_ctx_t</name>;</typedef>

<comment type="block">/* Filter to handle any error buckets on output */</comment>
<function><type><name>apr_status_t</name></type> <name>ap_http_outerror_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                     <param><decl><type><name>apr_bucket_brigade</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name><name>f</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>outerror_filter_ctx_t</name> *</type><name>ctx</name> <init>= <expr><call>(<name>outerror_filter_ctx_t</name> *)<argument_list>(<argument><expr><name><name>f</name>-&gt;<name>ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>e</name></decl>;</decl_stmt>

    <comment type="block">/* Create context if none is present */</comment>
    <if>if <condition>(<expr>!<name>ctx</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>ctx</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>outerror_filter_ctx_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>f</name>-&gt;<name>ctx</name></name> = <name>ctx</name></expr>;</expr_stmt>
    }</block></then></if>
    <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
        <if>if <condition>(<expr><call><name>AP_BUCKET_IS_ERROR</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <comment type="block">/*
             * Start of error handling state tree. Just one condition
             * right now :)
             */</comment>
            <if>if <condition>(<expr>(<call>(<name>ap_bucket_error</name> *)<argument_list>(<argument><expr><name><name>e</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call>)-&gt;<name>status</name> == <name>HTTP_BAD_GATEWAY</name></expr>)</condition><then> <block>{
                <comment type="block">/* stream aborted and we have not ended it yet */</comment>
                <expr_stmt><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>keepalive</name></name> = <name>AP_CONN_CLOSE</name></expr>;</expr_stmt>
            }</block></then></if>
            <continue>continue;</continue>
        }</block></then></if>
        <comment type="block">/* Detect EOC buckets and memorize this in the context. */</comment>
        <if>if <condition>(<expr><call><name>AP_BUCKET_IS_EOC</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>ctx</name>-&gt;<name>seen_eoc</name></name> = 1</expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
    <comment type="block">/*
     * Remove all data buckets that are in a brigade after an EOC bucket
     * was seen, as an EOC bucket tells us that no (further) resource
     * and protocol data should go out to the client. OTOH meta buckets
     * are still welcome as they might trigger needed actions down in
     * the chain (e.g. in network filters like SSL).
     * Remark 1: It is needed to dump ALL data buckets in the brigade
     *           since an filter in between might have inserted data
     *           buckets BEFORE the EOC bucket sent by the original
     *           sender and we do NOT want this data to be sent.
     * Remark 2: Dumping all data buckets here does not necessarily mean
     *           that no further data is send to the client as:
     *           1. Network filters like SSL can still be triggered via
     *              meta buckets to talk with the client e.g. for a
     *              clean shutdown.
     *           2. There could be still data that was buffered before
     *              down in the chain that gets flushed by a FLUSH or an
     *              EOS bucket.
     */</comment>
    <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>seen_eoc</name></name></expr>)</condition><then> <block>{
        <for>for (<init><expr><name>e</name> = <call><name>APR_BRIGADE_FIRST</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</init>
             <condition><expr><name>e</name> != <call><name>APR_BRIGADE_SENTINEL</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</condition>
             <incr><expr><name>e</name> = <call><name>APR_BUCKET_NEXT</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
            <if>if <condition>(<expr>!<call><name>APR_BUCKET_IS_METADATA</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>APR_BUCKET_REMOVE</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

    <return>return <expr><call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>next</name></name></expr></argument>,  <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
