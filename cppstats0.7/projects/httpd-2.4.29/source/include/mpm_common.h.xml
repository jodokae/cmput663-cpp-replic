<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/mpm_common.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/* The purpose of this file is to store the code that MOST mpm's will need
 * this does not mean a function only goes into this file if every MPM needs
 * it.  It means that if a function is needed by more than one MPM, and
 * future maintenance would be served by making the code common, then the
 * function belongs here.
 *
 * This is going in src/main because it is not platform specific, it is
 * specific to multi-process servers, but NOT to Unix.  Which is why it
 * does not belong in src/os/unix
 */</comment>

<comment type="block">/**
 * @file  mpm_common.h
 * @brief Multi-Processing Modules functions
 *
 * @defgroup APACHE_MPM Multi-Processing Modules
 * @ingroup  APACHE
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APACHE_MPM_COMMON_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APACHE_MPM_COMMON_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_mpm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"scoreboard.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAVE_NETINET_TCP_H</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/tcp.h&gt;</cpp:file></cpp:include>    <comment type="block">/* for TCP_NODELAY */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_proc_mutex.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The maximum length of the queue of pending connections, as defined
 * by listen(2).  Under some systems, it should be increased if you
 * are experiencing a heavy TCP SYN flood attack.
 *
 * It defaults to 511 instead of 512 because some systems store it
 * as an 8-bit datatype; 512 truncated to 8-bits is 0, while 511 is
 * 255 when truncated.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DEFAULT_LISTENBACKLOG</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_LISTENBACKLOG</name></cpp:macro> <cpp:value>511</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Signal used to gracefully restart */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SIG_GRACEFUL</name></cpp:macro> <cpp:value>SIGUSR1</cpp:value></cpp:define>

<comment type="block">/* Signal used to gracefully restart (without SIG prefix) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SIG_GRACEFUL_SHORT</name></cpp:macro> <cpp:value>USR1</cpp:value></cpp:define>

<comment type="block">/* Signal used to gracefully restart (as a quoted string) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SIG_GRACEFUL_STRING</name></cpp:macro> <cpp:value>"SIGUSR1"</cpp:value></cpp:define>

<comment type="block">/* Signal used to gracefully stop */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SIG_GRACEFUL_STOP</name></cpp:macro> <cpp:value>SIGWINCH</cpp:value></cpp:define>

<comment type="block">/* Signal used to gracefully stop (without SIG prefix) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SIG_GRACEFUL_STOP_SHORT</name></cpp:macro> <cpp:value>WINCH</cpp:value></cpp:define>

<comment type="block">/* Signal used to gracefully stop (as a quoted string) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_SIG_GRACEFUL_STOP_STRING</name></cpp:macro> <cpp:value>"SIGWINCH"</cpp:value></cpp:define>

<comment type="block">/**
 * Callback function used for ap_reclaim_child_processes() and
 * ap_relieve_child_processes().  The callback function will be
 * called for each terminated child process.
 */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> <name>ap_reclaim_callback_fn_t</name><parameter_list>(<param><decl><type><name>int</name></type> <name>childnum</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>,
                                      <param><decl><type><name>ap_generation_t</name></type> <name>gen</name></decl></param>)</parameter_list>;</function_decl></typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NETWARE</name></expr></argument>)</argument_list></call>) || <call><name>defined</name><argument_list>(<argument><expr><name>DOXYGEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/**
 * Make sure all child processes that have been spawned by the parent process
 * have died.  This includes process registered as "other_children".
 *
 * @param terminate Either 1 or 0.  If 1, send the child processes SIGTERM
 *        each time through the loop.  If 0, give the process time to die
 *        on its own before signalling it.
 * @param mpm_callback Callback invoked for each dead child process
 *
 * @note The MPM child processes which are reclaimed are those listed
 * in the scoreboard as well as those currently registered via
 * ap_register_extra_mpm_process().
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_reclaim_child_processes</name><argument_list>(<argument>int terminate</argument>,
                                            <argument>ap_reclaim_callback_fn_t *mpm_callback</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Catch any child processes that have been spawned by the parent process
 * which have exited. This includes processes registered as "other_children".
 *
 * @param mpm_callback Callback invoked for each dead child process

 * @note The MPM child processes which are relieved are those listed
 * in the scoreboard as well as those currently registered via
 * ap_register_extra_mpm_process().
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_relieve_child_processes</name><argument_list>(<argument><expr><name>ap_reclaim_callback_fn_t</name> *<name>mpm_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Tell ap_reclaim_child_processes() and ap_relieve_child_processes() about
 * an MPM child process which has no entry in the scoreboard.
 * @param pid The process id of an MPM child process which should be
 * reclaimed when ap_reclaim_child_processes() is called.
 * @param gen The generation of this MPM child process.
 *
 * @note If an extra MPM child process terminates prior to calling
 * ap_reclaim_child_processes(), remove it from the list of such processes
 * by calling ap_unregister_extra_mpm_process().
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_register_extra_mpm_process</name><argument_list>(<argument>pid_t pid</argument>, <argument>ap_generation_t gen</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Unregister an MPM child process which was previously registered by a
 * call to ap_register_extra_mpm_process().
 * @param pid The process id of an MPM child process which no longer needs to
 * be reclaimed.
 * @param old_gen Set to the server generation of the process, if found.
 * @return 1 if the process was found and removed, 0 otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_unregister_extra_mpm_process</name><argument_list>(<argument>pid_t pid</argument>, <argument>ap_generation_t *old_gen</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Safely signal an MPM child process, if the process is in the
 * current process group.  Otherwise fail.
 * @param pid the process id of a child process to signal
 * @param sig the signal number to send
 * @return APR_SUCCESS if signal is sent, otherwise an error as per kill(3);
 * APR_EINVAL is returned if passed either an invalid (&lt; 1) pid, or if
 * the pid is not in the current process group
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_safe_kill</name><argument_list>(<argument>pid_t pid</argument>, <argument>int sig</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Log why a child died to the error log, if the child died without the
 * parent signalling it.
 * @param pid The child that has died
 * @param why The return code of the child process
 * @param status The status returned from ap_wait_or_timeout
 * @return 0 on success, APEXIT_CHILDFATAL if MPM should terminate
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_process_child_status</name><argument_list>(<argument>apr_proc_t *pid</argument>, <argument>apr_exit_why_e why</argument>, <argument>int status</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_fatal_signal_setup</name><argument_list>(<argument><expr><name>server_rec</name> *<name>s</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>in_pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_fatal_signal_child_setup</name><argument_list>(<argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* (!WIN32 &amp;&amp; !NETWARE) || DOXYGEN */</comment>

<comment type="block">/**
 * Pool cleanup for end-generation hook implementation
 * (core httpd function)
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>ap_mpm_end_gen_helper</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Run the monitor hook (once every ten calls), determine if any child
 * process has died and, if none died, sleep one second.
 * @param status The return code if a process has died
 * @param exitcode The returned exit status of the child, if a child process
 *                 dies, or the signal that caused the child to die.
 * @param ret The process id of the process that died
 * @param p The pool to allocate out of
 * @param s The server_rec to pass
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_wait_or_timeout</name><argument_list>(<argument><expr><name>apr_exit_why_e</name> *<name>status</name></expr></argument>, <argument><expr><name>int</name> *<name>exitcode</name></expr></argument>,
                                    <argument><expr><name>apr_proc_t</name> *<name>ret</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, 
                                    <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCP_NODELAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<comment type="block">/**
 * Turn off the nagle algorithm for the specified socket.  The nagle algorithm
 * says that we should delay sending partial packets in the hopes of getting
 * more data.  There are bad interactions between persistent connections and
 * Nagle's algorithm that have severe performance penalties.
 * @param s The socket to disable nagle for.
 */</comment>
<function_decl><type><name>void</name></type> <name>ap_sock_disable_nagle</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_sock_disable_nagle</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro></cpp:define>        <comment type="block">/* NOOP */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETPWNAM</name></cpp:ifdef>
<comment type="block">/**
 * Convert a username to a numeric ID
 * @param name The name to convert
 * @return The user id corresponding to a name
 * @fn uid_t ap_uname2id(const char *name)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>uid_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_uname2id</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETGRNAM</name></cpp:ifdef>
<comment type="block">/**
 * Convert a group name to a numeric ID
 * @param name The name to convert
 * @return The group id corresponding to a name
 * @fn gid_t ap_gname2id(const char *name)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>gid_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_gname2id</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_INITGROUPS</name></cpp:ifndef>
<comment type="block">/**
 * The initgroups() function initializes the group access list by reading the
 * group database /etc/group and using all groups of which user is a member.
 * The additional group basegid is also added to the list.
 * @param name The user name - must be non-NULL
 * @param basegid The basegid to add
 * @return returns 0 on success
 * @fn int initgroups(const char *name, gid_t basegid)
 */</comment>
<function_decl><type><name>int</name></type> <name>initgroups</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>gid_t</name></type> <name>basegid</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(!<call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NETWARE</name></expr></argument>)</argument_list></call>) || <call><name>defined</name><argument_list>(<argument><expr><name>DOXYGEN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type>struct <name>ap_pod_t</name></type> <name>ap_pod_t</name>;</typedef>

<struct>struct <name>ap_pod_t</name> <block>{
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>pod_in</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>pod_out</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * Open the pipe-of-death.  The pipe of death is used to tell all child
 * processes that it is time to die gracefully.
 * @param p The pool to use for allocating the pipe
 * @param pod the pipe-of-death that is created.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_mpm_pod_open</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>ap_pod_t</name> **<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Check the pipe to determine if the process has been signalled to die.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_mpm_pod_check</name><argument_list>(<argument><expr><name>ap_pod_t</name> *<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Close the pipe-of-death
 *
 * @param pod the pipe-of-death to close.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_mpm_pod_close</name><argument_list>(<argument><expr><name>ap_pod_t</name> *<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Write data to the pipe-of-death, signalling that one child process
 * should die.
 * @param pod the pipe-of-death to write to.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_mpm_pod_signal</name><argument_list>(<argument><expr><name>ap_pod_t</name> *<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Write data to the pipe-of-death, signalling that all child process
 * should die.
 * @param pod The pipe-of-death to write to.
 * @param num The number of child processes to kill
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_mpm_pod_killpg</name><argument_list>(<argument>ap_pod_t *pod</argument>, <argument>int num</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPM_PODX_RESTART_CHAR</name></cpp:macro> <cpp:value>'$'</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MPM_PODX_GRACEFUL_CHAR</name></cpp:macro> <cpp:value>'!'</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum <block>{ <decl><name>AP_MPM_PODX_NORESTART</name></decl>, <decl><name>AP_MPM_PODX_RESTART</name></decl>, <decl><name>AP_MPM_PODX_GRACEFUL</name></decl> }</block></enum></type> <name>ap_podx_restart_t</name>;</typedef>

<comment type="block">/**
 * Open the extended pipe-of-death.
 * @param p The pool to use for allocating the pipe
 * @param pod The pipe-of-death that is created.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_mpm_podx_open</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>ap_pod_t</name> **<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Check the extended pipe to determine if the process has been signalled to die.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_mpm_podx_check</name><argument_list>(<argument><expr><name>ap_pod_t</name> *<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Close the pipe-of-death
 *
 * @param pod The pipe-of-death to close.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_mpm_podx_close</name><argument_list>(<argument><expr><name>ap_pod_t</name> *<name>pod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Write data to the extended pipe-of-death, signalling that one child process
 * should die.
 * @param pod the pipe-of-death to write to.
 * @param graceful restart-type
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_mpm_podx_signal</name><argument_list>(<argument>ap_pod_t *pod</argument>,
                                            <argument>ap_podx_restart_t graceful</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Write data to the extended pipe-of-death, signalling that all child process
 * should die.
 * @param pod The pipe-of-death to write to.
 * @param num The number of child processes to kill
 * @param graceful restart-type
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_mpm_podx_killpg</name><argument_list>(<argument>ap_pod_t *pod</argument>, <argument>int num</argument>,
                                    <argument>ap_podx_restart_t graceful</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* (!WIN32 &amp;&amp; !NETWARE) || DOXYGEN */</comment>

<comment type="block">/**
 * Check that exactly one MPM is loaded
 * Returns NULL if yes, error string if not.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_check_mpm</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * These data members are common to all mpms. Each new mpm
 * should either use the appropriate ap_mpm_set_* function
 * in their command table or create their own for custom or
 * OS specific needs. These should work for most.
 */</comment>

<comment type="block">/**
 * The maximum number of requests each child thread or
 * process handles before dying off
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>int</name></type> <name>ap_max_requests_per_child</name></decl>;</decl_stmt>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>ap_mpm_set_max_requests</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * The filename used to store the process id.
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_pid_fname</name></decl>;</decl_stmt>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>ap_mpm_set_pidfile</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_mpm_dump_pidfile</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>out</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
 * The directory that the server changes directory to dump core.
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>char</name></type> <name><name>ap_coredump_dir</name><index>[<expr><name>MAX_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>int</name></type> <name>ap_coredumpdir_configured</name></decl>;</decl_stmt>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>ap_mpm_set_coredumpdir</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Set the timeout period for a graceful shutdown.
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>int</name></type> <name>ap_graceful_shutdown_timeout</name></decl>;</decl_stmt>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro><expr_stmt><expr><call><name>ap_mpm_set_graceful_shutdown</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>, <argument><expr><name>void</name> *<name>dummy</name></expr></argument>,
                                         <argument><expr>const <name>char</name> *<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_GRACEFUL_SHUTDOWN_TIMEOUT_COMMAND</name></cpp:macro> \
<cpp:value>AP_INIT_TAKE1("GracefulShutdownTimeout", ap_mpm_set_graceful_shutdown, NULL, \
              RSRC_CONF, "Maximum time in seconds to wait for child "        \
              "processes to complete transactions during shutdown")</cpp:value></cpp:define>


<function_decl><type><name>int</name></type> <name>ap_signal_server</name><parameter_list>(<param><decl><type><name>int</name> *</type></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>ap_mpm_rewrite_args</name><parameter_list>(<param><decl><type><name>process_rec</name> *</type></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>apr_uint32_t</name></type> <name>ap_max_mem_free</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_mpm_set_max_mem_free</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>apr_size_t</name></type> <name>ap_thread_stacksize</name></decl>;</decl_stmt>
<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_mpm_set_thread_stacksize</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* core's implementation of child_status hook */</comment>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>ap_core_child_status</name><parameter_list>(<param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>, <param><decl><type><name>pid_t</name></type> <name>pid</name></decl></param>, <param><decl><type><name>ap_generation_t</name></type> <name>gen</name></decl></param>,
                                 <param><decl><type><name>int</name></type> <name>slot</name></decl></param>, <param><decl><type><name>mpm_child_status</name></type> <name>status</name></decl></param>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>AP_ENABLE_EXCEPTION_HOOK</name></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>char</name> *</type><name>ap_mpm_set_exception_hook</name><parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>cmd</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dummy</name></decl></param>,
                                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>arg</name></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>monitor</argument>,<argument>(apr_pool_t *p, server_rec *s)</argument>)</argument_list></macro>

<comment type="block">/* register modules that undertake to manage system security */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_sys_privileges_handlers</name><argument_list>(<argument>int inc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>, <argument>drop_privileges</argument>, <argument>(apr_pool_t * pchild, server_rec * s)</argument>)</argument_list></macro>

<comment type="block">/* implement the ap_mpm_query() function
 * The MPM should return OK+APR_ENOTIMPL for any unimplemented query codes;
 * modules which intercede for specific query codes should DECLINE for others.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>, <argument>mpm_query</argument>, <argument>(int query_code, int *result, apr_status_t *rv)</argument>)</argument_list></macro>

<comment type="block">/* register the specified callback */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>apr_status_t</argument>, <argument>mpm_register_timed_callback</argument>,
                <argument>(apr_time_t t, ap_mpm_callback_fn_t *cbfn, void *baton)</argument>)</argument_list></macro>

<comment type="block">/* get MPM name (e.g., "prefork" or "event") */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>const char *</argument>,<argument>mpm_get_name</argument>,<argument>(void)</argument>)</argument_list></macro>

<comment type="block">/**
 * Notification that connection handling is suspending (disassociating from the
 * current thread)
 * @param c The current connection
 * @param r The current request, or NULL if there is no active request
 * @ingroup hooks
 * @see ap_hook_resume_connection
 * @note This hook is not implemented by MPMs like Prefork and Worker which 
 * handle all processing of a particular connection on the same thread.
 * @note This hook will be called on the thread that was previously
 * processing the connection.
 * @note This hook is not called at the end of connection processing.  This
 * hook only notifies a module when processing of an active connection is
 * suspended.
 * @note Resumption and subsequent suspension of a connection solely to perform
 * I/O by the MPM, with no execution of non-MPM code, may not necessarily result
 * in a call to this hook.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>, <argument>suspend_connection</argument>,
                <argument>(conn_rec *c, request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/**
 * Notification that connection handling is resuming (associating with a thread)
 * @param c The current connection
 * @param r The current request, or NULL if there is no active request
 * @ingroup hooks
 * @see ap_hook_suspend_connection
 * @note This hook is not implemented by MPMs like Prefork and Worker which 
 * handle all processing of a particular connection on the same thread.
 * @note This hook will be called on the thread that will resume processing
 * the connection.
 * @note This hook is not called at the beginning of connection processing.
 * This hook only notifies a module when processing resumes for a
 * previously-suspended connection.
 * @note Resumption and subsequent suspension of a connection solely to perform
 * I/O by the MPM, with no execution of non-MPM code, may not necessarily result
 * in a call to this hook.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>, <argument>resume_connection</argument>,
                <argument>(conn_rec *c, request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/* mutex type string for accept mutex, if any; MPMs should use the
 * same mutex type for ease of configuration
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_ACCEPT_MUTEX_TYPE</name></cpp:macro> <cpp:value>"mpm-accept"</cpp:value></cpp:define>

<comment type="block">/* internal pre-config logic for MPM-related settings, callable only from
 * core's pre-config hook
 */</comment>
<function_decl><type><name>void</name></type> <name>mpm_common_pre_config</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pconf</name></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !APACHE_MPM_COMMON_H */</comment>
<comment type="block">/** @} */</comment>
</unit>
