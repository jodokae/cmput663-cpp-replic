<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/httpd-2.4.29/include/http_config.h"><comment type="block">/* Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */</comment>

<comment type="block">/**
 * @file http_config.h
 * @brief Apache Configuration
 *
 * @defgroup APACHE_CORE_CONFIG Configuration
 * @ingroup  APACHE_CORE
 * @{
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APACHE_HTTP_CONFIG_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APACHE_HTTP_CONFIG_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"util_cfgtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ap_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"apr_tables.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * The central data structures around here...
 */</comment>

<comment type="block">/* Command dispatch structures... */</comment>

<comment type="block">/**
 * How the directives arguments should be parsed.
 * @remark Note that for all of these except RAW_ARGS, the config routine is
 *      passed a freshly allocated string which can be modified or stored
 *      or whatever...
 */</comment>
<enum>enum <name>cmd_how</name> <block>{
    <decl><name>RAW_ARGS</name></decl>,           <comment type="block">/**&lt; cmd_func parses command line itself */</comment>
    <decl><name>TAKE1</name></decl>,              <comment type="block">/**&lt; one argument only */</comment>
    <decl><name>TAKE2</name></decl>,              <comment type="block">/**&lt; two arguments only */</comment>
    <decl><name>ITERATE</name></decl>,            <comment type="block">/**&lt; one argument, occurring multiple times
                         * (e.g., IndexIgnore)
                         */</comment>
    <decl><name>ITERATE2</name></decl>,           <comment type="block">/**&lt; two arguments, 2nd occurs multiple times
                         * (e.g., AddIcon)
                         */</comment>
    <decl><name>FLAG</name></decl>,               <comment type="block">/**&lt; One of 'On' or 'Off' */</comment>
    <decl><name>NO_ARGS</name></decl>,            <comment type="block">/**&lt; No args at all, e.g. &amp;lt;/Directory&amp;gt; */</comment>
    <decl><name>TAKE12</name></decl>,             <comment type="block">/**&lt; one or two arguments */</comment>
    <decl><name>TAKE3</name></decl>,              <comment type="block">/**&lt; three arguments only */</comment>
    <decl><name>TAKE23</name></decl>,             <comment type="block">/**&lt; two or three arguments */</comment>
    <decl><name>TAKE123</name></decl>,            <comment type="block">/**&lt; one, two or three arguments */</comment>
    <decl><name>TAKE13</name></decl>,             <comment type="block">/**&lt; one or three arguments */</comment>
    <decl><name>TAKE_ARGV</name></decl>           <comment type="block">/**&lt; an argc and argv are passed */</comment>
}</block>;</enum>

<comment type="block">/**
 * This structure is passed to a command which is being invoked,
 * to carry a large variety of miscellaneous data which is all of
 * use to *somebody*...
 */</comment>
<typedef>typedef <type>struct <name>cmd_parms_struct</name></type> <name>cmd_parms</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AP_HAVE_DESIGNATED_INITIALIZER</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>DOXYGEN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/**
 * All the types of functions that can be used in directives
 * @internal
 */</comment>
<typedef>typedef <type><union>union <block>{
    <comment type="block">/** function to call for a no-args */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>no_args</name>) <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>parms</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** function to call for a raw-args */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>raw_args</name>) <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>parms</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>args</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** function to call for a argv/argc */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>take_argv</name>) <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>parms</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>,
                             <param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> *<specifier>const</specifier></type> <name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** function to call for a take1 */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>take1</name>) <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>parms</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>w</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** function to call for a take2 */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>take2</name>) <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>parms</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>w</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>w2</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** function to call for a take3 */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>take3</name>) <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>parms</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>w</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>w2</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>w3</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** function to call for a flag */</comment>
    <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>flag</name>) <parameter_list>(<param><decl><type><name>cmd_parms</name> *</type><name>parms</name></decl></param>, <param><decl><type><name>void</name> *</type><name>mconfig</name></decl></param>, <param><decl><type><name>int</name></type> <name>on</name></decl></param>)</parameter_list>;</function_decl>
}</block></union></type> <name>cmd_func</name>;</typedef>

<comment type="block">/** This configuration directive does not take any arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NO_ARGS</name></cpp:macro>     <cpp:value>func.no_args</cpp:value></cpp:define>
<comment type="block">/** This configuration directive will handle its own parsing of arguments*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_RAW_ARGS</name></cpp:macro>    <cpp:value>func.raw_args</cpp:value></cpp:define>
<comment type="block">/** This configuration directive will handle its own parsing of arguments*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TAKE_ARGV</name></cpp:macro>   <cpp:value>func.take_argv</cpp:value></cpp:define>
<comment type="block">/** This configuration directive takes 1 argument*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TAKE1</name></cpp:macro>       <cpp:value>func.take1</cpp:value></cpp:define>
<comment type="block">/** This configuration directive takes 2 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TAKE2</name></cpp:macro>       <cpp:value>func.take2</cpp:value></cpp:define>
<comment type="block">/** This configuration directive takes 3 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TAKE3</name></cpp:macro>       <cpp:value>func.take3</cpp:value></cpp:define>
<comment type="block">/** This configuration directive takes a flag (on/off) as a argument*/</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FLAG</name></cpp:macro>        <cpp:value>func.flag</cpp:value></cpp:define>

<comment type="block">/** mechanism for declaring a directive with no arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_NO_ARGS</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .no_args=func }, mconfig, where, RAW_ARGS, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive with raw argument parsing */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_RAW_ARGS</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .raw_args=func }, mconfig, where, RAW_ARGS, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive with raw argument parsing */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE_ARGV</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take_argv=func }, mconfig, where, TAKE_ARGV, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes 1 argument */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE1</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take1=func }, mconfig, where, TAKE1, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes multiple arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_ITERATE</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take1=func }, mconfig, where, ITERATE, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes 2 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE2</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take2=func }, mconfig, where, TAKE2, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes 1 or 2 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE12</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take2=func }, mconfig, where, TAKE12, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes multiple 2 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_ITERATE2</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take2=func }, mconfig, where, ITERATE2, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes 1 or 3 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE13</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take3=func }, mconfig, where, TAKE13, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes 2 or 3 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE23</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take3=func }, mconfig, where, TAKE23, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes 1 to 3 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE123</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take3=func }, mconfig, where, TAKE123, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes 3 arguments */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE3</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .take3=func }, mconfig, where, TAKE3, help }</cpp:value></cpp:define>
<comment type="block">/** mechanism for declaring a directive which takes a flag (on/off) argument */</comment>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_FLAG</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, { .flag=func }, mconfig, where, FLAG, help }</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* AP_HAVE_DESIGNATED_INITIALIZER */</comment>

<typedef>typedef <function_decl><type><specifier>const</specifier> <name>char</name> *</type>(*<name>cmd_func</name>) <parameter_list>()</parameter_list>;</function_decl></typedef>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_NO_ARGS</name></cpp:macro>  <cpp:value>func</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_RAW_ARGS</name></cpp:macro> <cpp:value>func</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TAKE_ARGV</name></cpp:macro> <cpp:value>func</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TAKE1</name></cpp:macro>    <cpp:value>func</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TAKE2</name></cpp:macro>    <cpp:value>func</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_TAKE3</name></cpp:macro>    <cpp:value>func</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_FLAG</name></cpp:macro>     <cpp:value>func</cpp:value></cpp:define>

<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_NO_ARGS</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, RAW_ARGS, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_RAW_ARGS</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, RAW_ARGS, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE_ARGV</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, TAKE_ARGV, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE1</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, TAKE1, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_ITERATE</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, ITERATE, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE2</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, TAKE2, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE12</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, TAKE12, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_ITERATE2</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, ITERATE2, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE13</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, TAKE13, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE23</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, TAKE23, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE123</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, TAKE123, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_TAKE3</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, TAKE3, help }</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_INIT_FLAG</name><parameter_list>(<param><type><name>directive</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>mconfig</name></type></param>, <param><type><name>where</name></type></param>, <param><type><name>help</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>{ directive, func, mconfig, where, FLAG, help }</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_HAVE_DESIGNATED_INITIALIZER */</comment>

<comment type="block">/**
 * The command record structure.  Modules can define a table of these
 * to define the directives it will implement.
 */</comment>
<typedef>typedef <type>struct <name>command_struct</name></type> <name>command_rec</name>;</typedef>
<struct>struct <name>command_struct</name> <block>{
    <comment type="block">/** Name of this command */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <comment type="block">/** The function to be called when this directive is parsed */</comment>
    <decl_stmt><decl><type><name>cmd_func</name></type> <name>func</name></decl>;</decl_stmt>
    <comment type="block">/** Extra data, for functions which implement multiple commands... */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>cmd_data</name></decl>;</decl_stmt>
    <comment type="block">/** What overrides need to be allowed to enable this command. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>req_override</name></decl>;</decl_stmt>
    <comment type="block">/** What the command expects as arguments */</comment>
    <enum>enum <name>cmd_how</name> <name>args_how</name>;</enum>

    <comment type="block">/** 'usage' message, in case of syntax errors */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * @defgroup ConfigDirectives Allowed locations for configuration directives.
 *
 * The allowed locations for a configuration directive are the union of
 * those indicated by each set bit in the req_override mask.
 *
 * @{
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OR_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>             <comment type="block">/**&lt; *.conf is not available anywhere in this override */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OR_LIMIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>           <comment type="block">/**&lt; *.conf inside &amp;lt;Directory&amp;gt; or &amp;lt;Location&amp;gt;
                                and .htaccess when AllowOverride Limit */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OR_OPTIONS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>         <comment type="block">/**&lt; *.conf anywhere
                                and .htaccess when AllowOverride Options */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OR_FILEINFO</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>        <comment type="block">/**&lt; *.conf anywhere
                                and .htaccess when AllowOverride FileInfo */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OR_AUTHCFG</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>         <comment type="block">/**&lt; *.conf inside &amp;lt;Directory&amp;gt; or &amp;lt;Location&amp;gt;
                                and .htaccess when AllowOverride AuthConfig */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OR_INDEXES</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>        <comment type="block">/**&lt; *.conf anywhere
                                and .htaccess when AllowOverride Indexes */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OR_UNSET</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>          <comment type="block">/**&lt; bit to indicate that AllowOverride has not been set */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACCESS_CONF</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>       <comment type="block">/**&lt; *.conf inside &amp;lt;Directory&amp;gt; or &amp;lt;Location&amp;gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RSRC_CONF</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>        <comment type="block">/**&lt; *.conf outside &amp;lt;Directory&amp;gt; or &amp;lt;Location&amp;gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_ON_READ</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>     <comment type="block">/**&lt; force directive to execute a command
                which would modify the configuration (like including another
                file, or IFModule */</comment>
<comment type="block">/* Flags to determine whether syntax errors in .htaccess should be
 * treated as nonfatal (log and ignore errors)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NONFATAL_OVERRIDE</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>    <comment type="block">/* Violation of AllowOverride rule */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NONFATAL_UNKNOWN</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>    <comment type="block">/* Unrecognised directive */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NONFATAL_ALL</name></cpp:macro> <cpp:value>(NONFATAL_OVERRIDE|NONFATAL_UNKNOWN)</cpp:value></cpp:define>

<comment type="block">/** this directive can be placed anywhere */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OR_ALL</name></cpp:macro> <cpp:value>(OR_LIMIT|OR_OPTIONS|OR_FILEINFO|OR_AUTHCFG|OR_INDEXES)</cpp:value></cpp:define>

<comment type="block">/** @} */</comment>

<comment type="block">/**
 * This can be returned by a function if they don't wish to handle
 * a command. Make it something not likely someone will actually use
 * as an error code.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECLINE_CMD</name></cpp:macro> <cpp:value>"\a\b"</cpp:value></cpp:define>

<comment type="block">/** Common structure for reading of config files / passwd files etc. */</comment>
<typedef>typedef <type>struct <name>ap_configfile_t</name></type> <name>ap_configfile_t</name>;</typedef>
<struct>struct <name>ap_configfile_t</name> <block>{
    <comment type="block">/**&lt; an apr_file_getc()-like function */</comment>
    <function_decl><type><name>apr_status_t</name></type> (*<name>getch</name>) <parameter_list>(<param><decl><type><name>char</name> *</type><name>ch</name></decl></param>, <param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/**&lt; an apr_file_gets()-like function */</comment>
    <function_decl><type><name>apr_status_t</name></type> (*<name>getstr</name>) <parameter_list>(<param><decl><type><name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bufsiz</name></decl></param>, <param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/**&lt; a close handler function */</comment>
    <function_decl><type><name>apr_status_t</name></type> (*<name>close</name>) <parameter_list>(<param><decl><type><name>void</name> *</type><name>param</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/**&lt; the argument passed to getch/getstr/close */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>param</name></decl>;</decl_stmt>
    <comment type="block">/**&lt; the filename / description */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <comment type="block">/**&lt; current line number, starting at 1 */</comment>
    <decl_stmt><decl><type><name>unsigned</name></type> <name>line_number</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/**
 * This structure is passed to a command which is being invoked,
 * to carry a large variety of miscellaneous data which is all of
 * use to *somebody*...
 */</comment>
<struct>struct <name>cmd_parms_struct</name> <block>{
    <comment type="block">/** Argument to command from cmd_table */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>info</name></decl>;</decl_stmt>
    <comment type="block">/** Which allow-override bits are set */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>override</name></decl>;</decl_stmt>
    <comment type="block">/** Which allow-override-opts bits are set */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>override_opts</name></decl>;</decl_stmt>
    <comment type="block">/** Table of directives allowed per AllowOverrideList */</comment>
    <decl_stmt><decl><type><name>apr_table_t</name> *</type><name>override_list</name></decl>;</decl_stmt>
    <comment type="block">/** Which methods are &amp;lt;Limit&amp;gt;ed */</comment>
    <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>limited</name></decl>;</decl_stmt>
    <comment type="block">/** methods which are limited */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>limited_xmethods</name></decl>;</decl_stmt>
    <comment type="block">/** methods which are xlimited */</comment>
    <decl_stmt><decl><type><name>ap_method_list_t</name> *</type><name>xlimited</name></decl>;</decl_stmt>

    <comment type="block">/** Config file structure. */</comment>
    <decl_stmt><decl><type><name>ap_configfile_t</name> *</type><name>config_file</name></decl>;</decl_stmt>
    <comment type="block">/** the directive specifying this command */</comment>
    <decl_stmt><decl><type><name>ap_directive_t</name> *</type><name>directive</name></decl>;</decl_stmt>

    <comment type="block">/** Pool to allocate new storage in */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
    <comment type="block">/** Pool for scratch memory; persists during configuration, but
     *  wiped before the first request is served...  */</comment>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>temp_pool</name></decl>;</decl_stmt>
    <comment type="block">/** Server_rec being configured for */</comment>
    <decl_stmt><decl><type><name>server_rec</name> *</type><name>server</name></decl>;</decl_stmt>
    <comment type="block">/** If configuring for a directory, pathname of that directory.
     *  NOPE!  That's what it meant previous to the existence of &amp;lt;Files&amp;gt;,
     * &amp;lt;Location&amp;gt; and regex matching.  Now the only usefulness that can be
     * derived from this field is whether a command is being called in a
     * server context (path == NULL) or being called in a dir context
     * (path != NULL).  */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
    <comment type="block">/** configuration command */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>command_rec</name> *</type><name>cmd</name></decl>;</decl_stmt>

    <comment type="block">/** per_dir_config vector passed to handle_command */</comment>
    <decl_stmt><decl><type>struct <name>ap_conf_vector_t</name> *</type><name>context</name></decl>;</decl_stmt>
    <comment type="block">/** directive with syntax error */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>ap_directive_t</name> *</type><name>err_directive</name></decl>;</decl_stmt>

}</block>;</struct>

<comment type="block">/**
 * Module structures.  Just about everything is dispatched through
 * these, directly or indirectly (through the command and handler
 * tables).
 */</comment>
<typedef>typedef <type>struct <name>module_struct</name></type> <name>module</name>;</typedef>
<struct>struct <name>module_struct</name> <block>{
    <comment type="block">/** API version, *not* module version; check that module is
     * compatible with this version of the server.
     */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>version</name></decl>;</decl_stmt>
    <comment type="block">/** API minor version. Provides API feature milestones. Not checked
     *  during module init */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>minor_version</name></decl>;</decl_stmt>
    <comment type="block">/** Index to this modules structures in config vectors.  */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>module_index</name></decl>;</decl_stmt>

    <comment type="block">/** The name of the module's C file */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <comment type="block">/** The handle for the DSO.  Internal use only */</comment>
    <decl_stmt><decl><type><name>void</name> *</type><name>dynamic_load_handle</name></decl>;</decl_stmt>

    <comment type="block">/** A pointer to the next module in the list
     *  @var module_struct *next
     */</comment>
    <decl_stmt><decl><type>struct <name>module_struct</name> *</type><name>next</name></decl>;</decl_stmt>

    <comment type="block">/** Magic Cookie to identify a module structure;  It's mainly
     *  important for the DSO facility (see also mod_so).  */</comment>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>magic</name></decl>;</decl_stmt>

    <comment type="block">/** Function to allow MPMs to re-write command line arguments.  This
     *  hook is only available to MPMs.
     *  @param The process that the server is running in.
     */</comment>
    <function_decl><type><name>void</name></type> (*<name>rewrite_args</name>) <parameter_list>(<param><decl><type><name>process_rec</name> *</type><name>process</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** Function to allow all modules to create per directory configuration
     *  structures.
     *  @param p The pool to use for all allocations.
     *  @param dir The directory currently being processed.
     *  @return The per-directory structure created
     */</comment>
    <function_decl><type><name>void</name> *</type>(*<name>create_dir_config</name>) <parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>char</name> *</type><name>dir</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** Function to allow all modules to merge the per directory configuration
     *  structures for two directories.
     *  @param p The pool to use for all allocations.
     *  @param base_conf The directory structure created for the parent directory.
     *  @param new_conf The directory structure currently being processed.
     *  @return The new per-directory structure created
     */</comment>
    <function_decl><type><name>void</name> *</type>(*<name>merge_dir_config</name>) <parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>base_conf</name></decl></param>, <param><decl><type><name>void</name> *</type><name>new_conf</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** Function to allow all modules to create per server configuration
     *  structures.
     *  @param p The pool to use for all allocations.
     *  @param s The server currently being processed.
     *  @return The per-server structure created
     */</comment>
    <function_decl><type><name>void</name> *</type>(*<name>create_server_config</name>) <parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>server_rec</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
    <comment type="block">/** Function to allow all modules to merge the per server configuration
     *  structures for two servers.
     *  @param p The pool to use for all allocations.
     *  @param base_conf The directory structure created for the parent directory.
     *  @param new_conf The directory structure currently being processed.
     *  @return The new per-directory structure created
     */</comment>
    <function_decl><type><name>void</name> *</type>(*<name>merge_server_config</name>) <parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>void</name> *</type><name>base_conf</name></decl></param>,
                                  <param><decl><type><name>void</name> *</type><name>new_conf</name></decl></param>)</parameter_list>;</function_decl>

    <comment type="block">/** A command_rec table that describes all of the directives this module
     * defines. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>command_rec</name> *</type><name>cmds</name></decl>;</decl_stmt>

    <comment type="block">/** A hook to allow modules to hook other points in the request processing.
     *  In this function, modules should call the ap_hook_*() functions to
     *  register an interest in a specific step in processing the current
     *  request.
     *  @param p the pool to use for all allocations
     */</comment>
    <function_decl><type><name>void</name></type> (*<name>register_hooks</name>) <parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>)</parameter_list>;</function_decl>
}</block>;</struct>

<comment type="block">/**
 * The AP_MAYBE_UNUSED macro is used for variable declarations that
 * might potentially exhibit "unused var" warnings on some compilers if
 * left untreated.
 * Since static intializers are not part of the C language (C89), making
 * (void) usage is not possible. However many compiler have proprietary 
 * mechanism to suppress those warnings.  
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AP_MAYBE_UNUSED</name></cpp:ifdef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAYBE_UNUSED</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x __attribute__((unused))</cpp:value></cpp:define> 
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__LCLINT__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAYBE_UNUSED</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <comment type="block">/*@unused@*/</comment> <cpp:value>x</cpp:value></cpp:define>  
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>AP_MAYBE_UNUSED</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
<comment type="block">/**
 * The APLOG_USE_MODULE macro is used choose which module a file belongs to.
 * This is necessary to allow per-module loglevel configuration.
 *
 * APLOG_USE_MODULE indirectly sets APLOG_MODULE_INDEX and APLOG_MARK.
 *
 * If a module should be backward compatible with versions before 2.3.6,
 * APLOG_USE_MODULE needs to be enclosed in a ifdef APLOG_USE_MODULE block.
 *
 * @param foo name of the module symbol of the current module, without the
 *            trailing "_module" part
 * @see APLOG_MARK
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APLOG_USE_MODULE</name><parameter_list>(<param><type><name>foo</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>extern module AP_MODULE_DECLARE_DATA foo##_module;                  \
    AP_MAYBE_UNUSED(static int * const aplog_module_index) = &amp;(foo##_module.module_index)</cpp:value></cpp:define>

<comment type="block">/**
 * AP_DECLARE_MODULE is a convenience macro that combines a call of
 * APLOG_USE_MODULE with the definition of the module symbol.
 *
 * If a module should be backward compatible with versions before 2.3.6,
 * APLOG_USE_MODULE should be used explicitly instead of AP_DECLARE_MODULE.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AP_DECLARE_MODULE</name><parameter_list>(<param><type><name>foo</name></type></param>)</parameter_list></cpp:macro> \
    <cpp:value>APLOG_USE_MODULE(foo);                         \
    module AP_MODULE_DECLARE_DATA foo##_module</cpp:value></cpp:define>

<comment type="block">/**
 * @defgroup ModuleInit Module structure initializers
 *
 * Initializer for the first few module slots, which are only
 * really set up once we start running.  Note that the first two slots
 * provide a version check; this should allow us to deal with changes to
 * the API. The major number should reflect changes to the API handler table
 * itself or removal of functionality. The minor number should reflect
 * additions of functionality to the existing API. (the server can detect
 * an old-format module, and either handle it back-compatibly, or at least
 * signal an error). See src/include/ap_mmn.h for MMN version history.
 * @{
 */</comment>

<comment type="block">/** The one used in Apache 1.3, which will deliberately cause an error */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STANDARD_MODULE_STUFF</name></cpp:macro>   <cpp:value>this_module_needs_to_be_ported_to_apache_2_0</cpp:value></cpp:define>

<comment type="block">/** Use this in all standard modules */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STANDARD20_MODULE_STUFF</name></cpp:macro> <cpp:value>MODULE_MAGIC_NUMBER_MAJOR, \
                                MODULE_MAGIC_NUMBER_MINOR, \
                                -1, \
                                __FILE__, \
                                NULL, \
                                NULL, \
                                MODULE_MAGIC_COOKIE, \
                                NULL</cpp:value></cpp:define>      <comment type="block">/* rewrite args spot */</comment>

<comment type="block">/** Use this only in MPMs */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MPM20_MODULE_STUFF</name></cpp:macro>      <cpp:value>MODULE_MAGIC_NUMBER_MAJOR, \
                                MODULE_MAGIC_NUMBER_MINOR, \
                                -1, \
                                __FILE__, \
                                NULL, \
                                NULL, \
                                MODULE_MAGIC_COOKIE</cpp:value></cpp:define>

<comment type="block">/** @} */</comment>

<comment type="block">/* CONFIGURATION VECTOR FUNCTIONS */</comment>

<comment type="block">/** configuration vector structure */</comment>
<typedef>typedef <type>struct <name>ap_conf_vector_t</name></type> <name>ap_conf_vector_t</name>;</typedef>

<comment type="block">/**
 * Generic accessors for other modules to get at their own module-specific
 * data
 * @param cv The vector in which the modules configuration is stored.
 *        usually r-&gt;per_dir_config or s-&gt;module_config
 * @param m The module to get the data for.
 * @return The module-specific data
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_get_module_config</name><argument_list>(<argument><expr>const <name>ap_conf_vector_t</name> *<name>cv</name></expr></argument>,
                                        <argument><expr>const <name>module</name> *<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Generic accessors for other modules to set their own module-specific
 * data
 * @param cv The vector in which the modules configuration is stored.
 *        usually r-&gt;per_dir_config or s-&gt;module_config
 * @param m The module to set the data for.
 * @param val The module-specific data to set
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_module_config</name><argument_list>(<argument><expr><name>ap_conf_vector_t</name> *<name>cv</name></expr></argument>, <argument><expr>const <name>module</name> *<name>m</name></expr></argument>,
                                      <argument><expr><name>void</name> *<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>AP_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_module_config</name><parameter_list>(<param><type><name>v</name></type></param>,<param><type><name>m</name></type></param>)</parameter_list></cpp:macro>       \
    <cpp:value>(((void **)(v))[(m)-&gt;module_index])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_set_module_config</name><parameter_list>(<param><type><name>v</name></type></param>,<param><type><name>m</name></type></param>,<param><type><name>val</name></type></param>)</parameter_list></cpp:macro>   \
    <cpp:value>((((void **)(v))[(m)-&gt;module_index]) = (val))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_DEBUG */</comment>


<comment type="block">/**
 * Generic accessor for modules to get the module-specific loglevel
 * @param s The server from which to get the loglevel.
 * @param index The module_index of the module to get the loglevel for.
 * @return The module-specific loglevel
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_get_server_module_loglevel</name><argument_list>(<argument>const server_rec *s</argument>, <argument>int index</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Generic accessor for modules the module-specific loglevel
 * @param c The connection from which to get the loglevel.
 * @param index The module_index of the module to get the loglevel for.
 * @return The module-specific loglevel
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_get_conn_module_loglevel</name><argument_list>(<argument>const conn_rec *c</argument>, <argument>int index</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Generic accessor for modules the module-specific loglevel
 * @param c The connection from which to get the loglevel.
 * @param s The server from which to get the loglevel if c does not have a
 *          specific loglevel configuration.
 * @param index The module_index of the module to get the loglevel for.
 * @return The module-specific loglevel
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_get_conn_server_module_loglevel</name><argument_list>(<argument>const conn_rec *c</argument>,
                                                   <argument>const server_rec *s</argument>,
                                                   <argument>int index</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Generic accessor for modules to get the module-specific loglevel
 * @param r The request from which to get the loglevel.
 * @param index The module_index of the module to get the loglevel for.
 * @return The module-specific loglevel
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_get_request_module_loglevel</name><argument_list>(<argument>const request_rec *r</argument>, <argument>int index</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Accessor to set module-specific loglevel
 * @param p A pool
 * @param l The ap_logconf struct to modify.
 * @param index The module_index of the module to set the loglevel for.
 * @param level The new log level
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_set_module_loglevel</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>struct ap_logconf *l</argument>,
                                        <argument>int index</argument>, <argument>int level</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>AP_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_conn_logconf</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro>                     \
    <cpp:value>((c)-&gt;log             ? (c)-&gt;log             : \
     &amp;(c)-&gt;base_server-&gt;log)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_conn_server_logconf</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>s</name></type></param>)</parameter_list></cpp:macro>                             \
    <cpp:value>( ( (c)-&gt;log != &amp;(c)-&gt;base_server-&gt;log &amp;&amp; (c)-&gt;log != NULL )  ? \
      (c)-&gt;log                                                    : \
      &amp;(s)-&gt;log )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_request_logconf</name><parameter_list>(<param><type><name>r</name></type></param>)</parameter_list></cpp:macro>                  \
    <cpp:value>((r)-&gt;log             ? (r)-&gt;log             : \
     (r)-&gt;connection-&gt;log ? (r)-&gt;connection-&gt;log : \
     &amp;(r)-&gt;server-&gt;log)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_module_loglevel</name><parameter_list>(<param><type><name>l</name></type></param>,<param><type><name>i</name></type></param>)</parameter_list></cpp:macro>                                     \
    <cpp:value>(((i) &lt; 0 || (l)-&gt;module_levels == NULL || (l)-&gt;module_levels[i] &lt; 0) ?  \
     (l)-&gt;level :                                                         \
     (l)-&gt;module_levels[i])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_server_module_loglevel</name><parameter_list>(<param><type><name>s</name></type></param>,<param><type><name>i</name></type></param>)</parameter_list></cpp:macro>  \
    <cpp:value>(ap_get_module_loglevel(&amp;(s)-&gt;log,i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_conn_module_loglevel</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>i</name></type></param>)</parameter_list></cpp:macro>  \
    <cpp:value>(ap_get_module_loglevel(ap_get_conn_logconf(c),i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_conn_server_module_loglevel</name><parameter_list>(<param><type><name>c</name></type></param>,<param><type><name>s</name></type></param>,<param><type><name>i</name></type></param>)</parameter_list></cpp:macro>  \
    <cpp:value>(ap_get_module_loglevel(ap_get_conn_server_logconf(c,s),i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ap_get_request_module_loglevel</name><parameter_list>(<param><type><name>r</name></type></param>,<param><type><name>i</name></type></param>)</parameter_list></cpp:macro>  \
    <cpp:value>(ap_get_module_loglevel(ap_get_request_logconf(r),i))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* AP_DEBUG */</comment>

<comment type="block">/**
 * Set all module-specific loglevels to val
 * @param l The log config for which to set the loglevels.
 * @param val the value to set all loglevels to
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_reset_module_loglevels</name><argument_list>(<argument>struct ap_logconf *l</argument>, <argument>int val</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Generic command handling function for strings
 * @param cmd The command parameters for this directive
 * @param struct_ptr pointer into a given type
 * @param arg The argument to the directive
 * @return An error string or NULL on success
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_string_slot</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>,
                                                   <argument><expr><name>void</name> *<name>struct_ptr</name></expr></argument>,
                                                   <argument><expr>const <name>char</name> *<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Generic command handling function for integers
 * @param cmd The command parameters for this directive
 * @param struct_ptr pointer into a given type
 * @param arg The argument to the directive
 * @return An error string or NULL on success
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_int_slot</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>,
                                                <argument><expr><name>void</name> *<name>struct_ptr</name></expr></argument>,
                                                <argument><expr>const <name>char</name> *<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Parsing function for log level
 * @param str The string to parse
 * @param val The parsed log level
 * @return An error string or NULL on success
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_parse_log_level</name><argument_list>(<argument><expr>const <name>char</name> *<name>str</name></expr></argument>, <argument><expr><name>int</name> *<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Return true if the specified method is limited by being listed in
 * a &amp;lt;Limit&amp;gt; container, or by *not* being listed in a &amp;lt;LimitExcept&amp;gt;
 * container.
 *
 * @param   method  Pointer to a string specifying the method to check.
 * @param   cmd     Pointer to the cmd_parms structure passed to the
 *                  directive handler.
 * @return  0 if the method is not limited in the current scope
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_method_is_limited</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>, <argument><expr>const <name>char</name> *<name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Generic command handling function for strings, always sets the value
 * to a lowercase string
 * @param cmd The command parameters for this directive
 * @param struct_ptr pointer into a given type
 * @param arg The argument to the directive
 * @return An error string or NULL on success
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_string_slot_lower</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>,
                                                         <argument><expr><name>void</name> *<name>struct_ptr</name></expr></argument>,
                                                         <argument><expr>const <name>char</name> *<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Generic command handling function for flags stored in an int
 * @param cmd The command parameters for this directive
 * @param struct_ptr pointer into a given type
 * @param arg The argument to the directive (either 1 or 0)
 * @return An error string or NULL on success
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_set_flag_slot</name><argument_list>(<argument>cmd_parms *cmd</argument>,
                                                 <argument>void *struct_ptr</argument>,
                                                 <argument>int arg</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<comment type="block">/**
 * Generic command handling function for flags stored in a char
 * @param cmd The command parameters for this directive
 * @param struct_ptr pointer into a given type
 * @param arg The argument to the directive (either 1 or 0)
 * @return An error string or NULL on success
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_set_flag_slot_char</name><argument_list>(<argument>cmd_parms *cmd</argument>,
                                                      <argument>void *struct_ptr</argument>,
                                                      <argument>int arg</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<comment type="block">/**
 * Generic command handling function for files
 * @param cmd The command parameters for this directive
 * @param struct_ptr pointer into a given type
 * @param arg The argument to the directive
 * @return An error string or NULL on success
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_file_slot</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>,
                                                 <argument><expr><name>void</name> *<name>struct_ptr</name></expr></argument>,
                                                 <argument><expr>const <name>char</name> *<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Generic command handling function to respond with cmd-&gt;help as an error
 * @param cmd The command parameters for this directive
 * @param struct_ptr pointer into a given type
 * @param arg The argument to the directive
 * @return The cmd-&gt;help value as the error string
 * @note This allows simple declarations such as:
 * @code
 *     AP_INIT_RAW_ARGS("Foo", ap_set_deprecated, NULL, OR_ALL,
 *         "The Foo directive is no longer supported, use Bar"),
 * @endcode
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_deprecated</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>,
                                                  <argument><expr><name>void</name> *<name>struct_ptr</name></expr></argument>,
                                                  <argument><expr>const <name>char</name> *<name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * For modules which need to read config files, open logs, etc. this returns
 * the canonical form of fname made absolute to ap_server_root.
 * @param p pool to allocate data from
 * @param fname The file name
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_server_root_relative</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Compute the name of a run-time file (e.g., shared memory "file") relative
 * to the appropriate run-time directory.  Absolute paths are returned as-is.
 * The run-time directory is configured via the DefaultRuntimeDir directive or
 * at build time.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_runtime_dir_relative</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Finally, the hook for dynamically loading modules in... */</comment>

<comment type="block">/**
 * Add a module to the server
 * @param m The module structure of the module to add
 * @param p The pool of the same lifetime as the module
 * @param s The module's symbol name (used for logging)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_add_module</name><argument_list>(<argument><expr><name>module</name> *<name>m</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                       <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Remove a module from the server.  There are some caveats:
 * when the module is removed, its slot is lost so all the current
 * per-dir and per-server configurations are invalid. So we should
 * only ever call this function when you are invalidating almost
 * all our current data. I.e. when doing a restart.
 * @param m the module structure of the module to remove
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_remove_module</name><argument_list>(<argument><expr><name>module</name> *<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Add a module to the chained modules list and the list of loaded modules
 * @param mod The module structure of the module to add
 * @param p The pool with the same lifetime as the module
 * @param s The module's symbol name (used for logging)
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_add_loaded_module</name><argument_list>(<argument><expr><name>module</name> *<name>mod</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                              <argument><expr>const <name>char</name> *<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Remove a module fromthe chained modules list and the list of loaded modules
 * @param mod the module structure of the module to remove
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_remove_loaded_module</name><argument_list>(<argument><expr><name>module</name> *<name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Find the name of the specified module
 * @param m The module to get the name for
 * @return the name of the module
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_module_name</name><argument_list>(<argument><expr><name>module</name> *<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="block">/**
 * Find the short name of the module identified by the specified module index
 * @param module_index The module index to get the name for
 * @return the name of the module, NULL if not found
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_find_module_short_name</name><argument_list>(<argument>int module_index</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<comment type="block">/**
 * Find a module based on the name of the module
 * @param name the name of the module
 * @return the module structure if found, NULL otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>module *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_linked_module</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Open a ap_configfile_t as apr_file_t
 * @param ret_cfg open ap_configfile_t struct pointer
 * @param p The pool to allocate the structure from
 * @param name the name of the file to open
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_pcfg_openfile</name><argument_list>(<argument><expr><name>ap_configfile_t</name> **<name>ret_cfg</name></expr></argument>,
                                          <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr>const <name>char</name> *<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Allocate a ap_configfile_t handle with user defined functions and params
 * @param p The pool to allocate from
 * @param descr The name of the file
 * @param param The argument passed to getch/getstr/close
 * @param getc_func The getch function
 * @param gets_func The getstr function
 * @param close_func The close function
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_configfile_t *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_pcfg_open_custom</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
    <argument><expr>const <name>char</name> *<name>descr</name></expr></argument>,
    <argument><expr><name>void</name> *<name>param</name></expr></argument>,
    <argument><expr><call><call><name>apr_status_t</name> <argument_list>(<argument><expr>*<name>getc_func</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>char</name> *<name>ch</name></expr></argument>, <argument><expr><name>void</name> *<name>param</name></expr></argument>)</argument_list></call></expr></argument>,
    <argument><expr><macro><name>apr_status_t</name> <argument_list>(<argument>*gets_func</argument>)</argument_list></macro> (<name>void</name> *<name>buf</name>, <name>apr_size_t</name> <name>bufsiz</name>, <name>void</name> *<name>param</name>)</expr></argument>,
    <argument><expr><call><call><name>apr_status_t</name> <argument_list>(<argument><expr>*<name>close_func</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>void</name> *<name>param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Read one line from open ap_configfile_t, strip leading and trailing
 * whitespace, increase line number
 * @param buf place to store the line read
 * @param bufsize size of the buffer
 * @param cfp File to read from
 * @return error status, APR_ENOSPC if bufsize is too small for the line
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <macro><name>ap_cfg_getline</name><argument_list>(<argument>char *buf</argument>, <argument>apr_size_t bufsize</argument>, <argument>ap_configfile_t *cfp</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Read one char from open configfile_t, increase line number upon LF
 * @param ch place to store the char read
 * @param cfp The file to read from
 * @return error status
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_cfg_getc</name><argument_list>(<argument><expr><name>char</name> *<name>ch</name></expr></argument>, <argument><expr><name>ap_configfile_t</name> *<name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Detach from open ap_configfile_t, calling the close handler
 * @param cfp The file to close
 * @return 1 on success, 0 on failure
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_cfg_closefile</name><argument_list>(<argument><expr><name>ap_configfile_t</name> *<name>cfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Convert a return value from ap_cfg_getline or ap_cfg_getc to a user friendly
 * string.
 * @param p The pool to allocate the string from
 * @param cfp The config file
 * @param rc The return value to convert
 * @return The error string, NULL if rc == APR_SUCCESS
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_pcfg_strerror</name><argument_list>(<argument>apr_pool_t *p</argument>, <argument>ap_configfile_t *cfp</argument>,
                                          <argument>apr_status_t rc</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Read all data between the current &amp;lt;foo&amp;gt; and the matching &amp;lt;/foo&amp;gt;.  All
 * of this data is forgotten immediately.
 * @param cmd The cmd_parms to pass to the directives inside the container
 * @param directive The directive name to read until
 * @return Error string on failure, NULL on success
 * @note If cmd-&gt;pool == cmd-&gt;temp_pool, ap_soak_end_container() will assume
 *       .htaccess context and use a lower maximum line length.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_soak_end_container</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>cmd</name></expr></argument>, <argument><expr><name>char</name> *<name>directive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Read all data between the current &amp;lt;foo&amp;gt; and the matching &amp;lt;/foo&amp;gt; and build
 * a config tree from it
 * @param p pool to allocate from
 * @param temp_pool Temporary pool to allocate from
 * @param parms The cmd_parms to pass to all directives read
 * @param current The current node in the tree
 * @param curr_parent The current parent node
 * @param orig_directive The directive to read until hit.
 * @return Error string on failure, NULL on success
 * @note If p == temp_pool, ap_build_cont_config() will assume .htaccess
 *       context and use a lower maximum line length.
*/</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_build_cont_config</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                              <argument><expr><name>apr_pool_t</name> *<name>temp_pool</name></expr></argument>,
                                              <argument><expr><name>cmd_parms</name> *<name>parms</name></expr></argument>,
                                              <argument><expr><name>ap_directive_t</name> **<name>current</name></expr></argument>,
                                              <argument><expr><name>ap_directive_t</name> **<name>curr_parent</name></expr></argument>,
                                              <argument><expr><name>char</name> *<name>orig_directive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Build a config tree from a config file
 * @param parms The cmd_parms to pass to all of the directives in the file
 * @param conf_pool The pconf pool
 * @param temp_pool The temporary pool
 * @param conftree Place to store the root node of the config tree
 * @return Error string on erro, NULL otherwise
 * @note If conf_pool == temp_pool, ap_build_config() will assume .htaccess
 *       context and use a lower maximum line length.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_build_config</name><argument_list>(<argument><expr><name>cmd_parms</name> *<name>parms</name></expr></argument>,
                                         <argument><expr><name>apr_pool_t</name> *<name>conf_pool</name></expr></argument>,
                                         <argument><expr><name>apr_pool_t</name> *<name>temp_pool</name></expr></argument>,
                                         <argument><expr><name>ap_directive_t</name> **<name>conftree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Walk a config tree and setup the server's internal structures
 * @param conftree The config tree to walk
 * @param parms The cmd_parms to pass to all functions
 * @param section_vector The per-section config vector.
 * @return Error string on error, NULL otherwise
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_walk_config</name><argument_list>(<argument><expr><name>ap_directive_t</name> *<name>conftree</name></expr></argument>,
                                        <argument><expr><name>cmd_parms</name> *<name>parms</name></expr></argument>,
                                        <argument><expr><name>ap_conf_vector_t</name> *<name>section_vector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * @defgroup ap_check_cmd_context Check command context
 * @{
 */</comment>
<comment type="block">/**
 * Check the context a command is used in.
 * @param cmd The command to check
 * @param forbidden Where the command is forbidden.
 * @return Error string on error, NULL on success
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_check_cmd_context</name><argument_list>(<argument>cmd_parms *cmd</argument>,
                                              <argument>unsigned forbidden</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>NOT_IN_VIRTUALHOST</name></cpp:macro>     <cpp:value>0x01</cpp:value></cpp:define> <comment type="block">/**&lt; Forbidden in &amp;lt;VirtualHost&amp;gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>NOT_IN_LIMIT</name></cpp:macro>           <cpp:value>0x02</cpp:value></cpp:define> <comment type="block">/**&lt; Forbidden in &amp;lt;Limit&amp;gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>NOT_IN_DIRECTORY</name></cpp:macro>       <cpp:value>0x04</cpp:value></cpp:define> <comment type="block">/**&lt; Forbidden in &amp;lt;Directory&amp;gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>NOT_IN_LOCATION</name></cpp:macro>        <cpp:value>0x08</cpp:value></cpp:define> <comment type="block">/**&lt; Forbidden in &amp;lt;Location&amp;gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>NOT_IN_FILES</name></cpp:macro>           <cpp:value>0x10</cpp:value></cpp:define> <comment type="block">/**&lt; Forbidden in &amp;lt;Files&amp;gt; or &amp;lt;If&amp;gt;*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>NOT_IN_HTACCESS</name></cpp:macro>        <cpp:value>0x20</cpp:value></cpp:define> <comment type="block">/**&lt; Forbidden in .htaccess files */</comment>
<comment type="block">/** Forbidden in &amp;lt;Directory&amp;gt;/&amp;lt;Location&amp;gt;/&amp;lt;Files&amp;gt;&amp;lt;If&amp;gt;*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>NOT_IN_DIR_LOC_FILE</name></cpp:macro>    <cpp:value>(NOT_IN_DIRECTORY|NOT_IN_LOCATION|NOT_IN_FILES)</cpp:value></cpp:define>
<comment type="block">/** Forbidden in &amp;lt;VirtualHost&amp;gt;/&amp;lt;Limit&amp;gt;/&amp;lt;Directory&amp;gt;/&amp;lt;Location&amp;gt;/&amp;lt;Files&amp;gt;/&amp;lt;If&amp;gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive>  <cpp:macro><name>GLOBAL_ONLY</name></cpp:macro>            <cpp:value>(NOT_IN_VIRTUALHOST|NOT_IN_LIMIT|NOT_IN_DIR_LOC_FILE)</cpp:value></cpp:define>

<comment type="block">/** @} */</comment>

<comment type="block">/**
 * @brief This structure is used to assign symbol names to module pointers
 */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>module</name> *</type><name>modp</name></decl>;</decl_stmt>
}</block></struct></type> <name>ap_module_symbol_t</name>;</typedef>

<comment type="block">/**
 * The topmost module in the list
 * @var module *ap_top_module
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>module</name> *</type><name>ap_top_module</name></decl>;</decl_stmt>

<comment type="block">/**
 * Array of all statically linked modules
 * @var module *ap_prelinked_modules[]
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>module</name> *</type><name><name>ap_prelinked_modules</name><index>[]</index></name></decl>;</decl_stmt>
<comment type="block">/**
 * Array of all statically linked modulenames (symbols)
 * @var ap_module_symbol_t ap_prelinked_module_symbols[]
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>ap_module_symbol_t</name></type> <name><name>ap_prelinked_module_symbols</name><index>[]</index></name></decl>;</decl_stmt>
<comment type="block">/**
 * Array of all preloaded modules
 * @var module *ap_preloaded_modules[]
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>module</name> *</type><name><name>ap_preloaded_modules</name><index>[]</index></name></decl>;</decl_stmt>
<comment type="block">/**
 * Array of all loaded modules
 * @var module **ap_loaded_modules
 */</comment>
<decl_stmt><decl><type><name>AP_DECLARE_DATA</name> <specifier>extern</specifier> <name>module</name> **</type><name>ap_loaded_modules</name></decl>;</decl_stmt>

<comment type="block">/* For mod_so.c... */</comment>
<comment type="block">/** Run a single module's two create_config hooks
 *  @param p the pool to allocate from
 *  @param s The server to configure for.
 *  @param m The module to configure
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_single_module_configure</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>, <argument><expr><name>server_rec</name> *<name>s</name></expr></argument>,
                                            <argument><expr><name>module</name> *<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* For http_main.c... */</comment>
<comment type="block">/**
 * Add all of the prelinked modules into the loaded module list
 * @param process The process that is currently running the server
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_setup_prelinked_modules</name><argument_list>(<argument><expr><name>process_rec</name> *<name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Show the preloaded configuration directives, the help string explaining
 * the directive arguments, in what module they are handled, and in
 * what parts of the configuration they are allowed.  Used for httpd -h.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_show_directives</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Show the preloaded module names.  Used for httpd -l.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_show_modules</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Show the MPM name.  Used in reporting modules such as mod_info to
 * provide extra information to the user
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_show_mpm</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Read all config files and setup the server
 * @param process The process running the server
 * @param temp_pool A pool to allocate temporary data from.
 * @param config_name The name of the config file
 * @param conftree Place to store the root of the config tree
 * @return The setup server_rec list.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>server_rec *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_read_config</name><argument_list>(<argument><expr><name>process_rec</name> *<name>process</name></expr></argument>,
                                        <argument><expr><name>apr_pool_t</name> *<name>temp_pool</name></expr></argument>,
                                        <argument><expr>const <name>char</name> *<name>config_name</name></expr></argument>,
                                        <argument><expr><name>ap_directive_t</name> **<name>conftree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Run all rewrite args hooks for loaded modules
 * @param process The process currently running the server
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_run_rewrite_args</name><argument_list>(<argument><expr><name>process_rec</name> *<name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Run the register hooks function for a specified module
 * @param m The module to run the register hooks function fo
 * @param p The pool valid for the lifetime of the module
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_register_hooks</name><argument_list>(<argument><expr><name>module</name> *<name>m</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Setup all virtual hosts
 * @param p The pool to allocate from
 * @param main_server The head of the server_rec list
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_fixup_virtual_hosts</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                        <argument><expr><name>server_rec</name> *<name>main_server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Reserve some modules slots for modules loaded by other means than
 * EXEC_ON_READ directives.
 * Relevant modules should call this in the pre_config stage.
 * @param count The number of slots to reserve.
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <macro><name>ap_reserve_module_slots</name><argument_list>(<argument>int count</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Reserve some modules slots for modules loaded by a specific
 * non-EXEC_ON_READ config directive.
 * This counts how often the given directive is used in the config and calls
 * ap_reserve_module_slots() accordingly.
 * @param directive The name of the directive
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_reserve_module_slots_directive</name><argument_list>(<argument><expr>const <name>char</name> *<name>directive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* For http_request.c... */</comment>

<comment type="block">/**
 * Setup the config vector for a request_rec
 * @param p The pool to allocate the config vector from
 * @return The config vector
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>ap_conf_vector_t*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_create_request_config</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Setup the config vector for per dir module configs
 * @param p The pool to allocate the config vector from
 * @return The config vector
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>ap_conf_vector_t *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_create_per_dir_config</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Run all of the modules merge per dir config functions
 * @param p The pool to pass to the merge functions
 * @param base The base directory config structure
 * @param new_conf The new directory config structure
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>ap_conf_vector_t*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_merge_per_dir_configs</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                           <argument><expr><name>ap_conf_vector_t</name> *<name>base</name></expr></argument>,
                                           <argument><expr><name>ap_conf_vector_t</name> *<name>new_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Allocate new ap_logconf and make (deep) copy of old ap_logconf
 * @param p The pool to alloc from
 * @param old The ap_logconf to copy (may be NULL)
 * @return The new ap_logconf struct
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>struct ap_logconf *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_new_log_config</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                                  <argument><expr>const struct <name>ap_logconf</name> *<name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Merge old ap_logconf into new ap_logconf.
 * old and new must have the same life time.
 * @param old_conf The ap_logconf to merge from
 * @param new_conf The ap_logconf to merge into
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_merge_log_config</name><argument_list>(<argument><expr>const struct <name>ap_logconf</name> *<name>old_conf</name></expr></argument>,
                                     <argument>struct <expr><name>ap_logconf</name> *<name>new_conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* For http_connection.c... */</comment>
<comment type="block">/**
 * Setup the config vector for a connection_rec
 * @param p The pool to allocate the config vector from
 * @return The config vector
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>ap_conf_vector_t*</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_create_conn_config</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* For http_core.c... (&amp;lt;Directory&amp;gt; command and virtual hosts) */</comment>

<comment type="block">/**
 * parse an htaccess file
 * @param result htaccess_result
 * @param r The request currently being served
 * @param override Which overrides are active
 * @param override_opts Which allow-override-opts bits are set
 * @param override_list Table of directives allowed for override
 * @param path The path to the htaccess file
 * @param access_name The list of possible names for .htaccess files
 * int The status of the current request
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>ap_parse_htaccess</name><argument_list>(<argument>ap_conf_vector_t **result</argument>,
                                       <argument>request_rec *r</argument>,
                                       <argument>int override</argument>,
                                       <argument>int override_opts</argument>,
                                       <argument>apr_table_t *override_list</argument>,
                                       <argument>const char *path</argument>,
                                       <argument>const char *access_name</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Setup a virtual host
 * @param p The pool to allocate all memory from
 * @param hostname The hostname of the virtual hsot
 * @param main_server The main server for this Apache configuration
 * @param ps Place to store the new server_rec
 * return Error string on error, NULL on success
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_init_virtual_host</name><argument_list>(<argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                                   <argument><expr>const <name>char</name> *<name>hostname</name></expr></argument>,
                                                   <argument><expr><name>server_rec</name> *<name>main_server</name></expr></argument>,
                                                   <argument><expr><name>server_rec</name> **<name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Process a config file for Apache
 * @param s The server rec to use for the command parms
 * @param fname The name of the config file
 * @param conftree The root node of the created config tree
 * @param p Pool for general allocation
 * @param ptemp Pool for temporary allocation
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_process_resource_config</name><argument_list>(<argument><expr><name>server_rec</name> *<name>s</name></expr></argument>,
                                                    <argument><expr>const <name>char</name> *<name>fname</name></expr></argument>,
                                                    <argument><expr><name>ap_directive_t</name> **<name>conftree</name></expr></argument>,
                                                    <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                                    <argument><expr><name>apr_pool_t</name> *<name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Process all matching files as Apache configs
 * @param s The server rec to use for the command parms
 * @param fname The filename pattern of the config file
 * @param conftree The root node of the created config tree
 * @param p Pool for general allocation
 * @param ptemp Pool for temporary allocation
 * @param optional Whether a no-match wildcard is allowed
 * @see apr_fnmatch for pattern handling
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>const char *</argument>)</argument_list></macro> <macro><name>ap_process_fnmatch_configs</name><argument_list>(<argument>server_rec *s</argument>,
                                                    <argument>const char *fname</argument>,
                                                    <argument>ap_directive_t **conftree</argument>,
                                                    <argument>apr_pool_t *p</argument>,
                                                    <argument>apr_pool_t *ptemp</argument>,
                                                    <argument>int optional</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Process all directives in the config tree
 * @param s The server rec to use in the command parms
 * @param conftree The config tree to process
 * @param p The pool for general allocation
 * @param ptemp The pool for temporary allocations
 * @return OK if no problems
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_process_config_tree</name><argument_list>(<argument><expr><name>server_rec</name> *<name>s</name></expr></argument>,
                                       <argument><expr><name>ap_directive_t</name> *<name>conftree</name></expr></argument>,
                                       <argument><expr><name>apr_pool_t</name> *<name>p</name></expr></argument>,
                                       <argument><expr><name>apr_pool_t</name> *<name>ptemp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Store data which will be retained across unload/load of modules
 * @param key The unique key associated with this module's retained data
 * @param size in bytes of the retained data (to be allocated)
 * @return Address of new retained data structure, initially cleared
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <macro><name>ap_retained_data_create</name><argument_list>(<argument>const char *key</argument>, <argument>apr_size_t size</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<comment type="block">/**
 * Retrieve data which was stored by ap_retained_data_create()
 * @param key The unique key associated with this module's retained data
 * @return Address of previously retained data structure, or NULL if not yet saved
 */</comment>
<macro><name>AP_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_retained_data_get</name><argument_list>(<argument><expr>const <name>char</name> *<name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Module-method dispatchers, also for http_request.c */</comment>
<comment type="block">/**
 * Run the handler phase of each module until a module accepts the
 * responsibility of serving the request
 * @param r The current request
 * @return The status of the current request
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_invoke_handler</name><argument_list>(<argument><expr><name>request_rec</name> *<name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* for mod_perl */</comment>

<comment type="block">/**
 * Find a given directive in a command_rec table
 * @param name The directive to search for
 * @param cmds The table to search
 * @return The directive definition of the specified directive
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>const command_rec *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_command</name><argument_list>(<argument><expr>const <name>char</name> *<name>name</name></expr></argument>,
                                                     <argument><expr>const <name>command_rec</name> *<name>cmds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Find a given directive in a list of modules.
 * @param cmd_name The directive to search for
 * @param mod Pointer to the first module in the linked list; will be set to
 *            the module providing cmd_name
 * @return The directive definition of the specified directive.
 *         *mod will be changed to point to the module containing the
 *         directive.
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>const command_rec *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_find_command_in_modules</name><argument_list>(<argument><expr>const <name>char</name> *<name>cmd_name</name></expr></argument>,
                                                                <argument><expr><name>module</name> **<name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/**
 * Ask a module to create per-server and per-section (dir/loc/file) configs
 * (if it hasn't happened already). The results are stored in the server's
 * config, and the specified per-section config vector.
 * @param server The server to operate upon.
 * @param section_vector The per-section config vector.
 * @param section Which section to create a config for.
 * @param mod The module which is defining the config data.
 * @param pconf A pool for all configuration allocations.
 * @return The (new) per-section config data.
 */</comment>
<macro><name>AP_CORE_DECLARE</name><argument_list>(<argument>void *</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_set_config_vectors</name><argument_list>(<argument><expr><name>server_rec</name> *<name>server</name></expr></argument>,
                                              <argument><expr><name>ap_conf_vector_t</name> *<name>section_vector</name></expr></argument>,
                                              <argument><expr>const <name>char</name> *<name>section</name></expr></argument>,
                                              <argument><expr><name>module</name> *<name>mod</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>pconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Hooks */</comment>

<comment type="block">/**
 * Run the header parser functions for each module
 * @param r The current request
 * @return OK or DECLINED
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>header_parser</argument>,<argument>(request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/**
 * Run the pre_config function for each module
 * @param pconf The config pool
 * @param plog The logging streams pool
 * @param ptemp The temporary pool
 * @return OK or DECLINED on success anything else is a error
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>pre_config</argument>,<argument>(apr_pool_t *pconf,apr_pool_t *plog,
                                apr_pool_t *ptemp)</argument>)</argument_list></macro>

<comment type="block">/**
 * Run the check_config function for each module
 * @param pconf The config pool
 * @param plog The logging streams pool
 * @param ptemp The temporary pool
 * @param s the server to operate upon
 * @return OK or DECLINED on success anything else is a error
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>check_config</argument>,<argument>(apr_pool_t *pconf, apr_pool_t *plog,
                                  apr_pool_t *ptemp, server_rec *s)</argument>)</argument_list></macro>

<comment type="block">/**
 * Run the test_config function for each module; this hook is run
 * only if the server was invoked to test the configuration syntax.
 * @param pconf The config pool
 * @param s The list of server_recs
 * @note To avoid reordering problems due to different buffering, hook
 *       functions should only apr_file_*() to print to stdout/stderr and
 *       not simple printf()/fprintf().
 *     
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>,<argument>test_config</argument>,<argument>(apr_pool_t *pconf, server_rec *s)</argument>)</argument_list></macro>

<comment type="block">/**
 * Run the post_config function for each module
 * @param pconf The config pool
 * @param plog The logging streams pool
 * @param ptemp The temporary pool
 * @param s The list of server_recs
 * @return OK or DECLINED on success anything else is a error
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>post_config</argument>,<argument>(apr_pool_t *pconf,apr_pool_t *plog,
                                 apr_pool_t *ptemp,server_rec *s)</argument>)</argument_list></macro>

<comment type="block">/**
 * Run the open_logs functions for each module
 * @param pconf The config pool
 * @param plog The logging streams pool
 * @param ptemp The temporary pool
 * @param s The list of server_recs
 * @return OK or DECLINED on success anything else is a error
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>open_logs</argument>,<argument>(apr_pool_t *pconf,apr_pool_t *plog,
                               apr_pool_t *ptemp,server_rec *s)</argument>)</argument_list></macro>

<comment type="block">/**
 * Run the child_init functions for each module
 * @param pchild The child pool
 * @param s The list of server_recs in this server
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>,<argument>child_init</argument>,<argument>(apr_pool_t *pchild, server_rec *s)</argument>)</argument_list></macro>

<comment type="block">/**
 * Run the handler functions for each module
 * @param r The request_rec
 * @remark non-wildcard handlers should HOOK_MIDDLE, wildcard HOOK_LAST
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>handler</argument>,<argument>(request_rec *r)</argument>)</argument_list></macro>

<comment type="block">/**
 * Run the quick handler functions for each module. The quick_handler
 * is run before any other requests hooks are called (location_walk,
 * directory_walk, access checking, et. al.). This hook was added
 * to provide a quick way to serve content from a URI keyed cache.
 *
 * @param r The request_rec
 * @param lookup_uri Controls whether the caller actually wants content or not.
 * lookup is set when the quick_handler is called out of
 * ap_sub_req_lookup_uri()
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>int</argument>,<argument>quick_handler</argument>,<argument>(request_rec *r, int lookup_uri)</argument>)</argument_list></macro>

<comment type="block">/**
 * Retrieve the optional functions for each module.
 * This is run immediately before the server starts. Optional functions should
 * be registered during the hook registration phase.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>void</argument>,<argument>optional_fn_retrieve</argument>,<argument>(void)</argument>)</argument_list></macro>

<comment type="block">/**
 * Allow modules to open htaccess files or perform operations before doing so
 * @param r The current request
 * @param dir_name The directory for which the htaccess file should be opened
 * @param access_name The filename  for which the htaccess file should be opened
 * @param conffile Where the pointer to the opened ap_configfile_t must be
 *        stored
 * @param full_name Where the full file name of the htaccess file must be
 *        stored.
 * @return APR_SUCCESS on success,
 *         APR_ENOENT or APR_ENOTDIR if no htaccess file exists,
 *         AP_DECLINED to let later modules do the opening,
 *         any other error code on error.
 */</comment>
<macro><name>AP_DECLARE_HOOK</name><argument_list>(<argument>apr_status_t</argument>,<argument>open_htaccess</argument>,
                <argument>(request_rec *r, const char *dir_name, const char *access_name,
                 ap_configfile_t **conffile, const char **full_name)</argument>)</argument_list></macro>

<comment type="block">/**
 * Core internal function, use ap_run_open_htaccess() instead.
 */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>ap_open_htaccess</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir_name</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>access_name</name></decl></param>, <param><decl><type><name>ap_configfile_t</name> **</type><name>conffile</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>full_name</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * A generic pool cleanup that will reset a pointer to NULL. For use with
 * apr_pool_cleanup_register.
 * @param data The address of the pointer
 * @return APR_SUCCESS
 */</comment>
<macro><name>AP_DECLARE_NONSTD</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <expr_stmt><expr><call><name>ap_pool_cleanup_set_null</name><argument_list>(<argument><expr><name>void</name> *<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* !APACHE_HTTP_CONFIG_H */</comment>
<comment type="block">/** @} */</comment>
</unit>
